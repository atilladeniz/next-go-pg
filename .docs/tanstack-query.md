---
source: https://tanstack.com/query/latest/docs
fetched: 2025-12-05T09:10:19Z
method: sitefetch
---

<page>
  <title>Overview | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs</url>
  <content>TanStack Query (formerly known as React Query) is often described as the missing data-fetching library for web applications, but in more technical terms, it makes **fetching, caching, synchronizing and updating server state** in your web applications a breeze.

[](#motivation)[Motivation](#motivation)
----------------------------------------

Most core web frameworks **do not** come with an opinionated way of fetching or updating data in a holistic way. Because of this developers end up building either meta-frameworks which encapsulate strict opinions about data-fetching, or they invent their own ways of fetching data. This usually means cobbling together component-based state and side-effects, or using more general purpose state management libraries to store and provide asynchronous data throughout their apps.

While most traditional state management libraries are great for working with client state, they are **not so great at working with async or server state**. This is because **server state is totally different**. For starters, server state:

*   Is persisted remotely in a location you may not control or own
*   Requires asynchronous APIs for fetching and updating
*   Implies shared ownership and can be changed by other people without your knowledge
*   Can potentially become "out of date" in your applications if you're not careful

Once you grasp the nature of server state in your application, **even more challenges will arise** as you go, for example:

*   Caching... (possibly the hardest thing to do in programming)
*   Deduping multiple requests for the same data into a single request
*   Updating "out of date" data in the background
*   Knowing when data is "out of date"
*   Reflecting updates to data as quickly as possible
*   Performance optimizations like pagination and lazy loading data
*   Managing memory and garbage collection of server state
*   Memoizing query results with structural sharing

If you're not overwhelmed by that list, then that must mean that you've probably solved all of your server state problems already and deserve an award. However, if you are like a vast majority of people, you either have yet to tackle all or most of these challenges and we're only scratching the surface!

TanStack Query is hands down one of the _best_ libraries for managing server state. It works amazingly well **out-of-the-box, with zero-config, and can be customized** to your liking as your application grows.

TanStack Query allows you to defeat and overcome the tricky challenges and hurdles of _server state_ and control your app data before it starts to control you.

On a more technical note, TanStack Query will likely:

*   Help you remove **many** lines of complicated and misunderstood code from your application and replace with just a handful of lines of TanStack Query logic
*   Make your application more maintainable and easier to build new features without worrying about wiring up new server state data sources
*   Have a direct impact on your end-users by making your application feel faster and more responsive than ever before
*   Potentially help you save on bandwidth and increase memory performance

[](#enough-talk-show-me-some-code-already)[Enough talk, show me some code already!](#enough-talk-show-me-some-code-already)
---------------------------------------------------------------------------------------------------------------------------

In the example below, you can see TanStack Query in its most basic and simple form being used to fetch the GitHub stats for the TanStack Query GitHub project itself:

[Open in StackBlitz](https://stackblitz.com/github/TanStack/query/tree/main/examples/react/simple)

    import {
      QueryClient,
      QueryClientProvider,
      useQuery,
    } from '@tanstack/react-query'
    
    const queryClient = new QueryClient()
    
    export default function App() {
      return (
        <QueryClientProvider client={queryClient}>
          <Example />
        </QueryClientProvider>
      )
    }
    
    function Example() {
      const { isPending, error, data } = useQuery({
        queryKey: ['repoData'],
        queryFn: () =>
          fetch('https://api.github.com/repos/TanStack/query').then((res) =>
            res.json(),
          ),
      })
    
      if (isPending) return 'Loading...'
    
      if (error) return 'An error has occurred: ' + error.message
    
      return (
        <div>
          <h1>{data.name}</h1>
          <p>{data.description}</p>
          <strong>üëÄ {data.subscribers_count}</strong>{' '}
          <strong>‚ú® {data.stargazers_count}</strong>{' '}
          <strong>üç¥ {data.forks_count}</strong>
        </div>
      )
    }
    

    import {
      QueryClient,
      QueryClientProvider,
      useQuery,
    } from '@tanstack/react-query'
    
    const queryClient = new QueryClient()
    
    export default function App() {
      return (
        <QueryClientProvider client={queryClient}>
          <Example />
        </QueryClientProvider>
      )
    }
    
    function Example() {
      const { isPending, error, data } = useQuery({
        queryKey: ['repoData'],
        queryFn: () =>
          fetch('https://api.github.com/repos/TanStack/query').then((res) =>
            res.json(),
          ),
      })
    
      if (isPending) return 'Loading...'
    
      if (error) return 'An error has occurred: ' + error.message
    
      return (
        <div>
          <h1>{data.name}</h1>
          <p>{data.description}</p>
          <strong>üëÄ {data.subscribers_count}</strong>{' '}
          <strong>‚ú® {data.stargazers_count}</strong>{' '}
          <strong>üç¥ {data.forks_count}</strong>
        </div>
      )
    }
    

[](#you-talked-me-into-it-so-what-now)[You talked me into it, so what now?](#you-talked-me-into-it-so-what-now)
---------------------------------------------------------------------------------------------------------------

*   Consider taking the official [TanStack Query Course](https://query.gg/?s=tanstack) (or buying it for your whole team!)
*   Learn TanStack Query at your own pace with our amazingly thorough [Walkthrough Guide](https://tanstack.com/query/latest/docs/framework/react/installation) and [API Reference](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery)
*   See the Article [Why You Want React Query](https://tkdodo.eu/blog/why-you-want-react-query).</content>
</page>

<page>
  <title>Overview | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/overview</url>
  <content>TanStack Query (formerly known as React Query) is often described as the missing data-fetching library for web applications, but in more technical terms, it makes **fetching, caching, synchronizing and updating server state** in your web applications a breeze.

[](#motivation)[Motivation](#motivation)
----------------------------------------

Most core web frameworks **do not** come with an opinionated way of fetching or updating data in a holistic way. Because of this developers end up building either meta-frameworks which encapsulate strict opinions about data-fetching, or they invent their own ways of fetching data. This usually means cobbling together component-based state and side-effects, or using more general purpose state management libraries to store and provide asynchronous data throughout their apps.

While most traditional state management libraries are great for working with client state, they are **not so great at working with async or server state**. This is because **server state is totally different**. For starters, server state:

*   Is persisted remotely in a location you may not control or own
*   Requires asynchronous APIs for fetching and updating
*   Implies shared ownership and can be changed by other people without your knowledge
*   Can potentially become "out of date" in your applications if you're not careful

Once you grasp the nature of server state in your application, **even more challenges will arise** as you go, for example:

*   Caching... (possibly the hardest thing to do in programming)
*   Deduping multiple requests for the same data into a single request
*   Updating "out of date" data in the background
*   Knowing when data is "out of date"
*   Reflecting updates to data as quickly as possible
*   Performance optimizations like pagination and lazy loading data
*   Managing memory and garbage collection of server state
*   Memoizing query results with structural sharing

If you're not overwhelmed by that list, then that must mean that you've probably solved all of your server state problems already and deserve an award. However, if you are like a vast majority of people, you either have yet to tackle all or most of these challenges and we're only scratching the surface!

TanStack Query is hands down one of the _best_ libraries for managing server state. It works amazingly well **out-of-the-box, with zero-config, and can be customized** to your liking as your application grows.

TanStack Query allows you to defeat and overcome the tricky challenges and hurdles of _server state_ and control your app data before it starts to control you.

On a more technical note, TanStack Query will likely:

*   Help you remove **many** lines of complicated and misunderstood code from your application and replace with just a handful of lines of TanStack Query logic
*   Make your application more maintainable and easier to build new features without worrying about wiring up new server state data sources
*   Have a direct impact on your end-users by making your application feel faster and more responsive than ever before
*   Potentially help you save on bandwidth and increase memory performance

[](#enough-talk-show-me-some-code-already)[Enough talk, show me some code already!](#enough-talk-show-me-some-code-already)
---------------------------------------------------------------------------------------------------------------------------

In the example below, you can see TanStack Query in its most basic and simple form being used to fetch the GitHub stats for the TanStack Query GitHub project itself:

[Open in StackBlitz](https://stackblitz.com/github/TanStack/query/tree/main/examples/react/simple)

    import {
      QueryClient,
      QueryClientProvider,
      useQuery,
    } from '@tanstack/react-query'
    
    const queryClient = new QueryClient()
    
    export default function App() {
      return (
        <QueryClientProvider client={queryClient}>
          <Example />
        </QueryClientProvider>
      )
    }
    
    function Example() {
      const { isPending, error, data } = useQuery({
        queryKey: ['repoData'],
        queryFn: () =>
          fetch('https://api.github.com/repos/TanStack/query').then((res) =>
            res.json(),
          ),
      })
    
      if (isPending) return 'Loading...'
    
      if (error) return 'An error has occurred: ' + error.message
    
      return (
        <div>
          <h1>{data.name}</h1>
          <p>{data.description}</p>
          <strong>üëÄ {data.subscribers_count}</strong>{' '}
          <strong>‚ú® {data.stargazers_count}</strong>{' '}
          <strong>üç¥ {data.forks_count}</strong>
        </div>
      )
    }
    

    import {
      QueryClient,
      QueryClientProvider,
      useQuery,
    } from '@tanstack/react-query'
    
    const queryClient = new QueryClient()
    
    export default function App() {
      return (
        <QueryClientProvider client={queryClient}>
          <Example />
        </QueryClientProvider>
      )
    }
    
    function Example() {
      const { isPending, error, data } = useQuery({
        queryKey: ['repoData'],
        queryFn: () =>
          fetch('https://api.github.com/repos/TanStack/query').then((res) =>
            res.json(),
          ),
      })
    
      if (isPending) return 'Loading...'
    
      if (error) return 'An error has occurred: ' + error.message
    
      return (
        <div>
          <h1>{data.name}</h1>
          <p>{data.description}</p>
          <strong>üëÄ {data.subscribers_count}</strong>{' '}
          <strong>‚ú® {data.stargazers_count}</strong>{' '}
          <strong>üç¥ {data.forks_count}</strong>
        </div>
      )
    }
    

[](#you-talked-me-into-it-so-what-now)[You talked me into it, so what now?](#you-talked-me-into-it-so-what-now)
---------------------------------------------------------------------------------------------------------------

*   Consider taking the official [TanStack Query Course](https://query.gg/?s=tanstack) (or buying it for your whole team!)
*   Learn TanStack Query at your own pace with our amazingly thorough [Walkthrough Guide](https://tanstack.com/query/latest/docs/framework/react/installation) and [API Reference](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery)
*   See the Article [Why You Want React Query](https://tkdodo.eu/blog/why-you-want-react-query).</content>
</page>

<page>
  <title>TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/contributors</url>
  <content>Guides & Concepts

*   [](https://tanstack.com/query/latest/docs/framework/react/guides/important-defaults)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/queries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-keys)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-functions)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-options)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/network-mode)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/parallel-queries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/disabling-queries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-retries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/paginated-queries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/infinite-queries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/placeholder-query-data)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/mutations)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/invalidations-from-mutations)
*   [
    
    Updates from Mutation Responses
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/updates-from-mutation-responses)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/optimistic-updates)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-cancellation)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/scroll-restoration)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/filters)
*   [
    
    Performance & Request Waterfalls
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/request-waterfalls)
*   [
    
    Prefetching & Router Integration
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/prefetching)
*   [
    
    Server Rendering & Hydration
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/ssr)
*   [
    
    Advanced Server Rendering
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/advanced-ssr)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/caching)
*   [
    
    Render Optimizations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/render-optimizations)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/suspense)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/testing)
*   [
    
    Does this replace \[Redux, MobX, etc\]?
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/does-this-replace-client-state)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-react-query-3)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-react-query-4)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-v5)

API Reference

*   [](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useQueries)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useInfiniteQuery)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useMutation)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useIsFetching)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useIsMutating)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useMutationState)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseQuery)
*   [
    
    useSuspenseInfiniteQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseInfiniteQuery)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseQueries)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/QueryClientProvider)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useQueryClient)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/queryOptions)
*   [
    
    infiniteQueryOptions
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/infiniteQueryOptions)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/mutationOptions)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/usePrefetchQuery)
*   [
    
    usePrefetchInfiniteQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/usePrefetchInfiniteQuery)
*   [
    
    QueryErrorResetBoundary
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/QueryErrorResetBoundary)
*   [
    
    useQueryErrorResetBoundary
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useQueryErrorResetBoundary)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/hydration)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Examples

*   [](https://tanstack.com/query/latest/docs/framework/react/examples/simple)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/basic)
*   [
    
    Basic w/ GraphQL-Request
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/basic-graphql-request)
*   [
    
    Auto Refetching / Polling / Realtime
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/auto-refetching)
*   [
    
    Optimistic Updates (UI)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/optimistic-updates-ui)
*   [
    
    Optimistic Updates (Cache)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/optimistic-updates-cache)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/pagination)
*   [
    
    Load-More & Infinite Scroll
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/load-more-infinite-scroll)
*   [
    
    Infinite query with Max pages
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/infinite-query-with-max-pages)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/suspense)
*   [
    
    Default Query Function
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/default-query-function)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/playground)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/prefetching)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/star-wars)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/rick-morty)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/nextjs)
*   [
    
    Next.js app with prefetching
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/nextjs-app-prefetching)
*   [
    
    Next.js app with streaming
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/nextjs-suspense-streaming)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/react-native)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/react-router)
*   [
    
    Offline Queries and Mutations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/offline)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/algolia)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/shadow-dom)
*   [
    
    Devtools Embedded Panel
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/devtools-panel)
*   [
    
    Chat example (streaming)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/chat)

Plugins

*   [](https://tanstack.com/query/latest/docs/framework/react/plugins/persistQueryClient)
*   [
    
    createSyncStoragePersister
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/createSyncStoragePersister)
*   [
    
    createAsyncStoragePersister
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/createAsyncStoragePersister)
*   [
    
    broadcastQueryClient (Experimental)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/broadcastQueryClient)
*   [
    
    createPersister (Experimental)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/createPersister)

Guides & Concepts

*   [](https://tanstack.com/query/latest/docs/framework/react/guides/important-defaults)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/queries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-keys)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-functions)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-options)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/network-mode)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/parallel-queries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/disabling-queries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-retries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/paginated-queries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/infinite-queries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/placeholder-query-data)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/mutations)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/invalidations-from-mutations)
*   [
    
    Updates from Mutation Responses
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/updates-from-mutation-responses)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/optimistic-updates)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-cancellation)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/scroll-restoration)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/filters)
*   [
    
    Performance & Request Waterfalls
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/request-waterfalls)
*   [
    
    Prefetching & Router Integration
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/prefetching)
*   [
    
    Server Rendering & Hydration
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/ssr)
*   [
    
    Advanced Server Rendering
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/advanced-ssr)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/caching)
*   [
    
    Render Optimizations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/render-optimizations)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/suspense)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/testing)
*   [
    
    Does this replace \[Redux, MobX, etc\]?
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/does-this-replace-client-state)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-react-query-3)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-react-query-4)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-v5)

API Reference

*   [](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useQueries)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useInfiniteQuery)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useMutation)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useIsFetching)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useIsMutating)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useMutationState)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseQuery)
*   [
    
    useSuspenseInfiniteQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseInfiniteQuery)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseQueries)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/QueryClientProvider)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useQueryClient)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/queryOptions)
*   [
    
    infiniteQueryOptions
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/infiniteQueryOptions)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/mutationOptions)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/usePrefetchQuery)
*   [
    
    usePrefetchInfiniteQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/usePrefetchInfiniteQuery)
*   [
    
    QueryErrorResetBoundary
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/QueryErrorResetBoundary)
*   [
    
    useQueryErrorResetBoundary
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useQueryErrorResetBoundary)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/hydration)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Examples

*   [](https://tanstack.com/query/latest/docs/framework/react/examples/simple)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/basic)
*   [
    
    Basic w/ GraphQL-Request
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/basic-graphql-request)
*   [
    
    Auto Refetching / Polling / Realtime
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/auto-refetching)
*   [
    
    Optimistic Updates (UI)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/optimistic-updates-ui)
*   [
    
    Optimistic Updates (Cache)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/optimistic-updates-cache)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/pagination)
*   [
    
    Load-More & Infinite Scroll
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/load-more-infinite-scroll)
*   [
    
    Infinite query with Max pages
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/infinite-query-with-max-pages)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/suspense)
*   [
    
    Default Query Function
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/default-query-function)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/playground)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/prefetching)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/star-wars)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/rick-morty)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/nextjs)
*   [
    
    Next.js app with prefetching
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/nextjs-app-prefetching)
*   [
    
    Next.js app with streaming
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/nextjs-suspense-streaming)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/react-native)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/react-router)
*   [
    
    Offline Queries and Mutations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/offline)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/algolia)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/shadow-dom)
*   [
    
    Devtools Embedded Panel
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/devtools-panel)
*   [
    
    Chat example (streaming)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/chat)

Plugins

*   [](https://tanstack.com/query/latest/docs/framework/react/plugins/persistQueryClient)
*   [
    
    createSyncStoragePersister
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/createSyncStoragePersister)
*   [
    
    createAsyncStoragePersister
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/createAsyncStoragePersister)
*   [
    
    broadcastQueryClient (Experimental)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/broadcastQueryClient)
*   [
    
    createPersister (Experimental)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/createPersister)

TanStack Query Maintainers and Contributors
-------------------------------------------

[](https://github.com/lachlancollins)

Lachlan Collins

Maintainer

All-Time Contributors
---------------------</content>
</page>

<page>
  <title>TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework</url>
  <content>Guides & Concepts

*   [](https://tanstack.com/query/latest/docs/framework/react/guides/important-defaults)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/queries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-keys)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-functions)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-options)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/network-mode)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/parallel-queries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/disabling-queries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-retries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/paginated-queries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/infinite-queries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/placeholder-query-data)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/mutations)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/invalidations-from-mutations)
*   [
    
    Updates from Mutation Responses
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/updates-from-mutation-responses)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/optimistic-updates)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-cancellation)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/scroll-restoration)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/filters)
*   [
    
    Performance & Request Waterfalls
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/request-waterfalls)
*   [
    
    Prefetching & Router Integration
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/prefetching)
*   [
    
    Server Rendering & Hydration
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/ssr)
*   [
    
    Advanced Server Rendering
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/advanced-ssr)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/caching)
*   [
    
    Render Optimizations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/render-optimizations)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/suspense)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/testing)
*   [
    
    Does this replace \[Redux, MobX, etc\]?
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/does-this-replace-client-state)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-react-query-3)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-react-query-4)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-v5)

API Reference

*   [](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useQueries)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useInfiniteQuery)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useMutation)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useIsFetching)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useIsMutating)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useMutationState)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseQuery)
*   [
    
    useSuspenseInfiniteQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseInfiniteQuery)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseQueries)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/QueryClientProvider)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useQueryClient)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/queryOptions)
*   [
    
    infiniteQueryOptions
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/infiniteQueryOptions)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/mutationOptions)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/usePrefetchQuery)
*   [
    
    usePrefetchInfiniteQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/usePrefetchInfiniteQuery)
*   [
    
    QueryErrorResetBoundary
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/QueryErrorResetBoundary)
*   [
    
    useQueryErrorResetBoundary
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useQueryErrorResetBoundary)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/hydration)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Examples

*   [](https://tanstack.com/query/latest/docs/framework/react/examples/simple)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/basic)
*   [
    
    Basic w/ GraphQL-Request
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/basic-graphql-request)
*   [
    
    Auto Refetching / Polling / Realtime
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/auto-refetching)
*   [
    
    Optimistic Updates (UI)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/optimistic-updates-ui)
*   [
    
    Optimistic Updates (Cache)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/optimistic-updates-cache)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/pagination)
*   [
    
    Load-More & Infinite Scroll
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/load-more-infinite-scroll)
*   [
    
    Infinite query with Max pages
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/infinite-query-with-max-pages)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/suspense)
*   [
    
    Default Query Function
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/default-query-function)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/playground)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/prefetching)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/star-wars)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/rick-morty)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/nextjs)
*   [
    
    Next.js app with prefetching
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/nextjs-app-prefetching)
*   [
    
    Next.js app with streaming
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/nextjs-suspense-streaming)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/react-native)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/react-router)
*   [
    
    Offline Queries and Mutations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/offline)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/algolia)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/shadow-dom)
*   [
    
    Devtools Embedded Panel
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/devtools-panel)
*   [
    
    Chat example (streaming)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/chat)

Plugins

*   [](https://tanstack.com/query/latest/docs/framework/react/plugins/persistQueryClient)
*   [
    
    createSyncStoragePersister
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/createSyncStoragePersister)
*   [
    
    createAsyncStoragePersister
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/createAsyncStoragePersister)
*   [
    
    broadcastQueryClient (Experimental)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/broadcastQueryClient)
*   [
    
    createPersister (Experimental)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/createPersister)

Guides & Concepts

*   [](https://tanstack.com/query/latest/docs/framework/react/guides/important-defaults)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/queries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-keys)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-functions)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-options)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/network-mode)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/parallel-queries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/disabling-queries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-retries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/paginated-queries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/infinite-queries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/placeholder-query-data)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/mutations)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/invalidations-from-mutations)
*   [
    
    Updates from Mutation Responses
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/updates-from-mutation-responses)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/optimistic-updates)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-cancellation)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/scroll-restoration)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/filters)
*   [
    
    Performance & Request Waterfalls
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/request-waterfalls)
*   [
    
    Prefetching & Router Integration
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/prefetching)
*   [
    
    Server Rendering & Hydration
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/ssr)
*   [
    
    Advanced Server Rendering
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/advanced-ssr)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/caching)
*   [
    
    Render Optimizations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/render-optimizations)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/suspense)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/testing)
*   [
    
    Does this replace \[Redux, MobX, etc\]?
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/does-this-replace-client-state)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-react-query-3)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-react-query-4)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-v5)

API Reference

*   [](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useQueries)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useInfiniteQuery)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useMutation)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useIsFetching)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useIsMutating)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useMutationState)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseQuery)
*   [
    
    useSuspenseInfiniteQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseInfiniteQuery)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseQueries)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/QueryClientProvider)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useQueryClient)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/queryOptions)
*   [
    
    infiniteQueryOptions
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/infiniteQueryOptions)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/mutationOptions)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/usePrefetchQuery)
*   [
    
    usePrefetchInfiniteQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/usePrefetchInfiniteQuery)
*   [
    
    QueryErrorResetBoundary
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/QueryErrorResetBoundary)
*   [
    
    useQueryErrorResetBoundary
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useQueryErrorResetBoundary)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/hydration)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Examples

*   [](https://tanstack.com/query/latest/docs/framework/react/examples/simple)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/basic)
*   [
    
    Basic w/ GraphQL-Request
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/basic-graphql-request)
*   [
    
    Auto Refetching / Polling / Realtime
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/auto-refetching)
*   [
    
    Optimistic Updates (UI)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/optimistic-updates-ui)
*   [
    
    Optimistic Updates (Cache)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/optimistic-updates-cache)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/pagination)
*   [
    
    Load-More & Infinite Scroll
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/load-more-infinite-scroll)
*   [
    
    Infinite query with Max pages
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/infinite-query-with-max-pages)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/suspense)
*   [
    
    Default Query Function
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/default-query-function)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/playground)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/prefetching)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/star-wars)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/rick-morty)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/nextjs)
*   [
    
    Next.js app with prefetching
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/nextjs-app-prefetching)
*   [
    
    Next.js app with streaming
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/nextjs-suspense-streaming)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/react-native)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/react-router)
*   [
    
    Offline Queries and Mutations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/offline)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/algolia)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/shadow-dom)
*   [
    
    Devtools Embedded Panel
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/devtools-panel)
*   [
    
    Chat example (streaming)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/chat)

Plugins

*   [](https://tanstack.com/query/latest/docs/framework/react/plugins/persistQueryClient)
*   [
    
    createSyncStoragePersister
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/createSyncStoragePersister)
*   [
    
    createAsyncStoragePersister
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/createAsyncStoragePersister)
*   [
    
    broadcastQueryClient (Experimental)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/broadcastQueryClient)
*   [
    
    createPersister (Experimental)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/createPersister)</content>
</page>

<page>
  <title>Installation | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/installation</url>
  <content>You can install React Query via [NPM](https://npmjs.com/), or a good ol' <script> via [ESM.sh](https://esm.sh/).

### [](#npm)[NPM](#npm)

    npm i @tanstack/react-query
    

    npm i @tanstack/react-query
    

or

    pnpm add @tanstack/react-query
    

    pnpm add @tanstack/react-query
    

or

    yarn add @tanstack/react-query
    

    yarn add @tanstack/react-query
    

or

    bun add @tanstack/react-query
    

    bun add @tanstack/react-query
    

React Query is compatible with React v18+ and works with ReactDOM and React Native.

> Wanna give it a spin before you download? Try out the [simple](https://tanstack.com/query/latest/docs/framework/react/examples/simple) or [basic](https://tanstack.com/query/latest/docs/framework/react/examples/basic) examples!

### [](#cdn)[CDN](#cdn)

If you're not using a module bundler or package manager, you can also use this library via an ESM-compatible CDN such as [ESM.sh](https://esm.sh/). Simply add a <script type="module"> tag to the bottom of your HTML file:

    <script type="module">
      import React from 'https://esm.sh/react@18.2.0'
      import ReactDOM from 'https://esm.sh/react-dom@18.2.0'
      import { QueryClient } from 'https://esm.sh/@tanstack/react-query'
    </script>
    

    <script type="module">
      import React from 'https://esm.sh/react@18.2.0'
      import ReactDOM from 'https://esm.sh/react-dom@18.2.0'
      import { QueryClient } from 'https://esm.sh/@tanstack/react-query'
    </script>
    

> You can find instructions on how to use React without JSX [here](https://react.dev/reference/react/createElement#creating-an-element-without-jsx).

### [](#requirements)[Requirements](#requirements)

React Query is optimized for modern browsers. It is compatible with the following browsers config

    Chrome >= 91
    Firefox >= 90
    Edge >= 91
    Safari >= 15
    iOS >= 15
    Opera >= 77
    

    Chrome >= 91
    Firefox >= 90
    Edge >= 91
    Safari >= 15
    iOS >= 15
    Opera >= 77
    

> Depending on your environment, you might need to add polyfills. If you want to support older browsers, you need to transpile the library from node\_modules yourselves.

### [](#recommendations)[Recommendations](#recommendations)

It is recommended to also use our [ESLint Plugin Query](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query) to help you catch bugs and inconsistencies while you code. You can install it via:

    npm i -D @tanstack/eslint-plugin-query
    

    npm i -D @tanstack/eslint-plugin-query
    

or

    pnpm add -D @tanstack/eslint-plugin-query
    

    pnpm add -D @tanstack/eslint-plugin-query
    

or

    yarn add -D @tanstack/eslint-plugin-query
    

    yarn add -D @tanstack/eslint-plugin-query
    

or

    bun add -D @tanstack/eslint-plugin-query
    

    bun add -D @tanstack/eslint-plugin-query</content>
</page>

<page>
  <title>Quick Start | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/quick-start</url>
  <content>This code snippet very briefly illustrates the 3 core concepts of React Query:

*   [Queries](https://tanstack.com/query/latest/docs/framework/react/guides/queries)
*   [Mutations](https://tanstack.com/query/latest/docs/framework/react/guides/mutations)
*   [Query Invalidation](https://tanstack.com/query/latest/docs/framework/react/guides/query-invalidation)

If you're looking for a fully functioning example, please have a look at our [simple StackBlitz example](https://tanstack.com/query/latest/docs/framework/react/examples/simple)

    import {
      useQuery,
      useMutation,
      useQueryClient,
      QueryClient,
      QueryClientProvider,
    } from '@tanstack/react-query'
    import { getTodos, postTodo } from '../my-api'
    
    // Create a client
    const queryClient = new QueryClient()
    
    function App() {
      return (
        // Provide the client to your App
        <QueryClientProvider client={queryClient}>
          <Todos />
        </QueryClientProvider>
      )
    }
    
    function Todos() {
      // Access the client
      const queryClient = useQueryClient()
    
      // Queries
      const query = useQuery({ queryKey: ['todos'], queryFn: getTodos })
    
      // Mutations
      const mutation = useMutation({
        mutationFn: postTodo,
        onSuccess: () => {
          // Invalidate and refetch
          queryClient.invalidateQueries({ queryKey: ['todos'] })
        },
      })
    
      return (
        <div>
          <ul>
            {query.data?.map((todo) => (
              <li key={todo.id}>{todo.title}</li>
            ))}
          </ul>
    
          <button
            onClick={() => {
              mutation.mutate({
                id: Date.now(),
                title: 'Do Laundry',
              })
            }}
          >
            Add Todo
          </button>
        </div>
      )
    }
    
    render(<App />, document.getElementById('root'))
    

    import {
      useQuery,
      useMutation,
      useQueryClient,
      QueryClient,
      QueryClientProvider,
    } from '@tanstack/react-query'
    import { getTodos, postTodo } from '../my-api'
    
    // Create a client
    const queryClient = new QueryClient()
    
    function App() {
      return (
        // Provide the client to your App
        <QueryClientProvider client={queryClient}>
          <Todos />
        </QueryClientProvider>
      )
    }
    
    function Todos() {
      // Access the client
      const queryClient = useQueryClient()
    
      // Queries
      const query = useQuery({ queryKey: ['todos'], queryFn: getTodos })
    
      // Mutations
      const mutation = useMutation({
        mutationFn: postTodo,
        onSuccess: () => {
          // Invalidate and refetch
          queryClient.invalidateQueries({ queryKey: ['todos'] })
        },
      })
    
      return (
        <div>
          <ul>
            {query.data?.map((todo) => (
              <li key={todo.id}>{todo.title}</li>
            ))}
          </ul>
    
          <button
            onClick={() => {
              mutation.mutate({
                id: Date.now(),
                title: 'Do Laundry',
              })
            }}
          >
            Add Todo
          </button>
        </div>
      )
    }
    
    render(<App />, document.getElementById('root'))
    

These three concepts make up most of the core functionality of React Query. The next sections of the documentation will go over each of these core concepts in great detail.</content>
</page>

<page>
  <title>TanStack Query Community Resources</title>
  <url>https://tanstack.com/query/latest/docs/community-resources</url>
  <content>Documentation

Framework

Version

Menu

*   [
    
    Home
    
    
    
    ](https://tanstack.com/query/latest)
*   [
    
    Frameworks
    
    
    
    ](https://tanstack.com/query/latest/docs/framework)
*   [
    
    Contributors
    
    
    
    ](https://tanstack.com/query/latest/docs/contributors)
*   [
    
    Community Resources
    
    
    
    ](https://tanstack.com/query/latest/docs/community-resources)
*   [
    
    GitHub
    
    
    
    ](https://github.com/tanstack/query)
*   [
    
    Discord
    
    
    
    ](https://tlinz.com/discord)

Getting Started

*   [
    
    Overview
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/overview)
*   [
    
    Installation
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/installation)
*   [
    
    Quick Start
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/quick-start)
*   [
    
    Devtools
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/devtools)
*   [
    
    Comparison
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/comparison)
*   [
    
    TypeScript
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/typescript)
*   [
    
    GraphQL
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/graphql)
*   [
    
    React Native
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/react-native)

Guides & Concepts

*   [
    
    Important Defaults
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/important-defaults)
*   [
    
    Queries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/queries)
*   [
    
    Query Keys
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/query-keys)
*   [
    
    Query Functions
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/query-functions)
*   [
    
    Query Options
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/query-options)
*   [
    
    Network Mode
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/network-mode)
*   [
    
    Parallel Queries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/parallel-queries)
*   [
    
    Dependent Queries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/disabling-queries)
*   [
    
    Query Retries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/query-retries)
*   [
    
    Paginated Queries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/paginated-queries)
*   [
    
    Infinite Queries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/infinite-queries)
*   [
    
    Initial Query Data
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/placeholder-query-data)
*   [
    
    Mutations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/mutations)
*   [
    
    Query Invalidation
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/invalidations-from-mutations)
*   [
    
    Updates from Mutation Responses
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/updates-from-mutation-responses)
*   [
    
    Optimistic Updates
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/optimistic-updates)
*   [
    
    Query Cancellation
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/query-cancellation)
*   [
    
    Scroll Restoration
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/scroll-restoration)
*   [
    
    Filters
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/filters)
*   [
    
    Performance & Request Waterfalls
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/request-waterfalls)
*   [
    
    Prefetching & Router Integration
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/prefetching)
*   [
    
    Server Rendering & Hydration
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/ssr)
*   [
    
    Advanced Server Rendering
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/advanced-ssr)
*   [
    
    Caching
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/caching)
*   [
    
    Render Optimizations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/render-optimizations)
*   [
    
    Default Query Fn
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function)
*   [
    
    Suspense
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/suspense)
*   [
    
    Testing
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/testing)
*   [
    
    Does this replace \[Redux, MobX, etc\]?
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/does-this-replace-client-state)
*   [
    
    Migrating to v3
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-react-query-3)
*   [
    
    Migrating to v4
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-react-query-4)
*   [
    
    Migrating to v5
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-v5)

API Reference

*   [
    
    QueryClient
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [
    
    QueryCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [
    
    MutationCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [
    
    QueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [
    
    QueriesObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [
    
    streamedQuery
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [
    
    focusManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [
    
    onlineManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [
    
    notifyManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [
    
    timeoutManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [
    
    useQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery)
*   [
    
    useQueries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useQueries)
*   [
    
    useInfiniteQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useInfiniteQuery)
*   [
    
    useMutation
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useMutation)
*   [
    
    useIsFetching
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useIsFetching)
*   [
    
    useIsMutating
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useIsMutating)
*   [
    
    useMutationState
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useMutationState)
*   [
    
    useSuspenseQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseQuery)
*   [
    
    useSuspenseInfiniteQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseInfiniteQuery)
*   [
    
    useSuspenseQueries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseQueries)
*   [
    
    QueryClientProvider
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/QueryClientProvider)
*   [
    
    useQueryClient
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useQueryClient)
*   [
    
    queryOptions
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/queryOptions)
*   [
    
    infiniteQueryOptions
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/infiniteQueryOptions)
*   [
    
    mutationOptions
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/mutationOptions)
*   [
    
    usePrefetchQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/usePrefetchQuery)
*   [
    
    usePrefetchInfiniteQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/usePrefetchInfiniteQuery)
*   [
    
    QueryErrorResetBoundary
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/QueryErrorResetBoundary)
*   [
    
    useQueryErrorResetBoundary
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useQueryErrorResetBoundary)
*   [
    
    hydration
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/hydration)

ESLint

*   [
    
    ESLint Plugin Query
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [
    
    Exhaustive Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [
    
    Stable Query Client
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [
    
    No Unstable Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Examples

*   [
    
    Simple
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/simple)
*   [
    
    Basic
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/basic)
*   [
    
    Basic w/ GraphQL-Request
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/basic-graphql-request)
*   [
    
    Auto Refetching / Polling / Realtime
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/auto-refetching)
*   [
    
    Optimistic Updates (UI)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/optimistic-updates-ui)
*   [
    
    Optimistic Updates (Cache)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/optimistic-updates-cache)
*   [
    
    Pagination
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/pagination)
*   [
    
    Load-More & Infinite Scroll
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/load-more-infinite-scroll)
*   [
    
    Infinite query with Max pages
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/infinite-query-with-max-pages)
*   [
    
    Suspense
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/suspense)
*   [
    
    Default Query Function
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/default-query-function)
*   [
    
    Playground
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/playground)
*   [
    
    Prefetching
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/prefetching)
*   [
    
    Star Wars
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/star-wars)
*   [
    
    Rick And Morty
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/rick-morty)
*   [
    
    Next.js Pages
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/nextjs)
*   [
    
    Next.js app with prefetching
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/nextjs-app-prefetching)
*   [
    
    Next.js app with streaming
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/nextjs-suspense-streaming)
*   [
    
    React Native
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/react-native)
*   [
    
    React Router
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/react-router)
*   [
    
    Offline Queries and Mutations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/offline)
*   [
    
    Algolia
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/algolia)
*   [
    
    Shadow DOM
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/shadow-dom)
*   [
    
    Devtools Embedded Panel
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/devtools-panel)
*   [
    
    Chat example (streaming)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/chat)

Plugins

*   [
    
    persistQueryClient
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/persistQueryClient)
*   [
    
    createSyncStoragePersister
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/createSyncStoragePersister)
*   [
    
    createAsyncStoragePersister
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/createAsyncStoragePersister)
*   [
    
    broadcastQueryClient (Experimental)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/broadcastQueryClient)
*   [
    
    createPersister (Experimental)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/createPersister)

Framework

Version

Menu

*   [
    
    Home
    
    
    
    ](https://tanstack.com/query/latest)
*   [
    
    Frameworks
    
    
    
    ](https://tanstack.com/query/latest/docs/framework)
*   [
    
    Contributors
    
    
    
    ](https://tanstack.com/query/latest/docs/contributors)
*   [
    
    Community Resources
    
    
    
    ](https://tanstack.com/query/latest/docs/community-resources)
*   [
    
    GitHub
    
    
    
    ](https://github.com/tanstack/query)
*   [
    
    Discord
    
    
    
    ](https://tlinz.com/discord)

Getting Started

*   [
    
    Overview
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/overview)
*   [
    
    Installation
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/installation)
*   [
    
    Quick Start
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/quick-start)
*   [
    
    Devtools
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/devtools)
*   [
    
    Comparison
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/comparison)
*   [
    
    TypeScript
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/typescript)
*   [
    
    GraphQL
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/graphql)
*   [
    
    React Native
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/react-native)

Guides & Concepts

*   [
    
    Important Defaults
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/important-defaults)
*   [
    
    Queries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/queries)
*   [
    
    Query Keys
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/query-keys)
*   [
    
    Query Functions
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/query-functions)
*   [
    
    Query Options
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/query-options)
*   [
    
    Network Mode
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/network-mode)
*   [
    
    Parallel Queries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/parallel-queries)
*   [
    
    Dependent Queries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/disabling-queries)
*   [
    
    Query Retries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/query-retries)
*   [
    
    Paginated Queries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/paginated-queries)
*   [
    
    Infinite Queries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/infinite-queries)
*   [
    
    Initial Query Data
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/placeholder-query-data)
*   [
    
    Mutations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/mutations)
*   [
    
    Query Invalidation
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/invalidations-from-mutations)
*   [
    
    Updates from Mutation Responses
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/updates-from-mutation-responses)
*   [
    
    Optimistic Updates
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/optimistic-updates)
*   [
    
    Query Cancellation
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/query-cancellation)
*   [
    
    Scroll Restoration
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/scroll-restoration)
*   [
    
    Filters
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/filters)
*   [
    
    Performance & Request Waterfalls
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/request-waterfalls)
*   [
    
    Prefetching & Router Integration
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/prefetching)
*   [
    
    Server Rendering & Hydration
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/ssr)
*   [
    
    Advanced Server Rendering
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/advanced-ssr)
*   [
    
    Caching
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/caching)
*   [
    
    Render Optimizations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/render-optimizations)
*   [
    
    Default Query Fn
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function)
*   [
    
    Suspense
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/suspense)
*   [
    
    Testing
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/testing)
*   [
    
    Does this replace \[Redux, MobX, etc\]?
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/does-this-replace-client-state)
*   [
    
    Migrating to v3
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-react-query-3)
*   [
    
    Migrating to v4
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-react-query-4)
*   [
    
    Migrating to v5
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-v5)

API Reference

*   [
    
    QueryClient
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [
    
    QueryCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [
    
    MutationCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [
    
    QueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [
    
    QueriesObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [
    
    streamedQuery
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [
    
    focusManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [
    
    onlineManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [
    
    notifyManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [
    
    timeoutManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [
    
    useQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery)
*   [
    
    useQueries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useQueries)
*   [
    
    useInfiniteQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useInfiniteQuery)
*   [
    
    useMutation
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useMutation)
*   [
    
    useIsFetching
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useIsFetching)
*   [
    
    useIsMutating
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useIsMutating)
*   [
    
    useMutationState
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useMutationState)
*   [
    
    useSuspenseQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseQuery)
*   [
    
    useSuspenseInfiniteQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseInfiniteQuery)
*   [
    
    useSuspenseQueries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseQueries)
*   [
    
    QueryClientProvider
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/QueryClientProvider)
*   [
    
    useQueryClient
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useQueryClient)
*   [
    
    queryOptions
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/queryOptions)
*   [
    
    infiniteQueryOptions
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/infiniteQueryOptions)
*   [
    
    mutationOptions
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/mutationOptions)
*   [
    
    usePrefetchQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/usePrefetchQuery)
*   [
    
    usePrefetchInfiniteQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/usePrefetchInfiniteQuery)
*   [
    
    QueryErrorResetBoundary
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/QueryErrorResetBoundary)
*   [
    
    useQueryErrorResetBoundary
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useQueryErrorResetBoundary)
*   [
    
    hydration
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/hydration)

ESLint

*   [
    
    ESLint Plugin Query
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [
    
    Exhaustive Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [
    
    Stable Query Client
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [
    
    No Unstable Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Examples

*   [
    
    Simple
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/simple)
*   [
    
    Basic
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/basic)
*   [
    
    Basic w/ GraphQL-Request
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/basic-graphql-request)
*   [
    
    Auto Refetching / Polling / Realtime
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/auto-refetching)
*   [
    
    Optimistic Updates (UI)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/optimistic-updates-ui)
*   [
    
    Optimistic Updates (Cache)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/optimistic-updates-cache)
*   [
    
    Pagination
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/pagination)
*   [
    
    Load-More & Infinite Scroll
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/load-more-infinite-scroll)
*   [
    
    Infinite query with Max pages
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/infinite-query-with-max-pages)
*   [
    
    Suspense
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/suspense)
*   [
    
    Default Query Function
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/default-query-function)
*   [
    
    Playground
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/playground)
*   [
    
    Prefetching
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/prefetching)
*   [
    
    Star Wars
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/star-wars)
*   [
    
    Rick And Morty
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/rick-morty)
*   [
    
    Next.js Pages
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/nextjs)
*   [
    
    Next.js app with prefetching
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/nextjs-app-prefetching)
*   [
    
    Next.js app with streaming
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/nextjs-suspense-streaming)
*   [
    
    React Native
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/react-native)
*   [
    
    React Router
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/react-router)
*   [
    
    Offline Queries and Mutations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/offline)
*   [
    
    Algolia
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/algolia)
*   [
    
    Shadow DOM
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/shadow-dom)
*   [
    
    Devtools Embedded Panel
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/devtools-panel)
*   [
    
    Chat example (streaming)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/chat)

Plugins

*   [
    
    persistQueryClient
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/persistQueryClient)
*   [
    
    createSyncStoragePersister
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/createSyncStoragePersister)
*   [
    
    createAsyncStoragePersister
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/createAsyncStoragePersister)
*   [
    
    broadcastQueryClient (Experimental)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/broadcastQueryClient)
*   [
    
    createPersister (Experimental)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/createPersister)

Discover resources created by the **TanStack Query** community. Have something to share? [Submit a PR on GitHub](https://github.com/query/edit/main/docs/community-resources.md) to contribute to this list.

article
-------

[TkDodo's Blog Posts

TkDodo, a maintainer of TanStack Query, writes a series of blog posts about the library. These articles offer general best practices and often present opinionated perspectives on using TanStack Query.

](https://tkdodo.eu/blog/practical-react-query)

media
-----

[React Query: It‚Äôs Time to Break up with your Global State! ‚Äì Tanner Linsley

Get the lowdown on ‚Äúglobal state‚Äù and how React Query can help you fetch, cache and manage your asynchronous data with a fraction of the effort and code that you‚Äôre used to

](https://www.youtube.com/watch?v=seU46c6Jz7E)[All About React Query (with Tanner Linsley) ‚Äî Learn With Jason

Learn all about React Query with its creator Tanner Linsley.

](https://www.youtube.com/watch?v=DocXo3gqGdI)[Hooks for Fetching with ReactQuery Creator Tanner Linsley aka @tannerlinsley

Learn how React Query simplifies asynchronous data fetching in React applications.

](https://www.youtube.com/watch?v=PPvWXbSCtBU)[React Query - Open Source Friday stream with Tanner Linsley from

An Open Source Friday stream featuring Tanner Linsley.

](https://www.youtube.com/watch?v=B3cJDT3j19I)[React Query Presentation - Tanner Linsley

Tanner Linsley gives a talk to Lambda School students about the React Query.

](https://www.youtube.com/watch?v=_ehibado6rU)[TanStack Query v4 (with Dominik Dorfmeister) ‚Äî Learn With Jason

Dominik Dorfmeister covering TanStack Query v4.

](https://www.youtube.com/watch?v=SPPQm0dvEes)[React Query Exposed by Its Maintainer

Dominik Dorfmeister explores the less favorable aspects of React Query and situations where it may not be the best fit.

](https://www.youtube.com/watch?v=8-RTNnn9GR8)[React Query API Design: Lessons Learned - Dominik Dorfmeister

Dominik Dorfmeister walks through some of the API design choices that were made in React Query to get to the DX.

](https://www.youtube.com/watch?v=l3PxErcKeAI)

utility
-------

[batshit

A batch manager that will deduplicate and batch requests for a certain data type made within a window

](https://github.com/yornaath/batshit)[GraphQL Code Generator

Generate React Query hooks from your GraphQL schema

](https://the-guild.dev/graphql/codegen)[Http-wizard

End-to-end type-safe Fastify API with typeScript magic ‚ú®

](https://http-wizard.com/)[Normy

Automatic normalization and data updates for data fetching libraries

](https://github.com/klis87/normy)[Orval

Generate TypeScript client from OpenAPI specifications.

](https://orval.dev/)[Query Key Factory

A library for creating typesafe standardized query keys, useful for cache management in @tanstack/query

](https://github.com/lukemorales/query-key-factory)[React Query Kit

üïäÔ∏è A toolkit for ReactQuery that makes ReactQuery hooks reusable and typesafe

](https://github.com/liaoliao666/react-query-kit)[React Query Rewind

Time travel and visualize state during development

](https://reactqueryrewind.com/)[React Query Swagger

Generate React Query hooks based on Swagger API definitions

](https://github.com/Shaddix/react-query-swagger)[Suspensive React Query

Enhances React Query with Suspense support, allowing for simpler and more declarative data fetching

](https://suspensive.org/docs/react-query/motivation)[tRPC

End-to-end typesafe APIs made easy

](https://trpc.io/)

other
-----

[Atomic CRM

A full-featured CRM built with React, react-admin, and Supabase.

](https://marmelab.com/atomic-crm/)[Blitz

The Missing Fullstack Toolkit for Next.js

](https://blitzjs.com/)[Connect

A family of libraries for building browser and gRPC-compatible HTTP APIs.

](https://connectrpc.com/docs)[Hey API

The OpenAPI to TypeScript codegen. Generate clients, SDKs, validators, and more.

](https://heyapi.dev/openapi-ts/plugins/tanstack-query)[Kubb

Generate SDKs for all your APIs

](https://www.kubb.dev/)[OpenAPI codegen

A tool for generating code based on an OpenAPI schema.

](https://github.com/fabien0102/openapi-codegen)[OpenAPI Qraft React

Generate type-safe API clients and Hooks for TanStack Query directly from OpenAPI Documents.Zero-runtime overhead, Proxy-based design, seamless SSR support, and full TanStack Query functionality.

](https://github.com/OpenAPI-Qraft/openapi-qraft)[OpenAPI React Query codegen

Generate TanStack Query hooks based on an OpenAPI specification file.

](https://github.com/7nohe/openapi-react-query-codegen)[OpenAPI zod client

Generate a zodios client from an OpenAPI specification

](https://github.com/astahmer/openapi-zod-client)[openapi-fetch

A 2KB min, typesafe fetch wrapper that uses static TypeScript type inference and no runtime checks.

](https://openapi-ts.dev/openapi-react-query/)[oRPC

Easy to build APIs that are end-to-end type-safe and adhere to OpenAPI standards.

](https://orpc.unnoq.com/docs/integrations/tanstack-query)[Rapini

ü•¨ OpenAPI to React Query (or SWR) & Axios

](https://github.com/rametta/rapini)[ts-rest

Incrementally adoptable type-safety for your new and existing APIs

](https://ts-rest.com/)[wagmi

React Hooks for Ethereum based on @tanstack/react-query

](https://wagmi.sh/)[zodios

End-to-end typesafe REST API toolbox

](https://www.zodios.org/)

[Learn about TanStack Ads](https://tanstack.com/ads)[Hide Ads](https://tanstack.com/ads#hide-ads)

[

Home



](https://tanstack.com/query/latest)

[Partners](https://tanstack.com/partners)[Become a Partner](https://docs.google.com/document/d/1Hg2MzY2TU6U3hFEZ3MLe2oEOM3JS4-eByti3kdJU3I8)

[](https://coderabbit.link/tanstack?utm_source=tanstack&via=tanstack)[](https://www.cloudflare.com/?utm_source=tanstack)[](https://ag-grid.com/react-data-grid/?utm_source=reacttable&utm_campaign=githubreacttable)[](https://netlify.com/?utm_source=tanstack)[](https://neon.tech/?utm_source=tanstack)[](https://workos.com/?utm_source=tanstack)[](https://go.clerk.com/wOwHtuJ)[](https://convex.dev/?utm_source=tanstack)[](https://electric-sql.com/)[](https://sentry.io/?utm_source=tanstack)[](https://www.prisma.io/?utm_source=tanstack&via=tanstack)[](https://strapi.link/tanstack-start)[](https://www.unkey.com/?utm_source=tanstack)

[Learn about TanStack Ads](https://tanstack.com/ads)[Hide Ads](https://tanstack.com/ads#hide-ads)

[

###### Want to Skip the Docs?

Query.gg - The Official React Query Course

Black Friday Sale
-----------------

Get 50% off through December 6th

01

days

:

22

hours

:

56

minutes









](https://query.gg/?s=tanstack)</content>
</page>

<page>
  <title>Comparison | React Query vs SWR vs Apollo vs RTK Query vs React Router | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/comparison</url>
  <content>> This comparison table strives to be as accurate and as unbiased as possible. If you use any of these libraries and feel the information could be improved, feel free to suggest changes (with notes or evidence of claims) using the "Edit this page on Github" link at the bottom of this page.

Feature/Capability Key:

*   ‚úÖ 1st-class, built-in, and ready to use with no added configuration or code
*   üü° Supported, but as an unofficial 3rd party or community library/contribution
*   üî∂ Supported and documented, but requires extra user-code to implement
*   üõë Not officially supported or documented.

|  | React Query | SWR [_(Website)_](https://github.com/vercel/swr) | Apollo Client [_(Website)_](https://github.com/apollographql/apollo-client) | RTK-Query [_(Website)_](https://redux-toolkit.js.org/rtk-query/overview) | React Router [_(Website)_](https://github.com/remix-run/react-router) |
| --- | --- | --- | --- | --- | --- |
| Github Repo / Stars | [](https://github.com/tannerlinsley/react-query) | [](https://github.com/vercel/swr) | [](https://github.com/apollographql/apollo-client) | [](https://github.com/reduxjs/redux-toolkit) | [](https://github.com/remix-run/react-router) |
| Platform Requirements | React | React | React, GraphQL | Redux | React |
| Their Comparison |  | (none) | (none) | [Comparison](https://redux-toolkit.js.org/rtk-query/comparison) | (none) |
| Supported Query Syntax | Promise, REST, GraphQL | Promise, REST, GraphQL | GraphQL, Any (Reactive Variables) | Promise, REST, GraphQL | Promise, REST, GraphQL |
| Supported Frameworks | React | React | React + Others | Any | React |
| Caching Strategy | Hierarchical Key -> Value | Unique Key -> Value | Normalized Schema | Unique Key -> Value | Nested Route -> value |
| Cache Key Strategy | JSON | JSON | GraphQL Query | JSON | Route Path |
| Cache Change Detection | Deep Compare Keys (Stable Serialization) | Deep Compare Keys (Stable Serialization) | Deep Compare Keys (Unstable Serialization) | Key Referential Equality (===) | Route Change |
| Data Change Detection | Deep Comparison + Structural Sharing | Deep Compare (via stable-hash) | Deep Compare (Unstable Serialization) | Key Referential Equality (===) | Loader Run |
| Data Memoization | Full Structural Sharing | Identity (===) | Normalized Identity | Identity (===) | Identity (===) |
| Bundle Size | [](https://bundlephobia.com/result?p=react-query) | [](https://bundlephobia.com/result?p=swr) | [](https://bundlephobia.com/result?p=@apollo/client) | [](https://bundlephobia.com/package/@reduxjs/toolkit) | [](https://bundlephobia.com/result?p=react-router-dom)+[](https://bundlephobia.com/result?p=history) |
| API Definition Location | Component, External Config | Component | GraphQL Schema | External Config | Route Tree Configuration |
| Queries | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| Cache Persistence | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | üõë Active Routes Only 8 |
| Devtools | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | üõë |
| Polling/Intervals | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | üõë |
| Parallel Queries | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| Dependent Queries | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| Paginated Queries | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| Infinite Queries | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | üõë |
| Bi-directional Infinite Queries | ‚úÖ | üî∂ | üî∂ | ‚úÖ | üõë |
| Infinite Query Refetching | ‚úÖ | ‚úÖ | üõë | ‚úÖ | üõë |
| Lagged Query Data1 | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| Selectors | ‚úÖ | üõë | ‚úÖ | ‚úÖ | N/A |
| Initial Data | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| Scroll Recovery | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| Cache Manipulation | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | üõë |
| Outdated Query Dismissal | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| Render Batching & Optimization2 | ‚úÖ | ‚úÖ | üõë | ‚úÖ | ‚úÖ |
| Auto Garbage Collection | ‚úÖ | üõë | üõë | ‚úÖ | N/A |
| Mutation Hooks | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| Offline Mutation Support | ‚úÖ | üõë | üü° | üõë | üõë |
| Prefetching APIs | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| Query Cancellation | ‚úÖ | üõë | üõë | üõë | ‚úÖ |
| Partial Query Matching3 | ‚úÖ | üî∂ | ‚úÖ | ‚úÖ | N/A |
| Stale While Revalidate | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | üõë |
| Stale Time Configuration | ‚úÖ | üõë7 | üõë | ‚úÖ | üõë |
| Pre-usage Query/Mutation Configuration4 | ‚úÖ | üõë | ‚úÖ | ‚úÖ | ‚úÖ |
| Window Focus Refetching | ‚úÖ | ‚úÖ | üõë | ‚úÖ | üõë |
| Network Status Refetching | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | üõë |
| General Cache Dehydration/Rehydration | ‚úÖ | üõë | ‚úÖ | ‚úÖ | ‚úÖ |
| Offline Caching | ‚úÖ | üõë | ‚úÖ | üî∂ | üõë |
| React Suspense | ‚úÖ | ‚úÖ | ‚úÖ | üõë | ‚úÖ |
| Abstracted/Agnostic Core | ‚úÖ | üõë | ‚úÖ | ‚úÖ | üõë |
| Automatic Refetch after Mutation5 | üî∂ | üî∂ | ‚úÖ | ‚úÖ | ‚úÖ |
| Normalized Caching6 | üõë | üõë | ‚úÖ | üõë | üõë |

### [](#notes)[Notes](#notes)

> **1 Lagged Query Data** - React Query provides a way to continue to see an existing query's data while the next query loads (similar to the same UX that suspense will soon provide natively). This is extremely important when writing pagination UIs or infinite loading UIs where you do not want to show a hard loading state whenever a new query is requested. Other libraries do not have this capability and render a hard loading state for the new query (unless it has been prefetched), while the new query loads.

> **2 Render Optimization** - React Query has excellent rendering performance. By default, it will automatically track which fields are accessed and only re-render if one of them changes. If you would like to opt-out of this optimization, setting notifyOnChangeProps to 'all' will re-render your components whenever the query is updated. For example because it has new data, or to indicate it is fetching. React Query also batches updates together to make sure your application only re-renders once when multiple components are using the same query. If you are only interested in the data or error properties, you can reduce the number of renders even more by setting notifyOnChangeProps to \['data', 'error'\].

> **3 Partial query matching** - Because React Query uses deterministic query key serialization, this allows you to manipulate variable groups of queries without having to know each individual query-key that you want to match, eg. you can refetch every query that starts with todos in its key, regardless of variables, or you can target specific queries with (or without) variables or nested properties, and even use a filter function to only match queries that pass your specific conditions.

> **4 Pre-usage Query Configuration** - This is simply a fancy name for being able to configure how queries and mutations will behave before they are used. For instance, a query can be fully configured with defaults beforehand and when the time comes to use it, only useQuery({ queryKey }) is necessary, instead of being required to pass the fetcher and/or options with every usage. SWR does have a partial form of this feature by allowing you to pre-configure a default fetcher, but only as a global fetcher, not on a per-query basis and definitely not for mutations.

> **5 Automatic Refetch after Mutation** - For truly automatic refetching to happen after a mutation occurs, a schema is necessary (like the one graphQL provides) along with heuristics that help the library know how to identify individual entities and entities types in that schema.

> **6 Normalized Caching** - React Query, SWR and RTK-Query do not currently support automatic-normalized caching which describes storing entities in a flat architecture to avoid some high-level data duplication.

> **7 SWR's Immutable Mode** - SWR ships with an "immutable" mode that does allow you to only fetch a query once for the life of the cache, but it still does not have the concept of stale-time or conditional auto-revalidation

> **8 React Router cache persistence** - React Router does not cache data beyond the currently matched routes. If a route is left, its data is lost.</content>
</page>

<page>
  <title>Devtools | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/devtools</url>
  <content>Wave your hands in the air and shout hooray because React Query comes with dedicated devtools! ü•≥

When you begin your React Query journey, you'll want these devtools by your side. They help visualize all the inner workings of React Query and will likely save you hours of debugging if you find yourself in a pinch!

> For Chrome, Firefox, and Edge users: Third-party browser extensions are available for debugging TanStack Query directly in browser DevTools. These provide the same functionality as the framework-specific devtools packages:
> 
> *   [Devtools for Chrome](https://chromewebstore.google.com/detail/tanstack-query-devtools/annajfchloimdhceglpgglpeepfghfai)
> *   [Devtools for Firefox](https://addons.mozilla.org/en-US/firefox/addon/tanstack-query-devtools/)
> *   [Devtools for Edge](https://microsoftedge.microsoft.com/addons/detail/tanstack-query-devtools/edmdpkgkacmjopodhfolmphdenmddobj)

> For React Native users: A third-party native macOS app is available for debugging React Query in ANY js-based application. Monitor queries across devices in real-time. Check it out here: [rn-better-dev-tools](https://github.com/LovesWorking/rn-better-dev-tools)

> Note that since version 5, the dev tools support observing mutations as well.

The devtools are a separate package that you need to install:

    npm i @tanstack/react-query-devtools
    

    npm i @tanstack/react-query-devtools
    

or

    pnpm add @tanstack/react-query-devtools
    

    pnpm add @tanstack/react-query-devtools
    

or

    yarn add @tanstack/react-query-devtools
    

    yarn add @tanstack/react-query-devtools
    

or

    bun add @tanstack/react-query-devtools
    

    bun add @tanstack/react-query-devtools
    

For Next 13+ App Dir you must install it as a dev dependency for it to work.

You can import the devtools like this:

    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    

    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    

By default, React Query Devtools are only included in bundles when process.env.NODE\_ENV === 'development', so you don't need to worry about excluding them during a production build.

[](#floating-mode)[Floating Mode](#floating-mode)
-------------------------------------------------

Floating Mode will mount the devtools as a fixed, floating element in your app and provide a toggle in the corner of the screen to show and hide the devtools. This toggle state will be stored and remembered in localStorage across reloads.

Place the following code as high in your React app as you can. The closer it is to the root of the page, the better it will work!

    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    
    function App() {
      return (
        <QueryClientProvider client={queryClient}>
          {/* The rest of your application */}
          <ReactQueryDevtools initialIsOpen={false} />
        </QueryClientProvider>
      )
    }
    

    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    
    function App() {
      return (
        <QueryClientProvider client={queryClient}>
          {/* The rest of your application */}
          <ReactQueryDevtools initialIsOpen={false} />
        </QueryClientProvider>
      )
    }
    

### [](#options)[Options](#options)

*   initialIsOpen: boolean
    *   Set this true if you want the dev tools to default to being open
*   buttonPosition?: "top-left" | "top-right" | "bottom-left" | "bottom-right" | "relative"
    *   Defaults to bottom-right
    *   The position of the React Query logo to open and close the devtools panel
    *   If relative, the button is placed in the location that you render the devtools.
*   position?: "top" | "bottom" | "left" | "right"
    *   Defaults to bottom
    *   The position of the React Query devtools panel
*   client?: QueryClient,
    *   Use this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.
*   errorTypes?: { name: string; initializer: (query: Query) => TError}\[\]
    *   Use this to predefine some errors that can be triggered on your queries. Initializer will be called (with the specific query) when that error is toggled on from the UI. It must return an Error.
*   styleNonce?: string
    *   Use this to pass a nonce to the style tag that is added to the document head. This is useful if you are using a Content Security Policy (CSP) nonce to allow inline styles.
*   shadowDOMTarget?: ShadowRoot
    *   Default behavior will apply the devtool's styles to the head tag within the DOM.
    *   Use this to pass a shadow DOM target to the devtools so that the styles will be applied within the shadow DOM instead of within the head tag in the light DOM.

[](#embedded-mode)[Embedded Mode](#embedded-mode)
-------------------------------------------------

Embedded mode will show the development tools as a fixed element in your application, so you can use our panel in your own development tools.

Place the following code as high in your React app as you can. The closer it is to the root of the page, the better it will work!

    import { ReactQueryDevtoolsPanel } from '@tanstack/react-query-devtools'
    
    function App() {
      const [isOpen, setIsOpen] = React.useState(false)
    
      return (
        <QueryClientProvider client={queryClient}>
          {/* The rest of your application */}
          <button
            onClick={() => setIsOpen(!isOpen)}
          >{`${isOpen ? 'Close' : 'Open'} the devtools panel`}</button>
          {isOpen && <ReactQueryDevtoolsPanel onClose={() => setIsOpen(false)} />}
        </QueryClientProvider>
      )
    }
    

    import { ReactQueryDevtoolsPanel } from '@tanstack/react-query-devtools'
    
    function App() {
      const [isOpen, setIsOpen] = React.useState(false)
    
      return (
        <QueryClientProvider client={queryClient}>
          {/* The rest of your application */}
          <button
            onClick={() => setIsOpen(!isOpen)}
          >{`${isOpen ? 'Close' : 'Open'} the devtools panel`}</button>
          {isOpen && <ReactQueryDevtoolsPanel onClose={() => setIsOpen(false)} />}
        </QueryClientProvider>
      )
    }
    

### [](#options-1)[Options](#options-1)

*   style?: React.CSSProperties
    *   Custom styles for the devtools panel
    *   Default: { height: '500px' }
    *   Example: { height: '100%' }
    *   Example: { height: '100%', width: '100%' }
*   onClose?: () => unknown
    *   Callback function that is called when the devtools panel is closed
*   client?: QueryClient,
    *   Use this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.
*   errorTypes?: { name: string; initializer: (query: Query) => TError}\[\]
    *   Use this to predefine some errors that can be triggered on your queries. Initializer will be called (with the specific query) when that error is toggled on from the UI. It must return an Error.
*   styleNonce?: string
    *   Use this to pass a nonce to the style tag that is added to the document head. This is useful if you are using a Content Security Policy (CSP) nonce to allow inline styles.
*   shadowDOMTarget?: ShadowRoot
    *   Default behavior will apply the devtool's styles to the head tag within the DOM.
    *   Use this to pass a shadow DOM target to the devtools so that the styles will be applied within the shadow DOM instead of within the head tag in the light DOM.

Devtools are excluded in production builds. However, it might be desirable to lazy load the devtools in production:

    import * as React from 'react'
    import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    import { Example } from './Example'
    
    const queryClient = new QueryClient()
    
    const ReactQueryDevtoolsProduction = React.lazy(() =>
      import('@tanstack/react-query-devtools/build/modern/production.js').then(
        (d) => ({
          default: d.ReactQueryDevtools,
        }),
      ),
    )
    
    function App() {
      const [showDevtools, setShowDevtools] = React.useState(false)
    
      React.useEffect(() => {
        // @ts-expect-error
        window.toggleDevtools = () => setShowDevtools((old) => !old)
      }, [])
    
      return (
        <QueryClientProvider client={queryClient}>
          <Example />
          <ReactQueryDevtools initialIsOpen />
          {showDevtools && (
            <React.Suspense fallback={null}>
              <ReactQueryDevtoolsProduction />
            </React.Suspense>
          )}
        </QueryClientProvider>
      )
    }
    
    export default App
    

    import * as React from 'react'
    import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    import { Example } from './Example'
    
    const queryClient = new QueryClient()
    
    const ReactQueryDevtoolsProduction = React.lazy(() =>
      import('@tanstack/react-query-devtools/build/modern/production.js').then(
        (d) => ({
          default: d.ReactQueryDevtools,
        }),
      ),
    )
    
    function App() {
      const [showDevtools, setShowDevtools] = React.useState(false)
    
      React.useEffect(() => {
        // @ts-expect-error
        window.toggleDevtools = () => setShowDevtools((old) => !old)
      }, [])
    
      return (
        <QueryClientProvider client={queryClient}>
          <Example />
          <ReactQueryDevtools initialIsOpen />
          {showDevtools && (
            <React.Suspense fallback={null}>
              <ReactQueryDevtoolsProduction />
            </React.Suspense>
          )}
        </QueryClientProvider>
      )
    }
    
    export default App
    

With this, calling window.toggleDevtools() will download the devtools bundle and show them.

### [](#modern-bundlers)[Modern bundlers](#modern-bundlers)

If your bundler supports package exports, you can use the following import path:

    const ReactQueryDevtoolsProduction = React.lazy(() =>
      import('@tanstack/react-query-devtools/production').then((d) => ({
        default: d.ReactQueryDevtools,
      })),
    )
    

    const ReactQueryDevtoolsProduction = React.lazy(() =>
      import('@tanstack/react-query-devtools/production').then((d) => ({
        default: d.ReactQueryDevtools,
      })),
    )
    

For TypeScript, you would need to set moduleResolution: 'nodenext' in your tsconfig, which requires at least TypeScript v4.7.</content>
</page>

<page>
  <title>GraphQL | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/graphql</url>
  <content>Because React Query's fetching mechanisms are agnostically built on Promises, you can use React Query with literally any asynchronous data fetching client, including GraphQL!

> Keep in mind that React Query does not support normalized caching. While a vast majority of users do not actually need a normalized cache or even benefit from it as much as they believe they do, there may be very rare circumstances that may warrant it so be sure to check with us first to make sure it's truly something you need!

[](#type-safety-and-code-generation)[Type-Safety and Code Generation](#type-safety-and-code-generation)
-------------------------------------------------------------------------------------------------------

React Query, used in combination with graphql-request^5 and [GraphQL Code Generator](https://graphql-code-generator.com/) provides full-typed GraphQL operations:

    import request from 'graphql-request'
    import { useQuery } from '@tanstack/react-query'
    
    import { graphql } from './gql/gql'
    
    const allFilmsWithVariablesQueryDocument = graphql(/* GraphQL */ `
      query allFilmsWithVariablesQuery($first: Int!) {
        allFilms(first: $first) {
          edges {
            node {
              id
              title
            }
          }
        }
      }
    `)
    
    function App() {
      // `data` is fully typed!
      const { data } = useQuery({
        queryKey: ['films'],
        queryFn: async () =>
          request(
            'https://swapi-graphql.netlify.app/.netlify/functions/index',
            allFilmsWithVariablesQueryDocument,
            // variables are type-checked too!
            { first: 10 },
          ),
      })
      // ...
    }
    

    import request from 'graphql-request'
    import { useQuery } from '@tanstack/react-query'
    
    import { graphql } from './gql/gql'
    
    const allFilmsWithVariablesQueryDocument = graphql(/* GraphQL */ `
      query allFilmsWithVariablesQuery($first: Int!) {
        allFilms(first: $first) {
          edges {
            node {
              id
              title
            }
          }
        }
      }
    `)
    
    function App() {
      // `data` is fully typed!
      const { data } = useQuery({
        queryKey: ['films'],
        queryFn: async () =>
          request(
            'https://swapi-graphql.netlify.app/.netlify/functions/index',
            allFilmsWithVariablesQueryDocument,
            // variables are type-checked too!
            { first: 10 },
          ),
      })
      // ...
    }
    

_You can find a [complete example in the repo](https://github.com/dotansimha/graphql-code-generator/tree/7c25c4eeb77f88677fd79da557b7b5326e3f3950/examples/front-end/react/tanstack-react-query)_

Get started with the [dedicated guide on GraphQL Code Generator documentation](https://www.the-guild.dev/graphql/codegen/docs/guides/react-vue).</content>
</page>

<page>
  <title>TypeScript | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/typescript</url>
  <content>React Query is now written in **TypeScript** to make sure the library and your projects are type-safe!

Things to keep in mind:

*   Types currently require using TypeScript **v4.7** or greater
*   Changes to types in this repository are considered **non-breaking** and are usually released as **patch** semver changes (otherwise every type enhancement would be a major version!).
*   It is **highly recommended that you lock your react-query package version to a specific patch release and upgrade with the expectation that types may be fixed or upgraded between any release**
*   The non-type-related public API of React Query still follows semver very strictly.

[](#type-inference)[Type Inference](#type-inference)
----------------------------------------------------

Types in React Query generally flow through very well so that you don't have to provide type annotations for yourself

    const { data } = useQuery({
      //    ^? const data: number | undefined
      queryKey: ['test'],
      queryFn: () => Promise.resolve(5),
    })
    

    const { data } = useQuery({
      //    ^? const data: number | undefined
      queryKey: ['test'],
      queryFn: () => Promise.resolve(5),
    })
    

[typescript playground](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgVwM4FMCKz1QJ5wC+cAZlBCHAORToCGAxjALQCOO+VAsAFC8MQAdqnhIAJnRh0icALwoM2XHgAUAbSqDkIAEa4qAXQA0cFQEo5APjgAFciGAYAdLVQQANgDd0KgKxmzXgB6ILgw8IA9AH5eIA)

    const { data } = useQuery({
      //      ^? const data: string | undefined
      queryKey: ['test'],
      queryFn: () => Promise.resolve(5),
      select: (data) => data.toString(),
    })
    

    const { data } = useQuery({
      //      ^? const data: string | undefined
      queryKey: ['test'],
      queryFn: () => Promise.resolve(5),
      select: (data) => data.toString(),
    })
    

[typescript playground](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgVwM4FMCKz1QJ5wC+cAZlBCHAORToCGAxjALQCOO+VAsAFC8MQAdqnhIAJnRh0icALwoM2XHgAUAbSox0IqgF0ANHBUBKOQD44ABXIhgGAHS1UEADYA3dCoCsxw0gwu6EwAXHASUuZhknT2MBAAyjBQwIIA5iaExrwA9Nlw+QUAegD8vEA)

This works best if your queryFn has a well-defined returned type. Keep in mind that most data fetching libraries return any per default, so make sure to extract it to a properly typed function:

    const fetchGroups = (): Promise<Group[]> =>
      axios.get('/groups').then((response) => response.data)
    
    const { data } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })
    //      ^? const data: Group[] | undefined
    

    const fetchGroups = (): Promise<Group[]> =>
      axios.get('/groups').then((response) => response.data)
    
    const { data } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })
    //      ^? const data: Group[] | undefined
    

[typescript playground](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgVwM4FMCKz1QJ5wC+cAZlBCHAORToCGAxjALQCOO+VAsAFCiSw4dAB7AIqUuUpURY1Nx68YeMOjgBxcsjBwAvIjjAAJgC44AO2QgARriK9eDCOdTwS6GAwAWmiNon6ABQAlGYAClLAGAA8vtoA2gC6AHx6qbLiAHQA5h6BVAD02Vpg8sGZMF7o5oG0qJAuarqpdQ0YmUZ0MHTBDjxOLvBInd1EeigY2Lh4gfFUxX6lVIkANKQe3nGlvTwFBXAHhwB6APxwA65wI3RmW0lwAD4o5kboJMDm6Ea8QA)

[](#type-narrowing)[Type Narrowing](#type-narrowing)
----------------------------------------------------

React Query uses a [discriminated union type](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#discriminated-unions) for the query result, discriminated by the status field and the derived status boolean flags. This will allow you to check for e.g. success status to make data defined:

    const { data, isSuccess } = useQuery({
      queryKey: ['test'],
      queryFn: () => Promise.resolve(5),
    })
    
    if (isSuccess) {
      data
      //  ^? const data: number
    }
    

    const { data, isSuccess } = useQuery({
      queryKey: ['test'],
      queryFn: () => Promise.resolve(5),
    })
    
    if (isSuccess) {
      data
      //  ^? const data: number
    }
    

[typescript playground](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgVwM4FMCKz1QJ5wC+cAZlBCHAORToCGAxjALQCOO+VAsAFC8MQAdqnhIAJnRh0ANHGCoAysgYN0qVETgBeFBmy48ACgDaVGGphUAurMMBKbQD44ABXIh56AHS1UEADYAbuiGAKx2dry8wCRwhvJKKmqoDgi8cBlwElK8APS5GQB6APy8hLxAA)

[](#typing-the-error-field)[Typing the error field](#typing-the-error-field)
----------------------------------------------------------------------------

The type for error defaults to Error, because that is what most users expect.

    const { error } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })
    //      ^? const error: Error
    

    const { error } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })
    //      ^? const error: Error
    

[typescript playground](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgVwM4FMCKz1QJ5wC+cAZlBCHAOQACMAhgHaoMDGA1gPRTr2swBaAI458VALAAoUJFhx6AD2ARUpcpSqLlqCZKkw8YdHADi5ZGDgBeRHGAATAFxxGyEACNcRKVNYRm8CToMKwAFmYQFqo2ABQAlM4ACurAGAA8ERYA2gC6AHzWBVoqAHQA5sExVJxl5mA6cSUwoeiMMTyokMzGVgUdXRgl9vQMcT6SfgG2uORQRNYoGNi4eDFZVLWR9VQ5ADSkwWGZ9WOSnJxwl1cAegD8QA)

If you want to throw a custom error, or something that isn't an Error at all, you can specify the type of the error field:

    const { error } = useQuery<Group[], string>(['groups'], fetchGroups)
    //      ^? const error: string | null
    

    const { error } = useQuery<Group[], string>(['groups'], fetchGroups)
    //      ^? const error: string | null
    

However, this has the drawback that type inference for all other generics of useQuery will not work anymore. It is generally not considered a good practice to throw something that isn't an Error, so if you have a subclass like AxiosError you can use _type narrowing_ to make the error field more specific:

    import axios from 'axios'
    
    const { error } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })
    //      ^? const error: Error | null
    
    if (axios.isAxiosError(error)) {
      error
      // ^? const error: AxiosError
    }
    

    import axios from 'axios'
    
    const { error } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })
    //      ^? const error: Error | null
    
    if (axios.isAxiosError(error)) {
      error
      // ^? const error: AxiosError
    }
    

[typescript playground](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgVwM4FMCKz1QJ5wC+cAZlBCHAOQACMAhgHaoMDGA1gPRTr2swBaAI458VALAAoUJFhx6AD2ARUpcpSqLlqCZKkw8YdHADi5ZGDgBeRHGAATAFxxGyEACNcRKVNYRm8CToMKwAFmYQFqo2ABQAlM4ACurAGAA8ERYA2gC6AHzWBVoqAHQA5sExVJxl5mA6cSUwoeiMMTyokMzGVgUdXRgl9vQMcT6SfgG2uORQRNYoGNi4eDFIIisA0uh4zllUtZH1VDkANHAb+ABijM5BIeF1qoRjkpyccJ9fAHoA-OPAEhwGLFVAlVIAQSUKgAolBZjEZtA4nFEFJPkioOi4O84H8pIQgA)

### [](#registering-a-global-error)[Registering a global Error](#registering-a-global-error)

TanStack Query v5 allows for a way to set a global Error type for everything, without having to specify generics on call-sides, by amending the Register interface. This will make sure inference still works, but the error field will be of the specified type. If you want to enforce that call-sides must do explicit type-narrowing, set defaultError to unknown:

    import '@tanstack/react-query'
    
    declare module '@tanstack/react-query' {
      interface Register {
        // Use unknown so call sites must narrow explicitly.
        defaultError: unknown
      }
    }
    
    const { error } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })
    //      ^? const error: unknown | null
    

    import '@tanstack/react-query'
    
    declare module '@tanstack/react-query' {
      interface Register {
        // Use unknown so call sites must narrow explicitly.
        defaultError: unknown
      }
    }
    
    const { error } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })
    //      ^? const error: unknown | null
    

### [](#registering-global-meta)[Registering global Meta](#registering-global-meta)

Similarly to registering a [global error type](#registering-a-global-error) you can also register a global Meta type. This ensures the optional meta field on [queries](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery) and [mutations](https://tanstack.com/query/latest/docs/framework/react/reference/useMutation) stays consistent and is type-safe. Note that the registered type must extend Record<string, unknown> so that meta remains an object.

    import '@tanstack/react-query'
    
    interface MyMeta extends Record<string, unknown> {
      // Your meta type definition.
    }
    
    declare module '@tanstack/react-query' {
      interface Register {
        queryMeta: MyMeta
        mutationMeta: MyMeta
      }
    }
    

    import '@tanstack/react-query'
    
    interface MyMeta extends Record<string, unknown> {
      // Your meta type definition.
    }
    
    declare module '@tanstack/react-query' {
      interface Register {
        queryMeta: MyMeta
        mutationMeta: MyMeta
      }
    }
    

[](#typing-query-and-mutation-keys)[Typing query and mutation keys](#typing-query-and-mutation-keys)
----------------------------------------------------------------------------------------------------

### [](#registering-the-query-and-mutation-key-types)[Registering the query and mutation key types](#registering-the-query-and-mutation-key-types)

Also similarly to registering a [global error type](#registering-a-global-error), you can also register a global QueryKey and MutationKey type. This allows you to provide more structure to your keys, that matches your application's hierarchy, and have them be typed across all of the library's surface area. Note that the registered type must extend the Array type, so that your keys remain an array.

    import '@tanstack/react-query'
    
    type QueryKey = ['dashboard' | 'marketing', ...ReadonlyArray<unknown>]
    
    declare module '@tanstack/react-query' {
      interface Register {
        queryKey: QueryKey
        mutationKey: QueryKey
      }
    }
    

    import '@tanstack/react-query'
    
    type QueryKey = ['dashboard' | 'marketing', ...ReadonlyArray<unknown>]
    
    declare module '@tanstack/react-query' {
      interface Register {
        queryKey: QueryKey
        mutationKey: QueryKey
      }
    }
    

[](#typing-query-options)[Typing Query Options](#typing-query-options)
----------------------------------------------------------------------

If you inline query options into useQuery, you'll get automatic type inference. However, you might want to extract the query options into a separate function to share them between useQuery and e.g. prefetchQuery. In that case, you'd lose type inference. To get it back, you can use the queryOptions helper:

    import { queryOptions } from '@tanstack/react-query'
    
    function groupOptions() {
      return queryOptions({
        queryKey: ['groups'],
        queryFn: fetchGroups,
        staleTime: 5 * 1000,
      })
    }
    
    useQuery(groupOptions())
    queryClient.prefetchQuery(groupOptions())
    

    import { queryOptions } from '@tanstack/react-query'
    
    function groupOptions() {
      return queryOptions({
        queryKey: ['groups'],
        queryFn: fetchGroups,
        staleTime: 5 * 1000,
      })
    }
    
    useQuery(groupOptions())
    queryClient.prefetchQuery(groupOptions())
    

Further, the queryKey returned from queryOptions knows about the queryFn associated with it, and we can leverage that type information to make functions like queryClient.getQueryData aware of those types as well:

    function groupOptions() {
      return queryOptions({
        queryKey: ['groups'],
        queryFn: fetchGroups,
        staleTime: 5 * 1000,
      })
    }
    
    const data = queryClient.getQueryData(groupOptions().queryKey)
    //     ^? const data: Group[] | undefined
    

    function groupOptions() {
      return queryOptions({
        queryKey: ['groups'],
        queryFn: fetchGroups,
        staleTime: 5 * 1000,
      })
    }
    
    const data = queryClient.getQueryData(groupOptions().queryKey)
    //     ^? const data: Group[] | undefined
    

Without queryOptions, the type of data would be unknown, unless we'd pass a generic to it:

    const data = queryClient.getQueryData<Group[]>(['groups'])
    

    const data = queryClient.getQueryData<Group[]>(['groups'])
    

Note that type inference via queryOptions does _not_ work for queryClient.getQueriesData, because it returns an array of tuples with heterogeneous, unknown data. If you are sure of the type of data that your query will return, specify it explicitly:

    const entries = queryClient.getQueriesData<Group[]>(groupOptions().queryKey)
    //     ^? const entries: Array<[QueryKey, Group[] | undefined]>
    

    const entries = queryClient.getQueriesData<Group[]>(groupOptions().queryKey)
    //     ^? const entries: Array<[QueryKey, Group[] | undefined]>
    

[](#typing-mutation-options)[Typing Mutation Options](#typing-mutation-options)
-------------------------------------------------------------------------------

Similarly to queryOptions, you can use mutationOptions to extract mutation options into a separate function:

    function groupMutationOptions() {
      return mutationOptions({
        mutationKey: ['addGroup'],
        mutationFn: addGroup,
      })
    }
    
    useMutation({
      ...groupMutationOptions(),
      onSuccess: () => queryClient.invalidateQueries({ queryKey: ['groups'] }),
    })
    useIsMutating(groupMutationOptions())
    queryClient.isMutating(groupMutationOptions())
    

    function groupMutationOptions() {
      return mutationOptions({
        mutationKey: ['addGroup'],
        mutationFn: addGroup,
      })
    }
    
    useMutation({
      ...groupMutationOptions(),
      onSuccess: () => queryClient.invalidateQueries({ queryKey: ['groups'] }),
    })
    useIsMutating(groupMutationOptions())
    queryClient.isMutating(groupMutationOptions())
    

[](#typesafe-disabling-of-queries-using-skiptoken)[Typesafe disabling of queries using skipToken](#typesafe-disabling-of-queries-using-skiptoken)
-------------------------------------------------------------------------------------------------------------------------------------------------

If you are using TypeScript, you can use the skipToken to disable a query. This is useful when you want to disable a query based on a condition, but you still want to keep the query to be type safe. Read more about it in the [Disabling Queries](https://tanstack.com/query/latest/docs/framework/react/guides/disabling-queries) guide.

[](#further-reading)[Further Reading](#further-reading)
-------------------------------------------------------

For tips and tricks around type inference, see the article [React Query and TypeScript](https://tkdodo.eu/blog/react-query-and-type-script). To find out how to get the best possible type-safety, you can read [Type-safe React Query](https://tkdodo.eu/blog/type-safe-react-query). [The Query Options API](https://tkdodo.eu/blog/the-query-options-api) outlines how type inference works with the queryOptions helper function.</content>
</page>

<page>
  <title>React Native | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/react-native</url>
  <content>React Query is designed to work out of the box with React Native.

There are several options available for React Native DevTools integration:

1.  **Native macOS App**: A 3rd party app for debugging React Query in any js-based application: [https://github.com/LovesWorking/rn-better-dev-tools](https://github.com/LovesWorking/rn-better-dev-tools)
    
2.  **Flipper Plugin**: A 3rd party plugin for Flipper users: [https://github.com/bgaleotti/react-query-native-devtools](https://github.com/bgaleotti/react-query-native-devtools)
    
3.  **Reactotron Plugin**: A 3rd party plugin for Reactotron users: [https://github.com/hsndmr/reactotron-react-query](https://github.com/hsndmr/reactotron-react-query)
    

[](#online-status-management)[Online status management](#online-status-management)
----------------------------------------------------------------------------------

React Query already supports auto refetch on reconnect in web browser. To add this behavior in React Native you have to use React Query onlineManager as in the example below:

    import NetInfo from '@react-native-community/netinfo'
    import { onlineManager } from '@tanstack/react-query'
    
    onlineManager.setEventListener((setOnline) => {
      return NetInfo.addEventListener((state) => {
        setOnline(!!state.isConnected)
      })
    })
    

    import NetInfo from '@react-native-community/netinfo'
    import { onlineManager } from '@tanstack/react-query'
    
    onlineManager.setEventListener((setOnline) => {
      return NetInfo.addEventListener((state) => {
        setOnline(!!state.isConnected)
      })
    })
    

or

    import { onlineManager } from '@tanstack/react-query'
    import * as Network from 'expo-network'
    
    onlineManager.setEventListener((setOnline) => {
      const eventSubscription = Network.addNetworkStateListener((state) => {
        setOnline(!!state.isConnected)
      })
      return eventSubscription.remove
    })
    

    import { onlineManager } from '@tanstack/react-query'
    import * as Network from 'expo-network'
    
    onlineManager.setEventListener((setOnline) => {
      const eventSubscription = Network.addNetworkStateListener((state) => {
        setOnline(!!state.isConnected)
      })
      return eventSubscription.remove
    })
    

[](#refetch-on-app-focus)[Refetch on App focus](#refetch-on-app-focus)
----------------------------------------------------------------------

Instead of event listeners on window, React Native provides focus information through the [AppState module](https://reactnative.dev/docs/appstate#app-states). You can use the AppState "change" event to trigger an update when the app state changes to "active":

    import { useEffect } from 'react'
    import { AppState, Platform } from 'react-native'
    import type { AppStateStatus } from 'react-native'
    import { focusManager } from '@tanstack/react-query'
    
    function onAppStateChange(status: AppStateStatus) {
      if (Platform.OS !== 'web') {
        focusManager.setFocused(status === 'active')
      }
    }
    
    useEffect(() => {
      const subscription = AppState.addEventListener('change', onAppStateChange)
    
      return () => subscription.remove()
    }, [])
    

    import { useEffect } from 'react'
    import { AppState, Platform } from 'react-native'
    import type { AppStateStatus } from 'react-native'
    import { focusManager } from '@tanstack/react-query'
    
    function onAppStateChange(status: AppStateStatus) {
      if (Platform.OS !== 'web') {
        focusManager.setFocused(status === 'active')
      }
    }
    
    useEffect(() => {
      const subscription = AppState.addEventListener('change', onAppStateChange)
    
      return () => subscription.remove()
    }, [])
    

[](#refresh-on-screen-focus)[Refresh on Screen focus](#refresh-on-screen-focus)
-------------------------------------------------------------------------------

In some situations, you may want to refetch the query when a React Native Screen is focused again. This custom hook will refetch **all active stale queries** when the screen is focused again.

    import React from 'react'
    import { useFocusEffect } from '@react-navigation/native'
    import { useQueryClient } from '@tanstack/react-query'
    
    export function useRefreshOnFocus() {
      const queryClient = useQueryClient()
      const firstTimeRef = React.useRef(true)
    
      useFocusEffect(
        React.useCallback(() => {
          if (firstTimeRef.current) {
            firstTimeRef.current = false
            return
          }
    
          // refetch all stale active queries
          queryClient.refetchQueries({
            queryKey: ['posts'],
            stale: true,
            type: 'active',
          })
        }, [queryClient]),
      )
    }
    

    import React from 'react'
    import { useFocusEffect } from '@react-navigation/native'
    import { useQueryClient } from '@tanstack/react-query'
    
    export function useRefreshOnFocus() {
      const queryClient = useQueryClient()
      const firstTimeRef = React.useRef(true)
    
      useFocusEffect(
        React.useCallback(() => {
          if (firstTimeRef.current) {
            firstTimeRef.current = false
            return
          }
    
          // refetch all stale active queries
          queryClient.refetchQueries({
            queryKey: ['posts'],
            stale: true,
            type: 'active',
          })
        }, [queryClient]),
      )
    }
    

In the above code, the first focus (when the screen is initially mounted) is skipped because useFocusEffect calls our callback on mount in addition to screen focus.

[](#disable-queries-on-out-of-focus-screens)[Disable queries on out of focus screens](#disable-queries-on-out-of-focus-screens)
-------------------------------------------------------------------------------------------------------------------------------

If you don‚Äôt want certain queries to remain ‚Äúlive‚Äù while a screen is out of focus, you can use the subscribed prop on useQuery. This prop lets you control whether a query stays subscribed to updates. Combined with React Navigation‚Äôs useIsFocused, it allows you to seamlessly unsubscribe from queries when a screen isn‚Äôt in focus:

Example usage:

    import React from 'react'
    import { useIsFocused } from '@react-navigation/native'
    import { useQuery } from '@tanstack/react-query'
    import { Text } from 'react-native'
    
    function MyComponent() {
      const isFocused = useIsFocused()
    
      const { dataUpdatedAt } = useQuery({
        queryKey: ['key'],
        queryFn: () => fetch(...),
        subscribed: isFocused,
      })
    
      return <Text>DataUpdatedAt: {dataUpdatedAt}</Text>
    }
    

    import React from 'react'
    import { useIsFocused } from '@react-navigation/native'
    import { useQuery } from '@tanstack/react-query'
    import { Text } from 'react-native'
    
    function MyComponent() {
      const isFocused = useIsFocused()
    
      const { dataUpdatedAt } = useQuery({
        queryKey: ['key'],
        queryFn: () => fetch(...),
        subscribed: isFocused,
      })
    
      return <Text>DataUpdatedAt: {dataUpdatedAt}</Text>
    }
    

When subscribed is false, the query unsubscribes from updates and won‚Äôt trigger re-renders or fetch new data for that screen. Once it becomes true again (e.g., when the screen regains focus), the query re-subscribes and stays up to date.</content>
</page>

<page>
  <title>Important Defaults | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/important-defaults</url>
  <content>Out of the box, TanStack Query is configured with **aggressive but sane** defaults. **Sometimes these defaults can catch new users off guard or make learning/debugging difficult if they are unknown by the user.** Keep them in mind as you continue to learn and use TanStack Query:

*   Query instances via useQuery or useInfiniteQuery by default **consider cached data as stale**.

> To change this behavior, you can configure your queries both globally and per-query using the staleTime option. Specifying a longer staleTime means queries will not refetch their data as often

*   A Query that has a staleTime set is considered **fresh** until that staleTime has elapsed.
    
    *   set staleTime to e.g. 2 \* 60 \* 1000 to make sure data is read from the cache, without triggering any kinds of refetches, for 2 minutes, or until the Query is [invalidated manually](https://tanstack.com/query/latest/docs/framework/react/guides/query-invalidation).
    *   set staleTime to Infinity to never trigger a refetch until the Query is [invalidated manually](https://tanstack.com/query/latest/docs/framework/react/guides/query-invalidation).
    *   set staleTime to 'static' to **never** trigger a refetch, even if the Query is [invalidated manually](https://tanstack.com/query/latest/docs/framework/react/guides/query-invalidation).
*   Stale queries are refetched automatically in the background when:
    
    *   New instances of the query mount
    *   The window is refocused
    *   The network is reconnected

> Setting staleTime is the recommended way to avoid excessive refetches, but you can also customize the points in time for refetches by setting options like refetchOnMount, refetchOnWindowFocus and refetchOnReconnect.

*   Queries can optionally be configured with a refetchInterval to trigger refetches periodically, which is independent of the staleTime setting.
    
*   Query results that have no more active instances of useQuery, useInfiniteQuery or query observers are labeled as "inactive" and remain in the cache in case they are used again at a later time.
    
*   By default, "inactive" queries are garbage collected after **5 minutes**.
    
    > To change this, you can alter the default gcTime for queries to something other than 1000 \* 60 \* 5 milliseconds.
    
*   Queries that fail are **silently retried 3 times, with exponential backoff delay** before capturing and displaying an error to the UI.
    
    > To change this, you can alter the default retry and retryDelay options for queries to something other than 3 and the default exponential backoff function.
    
*   Query results by default are **structurally shared to detect if data has actually changed** and if not, **the data reference remains unchanged** to better help with value stabilization with regards to useMemo and useCallback. If this concept sounds foreign, then don't worry about it! 99.9% of the time you will not need to disable this and it makes your app more performant at zero cost to you.
    
    > Structural sharing only works with JSON-compatible values, any other value types will always be considered as changed. If you are seeing performance issues because of large responses for example, you can disable this feature with the config.structuralSharing flag. If you are dealing with non-JSON compatible values in your query responses and still want to detect if data has changed or not, you can provide your own custom function as config.structuralSharing to compute a value from the old and new responses, retaining references as required.
    

[](#further-reading)[Further Reading](#further-reading)
-------------------------------------------------------

Have a look at the following articles from our [Community Resources](https://tanstack.com/query/latest/docs/community-resources) for further explanations of the defaults:

*   [Practical React Query](https://tkdodo.eu/blog/practical-react-query)
*   [React Query as a State Manager](https://tkdodo.eu/blog/react-query-as-a-state-manager)
*   [Thinking in React Query](https://tkdodo.eu/blog/thinking-in-react-query)</content>
</page>

<page>
  <title>Query Keys | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/query-keys</url>
  <content>At its core, TanStack Query manages query caching for you based on query keys. Query keys have to be an Array at the top level, and can be as simple as an Array with a single string, or as complex as an array of many strings and nested objects. As long as the query key is serializable using JSON.stringify, and **unique to the query's data**, you can use it!

[](#simple-query-keys)[Simple Query Keys](#simple-query-keys)
-------------------------------------------------------------

The simplest form of a key is an array with constants values. This format is useful for:

*   Generic List/Index resources
*   Non-hierarchical resources

    // A list of todos
    useQuery({ queryKey: ['todos'], ... })
    
    // Something else, whatever!
    useQuery({ queryKey: ['something', 'special'], ... })
    

    // A list of todos
    useQuery({ queryKey: ['todos'], ... })
    
    // Something else, whatever!
    useQuery({ queryKey: ['something', 'special'], ... })
    

[](#array-keys-with-variables)[Array Keys with variables](#array-keys-with-variables)
-------------------------------------------------------------------------------------

When a query needs more information to uniquely describe its data, you can use an array with a string and any number of serializable objects to describe it. This is useful for:

*   Hierarchical or nested resources
    *   It's common to pass an ID, index, or other primitive to uniquely identify the item
*   Queries with additional parameters
    *   It's common to pass an object of additional options

    // An individual todo
    useQuery({ queryKey: ['todo', 5], ... })
    
    // An individual todo in a "preview" format
    useQuery({ queryKey: ['todo', 5, { preview: true }], ...})
    
    // A list of todos that are "done"
    useQuery({ queryKey: ['todos', { type: 'done' }], ... })
    

    // An individual todo
    useQuery({ queryKey: ['todo', 5], ... })
    
    // An individual todo in a "preview" format
    useQuery({ queryKey: ['todo', 5, { preview: true }], ...})
    
    // A list of todos that are "done"
    useQuery({ queryKey: ['todos', { type: 'done' }], ... })
    

[](#query-keys-are-hashed-deterministically)[Query Keys are hashed deterministically!](#query-keys-are-hashed-deterministically)
--------------------------------------------------------------------------------------------------------------------------------

This means that no matter the order of keys in objects, all of the following queries are considered equal:

    useQuery({ queryKey: ['todos', { status, page }], ... })
    useQuery({ queryKey: ['todos', { page, status }], ...})
    useQuery({ queryKey: ['todos', { page, status, other: undefined }], ... })
    

    useQuery({ queryKey: ['todos', { status, page }], ... })
    useQuery({ queryKey: ['todos', { page, status }], ...})
    useQuery({ queryKey: ['todos', { page, status, other: undefined }], ... })
    

The following query keys, however, are not equal. Array item order matters!

    useQuery({ queryKey: ['todos', status, page], ... })
    useQuery({ queryKey: ['todos', page, status], ...})
    useQuery({ queryKey: ['todos', undefined, page, status], ...})
    

    useQuery({ queryKey: ['todos', status, page], ... })
    useQuery({ queryKey: ['todos', page, status], ...})
    useQuery({ queryKey: ['todos', undefined, page, status], ...})
    

[](#if-your-query-function-depends-on-a-variable-include-it-in-your-query-key)[If your query function depends on a variable, include it in your query key](#if-your-query-function-depends-on-a-variable-include-it-in-your-query-key)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Since query keys uniquely describe the data they are fetching, they should include any variables you use in your query function that **change**. For example:

    function Todos({ todoId }) {
      const result = useQuery({
        queryKey: ['todos', todoId],
        queryFn: () => fetchTodoById(todoId),
      })
    }
    

    function Todos({ todoId }) {
      const result = useQuery({
        queryKey: ['todos', todoId],
        queryFn: () => fetchTodoById(todoId),
      })
    }
    

Note that query keys act as dependencies for your query functions. Adding dependent variables to your query key will ensure that queries are cached independently, and that any time a variable changes, _queries will be refetched automatically_ (depending on your staleTime settings). See the [exhaustive-deps](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps) section for more information and examples.

[](#further-reading)[Further reading](#further-reading)
-------------------------------------------------------

For tips on organizing Query Keys in larger applications, have a look at [Effective React Query Keys](https://tkdodo.eu/blog/effective-react-query-keys) and check the [Query Key Factory Package](https://github.com/lukemorales/query-key-factory) from the [Community Resources](https://tanstack.com/query/latest/docs/community-resources).</content>
</page>

<page>
  <title>Query Options | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/query-options</url>
  <content>One of the best ways to share queryKey and queryFn between multiple places, yet keep them co-located to one another, is to use the queryOptions helper. At runtime, this helper just returns whatever you pass into it, but it has a lot of advantages when using it [with TypeScript](https://tanstack.com/query/latest/docs/framework/react/typescript#typing-query-options). You can define all possible options for a query in one place, and you'll also get type inference and type safety for all of them.

    import { queryOptions } from '@tanstack/react-query'
    
    function groupOptions(id: number) {
      return queryOptions({
        queryKey: ['groups', id],
        queryFn: () => fetchGroups(id),
        staleTime: 5 * 1000,
      })
    }
    
    // usage:
    
    useQuery(groupOptions(1))
    useSuspenseQuery(groupOptions(5))
    useQueries({
      queries: [groupOptions(1), groupOptions(2)],
    })
    queryClient.prefetchQuery(groupOptions(23))
    queryClient.setQueryData(groupOptions(42).queryKey, newGroups)
    

    import { queryOptions } from '@tanstack/react-query'
    
    function groupOptions(id: number) {
      return queryOptions({
        queryKey: ['groups', id],
        queryFn: () => fetchGroups(id),
        staleTime: 5 * 1000,
      })
    }
    
    // usage:
    
    useQuery(groupOptions(1))
    useSuspenseQuery(groupOptions(5))
    useQueries({
      queries: [groupOptions(1), groupOptions(2)],
    })
    queryClient.prefetchQuery(groupOptions(23))
    queryClient.setQueryData(groupOptions(42).queryKey, newGroups)
    

For Infinite Queries, a separate [infiniteQueryOptions](https://tanstack.com/query/latest/docs/framework/react/reference/infiniteQueryOptions) helper is available.

You can still override some options at the component level. A very common and useful pattern is to create per-component [select](https://tanstack.com/query/latest/docs/framework/react/guides/render-optimizations#select) functions:

    // Type inference still works, so query.data will be the return type of select instead of queryFn
    
    const query = useQuery({
      ...groupOptions(1),
      select: (data) => data.groupName,
    })
    

    // Type inference still works, so query.data will be the return type of select instead of queryFn
    
    const query = useQuery({
      ...groupOptions(1),
      select: (data) => data.groupName,
    })</content>
</page>

<page>
  <title>Queries | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/queries</url>
  <content>[](#query-basics)[Query Basics](#query-basics)
----------------------------------------------

A query is a declarative dependency on an asynchronous source of data that is tied to a **unique key**. A query can be used with any Promise based method (including GET and POST methods) to fetch data from a server. If your method modifies data on the server, we recommend using [Mutations](https://tanstack.com/query/latest/docs/framework/react/guides/mutations) instead.

To subscribe to a query in your components or custom hooks, call the useQuery hook with at least:

*   A **unique key for the query**
*   A function that returns a promise that:
    *   Resolves the data, or
    *   Throws an error

    import { useQuery } from '@tanstack/react-query'
    
    function App() {
      const info = useQuery({ queryKey: ['todos'], queryFn: fetchTodoList })
    }
    

    import { useQuery } from '@tanstack/react-query'
    
    function App() {
      const info = useQuery({ queryKey: ['todos'], queryFn: fetchTodoList })
    }
    

The **unique key** you provide is used internally for refetching, caching, and sharing your queries throughout your application.

The query result returned by useQuery contains all of the information about the query that you'll need for templating and any other usage of the data:

    const result = useQuery({ queryKey: ['todos'], queryFn: fetchTodoList })
    

    const result = useQuery({ queryKey: ['todos'], queryFn: fetchTodoList })
    

The result object contains a few very important states you'll need to be aware of to be productive. A query can only be in one of the following states at any given moment:

*   isPending or status === 'pending' - The query has no data yet
*   isError or status === 'error' - The query encountered an error
*   isSuccess or status === 'success' - The query was successful and data is available

Beyond those primary states, more information is available depending on the state of the query:

*   error - If the query is in an isError state, the error is available via the error property.
*   data - If the query is in an isSuccess state, the data is available via the data property.
*   isFetching - In any state, if the query is fetching at any time (including background refetching) isFetching will be true.

For **most** queries, it's usually sufficient to check for the isPending state, then the isError state, then finally, assume that the data is available and render the successful state:

    function Todos() {
      const { isPending, isError, data, error } = useQuery({
        queryKey: ['todos'],
        queryFn: fetchTodoList,
      })
    
      if (isPending) {
        return <span>Loading...</span>
      }
    
      if (isError) {
        return <span>Error: {error.message}</span>
      }
    
      // We can assume by this point that `isSuccess === true`
      return (
        <ul>
          {data.map((todo) => (
            <li key={todo.id}>{todo.title}</li>
          ))}
        </ul>
      )
    }
    

    function Todos() {
      const { isPending, isError, data, error } = useQuery({
        queryKey: ['todos'],
        queryFn: fetchTodoList,
      })
    
      if (isPending) {
        return <span>Loading...</span>
      }
    
      if (isError) {
        return <span>Error: {error.message}</span>
      }
    
      // We can assume by this point that `isSuccess === true`
      return (
        <ul>
          {data.map((todo) => (
            <li key={todo.id}>{todo.title}</li>
          ))}
        </ul>
      )
    }
    

If booleans aren't your thing, you can always use the status state as well:

    function Todos() {
      const { status, data, error } = useQuery({
        queryKey: ['todos'],
        queryFn: fetchTodoList,
      })
    
      if (status === 'pending') {
        return <span>Loading...</span>
      }
    
      if (status === 'error') {
        return <span>Error: {error.message}</span>
      }
    
      // also status === 'success', but "else" logic works, too
      return (
        <ul>
          {data.map((todo) => (
            <li key={todo.id}>{todo.title}</li>
          ))}
        </ul>
      )
    }
    

    function Todos() {
      const { status, data, error } = useQuery({
        queryKey: ['todos'],
        queryFn: fetchTodoList,
      })
    
      if (status === 'pending') {
        return <span>Loading...</span>
      }
    
      if (status === 'error') {
        return <span>Error: {error.message}</span>
      }
    
      // also status === 'success', but "else" logic works, too
      return (
        <ul>
          {data.map((todo) => (
            <li key={todo.id}>{todo.title}</li>
          ))}
        </ul>
      )
    }
    

TypeScript will also narrow the type of data correctly if you've checked for pending and error before accessing it.

### [](#fetchstatus)[FetchStatus](#fetchstatus)

In addition to the status field, you will also get an additional fetchStatus property with the following options:

*   fetchStatus === 'fetching' - The query is currently fetching.
*   fetchStatus === 'paused' - The query wanted to fetch, but it is paused. Read more about this in the [Network Mode](https://tanstack.com/query/latest/docs/framework/react/guides/network-mode) guide.
*   fetchStatus === 'idle' - The query is not doing anything at the moment.

### [](#why-two-different-states)[Why two different states?](#why-two-different-states)

Background refetches and stale-while-revalidate logic make all combinations for status and fetchStatus possible. For example:

*   a query in success status will usually be in idle fetchStatus, but it could also be in fetching if a background refetch is happening.
*   a query that mounts and has no data will usually be in pending status and fetching fetchStatus, but it could also be paused if there is no network connection.

So keep in mind that a query can be in pending state without actually fetching data. As a rule of thumb:

*   The status gives information about the data: Do we have any or not?
*   The fetchStatus gives information about the queryFn: Is it running or not?

[](#further-reading)[Further Reading](#further-reading)
-------------------------------------------------------

For an alternative way of performing status checks, have a look at [this article by TkDodo](https://tkdodo.eu/blog/status-checks-in-react-query).</content>
</page>

<page>
  <title>React TanStack Query Basic Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/examples/basic</url>
  <content>    import * as React from 'react'
    import ReactDOM from 'react-dom/client'
    import { QueryClient, useQuery, useQueryClient } from '@tanstack/react-query'
    import { PersistQueryClientProvider } from '@tanstack/react-query-persist-client'
    import { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister'
    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          gcTime: 1000 * 60 * 60 * 24, // 24 hours
        },
      },
    })
    
    const persister = createAsyncStoragePersister({
      storage: window.localStorage,
    })
    
    type Post = {
      id: number
      title: string
      body: string
    }
    
    function usePosts() {
      return useQuery({
        queryKey: ['posts'],
        queryFn: async (): Promise<Array<Post>> => {
          const response = await fetch('https://jsonplaceholder.typicode.com/posts')
          return await response.json()
        },
      })
    }
    
    function Posts({
      setPostId,
    }: {
      setPostId: React.Dispatch<React.SetStateAction<number>>
    }) {
      const queryClient = useQueryClient()
      const { status, data, error, isFetching } = usePosts()
    
      return (
        <div>
          <h1>Posts</h1>
          <div>
            {status === 'pending' ? (
              'Loading...'
            ) : status === 'error' ? (
              <span>Error: {error.message}</span>
            ) : (
              <>
                <div>
                  {data.map((post) => (
                    <p key={post.id}>
                      <a
                        onClick={() => setPostId(post.id)}
                        href="#"
                        style={
                          // We can access the query data here to show bold links for
                          // ones that are cached
                          queryClient.getQueryData(['post', post.id])
                            ? {
                                fontWeight: 'bold',
                                color: 'green',
                              }
                            : {}
                        }
                      >
                        {post.title}
                      </a>
                    </p>
                  ))}
                </div>
                <div>{isFetching ? 'Background Updating...' : ' '}</div>
              </>
            )}
          </div>
        </div>
      )
    }
    
    const getPostById = async (id: number): Promise<Post> => {
      const response = await fetch(
        `https://jsonplaceholder.typicode.com/posts/${id}`,
      )
      return await response.json()
    }
    
    function usePost(postId: number) {
      return useQuery({
        queryKey: ['post', postId],
        queryFn: () => getPostById(postId),
        enabled: !!postId,
      })
    }
    
    function Post({
      postId,
      setPostId,
    }: {
      postId: number
      setPostId: React.Dispatch<React.SetStateAction<number>>
    }) {
      const { status, data, error, isFetching } = usePost(postId)
    
      return (
        <div>
          <div>
            <a onClick={() => setPostId(-1)} href="#">
              Back
            </a>
          </div>
          {!postId || status === 'pending' ? (
            'Loading...'
          ) : status === 'error' ? (
            <span>Error: {error.message}</span>
          ) : (
            <>
              <h1>{data.title}</h1>
              <div>
                <p>{data.body}</p>
              </div>
              <div>{isFetching ? 'Background Updating...' : ' '}</div>
            </>
          )}
        </div>
      )
    }
    
    function App() {
      const [postId, setPostId] = React.useState(-1)
    
      return (
        <PersistQueryClientProvider
          client={queryClient}
          persistOptions={{ persister }}
        >
          <p>
            As you visit the posts below, you will notice them in a loading state
            the first time you load them. However, after you return to this list and
            click on any posts you have already visited again, you will see them
            load instantly and background refresh right before your eyes!{' '}
            <strong>
              (You may need to throttle your network speed to simulate longer
              loading sequences)
            </strong>
          </p>
          {postId > -1 ? (
            <Post postId={postId} setPostId={setPostId} />
          ) : (
            <Posts setPostId={setPostId} />
          )}
          <ReactQueryDevtools initialIsOpen />
        </PersistQueryClientProvider>
      )
    }
    
    const rootElement = document.getElementById('root') as HTMLElement
    ReactDOM.createRoot(rootElement).render(<App />)
    

    import * as React from 'react'
    import ReactDOM from 'react-dom/client'
    import { QueryClient, useQuery, useQueryClient } from '@tanstack/react-query'
    import { PersistQueryClientProvider } from '@tanstack/react-query-persist-client'
    import { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister'
    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          gcTime: 1000 * 60 * 60 * 24, // 24 hours
        },
      },
    })
    
    const persister = createAsyncStoragePersister({
      storage: window.localStorage,
    })
    
    type Post = {
      id: number
      title: string
      body: string
    }
    
    function usePosts() {
      return useQuery({
        queryKey: ['posts'],
        queryFn: async (): Promise<Array<Post>> => {
          const response = await fetch('https://jsonplaceholder.typicode.com/posts')
          return await response.json()
        },
      })
    }
    
    function Posts({
      setPostId,
    }: {
      setPostId: React.Dispatch<React.SetStateAction<number>>
    }) {
      const queryClient = useQueryClient()
      const { status, data, error, isFetching } = usePosts()
    
      return (
        <div>
          <h1>Posts</h1>
          <div>
            {status === 'pending' ? (
              'Loading...'
            ) : status === 'error' ? (
              <span>Error: {error.message}</span>
            ) : (
              <>
                <div>
                  {data.map((post) => (
                    <p key={post.id}>
                      <a
                        onClick={() => setPostId(post.id)}
                        href="#"
                        style={
                          // We can access the query data here to show bold links for
                          // ones that are cached
                          queryClient.getQueryData(['post', post.id])
                            ? {
                                fontWeight: 'bold',
                                color: 'green',
                              }
                            : {}
                        }
                      >
                        {post.title}
                      </a>
                    </p>
                  ))}
                </div>
                <div>{isFetching ? 'Background Updating...' : ' '}</div>
              </>
            )}
          </div>
        </div>
      )
    }
    
    const getPostById = async (id: number): Promise<Post> => {
      const response = await fetch(
        `https://jsonplaceholder.typicode.com/posts/${id}`,
      )
      return await response.json()
    }
    
    function usePost(postId: number) {
      return useQuery({
        queryKey: ['post', postId],
        queryFn: () => getPostById(postId),
        enabled: !!postId,
      })
    }
    
    function Post({
      postId,
      setPostId,
    }: {
      postId: number
      setPostId: React.Dispatch<React.SetStateAction<number>>
    }) {
      const { status, data, error, isFetching } = usePost(postId)
    
      return (
        <div>
          <div>
            <a onClick={() => setPostId(-1)} href="#">
              Back
            </a>
          </div>
          {!postId || status === 'pending' ? (
            'Loading...'
          ) : status === 'error' ? (
            <span>Error: {error.message}</span>
          ) : (
            <>
              <h1>{data.title}</h1>
              <div>
                <p>{data.body}</p>
              </div>
              <div>{isFetching ? 'Background Updating...' : ' '}</div>
            </>
          )}
        </div>
      )
    }
    
    function App() {
      const [postId, setPostId] = React.useState(-1)
    
      return (
        <PersistQueryClientProvider
          client={queryClient}
          persistOptions={{ persister }}
        >
          <p>
            As you visit the posts below, you will notice them in a loading state
            the first time you load them. However, after you return to this list and
            click on any posts you have already visited again, you will see them
            load instantly and background refresh right before your eyes!{' '}
            <strong>
              (You may need to throttle your network speed to simulate longer
              loading sequences)
            </strong>
          </p>
          {postId > -1 ? (
            <Post postId={postId} setPostId={setPostId} />
          ) : (
            <Posts setPostId={setPostId} />
          )}
          <ReactQueryDevtools initialIsOpen />
        </PersistQueryClientProvider>
      )
    }
    
    const rootElement = document.getElementById('root') as HTMLElement
    ReactDOM.createRoot(rootElement).render(<App />)</content>
</page>

<page>
  <title>Query Functions | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/query-functions</url>
  <content>A query function can be literally any function that **returns a promise**. The promise that is returned should either **resolve the data** or **throw an error**.

All of the following are valid query function configurations:

    useQuery({ queryKey: ['todos'], queryFn: fetchAllTodos })
    useQuery({ queryKey: ['todos', todoId], queryFn: () => fetchTodoById(todoId) })
    useQuery({
      queryKey: ['todos', todoId],
      queryFn: async () => {
        const data = await fetchTodoById(todoId)
        return data
      },
    })
    useQuery({
      queryKey: ['todos', todoId],
      queryFn: ({ queryKey }) => fetchTodoById(queryKey[1]),
    })
    

    useQuery({ queryKey: ['todos'], queryFn: fetchAllTodos })
    useQuery({ queryKey: ['todos', todoId], queryFn: () => fetchTodoById(todoId) })
    useQuery({
      queryKey: ['todos', todoId],
      queryFn: async () => {
        const data = await fetchTodoById(todoId)
        return data
      },
    })
    useQuery({
      queryKey: ['todos', todoId],
      queryFn: ({ queryKey }) => fetchTodoById(queryKey[1]),
    })
    

[](#handling-and-throwing-errors)[Handling and Throwing Errors](#handling-and-throwing-errors)
----------------------------------------------------------------------------------------------

For TanStack Query to determine a query has errored, the query function **must throw** or return a **rejected Promise**. Any error that is thrown in the query function will be persisted on the error state of the query.

    const { error } = useQuery({
      queryKey: ['todos', todoId],
      queryFn: async () => {
        if (somethingGoesWrong) {
          throw new Error('Oh no!')
        }
        if (somethingElseGoesWrong) {
          return Promise.reject(new Error('Oh no!'))
        }
    
        return data
      },
    })
    

    const { error } = useQuery({
      queryKey: ['todos', todoId],
      queryFn: async () => {
        if (somethingGoesWrong) {
          throw new Error('Oh no!')
        }
        if (somethingElseGoesWrong) {
          return Promise.reject(new Error('Oh no!'))
        }
    
        return data
      },
    })
    

[](#usage-with-fetch-and-other-clients-that-do-not-throw-by-default)[Usage with fetch and other clients that do not throw by default](#usage-with-fetch-and-other-clients-that-do-not-throw-by-default)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

While most utilities like axios or graphql-request automatically throw errors for unsuccessful HTTP calls, some utilities like fetch do not throw errors by default. If that's the case, you'll need to throw them on your own. Here is a simple way to do that with the popular fetch API:

    useQuery({
      queryKey: ['todos', todoId],
      queryFn: async () => {
        const response = await fetch('/todos/' + todoId)
        if (!response.ok) {
          throw new Error('Network response was not ok')
        }
        return response.json()
      },
    })
    

    useQuery({
      queryKey: ['todos', todoId],
      queryFn: async () => {
        const response = await fetch('/todos/' + todoId)
        if (!response.ok) {
          throw new Error('Network response was not ok')
        }
        return response.json()
      },
    })
    

[](#query-function-variables)[Query Function Variables](#query-function-variables)
----------------------------------------------------------------------------------

Query keys are not just for uniquely identifying the data you are fetching, but are also conveniently passed into your query function as part of the QueryFunctionContext. While not always necessary, this makes it possible to extract your query functions if needed:

    function Todos({ status, page }) {
      const result = useQuery({
        queryKey: ['todos', { status, page }],
        queryFn: fetchTodoList,
      })
    }
    
    // Access the key, status and page variables in your query function!
    function fetchTodoList({ queryKey }) {
      const [_key, { status, page }] = queryKey
      return new Promise()
    }
    

    function Todos({ status, page }) {
      const result = useQuery({
        queryKey: ['todos', { status, page }],
        queryFn: fetchTodoList,
      })
    }
    
    // Access the key, status and page variables in your query function!
    function fetchTodoList({ queryKey }) {
      const [_key, { status, page }] = queryKey
      return new Promise()
    }
    

### [](#queryfunctioncontext)[QueryFunctionContext](#queryfunctioncontext)

The QueryFunctionContext is the object passed to each query function. It consists of:

*   queryKey: QueryKey: [Query Keys](https://tanstack.com/query/latest/docs/framework/react/guides/query-keys)
*   client: QueryClient: [QueryClient](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   signal?: AbortSignal
    *   [AbortSignal](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) instance provided by TanStack Query
    *   Can be used for [Query Cancellation](https://tanstack.com/query/latest/docs/framework/react/guides/query-cancellation)
*   meta: Record<string, unknown> | undefined
    *   an optional field you can fill with additional information about your query

Additionally, [Infinite Queries](https://tanstack.com/query/latest/docs/framework/react/guides/infinite-queries) get the following options passed:

*   pageParam: TPageParam
    *   the page parameter used to fetch the current page
*   direction: 'forward' | 'backward'
    *   **deprecated**
    *   the direction of the current page fetch
    *   To get access to the direction of the current page fetch, please add a direction to pageParam from getNextPageParam and getPreviousPageParam.</content>
</page>

<page>
  <title>Network Mode | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/network-mode</url>
  <content>TanStack Query provides three different network modes to distinguish how [Queries](https://tanstack.com/query/latest/docs/framework/react/guides/queries) and [Mutations](https://tanstack.com/query/latest/docs/framework/react/guides/mutations) should behave if you have no network connection. This mode can be set for each Query / Mutation individually, or globally via the query / mutation defaults.

Since TanStack Query is most often used for data fetching in combination with data fetching libraries, the default network mode is [online](#network-mode-online).

[](#network-mode-online)[Network Mode: online](#network-mode-online)
--------------------------------------------------------------------

In this mode, Queries and Mutations will not fire unless you have network connection. This is the default mode. If a fetch is initiated for a query, it will always stay in the state (pending, error, success) it is in if the fetch cannot be made because there is no network connection. However, a [fetchStatus](https://tanstack.com/query/latest/docs/framework/react/guides/queries#fetchstatus) is exposed additionally. This can be either:

*   fetching: The queryFn is really executing - a request is in-flight.
*   paused: The query is not executing - it is paused until you have connection again
*   idle: The query is not fetching and not paused

The flags isFetching and isPaused are derived from this state and exposed for convenience.

> Keep in mind that it might not be enough to check for pending state to show a loading spinner. Queries can be in state: 'pending', but fetchStatus: 'paused' if they are mounting for the first time, and you have no network connection.

If a query runs because you are online, but you go offline while the fetch is still happening, TanStack Query will also pause the retry mechanism. Paused queries will then continue to run once you re-gain network connection. This is independent of refetchOnReconnect (which also defaults to true in this mode), because it is not a refetch, but rather a continue. If the query has been [cancelled](https://tanstack.com/query/latest/docs/framework/react/guides/query-cancellation) in the meantime, it will not continue.

[](#network-mode-always)[Network Mode: always](#network-mode-always)
--------------------------------------------------------------------

In this mode, TanStack Query will always fetch and ignore the online / offline state. This is likely the mode you want to choose if you use TanStack Query in an environment where you don't need an active network connection for your Queries to work - e.g. if you just read from AsyncStorage, or if you just want to return Promise.resolve(5) from your queryFn.

*   Queries will never be paused because you have no network connection.
*   Retries will also not pause - your Query will go to error state if it fails.
*   refetchOnReconnect defaults to false in this mode, because reconnecting to the network is not a good indicator anymore that stale queries should be refetched. You can still turn it on if you want.

[](#network-mode-offlinefirst)[Network Mode: offlineFirst](#network-mode-offlinefirst)
--------------------------------------------------------------------------------------

This mode is the middle ground between the first two options, where TanStack Query will run the queryFn once, but then pause retries. This is very handy if you have a serviceWorker that intercepts a request for caching like in an [offline-first PWA](https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Offline_Service_workers), or if you use HTTP caching via the [Cache-Control header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#the_cache-control_header).

In those situations, the first fetch might succeed because it comes from an offline storage / cache. However, if there is a cache miss, the network request will go out and fail, in which case this mode behaves like an online query - pausing retries.

The [TanStack Query Devtools](https://tanstack.com/query/latest/docs/framework/react/devtools) will show Queries in a paused state if they would be fetching, but there is no network connection. There is also a toggle button to _Mock offline behavior_. Please note that this button will _not_ actually mess with your network connection (you can do that in the browser devtools), but it will set the [OnlineManager](https://tanstack.com/query/latest/docs/reference/onlineManager) in an offline state.

[](#signature)[Signature](#signature)
-------------------------------------

*   networkMode: 'online' | 'always' | 'offlineFirst'
    *   optional
    *   defaults to 'online'</content>
</page>

<page>
  <title>Parallel Queries | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/parallel-queries</url>
  <content>"Parallel" queries are queries that are executed in parallel, or at the same time so as to maximize fetching concurrency.

[](#manual-parallel-queries)[Manual Parallel Queries](#manual-parallel-queries)
-------------------------------------------------------------------------------

When the number of parallel queries does not change, there is **no extra effort** to use parallel queries. Just use any number of TanStack Query's useQuery and useInfiniteQuery hooks side-by-side!

    function App () {
      // The following queries will execute in parallel
      const usersQuery = useQuery({ queryKey: ['users'], queryFn: fetchUsers })
      const teamsQuery = useQuery({ queryKey: ['teams'], queryFn: fetchTeams })
      const projectsQuery = useQuery({ queryKey: ['projects'], queryFn: fetchProjects })
      ...
    }
    

    function App () {
      // The following queries will execute in parallel
      const usersQuery = useQuery({ queryKey: ['users'], queryFn: fetchUsers })
      const teamsQuery = useQuery({ queryKey: ['teams'], queryFn: fetchTeams })
      const projectsQuery = useQuery({ queryKey: ['projects'], queryFn: fetchProjects })
      ...
    }
    

> When using React Query in suspense mode, this pattern of parallelism does not work, since the first query would throw a promise internally and would suspend the component before the other queries run. To get around this, you'll either need to use the useSuspenseQueries hook (which is suggested) or orchestrate your own parallelism with separate components for each useSuspenseQuery instance.

[](#dynamic-parallel-queries-with-usequeries)[Dynamic Parallel Queries with useQueries](#dynamic-parallel-queries-with-usequeries)
----------------------------------------------------------------------------------------------------------------------------------

If the number of queries you need to execute is changing from render to render, you cannot use manual querying since that would violate the rules of hooks. Instead, TanStack Query provides a useQueries hook, which you can use to dynamically execute as many queries in parallel as you'd like.

useQueries accepts an **options object** with a **queries key** whose value is an **array of query objects**. It returns an **array of query results**:

    function App({ users }) {
      const userQueries = useQueries({
        queries: users.map((user) => {
          return {
            queryKey: ['user', user.id],
            queryFn: () => fetchUserById(user.id),
          }
        }),
      })
    }
    

    function App({ users }) {
      const userQueries = useQueries({
        queries: users.map((user) => {
          return {
            queryKey: ['user', user.id],
            queryFn: () => fetchUserById(user.id),
          }
        }),
      })
    }</content>
</page>

<page>
  <title>Background Fetching Indicators | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/background-fetching-indicators</url>
  <content>A query's status === 'pending' state is sufficient enough to show the initial hard-loading state for a query, but sometimes you may want to display an additional indicator that a query is refetching in the background. To do this, queries also supply you with an isFetching boolean that you can use to show that it's in a fetching state, regardless of the state of the status variable:

    function Todos() {
      const {
        status,
        data: todos,
        error,
        isFetching,
      } = useQuery({
        queryKey: ['todos'],
        queryFn: fetchTodos,
      })
    
      return status === 'pending' ? (
        <span>Loading...</span>
      ) : status === 'error' ? (
        <span>Error: {error.message}</span>
      ) : (
        <>
          {isFetching ? <div>Refreshing...</div> : null}
    
          <div>
            {todos.map((todo) => (
              <Todo todo={todo} />
            ))}
          </div>
        </>
      )
    }
    

    function Todos() {
      const {
        status,
        data: todos,
        error,
        isFetching,
      } = useQuery({
        queryKey: ['todos'],
        queryFn: fetchTodos,
      })
    
      return status === 'pending' ? (
        <span>Loading...</span>
      ) : status === 'error' ? (
        <span>Error: {error.message}</span>
      ) : (
        <>
          {isFetching ? <div>Refreshing...</div> : null}
    
          <div>
            {todos.map((todo) => (
              <Todo todo={todo} />
            ))}
          </div>
        </>
      )
    }
    

[](#displaying-global-background-fetching-loading-state)[Displaying Global Background Fetching Loading State](#displaying-global-background-fetching-loading-state)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------

In addition to individual query loading states, if you would like to show a global loading indicator when **any** queries are fetching (including in the background), you can use the useIsFetching hook:

    import { useIsFetching } from '@tanstack/react-query'
    
    function GlobalLoadingIndicator() {
      const isFetching = useIsFetching()
    
      return isFetching ? (
        <div>Queries are fetching in the background...</div>
      ) : null
    }
    

    import { useIsFetching } from '@tanstack/react-query'
    
    function GlobalLoadingIndicator() {
      const isFetching = useIsFetching()
    
      return isFetching ? (
        <div>Queries are fetching in the background...</div>
      ) : null
    }</content>
</page>

<page>
  <title>Window Focus Refetching | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/window-focus-refetching</url>
  <content>If a user leaves your application and returns and the query data is stale, **TanStack Query automatically requests fresh data for you in the background**. You can disable this globally or per-query using the refetchOnWindowFocus option:

#### [](#disabling-globally)[Disabling Globally](#disabling-globally)

    //
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          refetchOnWindowFocus: false, // default: true
        },
      },
    })
    
    function App() {
      return <QueryClientProvider client={queryClient}>...</QueryClientProvider>
    }
    

    //
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          refetchOnWindowFocus: false, // default: true
        },
      },
    })
    
    function App() {
      return <QueryClientProvider client={queryClient}>...</QueryClientProvider>
    }
    

#### [](#disabling-per-query)[Disabling Per-Query](#disabling-per-query)

    useQuery({
      queryKey: ['todos'],
      queryFn: fetchTodos,
      refetchOnWindowFocus: false,
    })
    

    useQuery({
      queryKey: ['todos'],
      queryFn: fetchTodos,
      refetchOnWindowFocus: false,
    })
    

[](#custom-window-focus-event)[Custom Window Focus Event](#custom-window-focus-event)
-------------------------------------------------------------------------------------

In rare circumstances, you may want to manage your own window focus events that trigger TanStack Query to revalidate. To do this, TanStack Query provides a focusManager.setEventListener function that supplies you the callback that should be fired when the window is focused and allows you to set up your own events. When calling focusManager.setEventListener, the previously set handler is removed (which in most cases will be the default handler) and your new handler is used instead. For example, this is the default handler:

    focusManager.setEventListener((handleFocus) => {
      // Listen to visibilitychange
      if (typeof window !== 'undefined' && window.addEventListener) {
        const visibilitychangeHandler = () => {
          handleFocus(document.visibilityState === 'visible')
        }
        window.addEventListener('visibilitychange', visibilitychangeHandler, false)
        return () => {
          // Be sure to unsubscribe if a new handler is set
          window.removeEventListener('visibilitychange', visibilitychangeHandler)
        }
      }
    })
    

    focusManager.setEventListener((handleFocus) => {
      // Listen to visibilitychange
      if (typeof window !== 'undefined' && window.addEventListener) {
        const visibilitychangeHandler = () => {
          handleFocus(document.visibilityState === 'visible')
        }
        window.addEventListener('visibilitychange', visibilitychangeHandler, false)
        return () => {
          // Be sure to unsubscribe if a new handler is set
          window.removeEventListener('visibilitychange', visibilitychangeHandler)
        }
      }
    })
    

[](#managing-focus-in-react-native)[Managing Focus in React Native](#managing-focus-in-react-native)
----------------------------------------------------------------------------------------------------

Instead of event listeners on window, React Native provides focus information through the [AppState module](https://reactnative.dev/docs/appstate#app-states). You can use the AppState "change" event to trigger an update when the app state changes to "active":

    import { AppState } from 'react-native'
    import { focusManager } from '@tanstack/react-query'
    
    function onAppStateChange(status: AppStateStatus) {
      if (Platform.OS !== 'web') {
        focusManager.setFocused(status === 'active')
      }
    }
    
    useEffect(() => {
      const subscription = AppState.addEventListener('change', onAppStateChange)
    
      return () => subscription.remove()
    }, [])
    

    import { AppState } from 'react-native'
    import { focusManager } from '@tanstack/react-query'
    
    function onAppStateChange(status: AppStateStatus) {
      if (Platform.OS !== 'web') {
        focusManager.setFocused(status === 'active')
      }
    }
    
    useEffect(() => {
      const subscription = AppState.addEventListener('change', onAppStateChange)
    
      return () => subscription.remove()
    }, [])
    

[](#managing-focus-state)[Managing focus state](#managing-focus-state)
----------------------------------------------------------------------

    import { focusManager } from '@tanstack/react-query'
    
    // Override the default focus state
    focusManager.setFocused(true)
    
    // Fallback to the default focus check
    focusManager.setFocused(undefined)
    

    import { focusManager } from '@tanstack/react-query'
    
    // Override the default focus state
    focusManager.setFocused(true)
    
    // Fallback to the default focus check
    focusManager.setFocused(undefined)</content>
</page>

<page>
  <title>Query Retries | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/query-retries</url>
  <content>When a useQuery query fails (the query function throws an error), TanStack Query will automatically retry the query if that query's request has not reached the max number of consecutive retries (defaults to 3) or a function is provided to determine if a retry is allowed.

You can configure retries both on a global level and an individual query level.

*   Setting retry = false will disable retries.
*   Setting retry = 6 will retry failing requests 6 times before showing the final error thrown by the function.
*   Setting retry = true will infinitely retry failing requests.
*   Setting retry = (failureCount, error) => ... allows for custom logic based on why the request failed.

> On the server, retries default to 0 to make server rendering as fast as possible.

    import { useQuery } from '@tanstack/react-query'
    
    // Make a specific query retry a certain number of times
    const result = useQuery({
      queryKey: ['todos', 1],
      queryFn: fetchTodoListPage,
      retry: 10, // Will retry failed requests 10 times before displaying an error
    })
    

    import { useQuery } from '@tanstack/react-query'
    
    // Make a specific query retry a certain number of times
    const result = useQuery({
      queryKey: ['todos', 1],
      queryFn: fetchTodoListPage,
      retry: 10, // Will retry failed requests 10 times before displaying an error
    })
    

> Info: Contents of the error property will be part of failureReason response property of useQuery until the last retry attempt. So in above example any error contents will be part of failureReason property for first 9 retry attempts (Overall 10 attempts) and finally they will be part of error after last attempt if error persists after all retry attempts.

[](#retry-delay)[Retry Delay](#retry-delay)
-------------------------------------------

By default, retries in TanStack Query do not happen immediately after a request fails. As is standard, a back-off delay is gradually applied to each retry attempt.

The default retryDelay is set to double (starting at 1000ms) with each attempt, but not exceed 30 seconds:

    // Configure for all queries
    import {
      QueryCache,
      QueryClient,
      QueryClientProvider,
    } from '@tanstack/react-query'
    
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
        },
      },
    })
    
    function App() {
      return <QueryClientProvider client={queryClient}>...</QueryClientProvider>
    }
    

    // Configure for all queries
    import {
      QueryCache,
      QueryClient,
      QueryClientProvider,
    } from '@tanstack/react-query'
    
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
        },
      },
    })
    
    function App() {
      return <QueryClientProvider client={queryClient}>...</QueryClientProvider>
    }
    

Though it is not recommended, you can obviously override the retryDelay function/integer in both the Provider and individual query options. If set to an integer instead of a function the delay will always be the same amount of time:

    const result = useQuery({
      queryKey: ['todos'],
      queryFn: fetchTodoList,
      retryDelay: 1000, // Will always wait 1000ms to retry, regardless of how many retries
    })
    

    const result = useQuery({
      queryKey: ['todos'],
      queryFn: fetchTodoList,
      retryDelay: 1000, // Will always wait 1000ms to retry, regardless of how many retries
    })
    

[](#background-retry-behavior)[Background Retry Behavior](#background-retry-behavior)
-------------------------------------------------------------------------------------

When using refetchInterval with refetchIntervalInBackground: true, retries will pause when the browser tab is inactive. This happens because retries respect the same focus behavior as regular refetches.

If you need continuous retries in the background, consider disabling retries and implementing a custom refetch strategy:

    const result = useQuery({
      queryKey: ['todos'],
      queryFn: fetchTodos,
      refetchInterval: (query) => {
        // Refetch more frequently when in error state
        return query.state.status === 'error' ? 5000 : 30000
      },
      refetchIntervalInBackground: true,
      retry: false, // Disable built-in retries
    })
    

    const result = useQuery({
      queryKey: ['todos'],
      queryFn: fetchTodos,
      refetchInterval: (query) => {
        // Refetch more frequently when in error state
        return query.state.status === 'error' ? 5000 : 30000
      },
      refetchIntervalInBackground: true,
      retry: false, // Disable built-in retries
    })
    

This approach lets you control retry timing manually while keeping refetches active in the background.</content>
</page>

<page>
  <title>Disabling/Pausing Queries | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/disabling-queries</url>
  <content>If you ever want to disable a query from automatically running, you can use the enabled = false option. The enabled option also accepts a callback that returns a boolean.

When enabled is false:

*   If the query has cached data, then the query will be initialized in the status === 'success' or isSuccess state.
*   If the query does not have cached data, then the query will start in the status === 'pending' and fetchStatus === 'idle' state.
*   The query will not automatically fetch on mount.
*   The query will not automatically refetch in the background.
*   The query will ignore query client invalidateQueries and refetchQueries calls that would normally result in the query refetching.
*   refetch returned from useQuery can be used to manually trigger the query to fetch. However, it will not work with skipToken.

> TypeScript users may prefer to use [skipToken](#typesafe-disabling-of-queries-using-skiptoken) as an alternative to enabled = false.

    function Todos() {
      const { isLoading, isError, data, error, refetch, isFetching } = useQuery({
        queryKey: ['todos'],
        queryFn: fetchTodoList,
        enabled: false,
      })
    
      return (
        <div>
          <button onClick={() => refetch()}>Fetch Todos</button>
    
          {data ? (
            <ul>
              {data.map((todo) => (
                <li key={todo.id}>{todo.title}</li>
              ))}
            </ul>
          ) : isError ? (
            <span>Error: {error.message}</span>
          ) : isLoading ? (
            <span>Loading...</span>
          ) : (
            <span>Not ready ...</span>
          )}
    
          <div>{isFetching ? 'Fetching...' : null}</div>
        </div>
      )
    }
    

    function Todos() {
      const { isLoading, isError, data, error, refetch, isFetching } = useQuery({
        queryKey: ['todos'],
        queryFn: fetchTodoList,
        enabled: false,
      })
    
      return (
        <div>
          <button onClick={() => refetch()}>Fetch Todos</button>
    
          {data ? (
            <ul>
              {data.map((todo) => (
                <li key={todo.id}>{todo.title}</li>
              ))}
            </ul>
          ) : isError ? (
            <span>Error: {error.message}</span>
          ) : isLoading ? (
            <span>Loading...</span>
          ) : (
            <span>Not ready ...</span>
          )}
    
          <div>{isFetching ? 'Fetching...' : null}</div>
        </div>
      )
    }
    

Permanently disabling a query opts out of many great features that TanStack Query has to offer (like background refetches), and it's also not the idiomatic way. It takes you from the declarative approach (defining dependencies when your query should run) into an imperative mode (fetch whenever I click here). It is also not possible to pass parameters to refetch. Oftentimes, all you want is a lazy query that defers the initial fetch:

[](#lazy-queries)[Lazy Queries](#lazy-queries)
----------------------------------------------

The enabled option can not only be used to permanently disable a query, but also to enable / disable it at a later time. A good example would be a filter form where you only want to fire off the first request once the user has entered a filter value:

    function Todos() {
      const [filter, setFilter] = React.useState('')
    
      const { data } = useQuery({
        queryKey: ['todos', filter],
        queryFn: () => fetchTodos(filter),
        // ‚¨áÔ∏è disabled as long as the filter is empty
        enabled: !!filter,
      })
    
      return (
        <div>
          // üöÄ applying the filter will enable and execute the query
          <FiltersForm onApply={setFilter} />
          {data && <TodosTable data={data} />}
        </div>
      )
    }
    

    function Todos() {
      const [filter, setFilter] = React.useState('')
    
      const { data } = useQuery({
        queryKey: ['todos', filter],
        queryFn: () => fetchTodos(filter),
        // ‚¨áÔ∏è disabled as long as the filter is empty
        enabled: !!filter,
      })
    
      return (
        <div>
          // üöÄ applying the filter will enable and execute the query
          <FiltersForm onApply={setFilter} />
          {data && <TodosTable data={data} />}
        </div>
      )
    }
    

### [](#isloading-previously-isinitialloading)[isLoading (Previously: isInitialLoading)](#isloading-previously-isinitialloading)

Lazy queries will be in status: 'pending' right from the start because pending means that there is no data yet. This is technically true, however, since we are not currently fetching any data (as the query is not _enabled_), it also means you likely cannot use this flag to show a loading spinner.

If you are using disabled or lazy queries, you can use the isLoading flag instead. It's a derived flag that is computed from:

isPending && isFetching

so it will only be true if the query is currently fetching for the first time.

[](#typesafe-disabling-of-queries-using-skiptoken)[Typesafe disabling of queries using skipToken](#typesafe-disabling-of-queries-using-skiptoken)
-------------------------------------------------------------------------------------------------------------------------------------------------

If you are using TypeScript, you can use the skipToken to disable a query. This is useful when you want to disable a query based on a condition, but you still want to keep the query to be type safe.

> **IMPORTANT**: refetch from useQuery will not work with skipToken. Calling refetch() on a query that uses skipToken will result in a Missing queryFn error because there is no valid query function to execute. If you need to manually trigger queries, consider using enabled: false instead, which allows refetch() to work properly. Other than this limitation, skipToken works the same as enabled: false.

    import { skipToken, useQuery } from '@tanstack/react-query'
    
    function Todos() {
      const [filter, setFilter] = React.useState<string | undefined>()
    
      const { data } = useQuery({
        queryKey: ['todos', filter],
        // ‚¨áÔ∏è disabled as long as the filter is undefined or empty
        queryFn: filter ? () => fetchTodos(filter) : skipToken,
      })
    
      return (
        <div>
          // üöÄ applying the filter will enable and execute the query
          <FiltersForm onApply={setFilter} />
          {data && <TodosTable data={data} />}
        </div>
      )
    }
    

    import { skipToken, useQuery } from '@tanstack/react-query'
    
    function Todos() {
      const [filter, setFilter] = React.useState<string | undefined>()
    
      const { data } = useQuery({
        queryKey: ['todos', filter],
        // ‚¨áÔ∏è disabled as long as the filter is undefined or empty
        queryFn: filter ? () => fetchTodos(filter) : skipToken,
      })
    
      return (
        <div>
          // üöÄ applying the filter will enable and execute the query
          <FiltersForm onApply={setFilter} />
          {data && <TodosTable data={data} />}
        </div>
      )
    }</content>
</page>

<page>
  <title>Dependent Queries | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/dependent-queries</url>
  <content>[](#usequery-dependent-query)[useQuery dependent Query](#usequery-dependent-query)
----------------------------------------------------------------------------------

Dependent (or serial) queries depend on previous ones to finish before they can execute. To achieve this, it's as easy as using the enabled option to tell a query when it is ready to run:

    // Get the user
    const { data: user } = useQuery({
      queryKey: ['user', email],
      queryFn: getUserByEmail,
    })
    
    const userId = user?.id
    
    // Then get the user's projects
    const {
      status,
      fetchStatus,
      data: projects,
    } = useQuery({
      queryKey: ['projects', userId],
      queryFn: getProjectsByUser,
      // The query will not execute until the userId exists
      enabled: !!userId,
    })
    

    // Get the user
    const { data: user } = useQuery({
      queryKey: ['user', email],
      queryFn: getUserByEmail,
    })
    
    const userId = user?.id
    
    // Then get the user's projects
    const {
      status,
      fetchStatus,
      data: projects,
    } = useQuery({
      queryKey: ['projects', userId],
      queryFn: getProjectsByUser,
      // The query will not execute until the userId exists
      enabled: !!userId,
    })
    

The projects query will start in:

    status: 'pending'
    isPending: true
    fetchStatus: 'idle'
    

    status: 'pending'
    isPending: true
    fetchStatus: 'idle'
    

As soon as the user is available, the projects query will be enabled and will then transition to:

    status: 'pending'
    isPending: true
    fetchStatus: 'fetching'
    

    status: 'pending'
    isPending: true
    fetchStatus: 'fetching'
    

Once we have the projects, it will go to:

    status: 'success'
    isPending: false
    fetchStatus: 'idle'
    

    status: 'success'
    isPending: false
    fetchStatus: 'idle'
    

[](#usequeries-dependent-query)[useQueries dependent Query](#usequeries-dependent-query)
----------------------------------------------------------------------------------------

Dynamic parallel query - useQueries can depend on a previous query also, here's how to achieve this:

    // Get the users ids
    const { data: userIds } = useQuery({
      queryKey: ['users'],
      queryFn: getUsersData,
      select: (users) => users.map((user) => user.id),
    })
    
    // Then get the users messages
    const usersMessages = useQueries({
      queries: userIds
        ? userIds.map((id) => {
            return {
              queryKey: ['messages', id],
              queryFn: () => getMessagesByUsers(id),
            }
          })
        : [], // if userIds is undefined, an empty array will be returned
    })
    

    // Get the users ids
    const { data: userIds } = useQuery({
      queryKey: ['users'],
      queryFn: getUsersData,
      select: (users) => users.map((user) => user.id),
    })
    
    // Then get the users messages
    const usersMessages = useQueries({
      queries: userIds
        ? userIds.map((id) => {
            return {
              queryKey: ['messages', id],
              queryFn: () => getMessagesByUsers(id),
            }
          })
        : [], // if userIds is undefined, an empty array will be returned
    })
    

**Note** that useQueries return an **array of query results**

[](#a-note-about-performance)[A note about performance](#a-note-about-performance)
----------------------------------------------------------------------------------

Dependent queries by definition constitutes a form of [request waterfall](https://tanstack.com/query/latest/docs/framework/react/guides/request-waterfalls), which hurts performance. If we pretend both queries take the same amount of time, doing them serially instead of in parallel always takes twice as much time, which is especially hurtful when it happens on a client that has high latency. If you can, it's always better to restructure the backend APIs so that both queries can be fetched in parallel, though that might not always be practically feasible.

In the example above, instead of first fetching getUserByEmail to be able to getProjectsByUser, introducing a new getProjectsByUserEmail query would flatten the waterfall.</content>
</page>

<page>
  <title>Infinite Queries | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/infinite-queries</url>
  <content>Rendering lists that can additively "load more" data onto an existing set of data or "infinite scroll" is also a very common UI pattern. TanStack Query supports a useful version of useQuery called useInfiniteQuery for querying these types of lists.

When using useInfiniteQuery, you'll notice a few things are different:

*   data is now an object containing infinite query data:
*   data.pages array containing the fetched pages
*   data.pageParams array containing the page params used to fetch the pages
*   The fetchNextPage and fetchPreviousPage functions are now available (fetchNextPage is required)
*   The initialPageParam option is now available (and required) to specify the initial page param
*   The getNextPageParam and getPreviousPageParam options are available for both determining if there is more data to load and the information to fetch it. This information is supplied as an additional parameter in the query function
*   A hasNextPage boolean is now available and is true if getNextPageParam returns a value other than null or undefined
*   A hasPreviousPage boolean is now available and is true if getPreviousPageParam returns a value other than null or undefined
*   The isFetchingNextPage and isFetchingPreviousPage booleans are now available to distinguish between a background refresh state and a loading more state

> Note: Options initialData or placeholderData need to conform to the same structure of an object with data.pages and data.pageParams properties.

[](#example)[Example](#example)
-------------------------------

Let's assume we have an API that returns pages of projects 3 at a time based on a cursor index along with a cursor that can be used to fetch the next group of projects:

    fetch('/api/projects?cursor=0')
    // { data: [...], nextCursor: 3}
    fetch('/api/projects?cursor=3')
    // { data: [...], nextCursor: 6}
    fetch('/api/projects?cursor=6')
    // { data: [...], nextCursor: 9}
    fetch('/api/projects?cursor=9')
    // { data: [...] }
    

    fetch('/api/projects?cursor=0')
    // { data: [...], nextCursor: 3}
    fetch('/api/projects?cursor=3')
    // { data: [...], nextCursor: 6}
    fetch('/api/projects?cursor=6')
    // { data: [...], nextCursor: 9}
    fetch('/api/projects?cursor=9')
    // { data: [...] }
    

With this information, we can create a "Load More" UI by:

*   Waiting for useInfiniteQuery to request the first group of data by default
*   Returning the information for the next query in getNextPageParam
*   Calling fetchNextPage function

    import { useInfiniteQuery } from '@tanstack/react-query'
    
    function Projects() {
      const fetchProjects = async ({ pageParam }) => {
        const res = await fetch('/api/projects?cursor=' + pageParam)
        return res.json()
      }
    
      const {
        data,
        error,
        fetchNextPage,
        hasNextPage,
        isFetching,
        isFetchingNextPage,
        status,
      } = useInfiniteQuery({
        queryKey: ['projects'],
        queryFn: fetchProjects,
        initialPageParam: 0,
        getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
      })
    
      return status === 'pending' ? (
        <p>Loading...</p>
      ) : status === 'error' ? (
        <p>Error: {error.message}</p>
      ) : (
        <>
          {data.pages.map((group, i) => (
            <React.Fragment key={i}>
              {group.data.map((project) => (
                <p key={project.id}>{project.name}</p>
              ))}
            </React.Fragment>
          ))}
          <div>
            <button
              onClick={() => fetchNextPage()}
              disabled={!hasNextPage || isFetching}
            >
              {isFetchingNextPage
                ? 'Loading more...'
                : hasNextPage
                  ? 'Load More'
                  : 'Nothing more to load'}
            </button>
          </div>
          <div>{isFetching && !isFetchingNextPage ? 'Fetching...' : null}</div>
        </>
      )
    }
    

    import { useInfiniteQuery } from '@tanstack/react-query'
    
    function Projects() {
      const fetchProjects = async ({ pageParam }) => {
        const res = await fetch('/api/projects?cursor=' + pageParam)
        return res.json()
      }
    
      const {
        data,
        error,
        fetchNextPage,
        hasNextPage,
        isFetching,
        isFetchingNextPage,
        status,
      } = useInfiniteQuery({
        queryKey: ['projects'],
        queryFn: fetchProjects,
        initialPageParam: 0,
        getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
      })
    
      return status === 'pending' ? (
        <p>Loading...</p>
      ) : status === 'error' ? (
        <p>Error: {error.message}</p>
      ) : (
        <>
          {data.pages.map((group, i) => (
            <React.Fragment key={i}>
              {group.data.map((project) => (
                <p key={project.id}>{project.name}</p>
              ))}
            </React.Fragment>
          ))}
          <div>
            <button
              onClick={() => fetchNextPage()}
              disabled={!hasNextPage || isFetching}
            >
              {isFetchingNextPage
                ? 'Loading more...'
                : hasNextPage
                  ? 'Load More'
                  : 'Nothing more to load'}
            </button>
          </div>
          <div>{isFetching && !isFetchingNextPage ? 'Fetching...' : null}</div>
        </>
      )
    }
    

It's essential to understand that calling fetchNextPage while an ongoing fetch is in progress runs the risk of overwriting data refreshes happening in the background. This situation becomes particularly critical when rendering a list and triggering fetchNextPage simultaneously.

Remember, there can only be a single ongoing fetch for an InfiniteQuery. A single cache entry is shared for all pages, attempting to fetch twice simultaneously might lead to data overwrites.

If you intend to enable simultaneous fetching, you can utilize the { cancelRefetch: false } option (default: true) within fetchNextPage.

To ensure a seamless querying process without conflicts, it's highly recommended to verify that the query is not in an isFetching state, especially if the user won't directly control that call.

    <List onEndReached={() => hasNextPage && !isFetching && fetchNextPage()} />
    

    <List onEndReached={() => hasNextPage && !isFetching && fetchNextPage()} />
    

[](#what-happens-when-an-infinite-query-needs-to-be-refetched)[What happens when an infinite query needs to be refetched?](#what-happens-when-an-infinite-query-needs-to-be-refetched)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

When an infinite query becomes stale and needs to be refetched, each group is fetched sequentially, starting from the first one. This ensures that even if the underlying data is mutated, we're not using stale cursors and potentially getting duplicates or skipping records. If an infinite query's results are ever removed from the queryCache, the pagination restarts at the initial state with only the initial group being requested.

[](#what-if-i-want-to-implement-a-bi-directional-infinite-list)[What if I want to implement a bi-directional infinite list?](#what-if-i-want-to-implement-a-bi-directional-infinite-list)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Bi-directional lists can be implemented by using the getPreviousPageParam, fetchPreviousPage, hasPreviousPage and isFetchingPreviousPage properties and functions.

    useInfiniteQuery({
      queryKey: ['projects'],
      queryFn: fetchProjects,
      initialPageParam: 0,
      getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
      getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,
    })
    

    useInfiniteQuery({
      queryKey: ['projects'],
      queryFn: fetchProjects,
      initialPageParam: 0,
      getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
      getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,
    })
    

[](#what-if-i-want-to-show-the-pages-in-reversed-order)[What if I want to show the pages in reversed order?](#what-if-i-want-to-show-the-pages-in-reversed-order)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------

Sometimes you may want to show the pages in reversed order. If this is case, you can use the select option:

    useInfiniteQuery({
      queryKey: ['projects'],
      queryFn: fetchProjects,
      select: (data) => ({
        pages: [...data.pages].reverse(),
        pageParams: [...data.pageParams].reverse(),
      }),
    })
    

    useInfiniteQuery({
      queryKey: ['projects'],
      queryFn: fetchProjects,
      select: (data) => ({
        pages: [...data.pages].reverse(),
        pageParams: [...data.pageParams].reverse(),
      }),
    })
    

[](#what-if-i-want-to-manually-update-the-infinite-query)[What if I want to manually update the infinite query?](#what-if-i-want-to-manually-update-the-infinite-query)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

### [](#manually-removing-first-page)[Manually removing first page:](#manually-removing-first-page)

    queryClient.setQueryData(['projects'], (data) => ({
      pages: data.pages.slice(1),
      pageParams: data.pageParams.slice(1),
    }))
    

    queryClient.setQueryData(['projects'], (data) => ({
      pages: data.pages.slice(1),
      pageParams: data.pageParams.slice(1),
    }))
    

### [](#manually-removing-a-single-value-from-an-individual-page)[Manually removing a single value from an individual page:](#manually-removing-a-single-value-from-an-individual-page)

    const newPagesArray =
      oldPagesArray?.pages.map((page) =>
        page.filter((val) => val.id !== updatedId),
      ) ?? []
    
    queryClient.setQueryData(['projects'], (data) => ({
      pages: newPagesArray,
      pageParams: data.pageParams,
    }))
    

    const newPagesArray =
      oldPagesArray?.pages.map((page) =>
        page.filter((val) => val.id !== updatedId),
      ) ?? []
    
    queryClient.setQueryData(['projects'], (data) => ({
      pages: newPagesArray,
      pageParams: data.pageParams,
    }))
    

### [](#keep-only-the-first-page)[Keep only the first page:](#keep-only-the-first-page)

    queryClient.setQueryData(['projects'], (data) => ({
      pages: data.pages.slice(0, 1),
      pageParams: data.pageParams.slice(0, 1),
    }))
    

    queryClient.setQueryData(['projects'], (data) => ({
      pages: data.pages.slice(0, 1),
      pageParams: data.pageParams.slice(0, 1),
    }))
    

Make sure to always keep the same data structure of pages and pageParams!

[](#what-if-i-want-to-limit-the-number-of-pages)[What if I want to limit the number of pages?](#what-if-i-want-to-limit-the-number-of-pages)
--------------------------------------------------------------------------------------------------------------------------------------------

In some use cases you may want to limit the number of pages stored in the query data to improve the performance and UX:

*   when the user can load a large number of pages (memory usage)
*   when you have to refetch an infinite query that contains dozens of pages (network usage: all the pages are sequentially fetched)

The solution is to use a "Limited Infinite Query". This is made possible by using the maxPages option in conjunction with getNextPageParam and getPreviousPageParam to allow fetching pages when needed in both directions.

In the following example only 3 pages are kept in the query data pages array. If a refetch is needed, only 3 pages will be refetched sequentially.

    useInfiniteQuery({
      queryKey: ['projects'],
      queryFn: fetchProjects,
      initialPageParam: 0,
      getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
      getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,
      maxPages: 3,
    })
    

    useInfiniteQuery({
      queryKey: ['projects'],
      queryFn: fetchProjects,
      initialPageParam: 0,
      getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
      getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,
      maxPages: 3,
    })
    

[](#what-if-my-api-doesnt-return-a-cursor)[What if my API doesn't return a cursor?](#what-if-my-api-doesnt-return-a-cursor)
---------------------------------------------------------------------------------------------------------------------------

If your API doesn't return a cursor, you can use the pageParam as a cursor. Because getNextPageParam and getPreviousPageParam also get the pageParamof the current page, you can use it to calculate the next / previous page param.

    return useInfiniteQuery({
      queryKey: ['projects'],
      queryFn: fetchProjects,
      initialPageParam: 0,
      getNextPageParam: (lastPage, allPages, lastPageParam) => {
        if (lastPage.length === 0) {
          return undefined
        }
        return lastPageParam + 1
      },
      getPreviousPageParam: (firstPage, allPages, firstPageParam) => {
        if (firstPageParam <= 1) {
          return undefined
        }
        return firstPageParam - 1
      },
    })
    

    return useInfiniteQuery({
      queryKey: ['projects'],
      queryFn: fetchProjects,
      initialPageParam: 0,
      getNextPageParam: (lastPage, allPages, lastPageParam) => {
        if (lastPage.length === 0) {
          return undefined
        }
        return lastPageParam + 1
      },
      getPreviousPageParam: (firstPage, allPages, firstPageParam) => {
        if (firstPageParam <= 1) {
          return undefined
        }
        return firstPageParam - 1
      },
    })
    

[](#further-reading)[Further reading](#further-reading)
-------------------------------------------------------

To get a better understanding of how Infinite Queries work under the hood, see the article [How Infinite Queries work](https://tkdodo.eu/blog/how-infinite-queries-work).</content>
</page>

<page>
  <title>Initial Query Data | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/initial-query-data</url>
  <content>There are many ways to supply initial data for a query to the cache before you need it:

*   Declaratively:
    *   Provide initialData to a query to prepopulate its cache if empty
*   Imperatively:
    *   [Prefetch the data using queryClient.prefetchQuery](https://tanstack.com/query/latest/docs/framework/react/guides/prefetching)
    *   [Manually place the data into the cache using queryClient.setQueryData](https://tanstack.com/query/latest/docs/framework/react/guides/prefetching)

[](#using-initialdata-to-prepopulate-a-query)[Using initialData to prepopulate a query](#using-initialdata-to-prepopulate-a-query)
----------------------------------------------------------------------------------------------------------------------------------

There may be times when you already have the initial data for a query available in your app and can simply provide it directly to your query. If and when this is the case, you can use the config.initialData option to set the initial data for a query and skip the initial loading state!

> IMPORTANT: initialData is persisted to the cache, so it is not recommended to provide placeholder, partial or incomplete data to this option and instead use placeholderData

    const result = useQuery({
      queryKey: ['todos'],
      queryFn: () => fetch('/todos'),
      initialData: initialTodos,
    })
    

    const result = useQuery({
      queryKey: ['todos'],
      queryFn: () => fetch('/todos'),
      initialData: initialTodos,
    })
    

### [](#staletime-and-initialdataupdatedat)[staleTime and initialDataUpdatedAt](#staletime-and-initialdataupdatedat)

By default, initialData is treated as totally fresh, as if it were just fetched. This also means that it will affect how it is interpreted by the staleTime option.

*   If you configure your query observer with initialData, and no staleTime (the default staleTime: 0), the query will immediately refetch when it mounts:
    
        // Will show initialTodos immediately, but also immediately refetch todos after mount
        const result = useQuery({
          queryKey: ['todos'],
          queryFn: () => fetch('/todos'),
          initialData: initialTodos,
        })
        
    
        // Will show initialTodos immediately, but also immediately refetch todos after mount
        const result = useQuery({
          queryKey: ['todos'],
          queryFn: () => fetch('/todos'),
          initialData: initialTodos,
        })
        
    
*   If you configure your query observer with initialData and a staleTime of 1000 ms, the data will be considered fresh for that same amount of time, as if it was just fetched from your query function.
    
        // Show initialTodos immediately, but won't refetch until another interaction event is encountered after 1000 ms
        const result = useQuery({
          queryKey: ['todos'],
          queryFn: () => fetch('/todos'),
          initialData: initialTodos,
          staleTime: 1000,
        })
        
    
        // Show initialTodos immediately, but won't refetch until another interaction event is encountered after 1000 ms
        const result = useQuery({
          queryKey: ['todos'],
          queryFn: () => fetch('/todos'),
          initialData: initialTodos,
          staleTime: 1000,
        })
        
    
*   So what if your initialData isn't totally fresh? That leaves us with the last configuration that is actually the most accurate and uses an option called initialDataUpdatedAt. This option allows you to pass a numeric JS timestamp in milliseconds of when the initialData itself was last updated, e.g. what Date.now() provides. Take note that if you have a unix timestamp, you'll need to convert it to a JS timestamp by multiplying it by 1000.
    
        // Show initialTodos immediately, but won't refetch until another interaction event is encountered after 1000 ms
        const result = useQuery({
          queryKey: ['todos'],
          queryFn: () => fetch('/todos'),
          initialData: initialTodos,
          staleTime: 60 * 1000, // 1 minute
          // This could be 10 seconds ago or 10 minutes ago
          initialDataUpdatedAt: initialTodosUpdatedTimestamp, // eg. 1608412420052
        })
        
    
        // Show initialTodos immediately, but won't refetch until another interaction event is encountered after 1000 ms
        const result = useQuery({
          queryKey: ['todos'],
          queryFn: () => fetch('/todos'),
          initialData: initialTodos,
          staleTime: 60 * 1000, // 1 minute
          // This could be 10 seconds ago or 10 minutes ago
          initialDataUpdatedAt: initialTodosUpdatedTimestamp, // eg. 1608412420052
        })
        
    
    This option allows the staleTime to be used for its original purpose, determining how fresh the data needs to be, while also allowing the data to be refetched on mount if the initialData is older than the staleTime. In the example above, our data needs to be fresh within 1 minute, and we can hint to the query when the initialData was last updated so the query can decide for itself whether the data needs to be refetched again or not.
    
    > If you would rather treat your data as **prefetched data**, we recommend that you use the prefetchQuery or fetchQuery APIs to populate the cache beforehand, thus letting you configure your staleTime independently from your initialData
    

### [](#initial-data-function)[Initial Data Function](#initial-data-function)

If the process for accessing a query's initial data is intensive or just not something you want to perform on every render, you can pass a function as the initialData value. This function will be executed only once when the query is initialized, saving you precious memory and/or CPU:

    const result = useQuery({
      queryKey: ['todos'],
      queryFn: () => fetch('/todos'),
      initialData: () => getExpensiveTodos(),
    })
    

    const result = useQuery({
      queryKey: ['todos'],
      queryFn: () => fetch('/todos'),
      initialData: () => getExpensiveTodos(),
    })
    

### [](#initial-data-from-cache)[Initial Data from Cache](#initial-data-from-cache)

In some circumstances, you may be able to provide the initial data for a query from the cached result of another. A good example of this would be searching the cached data from a todos list query for an individual todo item, then using that as the initial data for your individual todo query:

    const result = useQuery({
      queryKey: ['todo', todoId],
      queryFn: () => fetch('/todos'),
      initialData: () => {
        // Use a todo from the 'todos' query as the initial data for this todo query
        return queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId)
      },
    })
    

    const result = useQuery({
      queryKey: ['todo', todoId],
      queryFn: () => fetch('/todos'),
      initialData: () => {
        // Use a todo from the 'todos' query as the initial data for this todo query
        return queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId)
      },
    })
    

### [](#initial-data-from-the-cache-with-initialdataupdatedat)[Initial Data from the cache with initialDataUpdatedAt](#initial-data-from-the-cache-with-initialdataupdatedat)

Getting initial data from the cache means the source query you're using to look up the initial data from is likely old. Instead of using an artificial staleTime to keep your query from refetching immediately, it's suggested that you pass the source query's dataUpdatedAt to initialDataUpdatedAt. This provides the query instance with all the information it needs to determine if and when the query needs to be refetched, regardless of initial data being provided.

    const result = useQuery({
      queryKey: ['todos', todoId],
      queryFn: () => fetch(`/todos/${todoId}`),
      initialData: () =>
        queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId),
      initialDataUpdatedAt: () =>
        queryClient.getQueryState(['todos'])?.dataUpdatedAt,
    })
    

    const result = useQuery({
      queryKey: ['todos', todoId],
      queryFn: () => fetch(`/todos/${todoId}`),
      initialData: () =>
        queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId),
      initialDataUpdatedAt: () =>
        queryClient.getQueryState(['todos'])?.dataUpdatedAt,
    })
    

### [](#conditional-initial-data-from-cache)[Conditional Initial Data from Cache](#conditional-initial-data-from-cache)

If the source query you're using to look up the initial data from is old, you may not want to use the cached data at all and just fetch from the server. To make this decision easier, you can use the queryClient.getQueryState method instead to get more information about the source query, including a state.dataUpdatedAt timestamp you can use to decide if the query is "fresh" enough for your needs:

    const result = useQuery({
      queryKey: ['todo', todoId],
      queryFn: () => fetch(`/todos/${todoId}`),
      initialData: () => {
        // Get the query state
        const state = queryClient.getQueryState(['todos'])
    
        // If the query exists and has data that is no older than 10 seconds...
        if (state && Date.now() - state.dataUpdatedAt <= 10 * 1000) {
          // return the individual todo
          return state.data.find((d) => d.id === todoId)
        }
    
        // Otherwise, return undefined and let it fetch from a hard loading state!
      },
    })
    

    const result = useQuery({
      queryKey: ['todo', todoId],
      queryFn: () => fetch(`/todos/${todoId}`),
      initialData: () => {
        // Get the query state
        const state = queryClient.getQueryState(['todos'])
    
        // If the query exists and has data that is no older than 10 seconds...
        if (state && Date.now() - state.dataUpdatedAt <= 10 * 1000) {
          // return the individual todo
          return state.data.find((d) => d.id === todoId)
        }
    
        // Otherwise, return undefined and let it fetch from a hard loading state!
      },
    })
    

[](#further-reading)[Further reading](#further-reading)
-------------------------------------------------------

For a comparison between Initial Data and Placeholder Data, see the [article by TkDodo](https://tkdodo.eu/blog/placeholder-and-initial-data-in-react-query).</content>
</page>

<page>
  <title>Mutations | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/mutations</url>
  <content>Unlike queries, mutations are typically used to create/update/delete data or perform server side-effects. For this purpose, TanStack Query exports a useMutation hook.

Here's an example of a mutation that adds a new todo to the server:

    function App() {
      const mutation = useMutation({
        mutationFn: (newTodo) => {
          return axios.post('/todos', newTodo)
        },
      })
    
      return (
        <div>
          {mutation.isPending ? (
            'Adding todo...'
          ) : (
            <>
              {mutation.isError ? (
                <div>An error occurred: {mutation.error.message}</div>
              ) : null}
    
              {mutation.isSuccess ? <div>Todo added!</div> : null}
    
              <button
                onClick={() => {
                  mutation.mutate({ id: new Date(), title: 'Do Laundry' })
                }}
              >
                Create Todo
              </button>
            </>
          )}
        </div>
      )
    }
    

    function App() {
      const mutation = useMutation({
        mutationFn: (newTodo) => {
          return axios.post('/todos', newTodo)
        },
      })
    
      return (
        <div>
          {mutation.isPending ? (
            'Adding todo...'
          ) : (
            <>
              {mutation.isError ? (
                <div>An error occurred: {mutation.error.message}</div>
              ) : null}
    
              {mutation.isSuccess ? <div>Todo added!</div> : null}
    
              <button
                onClick={() => {
                  mutation.mutate({ id: new Date(), title: 'Do Laundry' })
                }}
              >
                Create Todo
              </button>
            </>
          )}
        </div>
      )
    }
    

A mutation can only be in one of the following states at any given moment:

*   isIdle or status === 'idle' - The mutation is currently idle or in a fresh/reset state
*   isPending or status === 'pending' - The mutation is currently running
*   isError or status === 'error' - The mutation encountered an error
*   isSuccess or status === 'success' - The mutation was successful and mutation data is available

Beyond those primary states, more information is available depending on the state of the mutation:

*   error - If the mutation is in an error state, the error is available via the error property.
*   data - If the mutation is in a success state, the data is available via the data property.

In the example above, you also saw that you can pass variables to your mutations function by calling the mutate function with a **single variable or object**.

Even with just variables, mutations aren't all that special, but when used with the onSuccess option, the [Query Client's invalidateQueries method](https://tanstack.com/query/latest/docs/reference/QueryClient#queryclientinvalidatequeries) and the [Query Client's setQueryData method](https://tanstack.com/query/latest/docs/reference/QueryClient#queryclientsetquerydata), mutations become a very powerful tool.

> IMPORTANT: The mutate function is an asynchronous function, which means you cannot use it directly in an event callback in **React 16 and earlier**. If you need to access the event in onSubmit you need to wrap mutate in another function. This is due to [React event pooling](https://reactjs.org/docs/legacy-event-pooling.html).

    // This will not work in React 16 and earlier
    const CreateTodo = () => {
      const mutation = useMutation({
        mutationFn: (event) => {
          event.preventDefault()
          return fetch('/api', new FormData(event.target))
        },
      })
    
      return <form onSubmit={mutation.mutate}>...</form>
    }
    
    // This will work
    const CreateTodo = () => {
      const mutation = useMutation({
        mutationFn: (formData) => {
          return fetch('/api', formData)
        },
      })
      const onSubmit = (event) => {
        event.preventDefault()
        mutation.mutate(new FormData(event.target))
      }
    
      return <form onSubmit={onSubmit}>...</form>
    }
    

    // This will not work in React 16 and earlier
    const CreateTodo = () => {
      const mutation = useMutation({
        mutationFn: (event) => {
          event.preventDefault()
          return fetch('/api', new FormData(event.target))
        },
      })
    
      return <form onSubmit={mutation.mutate}>...</form>
    }
    
    // This will work
    const CreateTodo = () => {
      const mutation = useMutation({
        mutationFn: (formData) => {
          return fetch('/api', formData)
        },
      })
      const onSubmit = (event) => {
        event.preventDefault()
        mutation.mutate(new FormData(event.target))
      }
    
      return <form onSubmit={onSubmit}>...</form>
    }
    

[](#resetting-mutation-state)[Resetting Mutation State](#resetting-mutation-state)
----------------------------------------------------------------------------------

It's sometimes the case that you need to clear the error or data of a mutation request. To do this, you can use the reset function to handle this:

    const CreateTodo = () => {
      const [title, setTitle] = useState('')
      const mutation = useMutation({ mutationFn: createTodo })
    
      const onCreateTodo = (e) => {
        e.preventDefault()
        mutation.mutate({ title })
      }
    
      return (
        <form onSubmit={onCreateTodo}>
          {mutation.error && (
            <h5 onClick={() => mutation.reset()}>{mutation.error}</h5>
          )}
          <input
            type="text"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
          />
          <br />
          <button type="submit">Create Todo</button>
        </form>
      )
    }
    

    const CreateTodo = () => {
      const [title, setTitle] = useState('')
      const mutation = useMutation({ mutationFn: createTodo })
    
      const onCreateTodo = (e) => {
        e.preventDefault()
        mutation.mutate({ title })
      }
    
      return (
        <form onSubmit={onCreateTodo}>
          {mutation.error && (
            <h5 onClick={() => mutation.reset()}>{mutation.error}</h5>
          )}
          <input
            type="text"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
          />
          <br />
          <button type="submit">Create Todo</button>
        </form>
      )
    }
    

[](#mutation-side-effects)[Mutation Side Effects](#mutation-side-effects)
-------------------------------------------------------------------------

useMutation comes with some helper options that allow quick and easy side-effects at any stage during the mutation lifecycle. These come in handy for both [invalidating and refetching queries after mutations](https://tanstack.com/query/latest/docs/framework/react/guides/invalidations-from-mutations) and even [optimistic updates](https://tanstack.com/query/latest/docs/framework/react/guides/optimistic-updates)

    useMutation({
      mutationFn: addTodo,
      onMutate: (variables, context) => {
        // A mutation is about to happen!
    
        // Optionally return a result containing data to use when for example rolling back
        return { id: 1 }
      },
      onError: (error, variables, onMutateResult, context) => {
        // An error happened!
        console.log(`rolling back optimistic update with id ${onMutateResult.id}`)
      },
      onSuccess: (data, variables, onMutateResult, context) => {
        // Boom baby!
      },
      onSettled: (data, error, variables, onMutateResult, context) => {
        // Error or success... doesn't matter!
      },
    })
    

    useMutation({
      mutationFn: addTodo,
      onMutate: (variables, context) => {
        // A mutation is about to happen!
    
        // Optionally return a result containing data to use when for example rolling back
        return { id: 1 }
      },
      onError: (error, variables, onMutateResult, context) => {
        // An error happened!
        console.log(`rolling back optimistic update with id ${onMutateResult.id}`)
      },
      onSuccess: (data, variables, onMutateResult, context) => {
        // Boom baby!
      },
      onSettled: (data, error, variables, onMutateResult, context) => {
        // Error or success... doesn't matter!
      },
    })
    

When returning a promise in any of the callback functions it will first be awaited before the next callback is called:

    useMutation({
      mutationFn: addTodo,
      onSuccess: async () => {
        console.log("I'm first!")
      },
      onSettled: async () => {
        console.log("I'm second!")
      },
    })
    

    useMutation({
      mutationFn: addTodo,
      onSuccess: async () => {
        console.log("I'm first!")
      },
      onSettled: async () => {
        console.log("I'm second!")
      },
    })
    

You might find that you want to **trigger additional callbacks** beyond the ones defined on useMutation when calling mutate. This can be used to trigger component-specific side effects. To do that, you can provide any of the same callback options to the mutate function after your mutation variable. Supported options include: onSuccess, onError and onSettled. Please keep in mind that those additional callbacks won't run if your component unmounts _before_ the mutation finishes.

    useMutation({
      mutationFn: addTodo,
      onSuccess: (data, variables, onMutateResult, context) => {
        // I will fire first
      },
      onError: (error, variables, onMutateResult, context) => {
        // I will fire first
      },
      onSettled: (data, error, variables, onMutateResult, context) => {
        // I will fire first
      },
    })
    
    mutate(todo, {
      onSuccess: (data, variables, onMutateResult, context) => {
        // I will fire second!
      },
      onError: (error, variables, onMutateResult, context) => {
        // I will fire second!
      },
      onSettled: (data, error, variables, onMutateResult, context) => {
        // I will fire second!
      },
    })
    

    useMutation({
      mutationFn: addTodo,
      onSuccess: (data, variables, onMutateResult, context) => {
        // I will fire first
      },
      onError: (error, variables, onMutateResult, context) => {
        // I will fire first
      },
      onSettled: (data, error, variables, onMutateResult, context) => {
        // I will fire first
      },
    })
    
    mutate(todo, {
      onSuccess: (data, variables, onMutateResult, context) => {
        // I will fire second!
      },
      onError: (error, variables, onMutateResult, context) => {
        // I will fire second!
      },
      onSettled: (data, error, variables, onMutateResult, context) => {
        // I will fire second!
      },
    })
    

### [](#consecutive-mutations)[Consecutive mutations](#consecutive-mutations)

There is a slight difference in handling onSuccess, onError and onSettled callbacks when it comes to consecutive mutations. When passed to the mutate function, they will be fired up only _once_ and only if the component is still mounted. This is due to the fact that mutation observer is removed and resubscribed every time when the mutate function is called. On the contrary, useMutation handlers execute for each mutate call.

> Be aware that most likely, mutationFn passed to useMutation is asynchronous. In that case, the order in which mutations are fulfilled may differ from the order of mutate function calls.

    useMutation({
      mutationFn: addTodo,
      onSuccess: (data, variables, onMutateResult, context) => {
        // Will be called 3 times
      },
    })
    
    const todos = ['Todo 1', 'Todo 2', 'Todo 3']
    todos.forEach((todo) => {
      mutate(todo, {
        onSuccess: (data, variables, onMutateResult, context) => {
          // Will execute only once, for the last mutation (Todo 3),
          // regardless which mutation resolves first
        },
      })
    })
    

    useMutation({
      mutationFn: addTodo,
      onSuccess: (data, variables, onMutateResult, context) => {
        // Will be called 3 times
      },
    })
    
    const todos = ['Todo 1', 'Todo 2', 'Todo 3']
    todos.forEach((todo) => {
      mutate(todo, {
        onSuccess: (data, variables, onMutateResult, context) => {
          // Will execute only once, for the last mutation (Todo 3),
          // regardless which mutation resolves first
        },
      })
    })
    

[](#promises)[Promises](#promises)
----------------------------------

Use mutateAsync instead of mutate to get a promise which will resolve on success or throw on an error. This can for example be used to compose side effects.

    const mutation = useMutation({ mutationFn: addTodo })
    
    try {
      const todo = await mutation.mutateAsync(todo)
      console.log(todo)
    } catch (error) {
      console.error(error)
    } finally {
      console.log('done')
    }
    

    const mutation = useMutation({ mutationFn: addTodo })
    
    try {
      const todo = await mutation.mutateAsync(todo)
      console.log(todo)
    } catch (error) {
      console.error(error)
    } finally {
      console.log('done')
    }
    

[](#retry)[Retry](#retry)
-------------------------

By default, TanStack Query will not retry a mutation on error, but it is possible with the retry option:

    const mutation = useMutation({
      mutationFn: addTodo,
      retry: 3,
    })
    

    const mutation = useMutation({
      mutationFn: addTodo,
      retry: 3,
    })
    

If mutations fail because the device is offline, they will be retried in the same order when the device reconnects.

[](#persist-mutations)[Persist mutations](#persist-mutations)
-------------------------------------------------------------

Mutations can be persisted to storage if needed and resumed at a later point. This can be done with the hydration functions:

    const queryClient = new QueryClient()
    
    // Define the "addTodo" mutation
    queryClient.setMutationDefaults(['addTodo'], {
      mutationFn: addTodo,
      onMutate: async (variables, context) => {
        // Cancel current queries for the todos list
        await context.client.cancelQueries({ queryKey: ['todos'] })
    
        // Create optimistic todo
        const optimisticTodo = { id: uuid(), title: variables.title }
    
        // Add optimistic todo to todos list
        context.client.setQueryData(['todos'], (old) => [...old, optimisticTodo])
    
        // Return a result with the optimistic todo
        return { optimisticTodo }
      },
      onSuccess: (result, variables, onMutateResult, context) => {
        // Replace optimistic todo in the todos list with the result
        context.client.setQueryData(['todos'], (old) =>
          old.map((todo) =>
            todo.id === onMutateResult.optimisticTodo.id ? result : todo,
          ),
        )
      },
      onError: (error, variables, onMutateResult, context) => {
        // Remove optimistic todo from the todos list
        context.client.setQueryData(['todos'], (old) =>
          old.filter((todo) => todo.id !== onMutateResult.optimisticTodo.id),
        )
      },
      retry: 3,
    })
    
    // Start mutation in some component:
    const mutation = useMutation({ mutationKey: ['addTodo'] })
    mutation.mutate({ title: 'title' })
    
    // If the mutation has been paused because the device is for example offline,
    // Then the paused mutation can be dehydrated when the application quits:
    const state = dehydrate(queryClient)
    
    // The mutation can then be hydrated again when the application is started:
    hydrate(queryClient, state)
    
    // Resume the paused mutations:
    queryClient.resumePausedMutations()
    

    const queryClient = new QueryClient()
    
    // Define the "addTodo" mutation
    queryClient.setMutationDefaults(['addTodo'], {
      mutationFn: addTodo,
      onMutate: async (variables, context) => {
        // Cancel current queries for the todos list
        await context.client.cancelQueries({ queryKey: ['todos'] })
    
        // Create optimistic todo
        const optimisticTodo = { id: uuid(), title: variables.title }
    
        // Add optimistic todo to todos list
        context.client.setQueryData(['todos'], (old) => [...old, optimisticTodo])
    
        // Return a result with the optimistic todo
        return { optimisticTodo }
      },
      onSuccess: (result, variables, onMutateResult, context) => {
        // Replace optimistic todo in the todos list with the result
        context.client.setQueryData(['todos'], (old) =>
          old.map((todo) =>
            todo.id === onMutateResult.optimisticTodo.id ? result : todo,
          ),
        )
      },
      onError: (error, variables, onMutateResult, context) => {
        // Remove optimistic todo from the todos list
        context.client.setQueryData(['todos'], (old) =>
          old.filter((todo) => todo.id !== onMutateResult.optimisticTodo.id),
        )
      },
      retry: 3,
    })
    
    // Start mutation in some component:
    const mutation = useMutation({ mutationKey: ['addTodo'] })
    mutation.mutate({ title: 'title' })
    
    // If the mutation has been paused because the device is for example offline,
    // Then the paused mutation can be dehydrated when the application quits:
    const state = dehydrate(queryClient)
    
    // The mutation can then be hydrated again when the application is started:
    hydrate(queryClient, state)
    
    // Resume the paused mutations:
    queryClient.resumePausedMutations()
    

### [](#persisting-offline-mutations)[Persisting Offline mutations](#persisting-offline-mutations)

If you persist offline mutations with the [persistQueryClient plugin](https://tanstack.com/query/latest/docs/framework/react/plugins/persistQueryClient), mutations cannot be resumed when the page is reloaded unless you provide a default mutation function.

This is a technical limitation. When persisting to an external storage, only the state of mutations is persisted, as functions cannot be serialized. After hydration, the component that triggers the mutation might not be mounted, so calling resumePausedMutations might yield an error: No mutationFn found.

    const persister = createSyncStoragePersister({
      storage: window.localStorage,
    })
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          gcTime: 1000 * 60 * 60 * 24, // 24 hours
        },
      },
    })
    
    // we need a default mutation function so that paused mutations can resume after a page reload
    queryClient.setMutationDefaults(['todos'], {
      mutationFn: ({ id, data }) => {
        return api.updateTodo(id, data)
      },
    })
    
    export default function App() {
      return (
        <PersistQueryClientProvider
          client={queryClient}
          persistOptions={{ persister }}
          onSuccess={() => {
            // resume mutations after initial restore from localStorage was successful
            queryClient.resumePausedMutations()
          }}
        >
          <RestOfTheApp />
        </PersistQueryClientProvider>
      )
    }
    

    const persister = createSyncStoragePersister({
      storage: window.localStorage,
    })
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          gcTime: 1000 * 60 * 60 * 24, // 24 hours
        },
      },
    })
    
    // we need a default mutation function so that paused mutations can resume after a page reload
    queryClient.setMutationDefaults(['todos'], {
      mutationFn: ({ id, data }) => {
        return api.updateTodo(id, data)
      },
    })
    
    export default function App() {
      return (
        <PersistQueryClientProvider
          client={queryClient}
          persistOptions={{ persister }}
          onSuccess={() => {
            // resume mutations after initial restore from localStorage was successful
            queryClient.resumePausedMutations()
          }}
        >
          <RestOfTheApp />
        </PersistQueryClientProvider>
      )
    }
    

We also have an extensive [offline example](https://tanstack.com/query/latest/docs/framework/react/examples/offline) that covers both queries and mutations.

[](#mutation-scopes)[Mutation Scopes](#mutation-scopes)
-------------------------------------------------------

Per default, all mutations run in parallel - even if you invoke .mutate() of the same mutation multiple times. Mutations can be given a scope with an id to avoid that. All mutations with the same scope.id will run in serial, which means when they are triggered, they will start in isPaused: true state if there is already a mutation for that scope in progress. They will be put into a queue and will automatically resume once their time in the queue has come.

    const mutation = useMutation({
      mutationFn: addTodo,
      scope: {
        id: 'todo',
      },
    })
    

    const mutation = useMutation({
      mutationFn: addTodo,
      scope: {
        id: 'todo',
      },
    })
    

[](#further-reading)[Further reading](#further-reading)
-------------------------------------------------------

For more information about mutations, have a look at [TkDodo's article on Mastering Mutations in React Query](https://tkdodo.eu/blog/mastering-mutations-in-react-query).</content>
</page>

<page>
  <title>Paginated / Lagged Queries | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/paginated-queries</url>
  <content>Rendering paginated data is a very common UI pattern and in TanStack Query, it "just works" by including the page information in the query key:

    const result = useQuery({
      queryKey: ['projects', page],
      queryFn: () => fetchProjects(page),
    })
    

    const result = useQuery({
      queryKey: ['projects', page],
      queryFn: () => fetchProjects(page),
    })
    

However, if you run this simple example, you might notice something strange:

**The UI jumps in and out of the success and pending states because each new page is treated like a brand new query.**

This experience is not optimal and unfortunately is how many tools today insist on working. But not TanStack Query! As you may have guessed, TanStack Query comes with an awesome feature called placeholderData that allows us to get around this.

[](#better-paginated-queries-with-placeholderdata)[Better Paginated Queries with placeholderData](#better-paginated-queries-with-placeholderdata)
-------------------------------------------------------------------------------------------------------------------------------------------------

Consider the following example where we would ideally want to increment a pageIndex (or cursor) for a query. If we were to use useQuery, **it would still technically work fine**, but the UI would jump in and out of the success and pending states as different queries are created and destroyed for each page or cursor. By setting placeholderData to (previousData) => previousData or keepPreviousData function exported from TanStack Query, we get a few new things:

*   **The data from the last successful fetch is available while new data is being requested, even though the query key has changed**.
*   When the new data arrives, the previous data is seamlessly swapped to show the new data.
*   isPlaceholderData is made available to know what data the query is currently providing you

    import { keepPreviousData, useQuery } from '@tanstack/react-query'
    import React from 'react'
    
    function Todos() {
      const [page, setPage] = React.useState(0)
    
      const fetchProjects = (page = 0) =>
        fetch('/api/projects?page=' + page).then((res) => res.json())
    
      const { isPending, isError, error, data, isFetching, isPlaceholderData } =
        useQuery({
          queryKey: ['projects', page],
          queryFn: () => fetchProjects(page),
          placeholderData: keepPreviousData,
        })
    
      return (
        <div>
          {isPending ? (
            <div>Loading...</div>
          ) : isError ? (
            <div>Error: {error.message}</div>
          ) : (
            <div>
              {data.projects.map((project) => (
                <p key={project.id}>{project.name}</p>
              ))}
            </div>
          )}
          <span>Current Page: {page + 1}</span>
          <button
            onClick={() => setPage((old) => Math.max(old - 1, 0))}
            disabled={page === 0}
          >
            Previous Page
          </button>
          <button
            onClick={() => {
              if (!isPlaceholderData && data.hasMore) {
                setPage((old) => old + 1)
              }
            }}
            // Disable the Next Page button until we know a next page is available
            disabled={isPlaceholderData || !data?.hasMore}
          >
            Next Page
          </button>
          {isFetching ? <span> Loading...</span> : null}
        </div>
      )
    }
    

    import { keepPreviousData, useQuery } from '@tanstack/react-query'
    import React from 'react'
    
    function Todos() {
      const [page, setPage] = React.useState(0)
    
      const fetchProjects = (page = 0) =>
        fetch('/api/projects?page=' + page).then((res) => res.json())
    
      const { isPending, isError, error, data, isFetching, isPlaceholderData } =
        useQuery({
          queryKey: ['projects', page],
          queryFn: () => fetchProjects(page),
          placeholderData: keepPreviousData,
        })
    
      return (
        <div>
          {isPending ? (
            <div>Loading...</div>
          ) : isError ? (
            <div>Error: {error.message}</div>
          ) : (
            <div>
              {data.projects.map((project) => (
                <p key={project.id}>{project.name}</p>
              ))}
            </div>
          )}
          <span>Current Page: {page + 1}</span>
          <button
            onClick={() => setPage((old) => Math.max(old - 1, 0))}
            disabled={page === 0}
          >
            Previous Page
          </button>
          <button
            onClick={() => {
              if (!isPlaceholderData && data.hasMore) {
                setPage((old) => old + 1)
              }
            }}
            // Disable the Next Page button until we know a next page is available
            disabled={isPlaceholderData || !data?.hasMore}
          >
            Next Page
          </button>
          {isFetching ? <span> Loading...</span> : null}
        </div>
      )
    }
    

[](#lagging-infinite-query-results-with-placeholderdata)[Lagging Infinite Query results with placeholderData](#lagging-infinite-query-results-with-placeholderdata)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------

While not as common, the placeholderData option also works flawlessly with the useInfiniteQuery hook, so you can seamlessly allow your users to continue to see cached data while infinite query keys change over time.</content>
</page>

<page>
  <title>Query Invalidation | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/query-invalidation</url>
  <content>Waiting for queries to become stale before they are fetched again doesn't always work, especially when you know for a fact that a query's data is out of date because of something the user has done. For that purpose, the QueryClient has an invalidateQueries method that lets you intelligently mark queries as stale and potentially refetch them too!

    // Invalidate every query in the cache
    queryClient.invalidateQueries()
    // Invalidate every query with a key that starts with `todos`
    queryClient.invalidateQueries({ queryKey: ['todos'] })
    

    // Invalidate every query in the cache
    queryClient.invalidateQueries()
    // Invalidate every query with a key that starts with `todos`
    queryClient.invalidateQueries({ queryKey: ['todos'] })
    

> Note: Where other libraries that use normalized caches would attempt to update local queries with the new data either imperatively or via schema inference, TanStack Query gives you the tools to avoid the manual labor that comes with maintaining normalized caches and instead prescribes **targeted invalidation, background-refetching and ultimately atomic updates**.

When a query is invalidated with invalidateQueries, two things happen:

*   It is marked as stale. This stale state overrides any staleTime configurations being used in useQuery or related hooks
*   If the query is currently being rendered via useQuery or related hooks, it will also be refetched in the background

[](#query-matching-with-invalidatequeries)[Query Matching with invalidateQueries](#query-matching-with-invalidatequeries)
-------------------------------------------------------------------------------------------------------------------------

When using APIs like invalidateQueries and removeQueries (and others that support partial query matching), you can match multiple queries by their prefix, or get really specific and match an exact query. For information on the types of filters you can use, please see [Query Filters](https://tanstack.com/query/latest/docs/framework/react/guides/filters#query-filters).

In this example, we can use the todos prefix to invalidate any queries that start with todos in their query key:

    import { useQuery, useQueryClient } from '@tanstack/react-query'
    
    // Get QueryClient from the context
    const queryClient = useQueryClient()
    
    queryClient.invalidateQueries({ queryKey: ['todos'] })
    
    // Both queries below will be invalidated
    const todoListQuery = useQuery({
      queryKey: ['todos'],
      queryFn: fetchTodoList,
    })
    const todoListQuery = useQuery({
      queryKey: ['todos', { page: 1 }],
      queryFn: fetchTodoList,
    })
    

    import { useQuery, useQueryClient } from '@tanstack/react-query'
    
    // Get QueryClient from the context
    const queryClient = useQueryClient()
    
    queryClient.invalidateQueries({ queryKey: ['todos'] })
    
    // Both queries below will be invalidated
    const todoListQuery = useQuery({
      queryKey: ['todos'],
      queryFn: fetchTodoList,
    })
    const todoListQuery = useQuery({
      queryKey: ['todos', { page: 1 }],
      queryFn: fetchTodoList,
    })
    

You can even invalidate queries with specific variables by passing a more specific query key to the invalidateQueries method:

    queryClient.invalidateQueries({
      queryKey: ['todos', { type: 'done' }],
    })
    
    // The query below will be invalidated
    const todoListQuery = useQuery({
      queryKey: ['todos', { type: 'done' }],
      queryFn: fetchTodoList,
    })
    
    // However, the following query below will NOT be invalidated
    const todoListQuery = useQuery({
      queryKey: ['todos'],
      queryFn: fetchTodoList,
    })
    

    queryClient.invalidateQueries({
      queryKey: ['todos', { type: 'done' }],
    })
    
    // The query below will be invalidated
    const todoListQuery = useQuery({
      queryKey: ['todos', { type: 'done' }],
      queryFn: fetchTodoList,
    })
    
    // However, the following query below will NOT be invalidated
    const todoListQuery = useQuery({
      queryKey: ['todos'],
      queryFn: fetchTodoList,
    })
    

The invalidateQueries API is very flexible, so even if you want to **only** invalidate todos queries that don't have any more variables or subkeys, you can pass an exact: true option to the invalidateQueries method:

    queryClient.invalidateQueries({
      queryKey: ['todos'],
      exact: true,
    })
    
    // The query below will be invalidated
    const todoListQuery = useQuery({
      queryKey: ['todos'],
      queryFn: fetchTodoList,
    })
    
    // However, the following query below will NOT be invalidated
    const todoListQuery = useQuery({
      queryKey: ['todos', { type: 'done' }],
      queryFn: fetchTodoList,
    })
    

    queryClient.invalidateQueries({
      queryKey: ['todos'],
      exact: true,
    })
    
    // The query below will be invalidated
    const todoListQuery = useQuery({
      queryKey: ['todos'],
      queryFn: fetchTodoList,
    })
    
    // However, the following query below will NOT be invalidated
    const todoListQuery = useQuery({
      queryKey: ['todos', { type: 'done' }],
      queryFn: fetchTodoList,
    })
    

If you find yourself wanting **even more** granularity, you can pass a predicate function to the invalidateQueries method. This function will receive each Query instance from the query cache and allow you to return true or false for whether you want to invalidate that query:

    queryClient.invalidateQueries({
      predicate: (query) =>
        query.queryKey[0] === 'todos' && query.queryKey[1]?.version >= 10,
    })
    
    // The query below will be invalidated
    const todoListQuery = useQuery({
      queryKey: ['todos', { version: 20 }],
      queryFn: fetchTodoList,
    })
    
    // The query below will be invalidated
    const todoListQuery = useQuery({
      queryKey: ['todos', { version: 10 }],
      queryFn: fetchTodoList,
    })
    
    // However, the following query below will NOT be invalidated
    const todoListQuery = useQuery({
      queryKey: ['todos', { version: 5 }],
      queryFn: fetchTodoList,
    })
    

    queryClient.invalidateQueries({
      predicate: (query) =>
        query.queryKey[0] === 'todos' && query.queryKey[1]?.version >= 10,
    })
    
    // The query below will be invalidated
    const todoListQuery = useQuery({
      queryKey: ['todos', { version: 20 }],
      queryFn: fetchTodoList,
    })
    
    // The query below will be invalidated
    const todoListQuery = useQuery({
      queryKey: ['todos', { version: 10 }],
      queryFn: fetchTodoList,
    })
    
    // However, the following query below will NOT be invalidated
    const todoListQuery = useQuery({
      queryKey: ['todos', { version: 5 }],
      queryFn: fetchTodoList,
    })</content>
</page>

<page>
  <title>Invalidations from Mutations | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/invalidations-from-mutations</url>
  <content>Invalidating queries is only half the battle. Knowing **when** to invalidate them is the other half. Usually when a mutation in your app succeeds, it's VERY likely that there are related queries in your application that need to be invalidated and possibly refetched to account for the new changes from your mutation.

For example, assume we have a mutation to post a new todo:

    const mutation = useMutation({ mutationFn: postTodo })
    

    const mutation = useMutation({ mutationFn: postTodo })
    

When a successful postTodo mutation happens, we likely want all todos queries to get invalidated and possibly refetched to show the new todo item. To do this, you can use useMutation's onSuccess options and the client's invalidateQueries function:

    import { useMutation, useQueryClient } from '@tanstack/react-query'
    
    const queryClient = useQueryClient()
    
    // When this mutation succeeds, invalidate any queries with the `todos` or `reminders` query key
    const mutation = useMutation({
      mutationFn: addTodo,
      onSuccess: async () => {
        // If you're invalidating a single query
        await queryClient.invalidateQueries({ queryKey: ['todos'] })
    
        // If you're invalidating multiple queries
        await Promise.all([
          queryClient.invalidateQueries({ queryKey: ['todos'] }),
          queryClient.invalidateQueries({ queryKey: ['reminders'] }),
        ])
      },
    })
    

    import { useMutation, useQueryClient } from '@tanstack/react-query'
    
    const queryClient = useQueryClient()
    
    // When this mutation succeeds, invalidate any queries with the `todos` or `reminders` query key
    const mutation = useMutation({
      mutationFn: addTodo,
      onSuccess: async () => {
        // If you're invalidating a single query
        await queryClient.invalidateQueries({ queryKey: ['todos'] })
    
        // If you're invalidating multiple queries
        await Promise.all([
          queryClient.invalidateQueries({ queryKey: ['todos'] }),
          queryClient.invalidateQueries({ queryKey: ['reminders'] }),
        ])
      },
    })
    

Returning a Promise on onSuccess makes sure the data is updated before the mutation is entirely complete (i.e., isPending is true until onSuccess is fulfilled)

You can wire up your invalidations to happen using any of the callbacks available in the [useMutation hook](https://tanstack.com/query/latest/docs/framework/react/guides/mutations)

[](#further-reading)[Further reading](#further-reading)
-------------------------------------------------------

For a technique to automatically invalidate Queries after Mutations, have a look at [TkDodo's article on Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/automatic-query-invalidation-after-mutations).</content>
</page>

<page>
  <title>Placeholder Query Data | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/placeholder-query-data</url>
  <content>[](#what-is-placeholder-data)[What is placeholder data?](#what-is-placeholder-data)
-----------------------------------------------------------------------------------

Placeholder data allows a query to behave as if it already has data, similar to the initialData option, but **the data is not persisted to the cache**. This comes in handy for situations where you have enough partial (or fake) data to render the query successfully while the actual data is fetched in the background.

> Example: An individual blog post query could pull "preview" data from a parent list of blog posts that only include title and a small snippet of the post body. You would not want to persist this partial data to the query result of the individual query, but it is useful for showing the content layout as quickly as possible while the actual query finishes to fetch the entire object.

There are a few ways to supply placeholder data for a query to the cache before you need it:

*   Declaratively:
    *   Provide placeholderData to a query to prepopulate its cache if empty
*   Imperatively:
    *   [Prefetch or fetch the data using queryClient and the placeholderData option](https://tanstack.com/query/latest/docs/framework/react/guides/prefetching)

When we use placeholderData, our Query will not be in a pending state - it will start out as being in success state, because we have data to display - even if that data is just "placeholder" data. To distinguish it from "real" data, we will also have the isPlaceholderData flag set to true on the Query result.

[](#placeholder-data-as-a-value)[Placeholder Data as a Value](#placeholder-data-as-a-value)
-------------------------------------------------------------------------------------------

    function Todos() {
      const result = useQuery({
        queryKey: ['todos'],
        queryFn: () => fetch('/todos'),
        placeholderData: placeholderTodos,
      })
    }
    

    function Todos() {
      const result = useQuery({
        queryKey: ['todos'],
        queryFn: () => fetch('/todos'),
        placeholderData: placeholderTodos,
      })
    }
    

### [](#placeholder-data-memoization)[Placeholder Data Memoization](#placeholder-data-memoization)

If the process for accessing a query's placeholder data is intensive or just not something you want to perform on every render, you can memoize the value:

    function Todos() {
      const placeholderData = useMemo(() => generateFakeTodos(), [])
      const result = useQuery({
        queryKey: ['todos'],
        queryFn: () => fetch('/todos'),
        placeholderData,
      })
    }
    

    function Todos() {
      const placeholderData = useMemo(() => generateFakeTodos(), [])
      const result = useQuery({
        queryKey: ['todos'],
        queryFn: () => fetch('/todos'),
        placeholderData,
      })
    }
    

[](#placeholder-data-as-a-function)[Placeholder Data as a Function](#placeholder-data-as-a-function)
----------------------------------------------------------------------------------------------------

placeholderData can also be a function, where you can get access to the data and Query meta information of a "previous" successful Query. This is useful for situations where you want to use the data from one query as the placeholder data for another query. When the QueryKey changes, e.g. from \['todos', 1\] to \['todos', 2\], we can keep displaying "old" data instead of having to show a loading spinner while data is _transitioning_ from one Query to the next. For more information, see [Paginated Queries](https://tanstack.com/query/latest/docs/framework/react/guides/paginated-queries).

    const result = useQuery({
      queryKey: ['todos', id],
      queryFn: () => fetch(`/todos/${id}`),
      placeholderData: (previousData, previousQuery) => previousData,
    })
    

    const result = useQuery({
      queryKey: ['todos', id],
      queryFn: () => fetch(`/todos/${id}`),
      placeholderData: (previousData, previousQuery) => previousData,
    })
    

### [](#placeholder-data-from-cache)[Placeholder Data from Cache](#placeholder-data-from-cache)

In some circumstances, you may be able to provide the placeholder data for a query from the cached result of another. A good example of this would be searching the cached data from a blog post list query for a preview version of the post, then using that as the placeholder data for your individual post query:

    function BlogPost({ blogPostId }) {
      const queryClient = useQueryClient()
      const result = useQuery({
        queryKey: ['blogPost', blogPostId],
        queryFn: () => fetch(`/blogPosts/${blogPostId}`),
        placeholderData: () => {
          // Use the smaller/preview version of the blogPost from the 'blogPosts'
          // query as the placeholder data for this blogPost query
          return queryClient
            .getQueryData(['blogPosts'])
            ?.find((d) => d.id === blogPostId)
        },
      })
    }
    

    function BlogPost({ blogPostId }) {
      const queryClient = useQueryClient()
      const result = useQuery({
        queryKey: ['blogPost', blogPostId],
        queryFn: () => fetch(`/blogPosts/${blogPostId}`),
        placeholderData: () => {
          // Use the smaller/preview version of the blogPost from the 'blogPosts'
          // query as the placeholder data for this blogPost query
          return queryClient
            .getQueryData(['blogPosts'])
            ?.find((d) => d.id === blogPostId)
        },
      })
    }
    

[](#further-reading)[Further reading](#further-reading)
-------------------------------------------------------

For a comparison between Placeholder Data and Initial Data, see the [article by TkDodo](https://tkdodo.eu/blog/placeholder-and-initial-data-in-react-query).</content>
</page>

<page>
  <title>Query Cancellation | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/query-cancellation</url>
  <content>TanStack Query provides each query function with an [AbortSignal instance](https://developer.mozilla.org/docs/Web/API/AbortSignal). When a query becomes out-of-date or inactive, this signal will become aborted. This means that all queries are cancellable, and you can respond to the cancellation inside your query function if desired. The best part about this is that it allows you to continue to use normal async/await syntax while getting all the benefits of automatic cancellation.

The AbortController API is available in [most runtime environments](https://developer.mozilla.org/docs/Web/API/AbortController#browser_compatibility), but if your runtime environment does not support it, you will need to provide a polyfill. There are [several available](https://www.npmjs.com/search?q=abortcontroller%20polyfill).

[](#default-behavior)[Default behavior](#default-behavior)
----------------------------------------------------------

By default, queries that unmount or become unused before their promises are resolved are _not_ cancelled. This means that after the promise has resolved, the resulting data will be available in the cache. This is helpful if you've started receiving a query, but then unmount the component before it finishes. If you mount the component again and the query has not been garbage collected yet, data will be available.

However, if you consume the AbortSignal, the Promise will be cancelled (e.g. aborting the fetch) and therefore, also the Query must be cancelled. Cancelling the query will result in its state being _reverted_ to its previous state.

[](#using-fetch)[Using fetch](#using-fetch)
-------------------------------------------

    const query = useQuery({
      queryKey: ['todos'],
      queryFn: async ({ signal }) => {
        const todosResponse = await fetch('/todos', {
          // Pass the signal to one fetch
          signal,
        })
        const todos = await todosResponse.json()
    
        const todoDetails = todos.map(async ({ details }) => {
          const response = await fetch(details, {
            // Or pass it to several
            signal,
          })
          return response.json()
        })
    
        return Promise.all(todoDetails)
      },
    })
    

    const query = useQuery({
      queryKey: ['todos'],
      queryFn: async ({ signal }) => {
        const todosResponse = await fetch('/todos', {
          // Pass the signal to one fetch
          signal,
        })
        const todos = await todosResponse.json()
    
        const todoDetails = todos.map(async ({ details }) => {
          const response = await fetch(details, {
            // Or pass it to several
            signal,
          })
          return response.json()
        })
    
        return Promise.all(todoDetails)
      },
    })
    

[](#using-axios-v0220)[Using axios](#using-axios-v0220) [v0.22.0+](https://github.com/axios/axios/releases/tag/v0.22.0)
-----------------------------------------------------------------------------------------------------------------------

    import axios from 'axios'
    
    const query = useQuery({
      queryKey: ['todos'],
      queryFn: ({ signal }) =>
        axios.get('/todos', {
          // Pass the signal to `axios`
          signal,
        }),
    })
    

    import axios from 'axios'
    
    const query = useQuery({
      queryKey: ['todos'],
      queryFn: ({ signal }) =>
        axios.get('/todos', {
          // Pass the signal to `axios`
          signal,
        }),
    })
    

### [](#using-axios-with-version-lower-than-v0220)[Using axios with version lower than v0.22.0](#using-axios-with-version-lower-than-v0220)

    import axios from 'axios'
    
    const query = useQuery({
      queryKey: ['todos'],
      queryFn: ({ signal }) => {
        // Create a new CancelToken source for this request
        const CancelToken = axios.CancelToken
        const source = CancelToken.source()
    
        const promise = axios.get('/todos', {
          // Pass the source token to your request
          cancelToken: source.token,
        })
    
        // Cancel the request if TanStack Query signals to abort
        signal?.addEventListener('abort', () => {
          source.cancel('Query was cancelled by TanStack Query')
        })
    
        return promise
      },
    })
    

    import axios from 'axios'
    
    const query = useQuery({
      queryKey: ['todos'],
      queryFn: ({ signal }) => {
        // Create a new CancelToken source for this request
        const CancelToken = axios.CancelToken
        const source = CancelToken.source()
    
        const promise = axios.get('/todos', {
          // Pass the source token to your request
          cancelToken: source.token,
        })
    
        // Cancel the request if TanStack Query signals to abort
        signal?.addEventListener('abort', () => {
          source.cancel('Query was cancelled by TanStack Query')
        })
    
        return promise
      },
    })
    

[](#using-xmlhttprequest)[Using XMLHttpRequest](#using-xmlhttprequest)
----------------------------------------------------------------------

    const query = useQuery({
      queryKey: ['todos'],
      queryFn: ({ signal }) => {
        return new Promise((resolve, reject) => {
          var oReq = new XMLHttpRequest()
          oReq.addEventListener('load', () => {
            resolve(JSON.parse(oReq.responseText))
          })
          signal?.addEventListener('abort', () => {
            oReq.abort()
            reject()
          })
          oReq.open('GET', '/todos')
          oReq.send()
        })
      },
    })
    

    const query = useQuery({
      queryKey: ['todos'],
      queryFn: ({ signal }) => {
        return new Promise((resolve, reject) => {
          var oReq = new XMLHttpRequest()
          oReq.addEventListener('load', () => {
            resolve(JSON.parse(oReq.responseText))
          })
          signal?.addEventListener('abort', () => {
            oReq.abort()
            reject()
          })
          oReq.open('GET', '/todos')
          oReq.send()
        })
      },
    })
    

[](#using-graphql-request)[Using graphql-request](#using-graphql-request)
-------------------------------------------------------------------------

An AbortSignal can be set in the client request method.

    const client = new GraphQLClient(endpoint)
    
    const query = useQuery({
      queryKey: ['todos'],
      queryFn: ({ signal }) => {
        client.request({ document: query, signal })
      },
    })
    

    const client = new GraphQLClient(endpoint)
    
    const query = useQuery({
      queryKey: ['todos'],
      queryFn: ({ signal }) => {
        client.request({ document: query, signal })
      },
    })
    

[](#using-graphql-request-with-version-lower-than-v400)[Using graphql-request with version lower than v4.0.0](#using-graphql-request-with-version-lower-than-v400)
------------------------------------------------------------------------------------------------------------------------------------------------------------------

An AbortSignal can be set in the GraphQLClient constructor.

    const query = useQuery({
      queryKey: ['todos'],
      queryFn: ({ signal }) => {
        const client = new GraphQLClient(endpoint, {
          signal,
        })
        return client.request(query, variables)
      },
    })
    

    const query = useQuery({
      queryKey: ['todos'],
      queryFn: ({ signal }) => {
        const client = new GraphQLClient(endpoint, {
          signal,
        })
        return client.request(query, variables)
      },
    })
    

[](#manual-cancellation)[Manual Cancellation](#manual-cancellation)
-------------------------------------------------------------------

You might want to cancel a query manually. For example, if the request takes a long time to finish, you can allow the user to click a cancel button to stop the request. To do this, you just need to call queryClient.cancelQueries({ queryKey }), which will cancel the query and revert it back to its previous state. If you have consumed the signal passed to the query function, TanStack Query will additionally also cancel the Promise.

    const query = useQuery({
      queryKey: ['todos'],
      queryFn: async ({ signal }) => {
        const resp = await fetch('/todos', { signal })
        return resp.json()
      },
    })
    
    const queryClient = useQueryClient()
    
    return (
      <button
        onClick={(e) => {
          e.preventDefault()
          queryClient.cancelQueries({ queryKey: ['todos'] })
        }}
      >
        Cancel
      </button>
    )
    

    const query = useQuery({
      queryKey: ['todos'],
      queryFn: async ({ signal }) => {
        const resp = await fetch('/todos', { signal })
        return resp.json()
      },
    })
    
    const queryClient = useQueryClient()
    
    return (
      <button
        onClick={(e) => {
          e.preventDefault()
          queryClient.cancelQueries({ queryKey: ['todos'] })
        }}
      >
        Cancel
      </button>
    )
    

[](#cancel-options)[Cancel Options](#cancel-options)
----------------------------------------------------

Cancel options are used to control the behavior of query cancellation operations.

    // Cancel specific queries silently
    await queryClient.cancelQueries({ queryKey: ['posts'] }, { silent: true })
    

    // Cancel specific queries silently
    await queryClient.cancelQueries({ queryKey: ['posts'] }, { silent: true })
    

A cancel options object supports the following properties:

*   silent?: boolean
    *   When set to true, suppresses propagation of CancelledError to observers (e.g., onError callbacks) and related notifications, and returns the retry promise instead of rejecting.
    *   Defaults to false
*   revert?: boolean
    *   When set to true, restores the query‚Äôs state (data and status) from immediately before the in-flight fetch, sets fetchStatus back to idle, and only throws if there was no prior data.
    *   Defaults to true

[](#limitations)[Limitations](#limitations)
-------------------------------------------

Cancellation does not work when working with Suspense hooks: useSuspenseQuery, useSuspenseQueries and useSuspenseInfiniteQuery.</content>
</page>

<page>
  <title>Scroll Restoration | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/scroll-restoration</url>
  <content>Traditionally, when you navigate to a previously visited page on a web browser, you would find that the page would be scrolled to the exact position where you were before you navigated away from that page. This is called **scroll restoration** and has been in a bit of a regression since web applications have started moving towards client side data fetching. With TanStack Query however, that's no longer the case.

Out of the box, "scroll restoration" for all queries (including paginated and infinite queries) Just Works‚Ñ¢Ô∏è in TanStack Query. The reason for this is that query results are cached and able to be retrieved synchronously when a query is rendered. As long as your queries are being cached long enough (the default time is 5 minutes) and have not been garbage collected, scroll restoration will work out of the box all the time.</content>
</page>

<page>
  <title>Updates from Mutation Responses | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/updates-from-mutation-responses</url>
  <content>When dealing with mutations that **update** objects on the server, it's common for the new object to be automatically returned in the response of the mutation. Instead of refetching any queries for that item and wasting a network call for data we already have, we can take advantage of the object returned by the mutation function and update the existing query with the new data immediately using the [Query Client's setQueryData](https://tanstack.com/query/latest/docs/reference/QueryClient#queryclientsetquerydata) method:

    const queryClient = useQueryClient()
    
    const mutation = useMutation({
      mutationFn: editTodo,
      onSuccess: (data) => {
        queryClient.setQueryData(['todo', { id: 5 }], data)
      },
    })
    
    mutation.mutate({
      id: 5,
      name: 'Do the laundry',
    })
    
    // The query below will be updated with the response from the
    // successful mutation
    const { status, data, error } = useQuery({
      queryKey: ['todo', { id: 5 }],
      queryFn: fetchTodoById,
    })
    

    const queryClient = useQueryClient()
    
    const mutation = useMutation({
      mutationFn: editTodo,
      onSuccess: (data) => {
        queryClient.setQueryData(['todo', { id: 5 }], data)
      },
    })
    
    mutation.mutate({
      id: 5,
      name: 'Do the laundry',
    })
    
    // The query below will be updated with the response from the
    // successful mutation
    const { status, data, error } = useQuery({
      queryKey: ['todo', { id: 5 }],
      queryFn: fetchTodoById,
    })
    

You might want to tie the onSuccess logic into a reusable mutation, for that you can create a custom hook like this:

    const useMutateTodo = () => {
      const queryClient = useQueryClient()
    
      return useMutation({
        mutationFn: editTodo,
        // Notice the second argument is the variables object that the `mutate` function receives
        onSuccess: (data, variables) => {
          queryClient.setQueryData(['todo', { id: variables.id }], data)
        },
      })
    }
    

    const useMutateTodo = () => {
      const queryClient = useQueryClient()
    
      return useMutation({
        mutationFn: editTodo,
        // Notice the second argument is the variables object that the `mutate` function receives
        onSuccess: (data, variables) => {
          queryClient.setQueryData(['todo', { id: variables.id }], data)
        },
      })
    }
    

[](#immutability)[Immutability](#immutability)
----------------------------------------------

Updates via setQueryData must be performed in an _immutable_ way. **DO NOT** attempt to write directly to the cache by mutating data (that you retrieved from the cache) in place. It might work at first but can lead to subtle bugs along the way.

    queryClient.setQueryData(['posts', { id }], (oldData) => {
      if (oldData) {
        // ‚ùå do not try this
        oldData.title = 'my new post title'
      }
      return oldData
    })
    
    queryClient.setQueryData(
      ['posts', { id }],
      // ‚úÖ this is the way
      (oldData) =>
        oldData
          ? {
              ...oldData,
              title: 'my new post title',
            }
          : oldData,
    )
    

    queryClient.setQueryData(['posts', { id }], (oldData) => {
      if (oldData) {
        // ‚ùå do not try this
        oldData.title = 'my new post title'
      }
      return oldData
    })
    
    queryClient.setQueryData(
      ['posts', { id }],
      // ‚úÖ this is the way
      (oldData) =>
        oldData
          ? {
              ...oldData,
              title: 'my new post title',
            }
          : oldData,
    )</content>
</page>

<page>
  <title>Optimistic Updates | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/optimistic-updates</url>
  <content>React Query provides two ways to optimistically update your UI before a mutation has completed. You can either use the onMutate option to update your cache directly, or leverage the returned variables to update your UI from the useMutation result.

[](#via-the-ui)[Via the UI](#via-the-ui)
----------------------------------------

This is the simpler variant, as it doesn't interact with the cache directly.

    const addTodoMutation = useMutation({
      mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
      // make sure to _return_ the Promise from the query invalidation
      // so that the mutation stays in `pending` state until the refetch is finished
      onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
    })
    
    const { isPending, submittedAt, variables, mutate, isError } = addTodoMutation
    

    const addTodoMutation = useMutation({
      mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
      // make sure to _return_ the Promise from the query invalidation
      // so that the mutation stays in `pending` state until the refetch is finished
      onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
    })
    
    const { isPending, submittedAt, variables, mutate, isError } = addTodoMutation
    

you will then have access to addTodoMutation.variables, which contain the added todo. In your UI list, where the query is rendered, you can append another item to the list while the mutation isPending:

    <ul>
      {todoQuery.items.map((todo) => (
        <li key={todo.id}>{todo.text}</li>
      ))}
      {isPending && <li style={{ opacity: 0.5 }}>{variables}</li>}
    </ul>
    

    <ul>
      {todoQuery.items.map((todo) => (
        <li key={todo.id}>{todo.text}</li>
      ))}
      {isPending && <li style={{ opacity: 0.5 }}>{variables}</li>}
    </ul>
    

We're rendering a temporary item with a different opacity as long as the mutation is pending. Once it completes, the item will automatically no longer be rendered. Given that the refetch succeeded, we should see the item as a "normal item" in our list.

If the mutation errors, the item will also disappear. But we could continue to show it, if we want, by checking for the isError state of the mutation. variables are _not_ cleared when the mutation errors, so we can still access them, maybe even show a retry button:

    {
      isError && (
        <li style={{ color: 'red' }}>
          {variables}
          <button onClick={() => mutate(variables)}>Retry</button>
        </li>
      )
    }
    

    {
      isError && (
        <li style={{ color: 'red' }}>
          {variables}
          <button onClick={() => mutate(variables)}>Retry</button>
        </li>
      )
    }
    

### [](#if-the-mutation-and-the-query-dont-live-in-the-same-component)[If the mutation and the query don't live in the same component](#if-the-mutation-and-the-query-dont-live-in-the-same-component)

This approach works very well if the mutation and the query live in the same component. However, you also get access to all mutations in other components via the dedicated useMutationState hook. It is best combined with a mutationKey:

    // somewhere in your app
    const { mutate } = useMutation({
      mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
      onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
      mutationKey: ['addTodo'],
    })
    
    // access variables somewhere else
    const variables = useMutationState<string>({
      filters: { mutationKey: ['addTodo'], status: 'pending' },
      select: (mutation) => mutation.state.variables,
    })
    

    // somewhere in your app
    const { mutate } = useMutation({
      mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
      onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
      mutationKey: ['addTodo'],
    })
    
    // access variables somewhere else
    const variables = useMutationState<string>({
      filters: { mutationKey: ['addTodo'], status: 'pending' },
      select: (mutation) => mutation.state.variables,
    })
    

variables will be an Array, because there might be multiple mutations running at the same time. If we need a unique key for the items, we can also select mutation.state.submittedAt. This will even make displaying concurrent optimistic updates a breeze.

[](#via-the-cache)[Via the cache](#via-the-cache)
-------------------------------------------------

When you optimistically update your state before performing a mutation, there is a chance that the mutation will fail. In most of these failure cases, you can just trigger a refetch for your optimistic queries to revert them to their true server state. In some circumstances though, refetching may not work correctly and the mutation error could represent some type of server issue that won't make it possible to refetch. In this event, you can instead choose to roll back your update.

To do this, useMutation's onMutate handler option allows you to return a value that will later be passed to both onError and onSettled handlers as the last argument. In most cases, it is most useful to pass a rollback function.

### [](#updating-a-list-of-todos-when-adding-a-new-todo)[Updating a list of todos when adding a new todo](#updating-a-list-of-todos-when-adding-a-new-todo)

    const queryClient = useQueryClient()
    
    useMutation({
      mutationFn: updateTodo,
      // When mutate is called:
      onMutate: async (newTodo, context) => {
        // Cancel any outgoing refetches
        // (so they don't overwrite our optimistic update)
        await context.client.cancelQueries({ queryKey: ['todos'] })
    
        // Snapshot the previous value
        const previousTodos = context.client.getQueryData(['todos'])
    
        // Optimistically update to the new value
        context.client.setQueryData(['todos'], (old) => [...old, newTodo])
    
        // Return a result with the snapshotted value
        return { previousTodos }
      },
      // If the mutation fails,
      // use the result returned from onMutate to roll back
      onError: (err, newTodo, onMutateResult, context) => {
        context.client.setQueryData(['todos'], onMutateResult.previousTodos)
      },
      // Always refetch after error or success:
      onSettled: (data, error, variables, onMutateResult, context) =>
        context.client.invalidateQueries({ queryKey: ['todos'] }),
    })
    

    const queryClient = useQueryClient()
    
    useMutation({
      mutationFn: updateTodo,
      // When mutate is called:
      onMutate: async (newTodo, context) => {
        // Cancel any outgoing refetches
        // (so they don't overwrite our optimistic update)
        await context.client.cancelQueries({ queryKey: ['todos'] })
    
        // Snapshot the previous value
        const previousTodos = context.client.getQueryData(['todos'])
    
        // Optimistically update to the new value
        context.client.setQueryData(['todos'], (old) => [...old, newTodo])
    
        // Return a result with the snapshotted value
        return { previousTodos }
      },
      // If the mutation fails,
      // use the result returned from onMutate to roll back
      onError: (err, newTodo, onMutateResult, context) => {
        context.client.setQueryData(['todos'], onMutateResult.previousTodos)
      },
      // Always refetch after error or success:
      onSettled: (data, error, variables, onMutateResult, context) =>
        context.client.invalidateQueries({ queryKey: ['todos'] }),
    })
    

### [](#updating-a-single-todo)[Updating a single todo](#updating-a-single-todo)

    useMutation({
      mutationFn: updateTodo,
      // When mutate is called:
      onMutate: async (newTodo, context) => {
        // Cancel any outgoing refetches
        // (so they don't overwrite our optimistic update)
        await context.client.cancelQueries({ queryKey: ['todos', newTodo.id] })
    
        // Snapshot the previous value
        const previousTodo = context.client.getQueryData(['todos', newTodo.id])
    
        // Optimistically update to the new value
        context.client.setQueryData(['todos', newTodo.id], newTodo)
    
        // Return a result with the previous and new todo
        return { previousTodo, newTodo }
      },
      // If the mutation fails, use the result we returned above
      onError: (err, newTodo, onMutateResult, context) => {
        context.client.setQueryData(
          ['todos', onMutateResult.newTodo.id],
          onMutateResult.previousTodo,
        )
      },
      // Always refetch after error or success:
      onSettled: (newTodo, error, variables, onMutateResult, context) =>
        context.client.invalidateQueries({ queryKey: ['todos', newTodo.id] }),
    })
    

    useMutation({
      mutationFn: updateTodo,
      // When mutate is called:
      onMutate: async (newTodo, context) => {
        // Cancel any outgoing refetches
        // (so they don't overwrite our optimistic update)
        await context.client.cancelQueries({ queryKey: ['todos', newTodo.id] })
    
        // Snapshot the previous value
        const previousTodo = context.client.getQueryData(['todos', newTodo.id])
    
        // Optimistically update to the new value
        context.client.setQueryData(['todos', newTodo.id], newTodo)
    
        // Return a result with the previous and new todo
        return { previousTodo, newTodo }
      },
      // If the mutation fails, use the result we returned above
      onError: (err, newTodo, onMutateResult, context) => {
        context.client.setQueryData(
          ['todos', onMutateResult.newTodo.id],
          onMutateResult.previousTodo,
        )
      },
      // Always refetch after error or success:
      onSettled: (newTodo, error, variables, onMutateResult, context) =>
        context.client.invalidateQueries({ queryKey: ['todos', newTodo.id] }),
    })
    

You can also use the onSettled function in place of the separate onError and onSuccess handlers if you wish:

    useMutation({
      mutationFn: updateTodo,
      // ...
      onSettled: async (newTodo, error, variables, onMutateResult, context) => {
        if (error) {
          // do something
        }
      },
    })
    

    useMutation({
      mutationFn: updateTodo,
      // ...
      onSettled: async (newTodo, error, variables, onMutateResult, context) => {
        if (error) {
          // do something
        }
      },
    })
    

[](#when-to-use-what)[When to use what](#when-to-use-what)
----------------------------------------------------------

If you only have one place where the optimistic result should be shown, using variables and updating the UI directly is the approach that requires less code and is generally easier to reason about. For example, you don't need to handle rollbacks at all.

However, if you have multiple places on the screen that would require to know about the update, manipulating the cache directly will take care of this for you automatically.

[](#further-reading)[Further reading](#further-reading)
-------------------------------------------------------

Have a look at the guide by TkDodo on [Concurrent Optimistic Updates](https://tkdodo.eu/blog/concurrent-optimistic-updates-in-react-query).</content>
</page>

<page>
  <title>Filters | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/filters</url>
  <content>Some methods within TanStack Query accept a QueryFilters or MutationFilters object.

[](#query-filters)[Query Filters](#query-filters)
-------------------------------------------------

A query filter is an object with certain conditions to match a query with:

    // Cancel all queries
    await queryClient.cancelQueries()
    
    // Remove all inactive queries that begin with `posts` in the key
    queryClient.removeQueries({ queryKey: ['posts'], type: 'inactive' })
    
    // Refetch all active queries
    await queryClient.refetchQueries({ type: 'active' })
    
    // Refetch all active queries that begin with `posts` in the key
    await queryClient.refetchQueries({ queryKey: ['posts'], type: 'active' })
    

    // Cancel all queries
    await queryClient.cancelQueries()
    
    // Remove all inactive queries that begin with `posts` in the key
    queryClient.removeQueries({ queryKey: ['posts'], type: 'inactive' })
    
    // Refetch all active queries
    await queryClient.refetchQueries({ type: 'active' })
    
    // Refetch all active queries that begin with `posts` in the key
    await queryClient.refetchQueries({ queryKey: ['posts'], type: 'active' })
    

A query filter object supports the following properties:

*   queryKey?: QueryKey
    *   Set this property to define a query key to match on.
*   exact?: boolean
    *   If you don't want to search queries inclusively by query key, you can pass the exact: true option to return only the query with the exact query key you have passed.
*   type?: 'active' | 'inactive' | 'all'
    *   Defaults to all
    *   When set to active it will match active queries.
    *   When set to inactive it will match inactive queries.
*   stale?: boolean
    *   When set to true it will match stale queries.
    *   When set to false it will match fresh queries.
*   fetchStatus?: FetchStatus
    *   When set to fetching it will match queries that are currently fetching.
    *   When set to paused it will match queries that wanted to fetch, but have been paused.
    *   When set to idle it will match queries that are not fetching.
*   predicate?: (query: Query) => boolean
    *   This predicate function will be used as a final filter on all matching queries. If no other filters are specified, this function will be evaluated against every query in the cache.

[](#mutation-filters)[Mutation Filters](#mutation-filters)
----------------------------------------------------------

A mutation filter is an object with certain conditions to match a mutation with:

    // Get the number of all fetching mutations
    await queryClient.isMutating()
    
    // Filter mutations by mutationKey
    await queryClient.isMutating({ mutationKey: ['post'] })
    
    // Filter mutations using a predicate function
    await queryClient.isMutating({
      predicate: (mutation) => mutation.state.variables?.id === 1,
    })
    

    // Get the number of all fetching mutations
    await queryClient.isMutating()
    
    // Filter mutations by mutationKey
    await queryClient.isMutating({ mutationKey: ['post'] })
    
    // Filter mutations using a predicate function
    await queryClient.isMutating({
      predicate: (mutation) => mutation.state.variables?.id === 1,
    })
    

A mutation filter object supports the following properties:

*   mutationKey?: MutationKey
    *   Set this property to define a mutation key to match on.
*   exact?: boolean
    *   If you don't want to search mutations inclusively by mutation key, you can pass the exact: true option to return only the mutation with the exact mutation key you have passed.
*   status?: MutationStatus
    *   Allows for filtering mutations according to their status.
*   predicate?: (mutation: Mutation) => boolean
    *   This predicate function will be used as a final filter on all matching mutations. If no other filters are specified, this function will be evaluated against every mutation in the cache.

[](#utils)[Utils](#utils)
-------------------------

### [](#matchquery)[matchQuery](#matchquery)

    const isMatching = matchQuery(filters, query)
    

    const isMatching = matchQuery(filters, query)
    

Returns a boolean that indicates whether a query matches the provided set of query filters.

### [](#matchmutation)[matchMutation](#matchmutation)

    const isMatching = matchMutation(filters, mutation)
    

    const isMatching = matchMutation(filters, mutation)
    

Returns a boolean that indicates whether a mutation matches the provided set of mutation filters.</content>
</page>

<page>
  <title>Performance & Request Waterfalls | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/request-waterfalls</url>
  <content>Application performance is a broad and complex area and while React Query can't make your APIs faster, there are still things to be mindful about in how you use React Query to ensure the best performance.

The biggest performance footgun when using React Query, or indeed any data fetching library that lets you fetch data inside of components, is request waterfalls. The rest of this page will explain what they are, how you can spot them and how you can restructure your application or APIs to avoid them.

The [Prefetching & Router Integration guide](https://tanstack.com/query/latest/docs/framework/react/guides/prefetching) builds on this and teaches you how to prefetch data ahead of time when it's not possible or feasible to restructure your application or APIs.

The [Server Rendering & Hydration guide](https://tanstack.com/query/latest/docs/framework/react/guides/ssr) teaches you how to prefetch data on the server and pass that data down to the client so you don't have to fetch it again.

The [Advanced Server Rendering guide](https://tanstack.com/query/latest/docs/framework/react/guides/advanced-ssr) further teaches you how to apply these patterns to Server Components and Streaming Server Rendering.

[](#what-is-a-request-waterfall)[What is a Request Waterfall?](#what-is-a-request-waterfall)
--------------------------------------------------------------------------------------------

A request waterfall is what happens when a request for a resource (code, css, images, data) does not start until _after_ another request for a resource has finished.

Consider a web page. Before you can load things like the CSS, JS etc, the browser first needs to load the markup. This is a request waterfall.

    1. |-> Markup
    2.   |-> CSS
    2.   |-> JS
    2.   |-> Image
    

    1. |-> Markup
    2.   |-> CSS
    2.   |-> JS
    2.   |-> Image
    

If you fetch your CSS inside a JS file, you now have a double waterfall:

    1. |-> Markup
    2.   |-> JS
    3.     |-> CSS
    

    1. |-> Markup
    2.   |-> JS
    3.     |-> CSS
    

If that CSS uses a background image, it's a triple waterfall:

    1. |-> Markup
    2.   |-> JS
    3.     |-> CSS
    4.       |-> Image
    

    1. |-> Markup
    2.   |-> JS
    3.     |-> CSS
    4.       |-> Image
    

The best way to spot and analyze your request waterfalls is usually by opening your browsers devtools "Network" tab.

Each waterfall represents at least one roundtrip to the server, unless the resource is locally cached (in practice, some of these waterfalls might represent more than one roundtrip because the browser needs to establish a connection which requires some back and forth, but let's ignore that here). Because of this, the negative effects of request waterfalls are highly dependent on the users latency. Consider the example of the triple waterfall, which actually represents 4 server roundtrips. With 250ms latency, which is not uncommon on 3g networks or in bad network conditions, we end up with a total time of 4\*250=1000ms **only counting latency**. If we were able to flatten that to the first example with only 2 roundtrips, we get 500ms instead, possibly loading that background image in half the time!

[](#request-waterfalls--react-query)[Request Waterfalls & React Query](#request-waterfalls--react-query)
--------------------------------------------------------------------------------------------------------

Now let's consider React Query. We'll focus on the case without Server Rendering first. Before we can even start making a query, we need to load the JS, so before we can show that data on the screen, we have a double waterfall:

    1. |-> Markup
    2.   |-> JS
    3.     |-> Query
    

    1. |-> Markup
    2.   |-> JS
    3.     |-> Query
    

With this as a basis, let's look at a few different patterns that can lead to Request Waterfalls in React Query, and how to avoid them.

*   Single Component Waterfalls / Serial Queries
*   Nested Component Waterfalls
*   Code Splitting

### [](#single-component-waterfalls--serial-queries)[Single Component Waterfalls / Serial Queries](#single-component-waterfalls--serial-queries)

When a single component first fetches one query, and then another, that's a request waterfall. This can happen when the second query is a [Dependent Query](https://tanstack.com/query/latest/docs/framework/react/guides/dependent-queries), that is, it depends on data from the first query when fetching:

    // Get the user
    const { data: user } = useQuery({
      queryKey: ['user', email],
      queryFn: getUserByEmail,
    })
    
    const userId = user?.id
    
    // Then get the user's projects
    const {
      status,
      fetchStatus,
      data: projects,
    } = useQuery({
      queryKey: ['projects', userId],
      queryFn: getProjectsByUser,
      // The query will not execute until the userId exists
      enabled: !!userId,
    })
    

    // Get the user
    const { data: user } = useQuery({
      queryKey: ['user', email],
      queryFn: getUserByEmail,
    })
    
    const userId = user?.id
    
    // Then get the user's projects
    const {
      status,
      fetchStatus,
      data: projects,
    } = useQuery({
      queryKey: ['projects', userId],
      queryFn: getProjectsByUser,
      // The query will not execute until the userId exists
      enabled: !!userId,
    })
    

While not always feasible, for optimal performance it's better to restructure your API so you can fetch both of these in a single query. In the example above, instead of first fetching getUserByEmail to be able to getProjectsByUser, introducing a new getProjectsByUserEmail query would flatten the waterfall.

> Another way to mitigate dependent queries without restructuring your API is to move the waterfall to the server where latency is lower. This is the idea behind Server Components which are covered in the [Advanced Server Rendering guide](https://tanstack.com/query/latest/docs/framework/react/guides/advanced-ssr).

Another example of serial queries is when you use React Query with Suspense:

    function App () {
      // The following queries will execute in serial, causing separate roundtrips to the server:
      const usersQuery = useSuspenseQuery({ queryKey: ['users'], queryFn: fetchUsers })
      const teamsQuery = useSuspenseQuery({ queryKey: ['teams'], queryFn: fetchTeams })
      const projectsQuery = useSuspenseQuery({ queryKey: ['projects'], queryFn: fetchProjects })
    
      // Note that since the queries above suspend rendering, no data
      // gets rendered until all of the queries finished
      ...
    }
    

    function App () {
      // The following queries will execute in serial, causing separate roundtrips to the server:
      const usersQuery = useSuspenseQuery({ queryKey: ['users'], queryFn: fetchUsers })
      const teamsQuery = useSuspenseQuery({ queryKey: ['teams'], queryFn: fetchTeams })
      const projectsQuery = useSuspenseQuery({ queryKey: ['projects'], queryFn: fetchProjects })
    
      // Note that since the queries above suspend rendering, no data
      // gets rendered until all of the queries finished
      ...
    }
    

Note that with regular useQuery these would happen in parallel.

Luckily, this is easy to fix, by always using the hook useSuspenseQueries when you have multiple suspenseful queries in a component.

    const [usersQuery, teamsQuery, projectsQuery] = useSuspenseQueries({
      queries: [
        { queryKey: ['users'], queryFn: fetchUsers },
        { queryKey: ['teams'], queryFn: fetchTeams },
        { queryKey: ['projects'], queryFn: fetchProjects },
      ],
    })
    

    const [usersQuery, teamsQuery, projectsQuery] = useSuspenseQueries({
      queries: [
        { queryKey: ['users'], queryFn: fetchUsers },
        { queryKey: ['teams'], queryFn: fetchTeams },
        { queryKey: ['projects'], queryFn: fetchProjects },
      ],
    })
    

### [](#nested-component-waterfalls)[Nested Component Waterfalls](#nested-component-waterfalls)

Nested Component Waterfalls is when both a parent and a child component contains queries, and the parent does not render the child until its query is done. This can happen both with useQuery and useSuspenseQuery.

If the child renders conditionally based on the data in the parent, or if the child relies on some part of the result being passed down as a prop from the parent to make its query, we have a _dependent_ nested component waterfall.

Let's first look at an example where the child is **not** dependent on the parent.

    function Article({ id }) {
      const { data: articleData, isPending } = useQuery({
        queryKey: ['article', id],
        queryFn: getArticleById,
      })
    
      if (isPending) {
        return 'Loading article...'
      }
    
      return (
        <>
          <ArticleHeader articleData={articleData} />
          <ArticleBody articleData={articleData} />
          <Comments id={id} />
        </>
      )
    
    }
    
    function Comments({ id }) {
      const { data, isPending } = useQuery({
        queryKey: ['article-comments', id],
        queryFn: getArticleCommentsById,
      })
    
      ...
    }
    

    function Article({ id }) {
      const { data: articleData, isPending } = useQuery({
        queryKey: ['article', id],
        queryFn: getArticleById,
      })
    
      if (isPending) {
        return 'Loading article...'
      }
    
      return (
        <>
          <ArticleHeader articleData={articleData} />
          <ArticleBody articleData={articleData} />
          <Comments id={id} />
        </>
      )
    
    }
    
    function Comments({ id }) {
      const { data, isPending } = useQuery({
        queryKey: ['article-comments', id],
        queryFn: getArticleCommentsById,
      })
    
      ...
    }
    

Note that while <Comments> takes a prop id from the parent, that id is already available when the <Article> renders so there is no reason we could not fetch the comments at the same time as the article. In real world applications, the child might be nested far below the parent and these kinds of waterfalls are often trickier to spot and fix, but for our example, one way to flatten the waterfall would be to hoist the comments query to the parent instead:

    function Article({ id }) {
      const { data: articleData, isPending: articlePending } = useQuery({
        queryKey: ['article', id],
        queryFn: getArticleById,
      })
    
      const { data: commentsData, isPending: commentsPending } = useQuery({
        queryKey: ['article-comments', id],
        queryFn: getArticleCommentsById,
      })
    
      if (articlePending) {
        return 'Loading article...'
      }
    
      return (
        <>
          <ArticleHeader articleData={articleData} />
          <ArticleBody articleData={articleData} />
          {commentsPending ? (
            'Loading comments...'
          ) : (
            <Comments commentsData={commentsData} />
          )}
        </>
      )
    }
    

    function Article({ id }) {
      const { data: articleData, isPending: articlePending } = useQuery({
        queryKey: ['article', id],
        queryFn: getArticleById,
      })
    
      const { data: commentsData, isPending: commentsPending } = useQuery({
        queryKey: ['article-comments', id],
        queryFn: getArticleCommentsById,
      })
    
      if (articlePending) {
        return 'Loading article...'
      }
    
      return (
        <>
          <ArticleHeader articleData={articleData} />
          <ArticleBody articleData={articleData} />
          {commentsPending ? (
            'Loading comments...'
          ) : (
            <Comments commentsData={commentsData} />
          )}
        </>
      )
    }
    

The two queries will now fetch in parallel. Note that if you are using suspense, you'd want to combine these two queries into a single useSuspenseQueries instead.

Another way to flatten this waterfall would be to prefetch the comments in the <Article> component, or prefetch both of these queries at the router level on page load or page navigation, read more about this in the [Prefetching & Router Integration guide](https://tanstack.com/query/latest/docs/framework/react/guides/prefetching).

Next, let's look at a _Dependent Nested Component Waterfall_.

    function Feed() {
      const { data, isPending } = useQuery({
        queryKey: ['feed'],
        queryFn: getFeed,
      })
    
      if (isPending) {
        return 'Loading feed...'
      }
    
      return (
        <>
          {data.map((feedItem) => {
            if (feedItem.type === 'GRAPH') {
              return <GraphFeedItem key={feedItem.id} feedItem={feedItem} />
            }
    
            return <StandardFeedItem key={feedItem.id} feedItem={feedItem} />
          })}
        </>
      )
    }
    
    function GraphFeedItem({ feedItem }) {
      const { data, isPending } = useQuery({
        queryKey: ['graph', feedItem.id],
        queryFn: getGraphDataById,
      })
    
      ...
    }
    

    function Feed() {
      const { data, isPending } = useQuery({
        queryKey: ['feed'],
        queryFn: getFeed,
      })
    
      if (isPending) {
        return 'Loading feed...'
      }
    
      return (
        <>
          {data.map((feedItem) => {
            if (feedItem.type === 'GRAPH') {
              return <GraphFeedItem key={feedItem.id} feedItem={feedItem} />
            }
    
            return <StandardFeedItem key={feedItem.id} feedItem={feedItem} />
          })}
        </>
      )
    }
    
    function GraphFeedItem({ feedItem }) {
      const { data, isPending } = useQuery({
        queryKey: ['graph', feedItem.id],
        queryFn: getGraphDataById,
      })
    
      ...
    }
    

The second query getGraphDataById is dependent on its parent in two different ways. First of all, it doesn't ever happen unless the feedItem is a graph, and second, it needs an id from the parent.

    1. |> getFeed()
    2.   |> getGraphDataById()
    

    1. |> getFeed()
    2.   |> getGraphDataById()
    

In this example, we can't trivially flatten the waterfall by just hoisting the query to the parent, or even adding prefetching. Just like the dependent query example at the beginning of this guide, one option is to refactor our API to include the graph data in the getFeed query. Another more advanced solution is to leverage Server Components to move the waterfall to the server where latency is lower (read more about this in the [Advanced Server Rendering guide](https://tanstack.com/query/latest/docs/framework/react/guides/advanced-ssr)) but note that this can be a very big architectural change.

You can have good performance even with a few query waterfalls here and there, just know they are a common performance concern and be mindful about them. An especially insidious version is when Code Splitting is involved, let's take a look at this next.

### [](#code-splitting)[Code Splitting](#code-splitting)

Splitting an applications JS-code into smaller chunks and only loading the necessary parts is usually a critical step in achieving good performance. It does have a downside however, in that it often introduces request waterfalls. When that code split code also has a query inside it, this problem is worsened further.

Consider this a slightly modified version of the Feed example.

    // This lazy loads the GraphFeedItem component, meaning
    // it wont start loading until something renders it
    const GraphFeedItem = React.lazy(() => import('./GraphFeedItem'))
    
    function Feed() {
      const { data, isPending } = useQuery({
        queryKey: ['feed'],
        queryFn: getFeed,
      })
    
      if (isPending) {
        return 'Loading feed...'
      }
    
      return (
        <>
          {data.map((feedItem) => {
            if (feedItem.type === 'GRAPH') {
              return <GraphFeedItem key={feedItem.id} feedItem={feedItem} />
            }
    
            return <StandardFeedItem key={feedItem.id} feedItem={feedItem} />
          })}
        </>
      )
    }
    
    // GraphFeedItem.tsx
    function GraphFeedItem({ feedItem }) {
      const { data, isPending } = useQuery({
        queryKey: ['graph', feedItem.id],
        queryFn: getGraphDataById,
      })
    
      ...
    }
    

    // This lazy loads the GraphFeedItem component, meaning
    // it wont start loading until something renders it
    const GraphFeedItem = React.lazy(() => import('./GraphFeedItem'))
    
    function Feed() {
      const { data, isPending } = useQuery({
        queryKey: ['feed'],
        queryFn: getFeed,
      })
    
      if (isPending) {
        return 'Loading feed...'
      }
    
      return (
        <>
          {data.map((feedItem) => {
            if (feedItem.type === 'GRAPH') {
              return <GraphFeedItem key={feedItem.id} feedItem={feedItem} />
            }
    
            return <StandardFeedItem key={feedItem.id} feedItem={feedItem} />
          })}
        </>
      )
    }
    
    // GraphFeedItem.tsx
    function GraphFeedItem({ feedItem }) {
      const { data, isPending } = useQuery({
        queryKey: ['graph', feedItem.id],
        queryFn: getGraphDataById,
      })
    
      ...
    }
    

This example has a double waterfall, looking like this:

    1. |> getFeed()
    2.   |> JS for <GraphFeedItem>
    3.     |> getGraphDataById()
    

    1. |> getFeed()
    2.   |> JS for <GraphFeedItem>
    3.     |> getGraphDataById()
    

But that's just looking at the code from the example, if we consider what the first page load of this page looks like, we actually have to complete 5 round trips to the server before we can render the graph!

    1. |> Markup
    2.   |> JS for <Feed>
    3.     |> getFeed()
    4.       |> JS for <GraphFeedItem>
    5.         |> getGraphDataById()
    

    1. |> Markup
    2.   |> JS for <Feed>
    3.     |> getFeed()
    4.       |> JS for <GraphFeedItem>
    5.         |> getGraphDataById()
    

Note that this looks a bit different when server rendering, we will explore that further in the [Server Rendering & Hydration guide](https://tanstack.com/query/latest/docs/framework/react/guides/ssr). Also note that it's not uncommon for the route that contains <Feed> to also be code split, which could add yet another hop.

In the code split case, it might actually help to hoist the getGraphDataById query to the <Feed> component and make it conditional, or add a conditional prefetch. That query could then be fetched in parallel with the code, turning the example part into this:

    1. |> getFeed()
    2.   |> getGraphDataById()
    2.   |> JS for <GraphFeedItem>
    

    1. |> getFeed()
    2.   |> getGraphDataById()
    2.   |> JS for <GraphFeedItem>
    

This is very much a tradeoff however. You are now including the data fetching code for getGraphDataById in the same bundle as <Feed>, so evaluate what is best for your case. Read more about how to do this in the [Prefetching & Router Integration guide](https://tanstack.com/query/latest/docs/framework/react/guides/prefetching).

> The tradeoff between:
> 
> *   Include all data fetching code in the main bundle, even if we seldom use it
> *   Put the data fetching code in the code split bundle, but with a request waterfall
> 
> is not great and has been one of the motivations for Server Components. With Server Components, it's possible to avoid both, read more about how this applies to React Query in the [Advanced Server Rendering guide](https://tanstack.com/query/latest/docs/framework/react/guides/advanced-ssr).

[](#summary-and-takeaways)[Summary and takeaways](#summary-and-takeaways)
-------------------------------------------------------------------------

Request Waterfalls are a very common and complex performance concern with many tradeoffs. There are many ways to accidentally introduce them into your application:

*   Adding a query to a child, not realizing a parent already has a query
*   Adding a query to a parent, not realizing a child already has a query
*   Moving a component with descendants that has a query to a new parent with an ancestor that has a query
*   Etc..

Because of this accidental complexity, it pays off to be mindful of waterfalls and regularly examine your application looking for them (a good way is to examine the Network tab every now and then!). You don't necessarily have to flatten them all to have good performance, but keep an eye out for the high impact ones.

In the next guide, we'll look at more ways to flatten waterfalls, by leveraging [Prefetching & Router Integration](https://tanstack.com/query/latest/docs/framework/react/guides/prefetching).</content>
</page>

<page>
  <title>Server Rendering & Hydration | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/ssr</url>
  <content>In this guide you'll learn how to use React Query with server rendering.

See the guide on [Prefetching & Router Integration](https://tanstack.com/query/latest/docs/framework/react/guides/prefetching) for some background. You might also want to check out the [Performance & Request Waterfalls guide](https://tanstack.com/query/latest/docs/framework/react/guides/request-waterfalls) before that.

For advanced server rendering patterns, such as streaming, Server Components and the new Next.js app router, see the [Advanced Server Rendering guide](https://tanstack.com/query/latest/docs/framework/react/guides/advanced-ssr).

If you just want to see some code, you can skip ahead to the [Full Next.js pages router example](#full-nextjs-pages-router-example) or the [Full Remix example](#full-remix-example) below.

[](#server-rendering--react-query)[Server Rendering & React Query](#server-rendering--react-query)
--------------------------------------------------------------------------------------------------

So what is server rendering anyway? The rest of this guide will assume you are familiar with the concept, but let's spend some time to look at how it relates to React Query. Server rendering is the act of generating the initial html on the server, so that the user has some content to look at as soon as the page loads. This can happen on demand when a page is requested (SSR). It can also happen ahead of time either because a previous request was cached, or at build time (SSG).

If you've read the Request Waterfalls guide, you might remember this:

    1. |-> Markup (without content)
    2.   |-> JS
    3.     |-> Query
    

    1. |-> Markup (without content)
    2.   |-> JS
    3.     |-> Query
    

With a client rendered application, these are the minimum 3 server roundtrips you will need to make before getting any content on the screen for the user. One way of viewing server rendering is that it turns the above into this:

    1. |-> Markup (with content AND initial data)
    2.   |-> JS
    

    1. |-> Markup (with content AND initial data)
    2.   |-> JS
    

As soon as **1.** is complete, the user can see the content and when **2.** finishes, the page is interactive and clickable. Because the markup also contains the initial data we need, step **3.** does not need to run on the client at all, at least until you want to revalidate the data for some reason.

This is all from the clients perspective. On the server, we need to **prefetch** that data before we generate/render the markup, we need to **dehydrate** that data into a serializable format we can embed in the markup, and on the client we need to **hydrate** that data into a React Query cache so we can avoid doing a new fetch on the client.

Read on to learn how to implement these three steps with React Query.

[](#a-quick-note-on-suspense)[A quick note on Suspense](#a-quick-note-on-suspense)
----------------------------------------------------------------------------------

This guide uses the regular useQuery API. While we don't necessarily recommend it, it is possible to replace this with useSuspenseQuery instead **as long as you always prefetch all your queries**. The upside is that you get to use <Suspense> for loading states on the client.

If you do forget to prefetch a query when you are using useSuspenseQuery, the consequences will depend on the framework you are using. In some cases, the data will Suspend and get fetched on the server but never be hydrated to the client, where it will fetch again. In these cases you will get a markup hydration mismatch, because the server and the client tried to render different things.

[](#initial-setup)[Initial setup](#initial-setup)
-------------------------------------------------

The first steps of using React Query is always to create a queryClient and wrap the application in a <QueryClientProvider>. When doing server rendering, it's important to create the queryClient instance **inside of your app**, in React state (an instance ref works fine too). **This ensures that data is not shared between different users and requests**, while still only creating the queryClient once per component lifecycle.

Next.js pages router:

    // _app.tsx
    import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
    
    // NEVER DO THIS:
    // const queryClient = new QueryClient()
    //
    // Creating the queryClient at the file root level makes the cache shared
    // between all requests and means _all_ data gets passed to _all_ users.
    // Besides being bad for performance, this also leaks any sensitive data.
    
    export default function MyApp({ Component, pageProps }) {
      // Instead do this, which ensures each request has its own cache:
      const [queryClient] = React.useState(
        () =>
          new QueryClient({
            defaultOptions: {
              queries: {
                // With SSR, we usually want to set some default staleTime
                // above 0 to avoid refetching immediately on the client
                staleTime: 60 * 1000,
              },
            },
          }),
      )
    
      return (
        <QueryClientProvider client={queryClient}>
          <Component {...pageProps} />
        </QueryClientProvider>
      )
    }
    

    // _app.tsx
    import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
    
    // NEVER DO THIS:
    // const queryClient = new QueryClient()
    //
    // Creating the queryClient at the file root level makes the cache shared
    // between all requests and means _all_ data gets passed to _all_ users.
    // Besides being bad for performance, this also leaks any sensitive data.
    
    export default function MyApp({ Component, pageProps }) {
      // Instead do this, which ensures each request has its own cache:
      const [queryClient] = React.useState(
        () =>
          new QueryClient({
            defaultOptions: {
              queries: {
                // With SSR, we usually want to set some default staleTime
                // above 0 to avoid refetching immediately on the client
                staleTime: 60 * 1000,
              },
            },
          }),
      )
    
      return (
        <QueryClientProvider client={queryClient}>
          <Component {...pageProps} />
        </QueryClientProvider>
      )
    }
    

Remix:

    // app/root.tsx
    import { Outlet } from '@remix-run/react'
    import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
    
    export default function MyApp() {
      const [queryClient] = React.useState(
        () =>
          new QueryClient({
            defaultOptions: {
              queries: {
                // With SSR, we usually want to set some default staleTime
                // above 0 to avoid refetching immediately on the client
                staleTime: 60 * 1000,
              },
            },
          }),
      )
    
      return (
        <QueryClientProvider client={queryClient}>
          <Outlet />
        </QueryClientProvider>
      )
    }
    

    // app/root.tsx
    import { Outlet } from '@remix-run/react'
    import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
    
    export default function MyApp() {
      const [queryClient] = React.useState(
        () =>
          new QueryClient({
            defaultOptions: {
              queries: {
                // With SSR, we usually want to set some default staleTime
                // above 0 to avoid refetching immediately on the client
                staleTime: 60 * 1000,
              },
            },
          }),
      )
    
      return (
        <QueryClientProvider client={queryClient}>
          <Outlet />
        </QueryClientProvider>
      )
    }
    

[](#get-started-fast-with-initialdata)[Get started fast with initialData](#get-started-fast-with-initialdata)
-------------------------------------------------------------------------------------------------------------

The quickest way to get started is to not involve React Query at all when it comes to prefetching and not use the dehydrate/hydrate APIs. What you do instead is passing the raw data in as the initialData option to useQuery. Let's look at an example using Next.js pages router, using getServerSideProps.

    export async function getServerSideProps() {
      const posts = await getPosts()
      return { props: { posts } }
    }
    
    function Posts(props) {
      const { data } = useQuery({
        queryKey: ['posts'],
        queryFn: getPosts,
        initialData: props.posts,
      })
    
      // ...
    }
    

    export async function getServerSideProps() {
      const posts = await getPosts()
      return { props: { posts } }
    }
    
    function Posts(props) {
      const { data } = useQuery({
        queryKey: ['posts'],
        queryFn: getPosts,
        initialData: props.posts,
      })
    
      // ...
    }
    

This also works with getStaticProps or even the older getInitialProps and the same pattern can be applied in any other framework that has equivalent functions. This is what the same example looks like with Remix:

    export async function loader() {
      const posts = await getPosts()
      return json({ posts })
    }
    
    function Posts() {
      const { posts } = useLoaderData<typeof loader>()
    
      const { data } = useQuery({
        queryKey: ['posts'],
        queryFn: getPosts,
        initialData: posts,
      })
    
      // ...
    }
    

    export async function loader() {
      const posts = await getPosts()
      return json({ posts })
    }
    
    function Posts() {
      const { posts } = useLoaderData<typeof loader>()
    
      const { data } = useQuery({
        queryKey: ['posts'],
        queryFn: getPosts,
        initialData: posts,
      })
    
      // ...
    }
    

The setup is minimal and this can be a quick solution for some cases, but there are a **few tradeoffs to consider** when compared to the full approach:

*   If you are calling useQuery in a component deeper down in the tree you need to pass the initialData down to that point
*   If you are calling useQuery with the same query in multiple locations, passing initialData to only one of them can be brittle and break when your app changes since. If you remove or move the component that has the useQuery with initialData, the more deeply nested useQuery might no longer have any data. Passing initialData to **all** queries that needs it can also be cumbersome.
*   There is no way to know at what time the query was fetched on the server, so dataUpdatedAt and determining if the query needs refetching is based on when the page loaded instead
*   If there is already data in the cache for a query, initialData will never overwrite this data, **even if the new data is fresher than the old one**.
    *   To understand why this is especially bad, consider the getServerSideProps example above. If you navigate back and forth to a page several times, getServerSideProps would get called each time and fetch new data, but because we are using the initialData option, the client cache and data would never be updated.

Setting up the full hydration solution is straightforward and does not have these drawbacks, this will be the focus for the rest of the documentation.

[](#using-the-hydration-apis)[Using the Hydration APIs](#using-the-hydration-apis)
----------------------------------------------------------------------------------

With just a little more setup, you can use a queryClient to prefetch queries during a preload phase, pass a serialized version of that queryClient to the rendering part of the app and reuse it there. This avoids the drawbacks above. Feel free to skip ahead for full Next.js pages router and Remix examples, but at a general level these are the extra steps:

*   In the framework loader function, create a const queryClient = new QueryClient(options)
*   In the loader function, do await queryClient.prefetchQuery(...) for each query you want to prefetch
    *   You want to use await Promise.all(...) to fetch the queries in parallel when possible
    *   It's fine to have queries that aren't prefetched. These wont be server rendered, instead they will be fetched on the client after the application is interactive. This can be great for content that are shown only after user interaction, or is far down on the page to avoid blocking more critical content.
*   From the loader, return dehydrate(queryClient), note that the exact syntax to return this differs between frameworks
*   Wrap your tree with <HydrationBoundary state={dehydratedState}> where dehydratedState comes from the framework loader. How you get dehydratedState also differs between frameworks.
    *   This can be done for each route, or at the top of the application to avoid boilerplate, see examples

> An interesting detail is that there are actually _three_ queryClients involved. The framework loaders are a form of "preloading" phase that happens before rendering, and this phase has its own queryClient that does the prefetching. The dehydrated result of this phase gets passed to **both** the server rendering process **and** the client rendering process which each has its own queryClient. This ensures they both start with the same data so they can return the same markup.

> Server Components are another form of "preloading" phase, that can also "preload" (pre-render) parts of a React component tree. Read more in the [Advanced Server Rendering guide](https://tanstack.com/query/latest/docs/framework/react/guides/advanced-ssr).

### [](#full-nextjs-pages-router-example)[Full Next.js pages router example](#full-nextjs-pages-router-example)

> For app router documentation, see the [Advanced Server Rendering guide](https://tanstack.com/query/latest/docs/framework/react/guides/advanced-ssr).

Initial setup:

    // _app.tsx
    import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
    
    export default function MyApp({ Component, pageProps }) {
      const [queryClient] = React.useState(
        () =>
          new QueryClient({
            defaultOptions: {
              queries: {
                // With SSR, we usually want to set some default staleTime
                // above 0 to avoid refetching immediately on the client
                staleTime: 60 * 1000,
              },
            },
          }),
      )
    
      return (
        <QueryClientProvider client={queryClient}>
          <Component {...pageProps} />
        </QueryClientProvider>
      )
    }
    

    // _app.tsx
    import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
    
    export default function MyApp({ Component, pageProps }) {
      const [queryClient] = React.useState(
        () =>
          new QueryClient({
            defaultOptions: {
              queries: {
                // With SSR, we usually want to set some default staleTime
                // above 0 to avoid refetching immediately on the client
                staleTime: 60 * 1000,
              },
            },
          }),
      )
    
      return (
        <QueryClientProvider client={queryClient}>
          <Component {...pageProps} />
        </QueryClientProvider>
      )
    }
    

In each route:

    // pages/posts.tsx
    import {
      dehydrate,
      HydrationBoundary,
      QueryClient,
      useQuery,
    } from '@tanstack/react-query'
    
    // This could also be getServerSideProps
    export async function getStaticProps() {
      const queryClient = new QueryClient()
    
      await queryClient.prefetchQuery({
        queryKey: ['posts'],
        queryFn: getPosts,
      })
    
      return {
        props: {
          dehydratedState: dehydrate(queryClient),
        },
      }
    }
    
    function Posts() {
      // This useQuery could just as well happen in some deeper child to
      // the <PostsRoute>, data will be available immediately either way
      const { data } = useQuery({ queryKey: ['posts'], queryFn: getPosts })
    
      // This query was not prefetched on the server and will not start
      // fetching until on the client, both patterns are fine to mix
      const { data: commentsData } = useQuery({
        queryKey: ['posts-comments'],
        queryFn: getComments,
      })
    
      // ...
    }
    
    export default function PostsRoute({ dehydratedState }) {
      return (
        <HydrationBoundary state={dehydratedState}>
          <Posts />
        </HydrationBoundary>
      )
    }
    

    // pages/posts.tsx
    import {
      dehydrate,
      HydrationBoundary,
      QueryClient,
      useQuery,
    } from '@tanstack/react-query'
    
    // This could also be getServerSideProps
    export async function getStaticProps() {
      const queryClient = new QueryClient()
    
      await queryClient.prefetchQuery({
        queryKey: ['posts'],
        queryFn: getPosts,
      })
    
      return {
        props: {
          dehydratedState: dehydrate(queryClient),
        },
      }
    }
    
    function Posts() {
      // This useQuery could just as well happen in some deeper child to
      // the <PostsRoute>, data will be available immediately either way
      const { data } = useQuery({ queryKey: ['posts'], queryFn: getPosts })
    
      // This query was not prefetched on the server and will not start
      // fetching until on the client, both patterns are fine to mix
      const { data: commentsData } = useQuery({
        queryKey: ['posts-comments'],
        queryFn: getComments,
      })
    
      // ...
    }
    
    export default function PostsRoute({ dehydratedState }) {
      return (
        <HydrationBoundary state={dehydratedState}>
          <Posts />
        </HydrationBoundary>
      )
    }
    

### [](#full-remix-example)[Full Remix example](#full-remix-example)

Initial setup:

    // app/root.tsx
    import { Outlet } from '@remix-run/react'
    import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
    
    export default function MyApp() {
      const [queryClient] = React.useState(
        () =>
          new QueryClient({
            defaultOptions: {
              queries: {
                // With SSR, we usually want to set some default staleTime
                // above 0 to avoid refetching immediately on the client
                staleTime: 60 * 1000,
              },
            },
          }),
      )
    
      return (
        <QueryClientProvider client={queryClient}>
          <Outlet />
        </QueryClientProvider>
      )
    }
    

    // app/root.tsx
    import { Outlet } from '@remix-run/react'
    import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
    
    export default function MyApp() {
      const [queryClient] = React.useState(
        () =>
          new QueryClient({
            defaultOptions: {
              queries: {
                // With SSR, we usually want to set some default staleTime
                // above 0 to avoid refetching immediately on the client
                staleTime: 60 * 1000,
              },
            },
          }),
      )
    
      return (
        <QueryClientProvider client={queryClient}>
          <Outlet />
        </QueryClientProvider>
      )
    }
    

In each route, note that it's fine to do this in nested routes too:

    // app/routes/posts.tsx
    import { json } from '@remix-run/node'
    import {
      dehydrate,
      HydrationBoundary,
      QueryClient,
      useQuery,
    } from '@tanstack/react-query'
    
    export async function loader() {
      const queryClient = new QueryClient()
    
      await queryClient.prefetchQuery({
        queryKey: ['posts'],
        queryFn: getPosts,
      })
    
      return json({ dehydratedState: dehydrate(queryClient) })
    }
    
    function Posts() {
      // This useQuery could just as well happen in some deeper child to
      // the <PostsRoute>, data will be available immediately either way
      const { data } = useQuery({ queryKey: ['posts'], queryFn: getPosts })
    
      // This query was not prefetched on the server and will not start
      // fetching until on the client, both patterns are fine to mix
      const { data: commentsData } = useQuery({
        queryKey: ['posts-comments'],
        queryFn: getComments,
      })
    
      // ...
    }
    
    export default function PostsRoute() {
      const { dehydratedState } = useLoaderData<typeof loader>()
      return (
        <HydrationBoundary state={dehydratedState}>
          <Posts />
        </HydrationBoundary>
      )
    }
    

    // app/routes/posts.tsx
    import { json } from '@remix-run/node'
    import {
      dehydrate,
      HydrationBoundary,
      QueryClient,
      useQuery,
    } from '@tanstack/react-query'
    
    export async function loader() {
      const queryClient = new QueryClient()
    
      await queryClient.prefetchQuery({
        queryKey: ['posts'],
        queryFn: getPosts,
      })
    
      return json({ dehydratedState: dehydrate(queryClient) })
    }
    
    function Posts() {
      // This useQuery could just as well happen in some deeper child to
      // the <PostsRoute>, data will be available immediately either way
      const { data } = useQuery({ queryKey: ['posts'], queryFn: getPosts })
    
      // This query was not prefetched on the server and will not start
      // fetching until on the client, both patterns are fine to mix
      const { data: commentsData } = useQuery({
        queryKey: ['posts-comments'],
        queryFn: getComments,
      })
    
      // ...
    }
    
    export default function PostsRoute() {
      const { dehydratedState } = useLoaderData<typeof loader>()
      return (
        <HydrationBoundary state={dehydratedState}>
          <Posts />
        </HydrationBoundary>
      )
    }
    

[](#optional---remove-boilerplate)[Optional - Remove boilerplate](#optional---remove-boilerplate)
-------------------------------------------------------------------------------------------------

Having this part in every route might seem like a lot of boilerplate:

    export default function PostsRoute({ dehydratedState }) {
      return (
        <HydrationBoundary state={dehydratedState}>
          <Posts />
        </HydrationBoundary>
      )
    }
    

    export default function PostsRoute({ dehydratedState }) {
      return (
        <HydrationBoundary state={dehydratedState}>
          <Posts />
        </HydrationBoundary>
      )
    }
    

While there is nothing wrong with this approach, if you want to get rid of this boilerplate, here's how you can modify your setup in Next.js:

    // _app.tsx
    import {
      HydrationBoundary,
      QueryClient,
      QueryClientProvider,
    } from '@tanstack/react-query'
    
    export default function MyApp({ Component, pageProps }) {
      const [queryClient] = React.useState(() => new QueryClient())
    
      return (
        <QueryClientProvider client={queryClient}>
          <HydrationBoundary state={pageProps.dehydratedState}>
            <Component {...pageProps} />
          </HydrationBoundary>
        </QueryClientProvider>
      )
    }
    
    // pages/posts.tsx
    // Remove PostsRoute with the HydrationBoundary and instead export Posts directly:
    export default function Posts() { ... }
    

    // _app.tsx
    import {
      HydrationBoundary,
      QueryClient,
      QueryClientProvider,
    } from '@tanstack/react-query'
    
    export default function MyApp({ Component, pageProps }) {
      const [queryClient] = React.useState(() => new QueryClient())
    
      return (
        <QueryClientProvider client={queryClient}>
          <HydrationBoundary state={pageProps.dehydratedState}>
            <Component {...pageProps} />
          </HydrationBoundary>
        </QueryClientProvider>
      )
    }
    
    // pages/posts.tsx
    // Remove PostsRoute with the HydrationBoundary and instead export Posts directly:
    export default function Posts() { ... }
    

With Remix, this is a little bit more involved, we recommend checking out the [use-dehydrated-state](https://github.com/maplegrove-io/use-dehydrated-state) package.

[](#prefetching-dependent-queries)[Prefetching dependent queries](#prefetching-dependent-queries)
-------------------------------------------------------------------------------------------------

Over in the Prefetching guide we learned how to [prefetch dependent queries](https://tanstack.com/query/latest/docs/framework/react/guides/prefetching#dependent-queries--code-splitting), but how do we do this in framework loaders? Consider the following code, taken from the [Dependent Queries guide](https://tanstack.com/query/latest/docs/framework/react/guides/dependent-queries):

    // Get the user
    const { data: user } = useQuery({
      queryKey: ['user', email],
      queryFn: getUserByEmail,
    })
    
    const userId = user?.id
    
    // Then get the user's projects
    const {
      status,
      fetchStatus,
      data: projects,
    } = useQuery({
      queryKey: ['projects', userId],
      queryFn: getProjectsByUser,
      // The query will not execute until the userId exists
      enabled: !!userId,
    })
    

    // Get the user
    const { data: user } = useQuery({
      queryKey: ['user', email],
      queryFn: getUserByEmail,
    })
    
    const userId = user?.id
    
    // Then get the user's projects
    const {
      status,
      fetchStatus,
      data: projects,
    } = useQuery({
      queryKey: ['projects', userId],
      queryFn: getProjectsByUser,
      // The query will not execute until the userId exists
      enabled: !!userId,
    })
    

How would we prefetch this so it can be server rendered? Here's an example:

    // For Remix, rename this to loader instead
    export async function getServerSideProps() {
      const queryClient = new QueryClient()
    
      const user = await queryClient.fetchQuery({
        queryKey: ['user', email],
        queryFn: getUserByEmail,
      })
    
      if (user?.userId) {
        await queryClient.prefetchQuery({
          queryKey: ['projects', userId],
          queryFn: getProjectsByUser,
        })
      }
    
      // For Remix:
      // return json({ dehydratedState: dehydrate(queryClient) })
      return { props: { dehydratedState: dehydrate(queryClient) } }
    }
    

    // For Remix, rename this to loader instead
    export async function getServerSideProps() {
      const queryClient = new QueryClient()
    
      const user = await queryClient.fetchQuery({
        queryKey: ['user', email],
        queryFn: getUserByEmail,
      })
    
      if (user?.userId) {
        await queryClient.prefetchQuery({
          queryKey: ['projects', userId],
          queryFn: getProjectsByUser,
        })
      }
    
      // For Remix:
      // return json({ dehydratedState: dehydrate(queryClient) })
      return { props: { dehydratedState: dehydrate(queryClient) } }
    }
    

This can get more complex of course, but since these loader functions are just JavaScript, you can use the full power of the language to build your logic. Make sure you prefetch all queries that you want to be server rendered.

[](#error-handling)[Error handling](#error-handling)
----------------------------------------------------

React Query defaults to a graceful degradation strategy. This means:

*   queryClient.prefetchQuery(...) never throws errors
*   dehydrate(...) only includes successful queries, not failed ones

This will lead to any failed queries being retried on the client and that the server rendered output will include loading states instead of the full content.

While a good default, sometimes this is not what you want. When critical content is missing, you might want to respond with a 404 or 500 status code depending on the situation. For these cases, use queryClient.fetchQuery(...) instead, which will throw errors when it fails, letting you handle things in a suitable way.

    let result
    
    try {
      result = await queryClient.fetchQuery(...)
    } catch (error) {
      // Handle the error, refer to your framework documentation
    }
    
    // You might also want to check and handle any invalid `result` here
    

    let result
    
    try {
      result = await queryClient.fetchQuery(...)
    } catch (error) {
      // Handle the error, refer to your framework documentation
    }
    
    // You might also want to check and handle any invalid `result` here
    

If you for some reason want to include failed queries in the dehydrated state to avoid retries, you can use the option shouldDehydrateQuery to override the default function and implement your own logic:

    dehydrate(queryClient, {
      shouldDehydrateQuery: (query) => {
        // This will include all queries, including failed ones,
        // but you can also implement your own logic by inspecting `query`
        return true
      },
    })
    

    dehydrate(queryClient, {
      shouldDehydrateQuery: (query) => {
        // This will include all queries, including failed ones,
        // but you can also implement your own logic by inspecting `query`
        return true
      },
    })
    

[](#serialization)[Serialization](#serialization)
-------------------------------------------------

When doing return { props: { dehydratedState: dehydrate(queryClient) } } in Next.js, or return json({ dehydratedState: dehydrate(queryClient) }) in Remix, what happens is that the dehydratedState representation of the queryClient is serialized by the framework so it can be embedded into the markup and transported to the client.

By default, these frameworks only supports returning things that are safely serializable/parsable, and therefore does not support undefined, Error, Date, Map, Set, BigInt, Infinity, NaN, \-0, regular expressions etc. This also means that you can not return any of these things from your queries. If returning these values is something you want, check out [superjson](https://github.com/blitz-js/superjson) or similar packages.

If you are using a custom SSR setup, you need to take care of this step yourself. Your first instinct might be to use JSON.stringify(dehydratedState), but because this doesn't escape things like <script>alert('Oh no..')</script> by default, this can easily lead to **XSS-vulnerabilities** in your application. [superjson](https://github.com/blitz-js/superjson) also **does not** escape values and is unsafe to use by itself in a custom SSR setup (unless you add an extra step for escaping the output). Instead we recommend using a library like [Serialize JavaScript](https://github.com/yahoo/serialize-javascript) or [devalue](https://github.com/Rich-Harris/devalue) which are both safe against XSS injections out of the box.

[](#a-note-about-request-waterfalls)[A note about request waterfalls](#a-note-about-request-waterfalls)
-------------------------------------------------------------------------------------------------------

In the [Performance & Request Waterfalls guide](https://tanstack.com/query/latest/docs/framework/react/guides/request-waterfalls) we mentioned we would revisit how server rendering changes one of the more complex nested waterfalls. Check back for the [specific code example](https://tanstack.com/query/latest/docs/framework/react/guides/request-waterfalls#code-splitting), but as a refresher, we have a code split <GraphFeedItem> component inside a <Feed> component. This only renders if the feed contains a graph item and both of these components fetches their own data. With client rendering, this leads to the following request waterfall:

    1. |> Markup (without content)
    2.   |> JS for <Feed>
    3.     |> getFeed()
    4.       |> JS for <GraphFeedItem>
    5.         |> getGraphDataById()
    

    1. |> Markup (without content)
    2.   |> JS for <Feed>
    3.     |> getFeed()
    4.       |> JS for <GraphFeedItem>
    5.         |> getGraphDataById()
    

The nice thing about server rendering is that we can turn the above into:

    1. |> Markup (with content AND initial data)
    2.   |> JS for <Feed>
    2.   |> JS for <GraphFeedItem>
    

    1. |> Markup (with content AND initial data)
    2.   |> JS for <Feed>
    2.   |> JS for <GraphFeedItem>
    

Note that the queries are no longer fetched on the client, instead their data was included in the markup. The reason we can now load the JS in parallel is that since <GraphFeedItem> was rendered on the server we know that we are going to need this JS on the client as well and can insert a script-tag for this chunk in the markup. On the server, we would still have this request waterfall:

    1. |> getFeed()
    2.   |> getGraphDataById()
    

    1. |> getFeed()
    2.   |> getGraphDataById()
    

We simply can not know before we have fetched the feed if we also need to fetch graph data, they are dependent queries. Because this happens on the server where latency is generally both lower and more stable, this often isn't such a big deal.

Amazing, we've mostly flattened our waterfalls! There's a catch though. Let's call this page the /feed page, and let's pretend we also have another page like /posts. If we type in www.example.com/feed directly in the url bar and hit enter, we get all these great server rendering benefits, BUT, if we instead type in www.example.com/posts and then **click a link** to /feed, we're back to this:

    1. |> JS for <Feed>
    2.   |> getFeed()
    3.     |> JS for <GraphFeedItem>
    4.       |> getGraphDataById()
    

    1. |> JS for <Feed>
    2.   |> getFeed()
    3.     |> JS for <GraphFeedItem>
    4.       |> getGraphDataById()
    

This is because with SPA's, server rendering only works for the initial page load, not for any subsequent navigation.

Modern frameworks often try to solve this by fetching the initial code and data in parallel, so if you were using Next.js or Remix with the prefetching patterns we outlined in this guide, including how to prefetch dependent queries, it would actually look like this instead:

    1. |> JS for <Feed>
    1. |> getFeed() + getGraphDataById()
    2.   |> JS for <GraphFeedItem>
    

    1. |> JS for <Feed>
    1. |> getFeed() + getGraphDataById()
    2.   |> JS for <GraphFeedItem>
    

This is much better, but if we want to improve this further we can flatten this to a single roundtrip with Server Components. Learn how in the [Advanced Server Rendering guide](https://tanstack.com/query/latest/docs/framework/react/guides/advanced-ssr).

[](#tips-tricks-and-caveats)[Tips, Tricks and Caveats](#tips-tricks-and-caveats)
--------------------------------------------------------------------------------

### [](#staleness-is-measured-from-when-the-query-was-fetched-on-the-server)[Staleness is measured from when the query was fetched on the server](#staleness-is-measured-from-when-the-query-was-fetched-on-the-server)

A query is considered stale depending on when it was dataUpdatedAt. A caveat here is that the server needs to have the correct time for this to work properly, but UTC time is used, so timezones do not factor into this.

Because staleTime defaults to 0, queries will be refetched in the background on page load by default. You might want to use a higher staleTime to avoid this double fetching, especially if you don't cache your markup.

This refetching of stale queries is a perfect match when caching markup in a CDN! You can set the cache time of the page itself decently high to avoid having to re-render pages on the server, but configure the staleTime of the queries lower to make sure data is refetched in the background as soon as a user visits the page. Maybe you want to cache the pages for a week, but refetch the data automatically on page load if it's older than a day?

### [](#high-memory-consumption-on-server)[High memory consumption on server](#high-memory-consumption-on-server)

In case you are creating the QueryClient for every request, React Query creates the isolated cache for this client, which is preserved in memory for the gcTime period. That may lead to high memory consumption on server in case of high number of requests during that period.

On the server, gcTime defaults to Infinity which disables manual garbage collection and will automatically clear memory once a request has finished. If you are explicitly setting a non-Infinity gcTime then you will be responsible for clearing the cache early.

Avoid setting gcTime to 0 as it may result in a hydration error. This occurs because the [Hydration Boundary](https://tanstack.com/query/latest/docs/framework/react/reference/hydration#hydrationboundary) places necessary data into the cache for rendering, but if the garbage collector removes the data before the rendering completes, issues may arise. If you require a shorter gcTime, we recommend setting it to 2 \* 1000 to allow sufficient time for the app to reference the data.

To clear the cache after it is not needed and to lower memory consumption, you can add a call to [queryClient.clear()](https://tanstack.com/query/latest/docs/reference/QueryClient#queryclientclear) after the request is handled and dehydrated state has been sent to the client.

Alternatively, you can set a smaller gcTime.

### [](#caveat-for-nextjs-rewrites)[Caveat for Next.js rewrites](#caveat-for-nextjs-rewrites)

There's a catch if you're using [Next.js' rewrites feature](https://nextjs.org/docs/app/api-reference/next-config-js/rewrites) together with [Automatic Static Optimization](https://nextjs.org/docs/pages/building-your-application/rendering/automatic-static-optimization) or getStaticProps: It will cause a second hydration by React Query. That's because [Next.js needs to ensure that they parse the rewrites](https://nextjs.org/docs/app/api-reference/next-config-js/rewrites#rewrite-parameters) on the client and collect any params after hydration so that they can be provided in router.query.

The result is missing referential equality for all the hydration data, which for example triggers wherever your data is used as props of components or in the dependency array of useEffects/useMemos.</content>
</page>

<page>
  <title>Advanced Server Rendering | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/advanced-ssr</url>
  <content>Welcome to the Advanced Server Rendering guide, where you will learn all about using React Query with streaming, Server Components and the Next.js app router.

You might want to read the [Server Rendering & Hydration guide](https://tanstack.com/query/latest/docs/framework/react/guides/ssr) before this one as it teaches the basics for using React Query with SSR, and [Performance & Request Waterfalls](https://tanstack.com/query/latest/docs/framework/react/guides/request-waterfalls) as well as [Prefetching & Router Integration](https://tanstack.com/query/latest/docs/framework/react/guides/prefetching) also contains valuable background.

Before we start, let's note that while the initialData approach outlined in the SSR guide also works with Server Components, we'll focus this guide on the hydration APIs.

[](#server-components--nextjs-app-router)[Server Components & Next.js app router](#server-components--nextjs-app-router)
------------------------------------------------------------------------------------------------------------------------

We won't cover Server Components in depth here, but the short version is that they are components that are guaranteed to _only_ run on the server, both for the initial page view and **also on page transitions**. This is similar to how Next.js getServerSideProps/getStaticProps and Remix loader works, as these also always run on the server but while those can only return data, Server Components can do a lot more. The data part is central to React Query however, so let's focus on that.

How do we take what we learned in the Server Rendering guide about [passing data prefetched in framework loaders to the app](https://tanstack.com/query/latest/docs/framework/react/guides/ssr#using-the-hydration-apis) and apply that to Server Components and the Next.js app router? The best way to start thinking about this is to consider Server Components as "just" another framework loader.

### [](#a-quick-note-on-terminology)[A quick note on terminology](#a-quick-note-on-terminology)

So far in these guides, we've been talking about the _server_ and the _client_. It's important to note that confusingly enough this does not match 1-1 with _Server Components_ and _Client Components_. Server Components are guaranteed to only run on the server, but Client Components can actually run in both places. The reason for this is that they can also render during the initial _server rendering_ pass.

One way to think of this is that even though Server Components also _render_, they happen during a "loader phase" (always happens on the server), while Client Components run during the "application phase". That application can run both on the server during SSR, and in for example a browser. Where exactly that application runs and if it runs during SSR or not might differ between frameworks.

### [](#initial-setup)[Initial setup](#initial-setup)

The first step of any React Query setup is always to create a queryClient and wrap your application in a QueryClientProvider. With Server Components, this looks mostly the same across frameworks, one difference being the filename conventions:

    // In Next.js, this file would be called: app/providers.tsx
    'use client'
    
    // Since QueryClientProvider relies on useContext under the hood, we have to put 'use client' on top
    import {
      isServer,
      QueryClient,
      QueryClientProvider,
    } from '@tanstack/react-query'
    
    function makeQueryClient() {
      return new QueryClient({
        defaultOptions: {
          queries: {
            // With SSR, we usually want to set some default staleTime
            // above 0 to avoid refetching immediately on the client
            staleTime: 60 * 1000,
          },
        },
      })
    }
    
    let browserQueryClient: QueryClient | undefined = undefined
    
    function getQueryClient() {
      if (isServer) {
        // Server: always make a new query client
        return makeQueryClient()
      } else {
        // Browser: make a new query client if we don't already have one
        // This is very important, so we don't re-make a new client if React
        // suspends during the initial render. This may not be needed if we
        // have a suspense boundary BELOW the creation of the query client
        if (!browserQueryClient) browserQueryClient = makeQueryClient()
        return browserQueryClient
      }
    }
    
    export default function Providers({ children }: { children: React.ReactNode }) {
      // NOTE: Avoid useState when initializing the query client if you don't
      //       have a suspense boundary between this and the code that may
      //       suspend because React will throw away the client on the initial
      //       render if it suspends and there is no boundary
      const queryClient = getQueryClient()
    
      return (
        <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
      )
    }
    

    // In Next.js, this file would be called: app/providers.tsx
    'use client'
    
    // Since QueryClientProvider relies on useContext under the hood, we have to put 'use client' on top
    import {
      isServer,
      QueryClient,
      QueryClientProvider,
    } from '@tanstack/react-query'
    
    function makeQueryClient() {
      return new QueryClient({
        defaultOptions: {
          queries: {
            // With SSR, we usually want to set some default staleTime
            // above 0 to avoid refetching immediately on the client
            staleTime: 60 * 1000,
          },
        },
      })
    }
    
    let browserQueryClient: QueryClient | undefined = undefined
    
    function getQueryClient() {
      if (isServer) {
        // Server: always make a new query client
        return makeQueryClient()
      } else {
        // Browser: make a new query client if we don't already have one
        // This is very important, so we don't re-make a new client if React
        // suspends during the initial render. This may not be needed if we
        // have a suspense boundary BELOW the creation of the query client
        if (!browserQueryClient) browserQueryClient = makeQueryClient()
        return browserQueryClient
      }
    }
    
    export default function Providers({ children }: { children: React.ReactNode }) {
      // NOTE: Avoid useState when initializing the query client if you don't
      //       have a suspense boundary between this and the code that may
      //       suspend because React will throw away the client on the initial
      //       render if it suspends and there is no boundary
      const queryClient = getQueryClient()
    
      return (
        <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
      )
    }
    

    // In Next.js, this file would be called: app/layout.tsx
    import Providers from './providers'
    
    export default function RootLayout({
      children,
    }: {
      children: React.ReactNode
    }) {
      return (
        <html lang="en">
          <head />
          <body>
            <Providers>{children}</Providers>
          </body>
        </html>
      )
    }
    

    // In Next.js, this file would be called: app/layout.tsx
    import Providers from './providers'
    
    export default function RootLayout({
      children,
    }: {
      children: React.ReactNode
    }) {
      return (
        <html lang="en">
          <head />
          <body>
            <Providers>{children}</Providers>
          </body>
        </html>
      )
    }
    

This part is pretty similar to what we did in the SSR guide, we just need to split things up into two different files.

### [](#prefetching-and-dehydrating-data)[Prefetching and de/hydrating data](#prefetching-and-dehydrating-data)

Next, let‚Äôs look at how to actually prefetch data, then dehydrate and hydrate it. This is what it looked like using the **Next.js Pages Router**:

    // pages/posts.tsx
    import {
      dehydrate,
      HydrationBoundary,
      QueryClient,
      useQuery,
    } from '@tanstack/react-query'
    
    // This could also be getServerSideProps
    export async function getStaticProps() {
      const queryClient = new QueryClient()
    
      await queryClient.prefetchQuery({
        queryKey: ['posts'],
        queryFn: getPosts,
      })
    
      return {
        props: {
          dehydratedState: dehydrate(queryClient),
        },
      }
    }
    
    function Posts() {
      // This useQuery could just as well happen in some deeper child to
      // the <PostsRoute>, data will be available immediately either way
      //
      // Note that we are using useQuery here instead of useSuspenseQuery.
      // Because this data has already been prefetched, there is no need to
      // ever suspend in the component itself. If we forget or remove the
      // prefetch, this will instead fetch the data on the client, while
      // using useSuspenseQuery would have had worse side effects.
      const { data } = useQuery({ queryKey: ['posts'], queryFn: getPosts })
    
      // This query was not prefetched on the server and will not start
      // fetching until on the client, both patterns are fine to mix
      const { data: commentsData } = useQuery({
        queryKey: ['posts-comments'],
        queryFn: getComments,
      })
    
      // ...
    }
    
    export default function PostsRoute({ dehydratedState }) {
      return (
        <HydrationBoundary state={dehydratedState}>
          <Posts />
        </HydrationBoundary>
      )
    }
    

    // pages/posts.tsx
    import {
      dehydrate,
      HydrationBoundary,
      QueryClient,
      useQuery,
    } from '@tanstack/react-query'
    
    // This could also be getServerSideProps
    export async function getStaticProps() {
      const queryClient = new QueryClient()
    
      await queryClient.prefetchQuery({
        queryKey: ['posts'],
        queryFn: getPosts,
      })
    
      return {
        props: {
          dehydratedState: dehydrate(queryClient),
        },
      }
    }
    
    function Posts() {
      // This useQuery could just as well happen in some deeper child to
      // the <PostsRoute>, data will be available immediately either way
      //
      // Note that we are using useQuery here instead of useSuspenseQuery.
      // Because this data has already been prefetched, there is no need to
      // ever suspend in the component itself. If we forget or remove the
      // prefetch, this will instead fetch the data on the client, while
      // using useSuspenseQuery would have had worse side effects.
      const { data } = useQuery({ queryKey: ['posts'], queryFn: getPosts })
    
      // This query was not prefetched on the server and will not start
      // fetching until on the client, both patterns are fine to mix
      const { data: commentsData } = useQuery({
        queryKey: ['posts-comments'],
        queryFn: getComments,
      })
    
      // ...
    }
    
    export default function PostsRoute({ dehydratedState }) {
      return (
        <HydrationBoundary state={dehydratedState}>
          <Posts />
        </HydrationBoundary>
      )
    }
    

Converting this to the app router actually looks pretty similar, we just need to move things around a bit. First, we'll create a Server Component to do the prefetching part:

    // app/posts/page.tsx
    import {
      dehydrate,
      HydrationBoundary,
      QueryClient,
    } from '@tanstack/react-query'
    import Posts from './posts'
    
    export default async function PostsPage() {
      const queryClient = new QueryClient()
    
      await queryClient.prefetchQuery({
        queryKey: ['posts'],
        queryFn: getPosts,
      })
    
      return (
        // Neat! Serialization is now as easy as passing props.
        // HydrationBoundary is a Client Component, so hydration will happen there.
        <HydrationBoundary state={dehydrate(queryClient)}>
          <Posts />
        </HydrationBoundary>
      )
    }
    

    // app/posts/page.tsx
    import {
      dehydrate,
      HydrationBoundary,
      QueryClient,
    } from '@tanstack/react-query'
    import Posts from './posts'
    
    export default async function PostsPage() {
      const queryClient = new QueryClient()
    
      await queryClient.prefetchQuery({
        queryKey: ['posts'],
        queryFn: getPosts,
      })
    
      return (
        // Neat! Serialization is now as easy as passing props.
        // HydrationBoundary is a Client Component, so hydration will happen there.
        <HydrationBoundary state={dehydrate(queryClient)}>
          <Posts />
        </HydrationBoundary>
      )
    }
    

Next, we'll look at what the Client Component part looks like:

    // app/posts/posts.tsx
    'use client'
    
    export default function Posts() {
      // This useQuery could just as well happen in some deeper
      // child to <Posts>, data will be available immediately either way
      const { data } = useQuery({
        queryKey: ['posts'],
        queryFn: () => getPosts(),
      })
    
      // This query was not prefetched on the server and will not start
      // fetching until on the client, both patterns are fine to mix.
      const { data: commentsData } = useQuery({
        queryKey: ['posts-comments'],
        queryFn: getComments,
      })
    
      // ...
    }
    

    // app/posts/posts.tsx
    'use client'
    
    export default function Posts() {
      // This useQuery could just as well happen in some deeper
      // child to <Posts>, data will be available immediately either way
      const { data } = useQuery({
        queryKey: ['posts'],
        queryFn: () => getPosts(),
      })
    
      // This query was not prefetched on the server and will not start
      // fetching until on the client, both patterns are fine to mix.
      const { data: commentsData } = useQuery({
        queryKey: ['posts-comments'],
        queryFn: getComments,
      })
    
      // ...
    }
    

One neat thing about the examples above is that the only thing that is Next.js-specific here are the file names, everything else would look the same in any other framework that supports Server Components.

In the SSR guide, we noted that you could get rid of the boilerplate of having <HydrationBoundary> in every route. This is not possible with Server Components.

> NOTE: If you encounter a type error while using async Server Components with TypeScript versions lower than 5.1.3 and @types/react versions lower than 18.2.8, it is recommended to update to the latest versions of both. Alternatively, you can use the temporary workaround of adding {/\* @ts-expect-error Server Component \*/} when calling this component inside another. For more information, see [Async Server Component TypeScript Error](https://nextjs.org/docs/app/building-your-application/configuring/typescript#async-server-component-typescript-error) in the Next.js 13 docs.

> NOTE: If you encounter an error Only plain objects, and a few built-ins, can be passed to Server Actions. Classes or null prototypes are not supported. make sure that you're **not** passing to queryFn a function reference, instead call the function because queryFn args has a bunch of properties and not all of it would be serializable. see [Server Action only works when queryFn isn't a reference](https://github.com/TanStack/query/issues/6264).

### [](#nesting-server-components)[Nesting Server Components](#nesting-server-components)

A nice thing about Server Components is that they can be nested and exist on many levels in the React tree, making it possible to prefetch data closer to where it's actually used instead of only at the top of the application (just like Remix loaders). This can be as simple as a Server Component rendering another Server Component (we'll leave the Client Components out in this example for brevity):

    // app/posts/page.tsx
    import {
      dehydrate,
      HydrationBoundary,
      QueryClient,
    } from '@tanstack/react-query'
    import Posts from './posts'
    import CommentsServerComponent from './comments-server'
    
    export default async function PostsPage() {
      const queryClient = new QueryClient()
    
      await queryClient.prefetchQuery({
        queryKey: ['posts'],
        queryFn: getPosts,
      })
    
      return (
        <HydrationBoundary state={dehydrate(queryClient)}>
          <Posts />
          <CommentsServerComponent />
        </HydrationBoundary>
      )
    }
    
    // app/posts/comments-server.tsx
    import {
      dehydrate,
      HydrationBoundary,
      QueryClient,
    } from '@tanstack/react-query'
    import Comments from './comments'
    
    export default async function CommentsServerComponent() {
      const queryClient = new QueryClient()
    
      await queryClient.prefetchQuery({
        queryKey: ['posts-comments'],
        queryFn: getComments,
      })
    
      return (
        <HydrationBoundary state={dehydrate(queryClient)}>
          <Comments />
        </HydrationBoundary>
      )
    }
    

    // app/posts/page.tsx
    import {
      dehydrate,
      HydrationBoundary,
      QueryClient,
    } from '@tanstack/react-query'
    import Posts from './posts'
    import CommentsServerComponent from './comments-server'
    
    export default async function PostsPage() {
      const queryClient = new QueryClient()
    
      await queryClient.prefetchQuery({
        queryKey: ['posts'],
        queryFn: getPosts,
      })
    
      return (
        <HydrationBoundary state={dehydrate(queryClient)}>
          <Posts />
          <CommentsServerComponent />
        </HydrationBoundary>
      )
    }
    
    // app/posts/comments-server.tsx
    import {
      dehydrate,
      HydrationBoundary,
      QueryClient,
    } from '@tanstack/react-query'
    import Comments from './comments'
    
    export default async function CommentsServerComponent() {
      const queryClient = new QueryClient()
    
      await queryClient.prefetchQuery({
        queryKey: ['posts-comments'],
        queryFn: getComments,
      })
    
      return (
        <HydrationBoundary state={dehydrate(queryClient)}>
          <Comments />
        </HydrationBoundary>
      )
    }
    

As you can see, it's perfectly fine to use <HydrationBoundary> in multiple places, and create and dehydrate multiple queryClient for prefetching.

Note that because we are awaiting getPosts before rendering CommentsServerComponent this would lead to a server side waterfall:

    1. |> getPosts()
    2.   |> getComments()
    

    1. |> getPosts()
    2.   |> getComments()
    

If the server latency to the data is low, this might not be a huge issue, but is still worth pointing out.

In Next.js, besides prefetching data in page.tsx, you can also do it in layout.tsx, and in [parallel routes](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes). Because these are all part of the routing, Next.js knows how to fetch them all in parallel. So if CommentsServerComponent above was instead expressed as a parallel route, the waterfall would be flattened automatically.

As more frameworks start supporting Server Components, they might have other routing conventions. Read your framework docs for details.

### [](#alternative-use-a-single-queryclient-for-prefetching)[Alternative: Use a single queryClient for prefetching](#alternative-use-a-single-queryclient-for-prefetching)

In the example above, we create a new queryClient for each Server Component that fetches data. This is the recommended approach, but if you want to, you can alternatively create a single one that is reused across all Server Components:

    // app/getQueryClient.tsx
    import { QueryClient } from '@tanstack/react-query'
    import { cache } from 'react'
    
    // cache() is scoped per request, so we don't leak data between requests
    const getQueryClient = cache(() => new QueryClient())
    export default getQueryClient
    

    // app/getQueryClient.tsx
    import { QueryClient } from '@tanstack/react-query'
    import { cache } from 'react'
    
    // cache() is scoped per request, so we don't leak data between requests
    const getQueryClient = cache(() => new QueryClient())
    export default getQueryClient
    

The benefit of this is that you can call getQueryClient() to get a hold of this client anywhere that gets called from a Server Component, including utility functions. The downside is that every time you call dehydrate(getQueryClient()), you serialize _the entire_ queryClient, including queries that have already been serialized before and are unrelated to the current Server Component which is unnecessary overhead.

Next.js already dedupes requests that utilize fetch(), but if you are using something else in your queryFn, or if you use a framework that does _not_ dedupe these requests automatically, using a single queryClient as described above might make sense, despite the duplicated serialization.

> As a future improvement, we might look into creating a dehydrateNew() function (name pending) that only dehydrate queries that are _new_ since the last call to dehydrateNew(). Feel free to get in touch if this sounds interesting and like something you want to help out with!

### [](#data-ownership-and-revalidation)[Data ownership and revalidation](#data-ownership-and-revalidation)

With Server Components, it's important to think about data ownership and revalidation. To explain why, let's look at a modified example from above:

    // app/posts/page.tsx
    import {
      dehydrate,
      HydrationBoundary,
      QueryClient,
    } from '@tanstack/react-query'
    import Posts from './posts'
    
    export default async function PostsPage() {
      const queryClient = new QueryClient()
    
      // Note we are now using fetchQuery()
      const posts = await queryClient.fetchQuery({
        queryKey: ['posts'],
        queryFn: getPosts,
      })
    
      return (
        <HydrationBoundary state={dehydrate(queryClient)}>
          {/* This is the new part */}
          <div>Nr of posts: {posts.length}</div>
          <Posts />
        </HydrationBoundary>
      )
    }
    

    // app/posts/page.tsx
    import {
      dehydrate,
      HydrationBoundary,
      QueryClient,
    } from '@tanstack/react-query'
    import Posts from './posts'
    
    export default async function PostsPage() {
      const queryClient = new QueryClient()
    
      // Note we are now using fetchQuery()
      const posts = await queryClient.fetchQuery({
        queryKey: ['posts'],
        queryFn: getPosts,
      })
    
      return (
        <HydrationBoundary state={dehydrate(queryClient)}>
          {/* This is the new part */}
          <div>Nr of posts: {posts.length}</div>
          <Posts />
        </HydrationBoundary>
      )
    }
    

We are now rendering data from the getPosts query both in a Server Component and in a Client Component. This will be fine for the initial page render, but what happens when the query revalidates on the client for some reason when staleTime has been passed?

React Query has no idea of how to _revalidate the Server Component_, so if it refetches the data on the client, causing React to rerender the list of posts, the Nr of posts: {posts.length} will end up out of sync.

This is fine if you set staleTime: Infinity, so that React Query never revalidates, but this is probably not what you want if you are using React Query in the first place.

Using React Query with Server Components makes most sense if:

*   You have an app using React Query and want to migrate to Server Components without rewriting all the data fetching
*   You want a familiar programming paradigm, but want to still sprinkle in the benefits of Server Components where it makes most sense
*   You have some use case that React Query covers, but that your framework of choice does not cover

It's hard to give general advice on when it makes sense to pair React Query with Server Components and not. **If you are just starting out with a new Server Components app, we suggest you start out with any tools for data fetching your framework provides you with and avoid bringing in React Query until you actually need it.** This might be never, and that's fine, use the right tool for the job!

If you do use it, a good rule of thumb is to avoid queryClient.fetchQuery unless you need to catch errors. If you do use it, don't render its result on the server or pass the result to another component, even a Client Component one.

From the React Query perspective, treat Server Components as a place to prefetch data, nothing more.

Of course, it's fine to have Server Components own some data, and Client Components own other, just make sure those two realities don't get out of sync.

[](#streaming-with-server-components)[Streaming with Server Components](#streaming-with-server-components)
----------------------------------------------------------------------------------------------------------

The Next.js app router automatically streams any part of the application that is ready to be displayed to the browser as soon as possible, so finished content can be displayed immediately without waiting for still pending content. It does this along <Suspense> boundary lines. Note that if you create a file loading.tsx, this automatically creates a <Suspense> boundary behind the scenes.

With the prefetching patterns described above, React Query is perfectly compatible with this form of streaming. As the data for each Suspense boundary resolves, Next.js can render and stream the finished content to the browser. This works even if you are using useQuery as outlined above because the suspending actually happens when you await the prefetch.

As of React Query v5.40.0, you don't have to await all prefetches for this to work, as pending Queries can also be dehydrated and sent to the client. This lets you kick off prefetches as early as possible without letting them block an entire Suspense boundary, and streams the _data_ to the client as the query finishes. This can be useful for example if you want to prefetch some content that is only visible after some user interaction, or say if you want to await and render the first page of an infinite query, but start prefetching page 2 without blocking rendering.

To make this work, we have to instruct the queryClient to also dehydrate pending Queries. We can do this globally, or by passing that option directly to dehydrate.

We will also need to move the getQueryClient() function out of our app/providers.tsx file as we want to use it in our server component and our client provider.

    // app/get-query-client.ts
    import {
      isServer,
      QueryClient,
      defaultShouldDehydrateQuery,
    } from '@tanstack/react-query'
    
    function makeQueryClient() {
      return new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: 60 * 1000,
          },
          dehydrate: {
            // include pending queries in dehydration
            shouldDehydrateQuery: (query) =>
              defaultShouldDehydrateQuery(query) ||
              query.state.status === 'pending',
            shouldRedactErrors: (error) => {
              // We should not catch Next.js server errors
              // as that's how Next.js detects dynamic pages
              // so we cannot redact them.
              // Next.js also automatically redacts errors for us
              // with better digests.
              return false
            },
          },
        },
      })
    }
    
    let browserQueryClient: QueryClient | undefined = undefined
    
    export function getQueryClient() {
      if (isServer) {
        // Server: always make a new query client
        return makeQueryClient()
      } else {
        // Browser: make a new query client if we don't already have one
        // This is very important, so we don't re-make a new client if React
        // suspends during the initial render. This may not be needed if we
        // have a suspense boundary BELOW the creation of the query client
        if (!browserQueryClient) browserQueryClient = makeQueryClient()
        return browserQueryClient
      }
    }
    

    // app/get-query-client.ts
    import {
      isServer,
      QueryClient,
      defaultShouldDehydrateQuery,
    } from '@tanstack/react-query'
    
    function makeQueryClient() {
      return new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: 60 * 1000,
          },
          dehydrate: {
            // include pending queries in dehydration
            shouldDehydrateQuery: (query) =>
              defaultShouldDehydrateQuery(query) ||
              query.state.status === 'pending',
            shouldRedactErrors: (error) => {
              // We should not catch Next.js server errors
              // as that's how Next.js detects dynamic pages
              // so we cannot redact them.
              // Next.js also automatically redacts errors for us
              // with better digests.
              return false
            },
          },
        },
      })
    }
    
    let browserQueryClient: QueryClient | undefined = undefined
    
    export function getQueryClient() {
      if (isServer) {
        // Server: always make a new query client
        return makeQueryClient()
      } else {
        // Browser: make a new query client if we don't already have one
        // This is very important, so we don't re-make a new client if React
        // suspends during the initial render. This may not be needed if we
        // have a suspense boundary BELOW the creation of the query client
        if (!browserQueryClient) browserQueryClient = makeQueryClient()
        return browserQueryClient
      }
    }
    

> Note: This works in NextJs and Server Components because React can serialize Promises over the wire when you pass them down to Client Components.

Then, all we need to do is provide a HydrationBoundary, but we don't need to await prefetches anymore:

    // app/posts/page.tsx
    import { dehydrate, HydrationBoundary } from '@tanstack/react-query'
    import { getQueryClient } from './get-query-client'
    import Posts from './posts'
    
    // the function doesn't need to be `async` because we don't `await` anything
    export default function PostsPage() {
      const queryClient = getQueryClient()
    
      // look ma, no await
      queryClient.prefetchQuery({
        queryKey: ['posts'],
        queryFn: getPosts,
      })
    
      return (
        <HydrationBoundary state={dehydrate(queryClient)}>
          <Posts />
        </HydrationBoundary>
      )
    }
    

    // app/posts/page.tsx
    import { dehydrate, HydrationBoundary } from '@tanstack/react-query'
    import { getQueryClient } from './get-query-client'
    import Posts from './posts'
    
    // the function doesn't need to be `async` because we don't `await` anything
    export default function PostsPage() {
      const queryClient = getQueryClient()
    
      // look ma, no await
      queryClient.prefetchQuery({
        queryKey: ['posts'],
        queryFn: getPosts,
      })
    
      return (
        <HydrationBoundary state={dehydrate(queryClient)}>
          <Posts />
        </HydrationBoundary>
      )
    }
    

On the client, the Promise will be put into the QueryCache for us. That means we can now call useSuspenseQuery inside the Posts component to "use" that Promise (which was created on the Server):

    // app/posts/posts.tsx
    'use client'
    
    export default function Posts() {
      const { data } = useSuspenseQuery({ queryKey: ['posts'], queryFn: getPosts })
    
      // ...
    }
    

    // app/posts/posts.tsx
    'use client'
    
    export default function Posts() {
      const { data } = useSuspenseQuery({ queryKey: ['posts'], queryFn: getPosts })
    
      // ...
    }
    

> Note that you could also useQuery instead of useSuspenseQuery, and the Promise would still be picked up correctly. However, NextJs won't suspend in that case and the component will render in the pending status, which also opts out of server rendering the content.

If you're using non-JSON data types and serialize the query results on the server, you can specify the dehydrate.serializeData and hydrate.deserializeData options to serialize and deserialize the data on each side of the boundary to ensure the data in the cache is the same format both on the server and the client:

    // app/get-query-client.ts
    import { QueryClient, defaultShouldDehydrateQuery } from '@tanstack/react-query'
    import { deserialize, serialize } from './transformer'
    
    function makeQueryClient() {
      return new QueryClient({
        defaultOptions: {
          // ...
          hydrate: {
            deserializeData: deserialize,
          },
          dehydrate: {
            serializeData: serialize,
          },
        },
      })
    }
    
    // ...
    

    // app/get-query-client.ts
    import { QueryClient, defaultShouldDehydrateQuery } from '@tanstack/react-query'
    import { deserialize, serialize } from './transformer'
    
    function makeQueryClient() {
      return new QueryClient({
        defaultOptions: {
          // ...
          hydrate: {
            deserializeData: deserialize,
          },
          dehydrate: {
            serializeData: serialize,
          },
        },
      })
    }
    
    // ...
    

    // app/posts/page.tsx
    import {
      dehydrate,
      HydrationBoundary,
      QueryClient,
    } from '@tanstack/react-query'
    import { getQueryClient } from './get-query-client'
    import { serialize } from './transformer'
    import Posts from './posts'
    
    export default function PostsPage() {
      const queryClient = getQueryClient()
    
      // look ma, no await
      queryClient.prefetchQuery({
        queryKey: ['posts'],
        queryFn: () => getPosts().then(serialize), // <-- serialize the data on the server
      })
    
      return (
        <HydrationBoundary state={dehydrate(queryClient)}>
          <Posts />
        </HydrationBoundary>
      )
    }
    

    // app/posts/page.tsx
    import {
      dehydrate,
      HydrationBoundary,
      QueryClient,
    } from '@tanstack/react-query'
    import { getQueryClient } from './get-query-client'
    import { serialize } from './transformer'
    import Posts from './posts'
    
    export default function PostsPage() {
      const queryClient = getQueryClient()
    
      // look ma, no await
      queryClient.prefetchQuery({
        queryKey: ['posts'],
        queryFn: () => getPosts().then(serialize), // <-- serialize the data on the server
      })
    
      return (
        <HydrationBoundary state={dehydrate(queryClient)}>
          <Posts />
        </HydrationBoundary>
      )
    }
    

    // app/posts/posts.tsx
    'use client'
    
    export default function Posts() {
      const { data } = useSuspenseQuery({ queryKey: ['posts'], queryFn: getPosts })
    
      // ...
    }
    

    // app/posts/posts.tsx
    'use client'
    
    export default function Posts() {
      const { data } = useSuspenseQuery({ queryKey: ['posts'], queryFn: getPosts })
    
      // ...
    }
    

Now, your getPosts function can return e.g. Temporal datetime objects and the data will be serialized and deserialized on the client, assuming your transformer can serialize and deserialize those data types.

For more information, check out the [Next.js App with Prefetching Example](https://tanstack.com/query/latest/docs/framework/react/examples/nextjs-app-prefetching).

[](#experimental-streaming-without-prefetching-in-nextjs)[Experimental streaming without prefetching in Next.js](#experimental-streaming-without-prefetching-in-nextjs)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

While we recommend the prefetching solution detailed above because it flattens request waterfalls both on the initial page load **and** any subsequent page navigation, there is an experimental way to skip prefetching altogether and still have streaming SSR work: @tanstack/react-query-next-experimental

This package will allow you to fetch data on the server (in a Client Component) by just calling useSuspenseQuery in your component. Results will then be streamed from the server to the client as SuspenseBoundaries resolve. If you call useSuspenseQuery without wrapping it in a <Suspense> boundary, the HTML response won't start until the fetch resolves. This can be when you want depending on the situation, but keep in mind that this will hurt your TTFB.

To achieve this, wrap your app in the ReactQueryStreamedHydration component:

    // app/providers.tsx
    'use client'
    
    import {
      isServer,
      QueryClient,
      QueryClientProvider,
    } from '@tanstack/react-query'
    import * as React from 'react'
    import { ReactQueryStreamedHydration } from '@tanstack/react-query-next-experimental'
    
    function makeQueryClient() {
      return new QueryClient({
        defaultOptions: {
          queries: {
            // With SSR, we usually want to set some default staleTime
            // above 0 to avoid refetching immediately on the client
            staleTime: 60 * 1000,
          },
        },
      })
    }
    
    let browserQueryClient: QueryClient | undefined = undefined
    
    function getQueryClient() {
      if (isServer) {
        // Server: always make a new query client
        return makeQueryClient()
      } else {
        // Browser: make a new query client if we don't already have one
        // This is very important, so we don't re-make a new client if React
        // suspends during the initial render. This may not be needed if we
        // have a suspense boundary BELOW the creation of the query client
        if (!browserQueryClient) browserQueryClient = makeQueryClient()
        return browserQueryClient
      }
    }
    
    export function Providers(props: { children: React.ReactNode }) {
      // NOTE: Avoid useState when initializing the query client if you don't
      //       have a suspense boundary between this and the code that may
      //       suspend because React will throw away the client on the initial
      //       render if it suspends and there is no boundary
      const queryClient = getQueryClient()
    
      return (
        <QueryClientProvider client={queryClient}>
          <ReactQueryStreamedHydration>
            {props.children}
          </ReactQueryStreamedHydration>
        </QueryClientProvider>
      )
    }
    

    // app/providers.tsx
    'use client'
    
    import {
      isServer,
      QueryClient,
      QueryClientProvider,
    } from '@tanstack/react-query'
    import * as React from 'react'
    import { ReactQueryStreamedHydration } from '@tanstack/react-query-next-experimental'
    
    function makeQueryClient() {
      return new QueryClient({
        defaultOptions: {
          queries: {
            // With SSR, we usually want to set some default staleTime
            // above 0 to avoid refetching immediately on the client
            staleTime: 60 * 1000,
          },
        },
      })
    }
    
    let browserQueryClient: QueryClient | undefined = undefined
    
    function getQueryClient() {
      if (isServer) {
        // Server: always make a new query client
        return makeQueryClient()
      } else {
        // Browser: make a new query client if we don't already have one
        // This is very important, so we don't re-make a new client if React
        // suspends during the initial render. This may not be needed if we
        // have a suspense boundary BELOW the creation of the query client
        if (!browserQueryClient) browserQueryClient = makeQueryClient()
        return browserQueryClient
      }
    }
    
    export function Providers(props: { children: React.ReactNode }) {
      // NOTE: Avoid useState when initializing the query client if you don't
      //       have a suspense boundary between this and the code that may
      //       suspend because React will throw away the client on the initial
      //       render if it suspends and there is no boundary
      const queryClient = getQueryClient()
    
      return (
        <QueryClientProvider client={queryClient}>
          <ReactQueryStreamedHydration>
            {props.children}
          </ReactQueryStreamedHydration>
        </QueryClientProvider>
      )
    }
    

For more information, check out the [NextJs Suspense Streaming Example](https://tanstack.com/query/latest/docs/framework/react/examples/nextjs-suspense-streaming).

The big upside is that you no longer need to prefetch queries manually to have SSR work, and it even still streams in the result! This gives you phenomenal DX and lower code complexity.

The downside is easiest to explain if we look back at [the complex request waterfall example](https://tanstack.com/query/latest/docs/framework/react/guides/request-waterfalls#code-splitting) in the Performance & Request Waterfalls guide. Server Components with prefetching effectively eliminates the request waterfalls both for the initial page load **and** any subsequent navigation. This prefetch-less approach however will only flatten the waterfalls on the initial page load but ends up the same deep waterfall as the original example on page navigations:

    1. |> JS for <Feed>
    2.   |> getFeed()
    3.     |> JS for <GraphFeedItem>
    4.       |> getGraphDataById()
    

    1. |> JS for <Feed>
    2.   |> getFeed()
    3.     |> JS for <GraphFeedItem>
    4.       |> getGraphDataById()
    

This is even worse than with getServerSideProps/getStaticProps, since with those we could at least parallelize data- and code-fetching.

If you value DX/iteration/shipping speed with low code complexity over performance, don't have deeply nested queries, or are on top of your request waterfalls with parallel fetching using tools like useSuspenseQueries, this can be a good tradeoff.

> It might be possible to combine the two approaches, but even we haven't tried that out yet. If you do try this, please report back your findings, or even update these docs with some tips!

[](#final-words)[Final words](#final-words)
-------------------------------------------

Server Components and streaming are still fairly new concepts and we are still figuring out how React Query fits in and what improvements we can make to the API. We welcome suggestions, feedback and bug reports!

Similarly, it would be impossible to teach all the intricacies of this new paradigm all in one guide, on the first try. If you are missing some piece of information here or have suggestions on how to improve this content, also get in touch, or even better, click the "Edit on GitHub" button below and help us out.

[](#further-reading)[Further reading](#further-reading)
-------------------------------------------------------

To understand if your application can benefit from React Query when also using Server Components, see the article [You Might Not Need React Query](https://tkdodo.eu/blog/you-might-not-need-react-query).</content>
</page>

<page>
  <title>Prefetching & Router Integration | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/prefetching</url>
  <content>When you know or suspect that a certain piece of data will be needed, you can use prefetching to populate the cache with that data ahead of time, leading to a faster experience.

There are a few different prefetching patterns:

1.  In event handlers
2.  In components
3.  Via router integration
4.  During Server Rendering (another form of router integration)

In this guide, we'll take a look at the first three, while the fourth will be covered in depth in the [Server Rendering & Hydration guide](https://tanstack.com/query/latest/docs/framework/react/guides/ssr) and the [Advanced Server Rendering guide](https://tanstack.com/query/latest/docs/framework/react/guides/advanced-ssr).

One specific use of prefetching is to avoid Request Waterfalls, for an in-depth background and explanation of those, see the [Performance & Request Waterfalls guide](https://tanstack.com/query/latest/docs/framework/react/guides/request-waterfalls).

[](#prefetchquery--prefetchinfinitequery)[prefetchQuery & prefetchInfiniteQuery](#prefetchquery--prefetchinfinitequery)
-----------------------------------------------------------------------------------------------------------------------

Before jumping into the different specific prefetch patterns, let's look at the prefetchQuery and prefetchInfiniteQuery functions. First a few basics:

*   Out of the box, these functions use the default staleTime configured for the queryClient to determine whether existing data in the cache is fresh or needs to be fetched again
*   You can also pass a specific staleTime like this: prefetchQuery({ queryKey: \['todos'\], queryFn: fn, staleTime: 5000 })
    *   This staleTime is only used for the prefetch, you still need to set it for any useQuery call as well
    *   If you want to ignore staleTime and instead always return data if it's available in the cache, you can use the ensureQueryData function.
    *   Tip: If you are prefetching on the server, set a default staleTime higher than 0 for that queryClient to avoid having to pass in a specific staleTime to each prefetch call
*   If no instances of useQuery appear for a prefetched query, it will be deleted and garbage collected after the time specified in gcTime
*   These functions returns Promise<void> and thus never return query data. If that's something you need, use fetchQuery/fetchInfiniteQuery instead.
*   The prefetch functions never throws errors because they usually try to fetch again in a useQuery which is a nice graceful fallback. If you need to catch errors, use fetchQuery/fetchInfiniteQuery instead.

This is how you use prefetchQuery:

    const prefetchTodos = async () => {
      // The results of this query will be cached like a normal query
      await queryClient.prefetchQuery({
        queryKey: ['todos'],
        queryFn: fetchTodos,
      })
    }
    

    const prefetchTodos = async () => {
      // The results of this query will be cached like a normal query
      await queryClient.prefetchQuery({
        queryKey: ['todos'],
        queryFn: fetchTodos,
      })
    }
    

Infinite Queries can be prefetched like regular Queries. Per default, only the first page of the Query will be prefetched and will be stored under the given QueryKey. If you want to prefetch more than one page, you can use the pages option, in which case you also have to provide a getNextPageParam function:

    const prefetchProjects = async () => {
      // The results of this query will be cached like a normal query
      await queryClient.prefetchInfiniteQuery({
        queryKey: ['projects'],
        queryFn: fetchProjects,
        initialPageParam: 0,
        getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
        pages: 3, // prefetch the first 3 pages
      })
    }
    

    const prefetchProjects = async () => {
      // The results of this query will be cached like a normal query
      await queryClient.prefetchInfiniteQuery({
        queryKey: ['projects'],
        queryFn: fetchProjects,
        initialPageParam: 0,
        getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
        pages: 3, // prefetch the first 3 pages
      })
    }
    

Next, let's look at how you can use these and other ways to prefetch in different situations.

[](#prefetch-in-event-handlers)[Prefetch in event handlers](#prefetch-in-event-handlers)
----------------------------------------------------------------------------------------

A straightforward form of prefetching is doing it when the user interacts with something. In this example we'll use queryClient.prefetchQuery to start a prefetch on onMouseEnter or onFocus.

    function ShowDetailsButton() {
      const queryClient = useQueryClient()
    
      const prefetch = () => {
        queryClient.prefetchQuery({
          queryKey: ['details'],
          queryFn: getDetailsData,
          // Prefetch only fires when data is older than the staleTime,
          // so in a case like this you definitely want to set one
          staleTime: 60000,
        })
      }
    
      return (
        <button onMouseEnter={prefetch} onFocus={prefetch} onClick={...}>
          Show Details
        </button>
      )
    }
    

    function ShowDetailsButton() {
      const queryClient = useQueryClient()
    
      const prefetch = () => {
        queryClient.prefetchQuery({
          queryKey: ['details'],
          queryFn: getDetailsData,
          // Prefetch only fires when data is older than the staleTime,
          // so in a case like this you definitely want to set one
          staleTime: 60000,
        })
      }
    
      return (
        <button onMouseEnter={prefetch} onFocus={prefetch} onClick={...}>
          Show Details
        </button>
      )
    }
    

[](#prefetch-in-components)[Prefetch in components](#prefetch-in-components)
----------------------------------------------------------------------------

Prefetching during the component lifecycle is useful when we know some child or descendant will need a particular piece of data, but we can't render that until some other query has finished loading. Let's borrow an example from the Request Waterfall guide to explain:

    function Article({ id }) {
      const { data: articleData, isPending } = useQuery({
        queryKey: ['article', id],
        queryFn: getArticleById,
      })
    
      if (isPending) {
        return 'Loading article...'
      }
    
      return (
        <>
          <ArticleHeader articleData={articleData} />
          <ArticleBody articleData={articleData} />
          <Comments id={id} />
        </>
      )
    }
    
    function Comments({ id }) {
      const { data, isPending } = useQuery({
        queryKey: ['article-comments', id],
        queryFn: getArticleCommentsById,
      })
    
      ...
    }
    

    function Article({ id }) {
      const { data: articleData, isPending } = useQuery({
        queryKey: ['article', id],
        queryFn: getArticleById,
      })
    
      if (isPending) {
        return 'Loading article...'
      }
    
      return (
        <>
          <ArticleHeader articleData={articleData} />
          <ArticleBody articleData={articleData} />
          <Comments id={id} />
        </>
      )
    }
    
    function Comments({ id }) {
      const { data, isPending } = useQuery({
        queryKey: ['article-comments', id],
        queryFn: getArticleCommentsById,
      })
    
      ...
    }
    

This results in a request waterfall looking like this:

    1. |> getArticleById()
    2.   |> getArticleCommentsById()
    

    1. |> getArticleById()
    2.   |> getArticleCommentsById()
    

As mentioned in that guide, one way to flatten this waterfall and improve performance is to hoist the getArticleCommentsById query to the parent and pass down the result as a prop, but what if this is not feasible or desirable, for example when the components are unrelated and have multiple levels between them?

In that case, we can instead prefetch the query in the parent. The simplest way to do this is to use a query but ignore the result:

    function Article({ id }) {
      const { data: articleData, isPending } = useQuery({
        queryKey: ['article', id],
        queryFn: getArticleById,
      })
    
      // Prefetch
      useQuery({
        queryKey: ['article-comments', id],
        queryFn: getArticleCommentsById,
        // Optional optimization to avoid rerenders when this query changes:
        notifyOnChangeProps: [],
      })
    
      if (isPending) {
        return 'Loading article...'
      }
    
      return (
        <>
          <ArticleHeader articleData={articleData} />
          <ArticleBody articleData={articleData} />
          <Comments id={id} />
        </>
      )
    }
    
    function Comments({ id }) {
      const { data, isPending } = useQuery({
        queryKey: ['article-comments', id],
        queryFn: getArticleCommentsById,
      })
    
      ...
    }
    

    function Article({ id }) {
      const { data: articleData, isPending } = useQuery({
        queryKey: ['article', id],
        queryFn: getArticleById,
      })
    
      // Prefetch
      useQuery({
        queryKey: ['article-comments', id],
        queryFn: getArticleCommentsById,
        // Optional optimization to avoid rerenders when this query changes:
        notifyOnChangeProps: [],
      })
    
      if (isPending) {
        return 'Loading article...'
      }
    
      return (
        <>
          <ArticleHeader articleData={articleData} />
          <ArticleBody articleData={articleData} />
          <Comments id={id} />
        </>
      )
    }
    
    function Comments({ id }) {
      const { data, isPending } = useQuery({
        queryKey: ['article-comments', id],
        queryFn: getArticleCommentsById,
      })
    
      ...
    }
    

This starts fetching 'article-comments' immediately and flattens the waterfall:

    1. |> getArticleById()
    1. |> getArticleCommentsById()
    

    1. |> getArticleById()
    1. |> getArticleCommentsById()
    

If you want to prefetch together with Suspense, you will have to do things a bit differently. You can't use useSuspenseQueries to prefetch, since the prefetch would block the component from rendering. You also can not use useQuery for the prefetch, because that wouldn't start the prefetch until after suspenseful query had resolved. For this scenario, you can use the [usePrefetchQuery](https://tanstack.com/query/latest/docs/framework/react/reference/usePrefetchQuery) or the [usePrefetchInfiniteQuery](https://tanstack.com/query/latest/docs/framework/react/reference/usePrefetchInfiniteQuery) hooks available in the library.

You can now use useSuspenseQuery in the component that actually needs the data. You _might_ want to wrap this later component in its own <Suspense> boundary so the "secondary" query we are prefetching does not block rendering of the "primary" data.

    function ArticleLayout({ id }) {
      usePrefetchQuery({
        queryKey: ['article-comments', id],
        queryFn: getArticleCommentsById,
      })
    
      return (
        <Suspense fallback="Loading article">
          <Article id={id} />
        </Suspense>
      )
    }
    
    function Article({ id }) {
      const { data: articleData, isPending } = useSuspenseQuery({
        queryKey: ['article', id],
        queryFn: getArticleById,
      })
    
      ...
    }
    

    function ArticleLayout({ id }) {
      usePrefetchQuery({
        queryKey: ['article-comments', id],
        queryFn: getArticleCommentsById,
      })
    
      return (
        <Suspense fallback="Loading article">
          <Article id={id} />
        </Suspense>
      )
    }
    
    function Article({ id }) {
      const { data: articleData, isPending } = useSuspenseQuery({
        queryKey: ['article', id],
        queryFn: getArticleById,
      })
    
      ...
    }
    

Another way is to prefetch inside of the query function. This makes sense if you know that every time an article is fetched it's very likely comments will also be needed. For this, we'll use queryClient.prefetchQuery:

    const queryClient = useQueryClient()
    const { data: articleData, isPending } = useQuery({
      queryKey: ['article', id],
      queryFn: (...args) => {
        queryClient.prefetchQuery({
          queryKey: ['article-comments', id],
          queryFn: getArticleCommentsById,
        })
    
        return getArticleById(...args)
      },
    })
    

    const queryClient = useQueryClient()
    const { data: articleData, isPending } = useQuery({
      queryKey: ['article', id],
      queryFn: (...args) => {
        queryClient.prefetchQuery({
          queryKey: ['article-comments', id],
          queryFn: getArticleCommentsById,
        })
    
        return getArticleById(...args)
      },
    })
    

Prefetching in an effect also works, but note that if you are using useSuspenseQuery in the same component, this effect wont run until _after_ the query finishes which might not be what you want.

    const queryClient = useQueryClient()
    
    useEffect(() => {
      queryClient.prefetchQuery({
        queryKey: ['article-comments', id],
        queryFn: getArticleCommentsById,
      })
    }, [queryClient, id])
    

    const queryClient = useQueryClient()
    
    useEffect(() => {
      queryClient.prefetchQuery({
        queryKey: ['article-comments', id],
        queryFn: getArticleCommentsById,
      })
    }, [queryClient, id])
    

To recap, if you want to prefetch a query during the component lifecycle, there are a few different ways to do it, pick the one that suits your situation best:

*   Prefetch before a suspense boundary using usePrefetchQuery or usePrefetchInfiniteQuery hooks
*   Use useQuery or useSuspenseQueries and ignore the result
*   Prefetch inside the query function
*   Prefetch in an effect

Let's look at a slightly more advanced case next.

### [](#dependent-queries--code-splitting)[Dependent Queries & Code Splitting](#dependent-queries--code-splitting)

Sometimes we want to prefetch conditionally, based on the result of another fetch. Consider this example borrowed from the [Performance & Request Waterfalls guide](https://tanstack.com/query/latest/docs/framework/react/guides/request-waterfalls):

    // This lazy loads the GraphFeedItem component, meaning
    // it wont start loading until something renders it
    const GraphFeedItem = React.lazy(() => import('./GraphFeedItem'))
    
    function Feed() {
      const { data, isPending } = useQuery({
        queryKey: ['feed'],
        queryFn: getFeed,
      })
    
      if (isPending) {
        return 'Loading feed...'
      }
    
      return (
        <>
          {data.map((feedItem) => {
            if (feedItem.type === 'GRAPH') {
              return <GraphFeedItem key={feedItem.id} feedItem={feedItem} />
            }
    
            return <StandardFeedItem key={feedItem.id} feedItem={feedItem} />
          })}
        </>
      )
    }
    
    // GraphFeedItem.tsx
    function GraphFeedItem({ feedItem }) {
      const { data, isPending } = useQuery({
        queryKey: ['graph', feedItem.id],
        queryFn: getGraphDataById,
      })
    
      ...
    }
    

    // This lazy loads the GraphFeedItem component, meaning
    // it wont start loading until something renders it
    const GraphFeedItem = React.lazy(() => import('./GraphFeedItem'))
    
    function Feed() {
      const { data, isPending } = useQuery({
        queryKey: ['feed'],
        queryFn: getFeed,
      })
    
      if (isPending) {
        return 'Loading feed...'
      }
    
      return (
        <>
          {data.map((feedItem) => {
            if (feedItem.type === 'GRAPH') {
              return <GraphFeedItem key={feedItem.id} feedItem={feedItem} />
            }
    
            return <StandardFeedItem key={feedItem.id} feedItem={feedItem} />
          })}
        </>
      )
    }
    
    // GraphFeedItem.tsx
    function GraphFeedItem({ feedItem }) {
      const { data, isPending } = useQuery({
        queryKey: ['graph', feedItem.id],
        queryFn: getGraphDataById,
      })
    
      ...
    }
    

As noted over in that guide, this example leads to the following double request waterfall:

    1. |> getFeed()
    2.   |> JS for <GraphFeedItem>
    3.     |> getGraphDataById()
    

    1. |> getFeed()
    2.   |> JS for <GraphFeedItem>
    3.     |> getGraphDataById()
    

If we can not restructure our API so getFeed() also returns the getGraphDataById() data when necessary, there is no way to get rid of the getFeed->getGraphDataById waterfall, but by leveraging conditional prefetching, we can at least load the code and data in parallel. Just like described above, there are multiple ways to do this, but for this example, we'll do it in the query function:

    function Feed() {
      const queryClient = useQueryClient()
      const { data, isPending } = useQuery({
        queryKey: ['feed'],
        queryFn: async (...args) => {
          const feed = await getFeed(...args)
    
          for (const feedItem of feed) {
            if (feedItem.type === 'GRAPH') {
              queryClient.prefetchQuery({
                queryKey: ['graph', feedItem.id],
                queryFn: getGraphDataById,
              })
            }
          }
    
          return feed
        }
      })
    
      ...
    }
    

    function Feed() {
      const queryClient = useQueryClient()
      const { data, isPending } = useQuery({
        queryKey: ['feed'],
        queryFn: async (...args) => {
          const feed = await getFeed(...args)
    
          for (const feedItem of feed) {
            if (feedItem.type === 'GRAPH') {
              queryClient.prefetchQuery({
                queryKey: ['graph', feedItem.id],
                queryFn: getGraphDataById,
              })
            }
          }
    
          return feed
        }
      })
    
      ...
    }
    

This would load the code and data in parallel:

    1. |> getFeed()
    2.   |> JS for <GraphFeedItem>
    2.   |> getGraphDataById()
    

    1. |> getFeed()
    2.   |> JS for <GraphFeedItem>
    2.   |> getGraphDataById()
    

There is a tradeoff however, in that the code for getGraphDataById is now included in the parent bundle instead of in JS for <GraphFeedItem> so you'll need to determine what's the best performance tradeoff on a case by case basis. If GraphFeedItem are likely, it's probably worth to include the code in the parent. If they are exceedingly rare, it's probably not.

[](#router-integration)[Router Integration](#router-integration)
----------------------------------------------------------------

Because data fetching in the component tree itself can easily lead to request waterfalls and the different fixes for that can be cumbersome as they accumulate throughout the application, an attractive way to do prefetching is integrating it at the router level.

In this approach, you explicitly declare for each _route_ what data is going to be needed for that component tree, ahead of time. Because Server Rendering has traditionally needed all data to be loaded before rendering starts, this has been the dominating approach for SSR'd apps for a long time. This is still a common approach and you can read more about it in the [Server Rendering & Hydration guide](https://tanstack.com/query/latest/docs/framework/react/guides/ssr).

For now, let's focus on the client side case and look at an example of how you can make this work with [Tanstack Router](https://tanstack.com/router). These examples leave out a lot of setup and boilerplate to stay concise, you can check out a [full React Query example](https://tanstack.com/router/.latest/docs/framework/react/examples/basic-react-query-file-based) over in the [Tanstack Router docs](https://tanstack.com/router/latest/docs).

When integrating at the router level, you can choose to either _block_ rendering of that route until all data is present, or you can start a prefetch but not await the result. That way, you can start rendering the route as soon as possible. You can also mix these two approaches and await some critical data, but start rendering before all the secondary data has finished loading. In this example, we'll configure an /article route to not render until the article data has finished loading, as well as start prefetching comments as soon as possible, but not block rendering the route if comments haven't finished loading yet.

    const queryClient = new QueryClient()
    const routerContext = new RouterContext()
    const rootRoute = routerContext.createRootRoute({
      component: () => { ... }
    })
    
    const articleRoute = new Route({
      getParentRoute: () => rootRoute,
      path: 'article',
      beforeLoad: () => {
        return {
          articleQueryOptions: { queryKey: ['article'], queryFn: fetchArticle },
          commentsQueryOptions: { queryKey: ['comments'], queryFn: fetchComments },
        }
      },
      loader: async ({
        context: { queryClient },
        routeContext: { articleQueryOptions, commentsQueryOptions },
      }) => {
        // Fetch comments asap, but don't block
        queryClient.prefetchQuery(commentsQueryOptions)
    
        // Don't render the route at all until article has been fetched
        await queryClient.prefetchQuery(articleQueryOptions)
      },
      component: ({ useRouteContext }) => {
        const { articleQueryOptions, commentsQueryOptions } = useRouteContext()
        const articleQuery = useQuery(articleQueryOptions)
        const commentsQuery = useQuery(commentsQueryOptions)
    
        return (
          ...
        )
      },
      errorComponent: () => 'Oh crap!',
    })
    

    const queryClient = new QueryClient()
    const routerContext = new RouterContext()
    const rootRoute = routerContext.createRootRoute({
      component: () => { ... }
    })
    
    const articleRoute = new Route({
      getParentRoute: () => rootRoute,
      path: 'article',
      beforeLoad: () => {
        return {
          articleQueryOptions: { queryKey: ['article'], queryFn: fetchArticle },
          commentsQueryOptions: { queryKey: ['comments'], queryFn: fetchComments },
        }
      },
      loader: async ({
        context: { queryClient },
        routeContext: { articleQueryOptions, commentsQueryOptions },
      }) => {
        // Fetch comments asap, but don't block
        queryClient.prefetchQuery(commentsQueryOptions)
    
        // Don't render the route at all until article has been fetched
        await queryClient.prefetchQuery(articleQueryOptions)
      },
      component: ({ useRouteContext }) => {
        const { articleQueryOptions, commentsQueryOptions } = useRouteContext()
        const articleQuery = useQuery(articleQueryOptions)
        const commentsQuery = useQuery(commentsQueryOptions)
    
        return (
          ...
        )
      },
      errorComponent: () => 'Oh crap!',
    })
    

Integration with other routers is also possible, see the [react-router](https://tanstack.com/query/latest/docs/framework/react/examples/react-router) for another demonstration.

[](#manually-priming-a-query)[Manually Priming a Query](#manually-priming-a-query)
----------------------------------------------------------------------------------

If you already have the data for your query synchronously available, you don't need to prefetch it. You can just use the [Query Client's setQueryData method](https://tanstack.com/query/latest/docs/reference/QueryClient#queryclientsetquerydata) to directly add or update a query's cached result by key.

    queryClient.setQueryData(['todos'], todos)
    

    queryClient.setQueryData(['todos'], todos)
    

[](#further-reading)[Further reading](#further-reading)
-------------------------------------------------------

For a deep-dive on how to get data into your Query Cache before you fetch, see the [article Seeding the Query Cache by TkDodo](https://tkdodo.eu/blog/seeding-the-query-cache).

Integrating with Server Side routers and frameworks is very similar to what we just saw, with the addition that the data has to passed from the server to the client to be hydrated into the cache there. To learn how, continue on to the [Server Rendering & Hydration guide](https://tanstack.com/query/latest/docs/framework/react/guides/ssr).</content>
</page>

<page>
  <title>Render Optimizations | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/render-optimizations</url>
  <content>React Query applies a couple of optimizations automatically to ensure that your components only re-render when they actually need to. This is done by the following means:

[](#structural-sharing)[structural sharing](#structural-sharing)
----------------------------------------------------------------

React Query uses a technique called "structural sharing" to ensure that as many references as possible will be kept intact between re-renders. If data is fetched over the network, usually, you'll get a completely new reference by json parsing the response. However, React Query will keep the original reference if _nothing_ changed in the data. If a subset changed, React Query will keep the unchanged parts and only replace the changed parts.

> Note: This optimization only works if the queryFn returns JSON compatible data. You can turn it off by setting structuralSharing: false globally or on a per-query basis, or you can implement your own structural sharing by passing a function to it.

### [](#referential-identity)[referential identity](#referential-identity)

The top level object returned from useQuery, useInfiniteQuery, useMutation and the Array returned from useQueries is **not referentially stable**. It will be a new reference on every render. However, the data properties returned from these hooks will be as stable as possible.

[](#tracked-properties)[tracked properties](#tracked-properties)
----------------------------------------------------------------

React Query will only trigger a re-render if one of the properties returned from useQuery is actually "used". This is done by using [Proxy object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy). This avoids a lot of unnecessary re-renders, e.g. because properties like isFetching or isStale might change often, but are not used in the component.

You can customize this feature by setting notifyOnChangeProps manually globally or on a per-query basis. If you want to turn that feature off, you can set notifyOnChangeProps: 'all'.

> Note: The get trap of a proxy is invoked by accessing a property, either via destructuring or by accessing it directly. If you use object rest destructuring, you will disable this optimization. We have a [lint rule](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring) to guard against this pitfall.

[](#select)[select](#select)
----------------------------

You can use the select option to select a subset of the data that your component should subscribe to. This is useful for highly optimized data transformations or to avoid unnecessary re-renders.

    export const useTodos = (select) => {
      return useQuery({
        queryKey: ['todos'],
        queryFn: fetchTodos,
        select,
      })
    }
    
    export const useTodoCount = () => {
      return useTodos((data) => data.length)
    }
    

    export const useTodos = (select) => {
      return useQuery({
        queryKey: ['todos'],
        queryFn: fetchTodos,
        select,
      })
    }
    
    export const useTodoCount = () => {
      return useTodos((data) => data.length)
    }
    

A component using the useTodoCount custom hook will only re-render if the length of the todos changes. It will **not** re-render if e.g. the name of a todo changed.

> Note: select operates on successfully cached data and is not the appropriate place to throw errors. The source of truth for errors is the queryFn, and a select function that returns an error results in data being undefined and isSuccess being true. We recommend handling errors in the queryFn if you wish to have a query fail on incorrect data, or outside of the query hook if you have a error case not related to caching.

### [](#memoization)[memoization](#memoization)

The select function will only re-run if:

*   the select function itself changed referentially
*   data changed

This means that an inlined select function, as shown above, will run on every render. To avoid this, you can wrap the select function in useCallback, or extract it to a stable function reference if it doesn't have any dependencies:

    // wrapped in useCallback
    export const useTodoCount = () => {
      return useTodos(useCallback((data) => data.length, []))
    }
    

    // wrapped in useCallback
    export const useTodoCount = () => {
      return useTodos(useCallback((data) => data.length, []))
    }
    

    // extracted to a stable function reference
    const selectTodoCount = (data) => data.length
    
    export const useTodoCount = () => {
      return useTodos(selectTodoCount)
    }
    

    // extracted to a stable function reference
    const selectTodoCount = (data) => data.length
    
    export const useTodoCount = () => {
      return useTodos(selectTodoCount)
    }
    

[](#further-reading)[Further Reading](#further-reading)
-------------------------------------------------------

For an in-depth guide about these topics, read [React Query Render Optimizations](https://tkdodo.eu/blog/react-query-render-optimizations) from the TkDodo. To learn how to best optimize the select option, read [React Query Selectors, Supercharged](https://tkdodo.eu/blog/react-query-selectors-supercharged)</content>
</page>

<page>
  <title>Caching Examples | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/caching</url>
  <content>> Please thoroughly read the [Important Defaults](https://tanstack.com/query/latest/docs/framework/react/guides/important-defaults) before reading this guide

[](#basic-example)[Basic Example](#basic-example)
-------------------------------------------------

This caching example illustrates the story and lifecycle of:

*   Query Instances with and without cache data
*   Background Refetching
*   Inactive Queries
*   Garbage Collection

Let's assume we are using the default gcTime of **5 minutes** and the default staleTime of 0.

*   A new instance of useQuery({ queryKey: \['todos'\], queryFn: fetchTodos }) mounts.
    *   Since no other queries have been made with the \['todos'\] query key, this query will show a hard loading state and make a network request to fetch the data.
    *   When the network request has completed, the returned data will be cached under the \['todos'\] key.
    *   The hook will mark the data as stale after the configured staleTime (defaults to 0, or immediately).
*   A second instance of useQuery({ queryKey: \['todos'\], queryFn: fetchTodos }) mounts elsewhere.
    *   Since the cache already has data for the \['todos'\] key from the first query, that data is immediately returned from the cache.
    *   The new instance triggers a new network request using its query function.
        *   Note that regardless of whether both fetchTodos query functions are identical or not, both queries' [status](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery) are updated (including isFetching, isPending, and other related values) because they have the same query key.
    *   When the request completes successfully, the cache's data under the \['todos'\] key is updated with the new data, and both instances are updated with the new data.
*   Both instances of the useQuery({ queryKey: \['todos'\], queryFn: fetchTodos }) query are unmounted and no longer in use.
    *   Since there are no more active instances of this query, a garbage collection timeout is set using gcTime to delete and garbage collect the query (defaults to **5 minutes**).
*   Before the cache timeout has completed, another instance of useQuery({ queryKey: \['todos'\], queryFn: fetchTodos }) mounts. The query immediately returns the available cached data while the fetchTodos function is being run in the background. When it completes successfully, it will populate the cache with fresh data.
*   The final instance of useQuery({ queryKey: \['todos'\], queryFn: fetchTodos }) unmounts.
*   No more instances of useQuery({ queryKey: \['todos'\], queryFn: fetchTodos }) appear within **5 minutes**.
    *   The cached data under the \['todos'\] key is deleted and garbage collected.</content>
</page>

<page>
  <title>Suspense | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/suspense</url>
  <content>React Query can also be used with React's Suspense for Data Fetching APIs. For this, we have dedicated hooks:

*   [useSuspenseQuery](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseQuery)
*   [useSuspenseInfiniteQuery](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseInfiniteQuery)
*   [useSuspenseQueries](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseQueries)
*   Additionally, you can use the useQuery().promise and React.use() (Experimental)

When using suspense mode, status states and error objects are not needed and are then replaced by usage of the React.Suspense component (including the use of the fallback prop and React error boundaries for catching errors). Please read the [Resetting Error Boundaries](#resetting-error-boundaries) and look at the [Suspense Example](https://tanstack.com/query/latest/docs/framework/react/examples/suspense) for more information on how to set up suspense mode.

If you want mutations to propagate errors to the nearest error boundary (similar to queries), you can set the throwOnError option to true as well.

Enabling suspense mode for a query:

    import { useSuspenseQuery } from '@tanstack/react-query'
    
    const { data } = useSuspenseQuery({ queryKey, queryFn })
    

    import { useSuspenseQuery } from '@tanstack/react-query'
    
    const { data } = useSuspenseQuery({ queryKey, queryFn })
    

This works nicely in TypeScript, because data is guaranteed to be defined (as errors and loading states are handled by Suspense- and ErrorBoundaries).

On the flip side, you therefore can't conditionally enable / disable the Query. This generally shouldn't be necessary for dependent Queries because with suspense, all your Queries inside one component are fetched in serial.

placeholderData also doesn't exist for this Query. To prevent the UI from being replaced by a fallback during an update, wrap your updates that change the QueryKey into [startTransition](https://react.dev/reference/react/Suspense#preventing-unwanted-fallbacks).

### [](#throwonerror-default)[throwOnError default](#throwonerror-default)

Not all errors are thrown to the nearest Error Boundary per default - we're only throwing errors if there is no other data to show. That means if a Query ever successfully got data in the cache, the component will render, even if data is stale. Thus, the default for throwOnError is:

    throwOnError: (error, query) => typeof query.state.data === 'undefined'
    

    throwOnError: (error, query) => typeof query.state.data === 'undefined'
    

Since you can't change throwOnError (because it would allow for data to become potentially undefined), you have to throw errors manually if you want all errors to be handled by Error Boundaries:

    import { useSuspenseQuery } from '@tanstack/react-query'
    
    const { data, error, isFetching } = useSuspenseQuery({ queryKey, queryFn })
    
    if (error && !isFetching) {
      throw error
    }
    
    // continue rendering data
    

    import { useSuspenseQuery } from '@tanstack/react-query'
    
    const { data, error, isFetching } = useSuspenseQuery({ queryKey, queryFn })
    
    if (error && !isFetching) {
      throw error
    }
    
    // continue rendering data
    

[](#resetting-error-boundaries)[Resetting Error Boundaries](#resetting-error-boundaries)
----------------------------------------------------------------------------------------

Whether you are using **suspense** or **throwOnError** in your queries, you will need a way to let queries know that you want to try again when re-rendering after some error occurred.

Query errors can be reset with the QueryErrorResetBoundary component or with the useQueryErrorResetBoundary hook.

When using the component it will reset any query errors within the boundaries of the component:

    import { QueryErrorResetBoundary } from '@tanstack/react-query'
    import { ErrorBoundary } from 'react-error-boundary'
    
    const App = () => (
      <QueryErrorResetBoundary>
        {({ reset }) => (
          <ErrorBoundary
            onReset={reset}
            fallbackRender={({ resetErrorBoundary }) => (
              <div>
                There was an error!
                <Button onClick={() => resetErrorBoundary()}>Try again</Button>
              </div>
            )}
          >
            <Page />
          </ErrorBoundary>
        )}
      </QueryErrorResetBoundary>
    )
    

    import { QueryErrorResetBoundary } from '@tanstack/react-query'
    import { ErrorBoundary } from 'react-error-boundary'
    
    const App = () => (
      <QueryErrorResetBoundary>
        {({ reset }) => (
          <ErrorBoundary
            onReset={reset}
            fallbackRender={({ resetErrorBoundary }) => (
              <div>
                There was an error!
                <Button onClick={() => resetErrorBoundary()}>Try again</Button>
              </div>
            )}
          >
            <Page />
          </ErrorBoundary>
        )}
      </QueryErrorResetBoundary>
    )
    

When using the hook it will reset any query errors within the closest QueryErrorResetBoundary. If there is no boundary defined it will reset them globally:

    import { useQueryErrorResetBoundary } from '@tanstack/react-query'
    import { ErrorBoundary } from 'react-error-boundary'
    
    const App = () => {
      const { reset } = useQueryErrorResetBoundary()
      return (
        <ErrorBoundary
          onReset={reset}
          fallbackRender={({ resetErrorBoundary }) => (
            <div>
              There was an error!
              <Button onClick={() => resetErrorBoundary()}>Try again</Button>
            </div>
          )}
        >
          <Page />
        </ErrorBoundary>
      )
    }
    

    import { useQueryErrorResetBoundary } from '@tanstack/react-query'
    import { ErrorBoundary } from 'react-error-boundary'
    
    const App = () => {
      const { reset } = useQueryErrorResetBoundary()
      return (
        <ErrorBoundary
          onReset={reset}
          fallbackRender={({ resetErrorBoundary }) => (
            <div>
              There was an error!
              <Button onClick={() => resetErrorBoundary()}>Try again</Button>
            </div>
          )}
        >
          <Page />
        </ErrorBoundary>
      )
    }
    

[](#fetch-on-render-vs-render-as-you-fetch)[Fetch-on-render vs Render-as-you-fetch](#fetch-on-render-vs-render-as-you-fetch)
----------------------------------------------------------------------------------------------------------------------------

Out of the box, React Query in suspense mode works really well as a **Fetch-on-render** solution with no additional configuration. This means that when your components attempt to mount, they will trigger query fetching and suspend, but only once you have imported them and mounted them. If you want to take it to the next level and implement a **Render-as-you-fetch** model, we recommend implementing [Prefetching](https://tanstack.com/query/latest/docs/framework/react/guides/prefetching) on routing callbacks and/or user interactions events to start loading queries before they are mounted and hopefully even before you start importing or mounting their parent components.

[](#suspense-on-the-server-with-streaming)[Suspense on the Server with streaming](#suspense-on-the-server-with-streaming)
-------------------------------------------------------------------------------------------------------------------------

If you are using NextJs, you can use our **experimental** integration for Suspense on the Server: @tanstack/react-query-next-experimental. This package will allow you to fetch data on the server (in a client component) by just calling useSuspenseQuery in your component. Results will then be streamed from the server to the client as SuspenseBoundaries resolve.

To achieve this, wrap your app in the ReactQueryStreamedHydration component:

    // app/providers.tsx
    'use client'
    
    import {
      isServer,
      QueryClient,
      QueryClientProvider,
    } from '@tanstack/react-query'
    import * as React from 'react'
    import { ReactQueryStreamedHydration } from '@tanstack/react-query-next-experimental'
    
    function makeQueryClient() {
      return new QueryClient({
        defaultOptions: {
          queries: {
            // With SSR, we usually want to set some default staleTime
            // above 0 to avoid refetching immediately on the client
            staleTime: 60 * 1000,
          },
        },
      })
    }
    
    let browserQueryClient: QueryClient | undefined = undefined
    
    function getQueryClient() {
      if (isServer) {
        // Server: always make a new query client
        return makeQueryClient()
      } else {
        // Browser: make a new query client if we don't already have one
        // This is very important, so we don't re-make a new client if React
        // suspends during the initial render. This may not be needed if we
        // have a suspense boundary BELOW the creation of the query client
        if (!browserQueryClient) browserQueryClient = makeQueryClient()
        return browserQueryClient
      }
    }
    
    export function Providers(props: { children: React.ReactNode }) {
      // NOTE: Avoid useState when initializing the query client if you don't
      //       have a suspense boundary between this and the code that may
      //       suspend because React will throw away the client on the initial
      //       render if it suspends and there is no boundary
      const queryClient = getQueryClient()
    
      return (
        <QueryClientProvider client={queryClient}>
          <ReactQueryStreamedHydration>
            {props.children}
          </ReactQueryStreamedHydration>
        </QueryClientProvider>
      )
    }
    

    // app/providers.tsx
    'use client'
    
    import {
      isServer,
      QueryClient,
      QueryClientProvider,
    } from '@tanstack/react-query'
    import * as React from 'react'
    import { ReactQueryStreamedHydration } from '@tanstack/react-query-next-experimental'
    
    function makeQueryClient() {
      return new QueryClient({
        defaultOptions: {
          queries: {
            // With SSR, we usually want to set some default staleTime
            // above 0 to avoid refetching immediately on the client
            staleTime: 60 * 1000,
          },
        },
      })
    }
    
    let browserQueryClient: QueryClient | undefined = undefined
    
    function getQueryClient() {
      if (isServer) {
        // Server: always make a new query client
        return makeQueryClient()
      } else {
        // Browser: make a new query client if we don't already have one
        // This is very important, so we don't re-make a new client if React
        // suspends during the initial render. This may not be needed if we
        // have a suspense boundary BELOW the creation of the query client
        if (!browserQueryClient) browserQueryClient = makeQueryClient()
        return browserQueryClient
      }
    }
    
    export function Providers(props: { children: React.ReactNode }) {
      // NOTE: Avoid useState when initializing the query client if you don't
      //       have a suspense boundary between this and the code that may
      //       suspend because React will throw away the client on the initial
      //       render if it suspends and there is no boundary
      const queryClient = getQueryClient()
    
      return (
        <QueryClientProvider client={queryClient}>
          <ReactQueryStreamedHydration>
            {props.children}
          </ReactQueryStreamedHydration>
        </QueryClientProvider>
      )
    }
    

For more information, check out the [NextJs Suspense Streaming Example](https://tanstack.com/query/latest/docs/framework/react/examples/nextjs-suspense-streaming) and the [Advanced Rendering & Hydration](https://tanstack.com/query/latest/docs/framework/react/guides/advanced-ssr) guide.

[](#using-usequerypromise-and-reactuse-experimental)[Using useQuery().promise and React.use() (Experimental)](#using-usequerypromise-and-reactuse-experimental)
---------------------------------------------------------------------------------------------------------------------------------------------------------------

> To enable this feature, you need to set the experimental\_prefetchInRender option to true when creating your QueryClient

**Example code:**

    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          experimental_prefetchInRender: true,
        },
      },
    })
    

    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          experimental_prefetchInRender: true,
        },
      },
    })
    

**Usage:**

    import React from 'react'
    import { useQuery } from '@tanstack/react-query'
    import { fetchTodos, type Todo } from './api'
    
    function TodoList({ query }: { query: UseQueryResult<Todo[]> }) {
      const data = React.use(query.promise)
    
      return (
        <ul>
          {data.map((todo) => (
            <li key={todo.id}>{todo.title}</li>
          ))}
        </ul>
      )
    }
    
    export function App() {
      const query = useQuery({ queryKey: ['todos'], queryFn: fetchTodos })
    
      return (
        <>
          <h1>Todos</h1>
          <React.Suspense fallback={<div>Loading...</div>}>
            <TodoList query={query} />
          </React.Suspense>
        </>
      )
    }
    

    import React from 'react'
    import { useQuery } from '@tanstack/react-query'
    import { fetchTodos, type Todo } from './api'
    
    function TodoList({ query }: { query: UseQueryResult<Todo[]> }) {
      const data = React.use(query.promise)
    
      return (
        <ul>
          {data.map((todo) => (
            <li key={todo.id}>{todo.title}</li>
          ))}
        </ul>
      )
    }
    
    export function App() {
      const query = useQuery({ queryKey: ['todos'], queryFn: fetchTodos })
    
      return (
        <>
          <h1>Todos</h1>
          <React.Suspense fallback={<div>Loading...</div>}>
            <TodoList query={query} />
          </React.Suspense>
        </>
      )
    }
    

For a more complete example, see [suspense example on GitHub](https://github.com/TanStack/query/tree/main/examples/react/suspense).

For a Next.js streaming example, see [nextjs-suspense-streaming example on GitHub](https://github.com/TanStack/query/tree/main/examples/react/nextjs-suspense-streaming).</content>
</page>

<page>
  <title>Default Query Function | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function</url>
  <content>If you find yourself wishing for whatever reason that you could just share the same query function for your entire app and just use query keys to identify what it should fetch, you can do that by providing a **default query function** to TanStack Query:

    // Define a default query function that will receive the query key
    const defaultQueryFn = async ({ queryKey }) => {
      const { data } = await axios.get(
        `https://jsonplaceholder.typicode.com${queryKey[0]}`,
      )
      return data
    }
    
    // provide the default query function to your app with defaultOptions
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          queryFn: defaultQueryFn,
        },
      },
    })
    
    function App() {
      return (
        <QueryClientProvider client={queryClient}>
          <YourApp />
        </QueryClientProvider>
      )
    }
    
    // All you have to do now is pass a key!
    function Posts() {
      const { status, data, error, isFetching } = useQuery({ queryKey: ['/posts'] })
    
      // ...
    }
    
    // You can even leave out the queryFn and just go straight into options
    function Post({ postId }) {
      const { status, data, error, isFetching } = useQuery({
        queryKey: [`/posts/${postId}`],
        enabled: !!postId,
      })
    
      // ...
    }
    

    // Define a default query function that will receive the query key
    const defaultQueryFn = async ({ queryKey }) => {
      const { data } = await axios.get(
        `https://jsonplaceholder.typicode.com${queryKey[0]}`,
      )
      return data
    }
    
    // provide the default query function to your app with defaultOptions
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          queryFn: defaultQueryFn,
        },
      },
    })
    
    function App() {
      return (
        <QueryClientProvider client={queryClient}>
          <YourApp />
        </QueryClientProvider>
      )
    }
    
    // All you have to do now is pass a key!
    function Posts() {
      const { status, data, error, isFetching } = useQuery({ queryKey: ['/posts'] })
    
      // ...
    }
    
    // You can even leave out the queryFn and just go straight into options
    function Post({ postId }) {
      const { status, data, error, isFetching } = useQuery({
        queryKey: [`/posts/${postId}`],
        enabled: !!postId,
      })
    
      // ...
    }
    

If you ever want to override the default queryFn, you can just provide your own like you normally would.</content>
</page>

<page>
  <title>Migrating to React Query 3 | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-react-query-3</url>
  <content>Previous versions of React Query were awesome and brought some amazing new features, more magic, and an overall better experience to the library. They also brought on massive adoption and likewise a lot of refining fire (issues/contributions) to the library and brought to light a few things that needed more polish to make the library even better. v3 contains that very polish.

[](#overview)[Overview](#overview)
----------------------------------

*   More scalable and testable cache configuration
*   Better SSR support
*   Data-lag (previously usePaginatedQuery) anywhere!
*   Bi-directional Infinite Queries
*   Query data selectors!
*   Fully configure defaults for queries and/or mutations before use
*   More granularity for optional rendering optimization
*   New useQueries hook! (Variable-length parallel query execution)
*   Query filter support for the useIsFetching() hook!
*   Retry/offline/replay support for mutations
*   Observe queries/mutations outside of React
*   Use the React Query core logic anywhere you want!
*   Bundled/Colocated Devtools via react-query/devtools
*   Cache Persistence to web storage (experimental via react-query/persistQueryClient-experimental and react-query/createWebStoragePersistor-experimental)

[](#breaking-changes)[Breaking Changes](#breaking-changes)
----------------------------------------------------------

### [](#the-querycache-has-been-split-into-a-queryclient-and-lower-level-querycache-and-mutationcache-instances)[The QueryCache has been split into a QueryClient and lower-level QueryCache and MutationCache instances.](#the-querycache-has-been-split-into-a-queryclient-and-lower-level-querycache-and-mutationcache-instances)

The QueryCache contains all queries, the MutationCache contains all mutations, and the QueryClient can be used to set configuration and to interact with them.

This has some benefits:

*   Allows for different types of caches.
*   Multiple clients with different configurations can use the same cache.
*   Clients can be used to track queries, which can be used for shared caches on SSR.
*   The client API is more focused towards general usage.
*   Easier to test the individual components.

When creating a new QueryClient(), a QueryCache and MutationCache are automatically created for you if you don't supply them.

    import { QueryClient } from 'react-query'
    
    const queryClient = new QueryClient()
    

    import { QueryClient } from 'react-query'
    
    const queryClient = new QueryClient()
    

### [](#reactqueryconfigprovider-and-reactquerycacheprovider-have-both-been-replaced-by-queryclientprovider)[ReactQueryConfigProvider and ReactQueryCacheProvider have both been replaced by QueryClientProvider](#reactqueryconfigprovider-and-reactquerycacheprovider-have-both-been-replaced-by-queryclientprovider)

Default options for queries and mutations can now be specified in QueryClient:

**Notice that it's now defaultOptions instead of defaultConfig**

    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          // query options
        },
        mutations: {
          // mutation options
        },
      },
    })
    

    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          // query options
        },
        mutations: {
          // mutation options
        },
      },
    })
    

The QueryClientProvider component is now used to connect a QueryClient to your application:

    import { QueryClient, QueryClientProvider } from 'react-query'
    
    const queryClient = new QueryClient()
    
    function App() {
      return <QueryClientProvider client={queryClient}>...</QueryClientProvider>
    }
    

    import { QueryClient, QueryClientProvider } from 'react-query'
    
    const queryClient = new QueryClient()
    
    function App() {
      return <QueryClientProvider client={queryClient}>...</QueryClientProvider>
    }
    

### [](#the-default-querycache-is-gone-for-real-this-time)[The default QueryCache is gone. **For real this time!**](#the-default-querycache-is-gone-for-real-this-time)

As previously noted with a deprecation, there is no longer a default QueryCache that is created or exported from the main package. **You must create your own via new QueryClient() or new QueryCache() (which you can then pass to new QueryClient({ queryCache }) )**

### [](#the-deprecated-makequerycache-utility-has-been-removed)[The deprecated makeQueryCache utility has been removed.](#the-deprecated-makequerycache-utility-has-been-removed)

It's been a long time coming, but it's finally gone :)

### [](#querycacheprefetchquery-has-been-moved-to-queryclientprefetchquery)[QueryCache.prefetchQuery() has been moved to QueryClient.prefetchQuery()](#querycacheprefetchquery-has-been-moved-to-queryclientprefetchquery)

The new QueryClient.prefetchQuery() function is async, but **does not return the data from the query**. If you require the data, use the new QueryClient.fetchQuery() function

    // Prefetch a query:
    await queryClient.prefetchQuery('posts', fetchPosts)
    
    // Fetch a query:
    try {
      const data = await queryClient.fetchQuery('posts', fetchPosts)
    } catch (error) {
      // Error handling
    }
    

    // Prefetch a query:
    await queryClient.prefetchQuery('posts', fetchPosts)
    
    // Fetch a query:
    try {
      const data = await queryClient.fetchQuery('posts', fetchPosts)
    } catch (error) {
      // Error handling
    }
    

### [](#reactqueryerrorresetboundary-and-querycachereseterrorboundaries-have-been-replaced-by-queryerrorresetboundary-and-usequeryerrorresetboundary)[ReactQueryErrorResetBoundary and QueryCache.resetErrorBoundaries() have been replaced by QueryErrorResetBoundary and useQueryErrorResetBoundary().](#reactqueryerrorresetboundary-and-querycachereseterrorboundaries-have-been-replaced-by-queryerrorresetboundary-and-usequeryerrorresetboundary)

Together, these provide the same experience as before, but with added control to choose which component trees you want to reset. For more information, see:

*   [QueryErrorResetBoundary](https://tanstack.com/query/latest/docs/framework/react/reference/QueryErrorResetBoundary)
*   [useQueryErrorResetBoundary](https://tanstack.com/query/latest/docs/framework/react/reference/useQueryErrorResetBoundary)

### [](#querycachegetquery-has-been-replaced-by-querycachefind)[QueryCache.getQuery() has been replaced by QueryCache.find().](#querycachegetquery-has-been-replaced-by-querycachefind)

QueryCache.find() should now be used to look up individual queries from a cache

### [](#querycachegetqueries-has-been-moved-to-querycachefindall)[QueryCache.getQueries() has been moved to QueryCache.findAll().](#querycachegetqueries-has-been-moved-to-querycachefindall)

QueryCache.findAll() should now be used to look up multiple queries from a cache

### [](#querycacheisfetching-has-been-moved-to-queryclientisfetching)[QueryCache.isFetching has been moved to QueryClient.isFetching().](#querycacheisfetching-has-been-moved-to-queryclientisfetching)

**Notice that it's now a function instead of a property**

### [](#the-usequerycache-hook-has-been-replaced-by-the-usequeryclient-hook)[The useQueryCache hook has been replaced by the useQueryClient hook.](#the-usequerycache-hook-has-been-replaced-by-the-usequeryclient-hook)

It returns the provided queryClient for its component tree and shouldn't need much tweaking beyond a rename.

### [](#query-key-partspieces-are-no-longer-automatically-spread-to-the-query-function)[Query key parts/pieces are no longer automatically spread to the query function.](#query-key-partspieces-are-no-longer-automatically-spread-to-the-query-function)

Inline functions are now the suggested way of passing parameters to your query functions:

    // Old
    useQuery(['post', id], (_key, id) => fetchPost(id))
    
    // New
    useQuery(['post', id], () => fetchPost(id))
    

    // Old
    useQuery(['post', id], (_key, id) => fetchPost(id))
    
    // New
    useQuery(['post', id], () => fetchPost(id))
    

If you still insist on not using inline functions, you can use the newly passed QueryFunctionContext:

    useQuery(['post', id], (context) => fetchPost(context.queryKey[1]))
    

    useQuery(['post', id], (context) => fetchPost(context.queryKey[1]))
    

### [](#infinite-query-page-params-are-now-passed-via-queryfunctioncontextpageparam)[Infinite Query Page params are now passed via QueryFunctionContext.pageParam](#infinite-query-page-params-are-now-passed-via-queryfunctioncontextpageparam)

They were previously added as the last query key parameter in your query function, but this proved to be difficult for some patterns

    // Old
    useInfiniteQuery(['posts'], (_key, pageParam = 0) => fetchPosts(pageParam))
    
    // New
    useInfiniteQuery(['posts'], ({ pageParam = 0 }) => fetchPosts(pageParam))
    

    // Old
    useInfiniteQuery(['posts'], (_key, pageParam = 0) => fetchPosts(pageParam))
    
    // New
    useInfiniteQuery(['posts'], ({ pageParam = 0 }) => fetchPosts(pageParam))
    

### [](#usepaginatedquery-has-been-removed-in-favor-of-the-keeppreviousdata-option)[usePaginatedQuery() has been removed in favor of the keepPreviousData option](#usepaginatedquery-has-been-removed-in-favor-of-the-keeppreviousdata-option)

The new keepPreviousData options is available for both useQuery and useInfiniteQuery and will have the same "lagging" effect on your data:

    import { useQuery } from 'react-query'
    
    function Page({ page }) {
      const { data } = useQuery(['page', page], fetchPage, {
        keepPreviousData: true,
      })
    }
    

    import { useQuery } from 'react-query'
    
    function Page({ page }) {
      const { data } = useQuery(['page', page], fetchPage, {
        keepPreviousData: true,
      })
    }
    

### [](#useinfinitequery-is-now-bi-directional)[useInfiniteQuery() is now bi-directional](#useinfinitequery-is-now-bi-directional)

The useInfiniteQuery() interface has changed to fully support bi-directional infinite lists.

*   options.getFetchMore has been renamed to options.getNextPageParam
*   queryResult.canFetchMore has been renamed to queryResult.hasNextPage
*   queryResult.fetchMore has been renamed to queryResult.fetchNextPage
*   queryResult.isFetchingMore has been renamed to queryResult.isFetchingNextPage
*   Added the options.getPreviousPageParam option
*   Added the queryResult.hasPreviousPage property
*   Added the queryResult.fetchPreviousPage property
*   Added the queryResult.isFetchingPreviousPage
*   The data of an infinite query is now an object containing the pages and the pageParams used to fetch the pages: { pages: \[data, data, data\], pageParams: \[...\]}

One direction:

    const { data, fetchNextPage, hasNextPage, isFetchingNextPage } =
      useInfiniteQuery(
        'projects',
        ({ pageParam = 0 }) => fetchProjects(pageParam),
        {
          getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
        },
      )
    

    const { data, fetchNextPage, hasNextPage, isFetchingNextPage } =
      useInfiniteQuery(
        'projects',
        ({ pageParam = 0 }) => fetchProjects(pageParam),
        {
          getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
        },
      )
    

Both directions:

    const {
      data,
      fetchNextPage,
      fetchPreviousPage,
      hasNextPage,
      hasPreviousPage,
      isFetchingNextPage,
      isFetchingPreviousPage,
    } = useInfiniteQuery(
      'projects',
      ({ pageParam = 0 }) => fetchProjects(pageParam),
      {
        getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
        getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,
      },
    )
    

    const {
      data,
      fetchNextPage,
      fetchPreviousPage,
      hasNextPage,
      hasPreviousPage,
      isFetchingNextPage,
      isFetchingPreviousPage,
    } = useInfiniteQuery(
      'projects',
      ({ pageParam = 0 }) => fetchProjects(pageParam),
      {
        getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
        getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,
      },
    )
    

One direction reversed:

    const { data, fetchNextPage, hasNextPage, isFetchingNextPage } =
      useInfiniteQuery(
        'projects',
        ({ pageParam = 0 }) => fetchProjects(pageParam),
        {
          select: (data) => ({
            pages: [...data.pages].reverse(),
            pageParams: [...data.pageParams].reverse(),
          }),
          getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
        },
      )
    

    const { data, fetchNextPage, hasNextPage, isFetchingNextPage } =
      useInfiniteQuery(
        'projects',
        ({ pageParam = 0 }) => fetchProjects(pageParam),
        {
          select: (data) => ({
            pages: [...data.pages].reverse(),
            pageParams: [...data.pageParams].reverse(),
          }),
          getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
        },
      )
    

### [](#infinite-query-data-now-contains-the-array-of-pages-and-pageparams-used-to-fetch-those-pages)[Infinite Query data now contains the array of pages and pageParams used to fetch those pages.](#infinite-query-data-now-contains-the-array-of-pages-and-pageparams-used-to-fetch-those-pages)

This allows for easier manipulation of the data and the page params, like, for example, removing the first page of data along with it's params:

    queryClient.setQueryData(['projects'], (data) => ({
      pages: data.pages.slice(1),
      pageParams: data.pageParams.slice(1),
    }))
    

    queryClient.setQueryData(['projects'], (data) => ({
      pages: data.pages.slice(1),
      pageParams: data.pageParams.slice(1),
    }))
    

### [](#usemutation-now-returns-an-object-instead-of-an-array)[useMutation now returns an object instead of an array](#usemutation-now-returns-an-object-instead-of-an-array)

Though the old way gave us warm fuzzy feelings of when we first discovered useState for the first time, they didn't last long. Now the mutation return is a single object.

    // Old:
    const [mutate, { status, reset }] = useMutation()
    
    // New:
    const { mutate, status, reset } = useMutation()
    

    // Old:
    const [mutate, { status, reset }] = useMutation()
    
    // New:
    const { mutate, status, reset } = useMutation()
    

### [](#mutationmutate-no-longer-return-a-promise)[mutation.mutate no longer return a promise](#mutationmutate-no-longer-return-a-promise)

*   The \[mutate\] variable has been changed to the mutation.mutate function
*   Added the mutation.mutateAsync function

We got a lot of questions regarding this behavior as users expected the promise to behave like a regular promise.

Because of this the mutate function is now split into a mutate and mutateAsync function.

The mutate function can be used when using callbacks:

    const { mutate } = useMutation({ mutationFn: addTodo })
    
    mutate('todo', {
      onSuccess: (data) => {
        console.log(data)
      },
      onError: (error) => {
        console.error(error)
      },
      onSettled: () => {
        console.log('settled')
      },
    })
    

    const { mutate } = useMutation({ mutationFn: addTodo })
    
    mutate('todo', {
      onSuccess: (data) => {
        console.log(data)
      },
      onError: (error) => {
        console.error(error)
      },
      onSettled: () => {
        console.log('settled')
      },
    })
    

The mutateAsync function can be used when using async/await:

    const { mutateAsync } = useMutation({ mutationFn: addTodo })
    
    try {
      const data = await mutateAsync('todo')
      console.log(data)
    } catch (error) {
      console.error(error)
    } finally {
      console.log('settled')
    }
    

    const { mutateAsync } = useMutation({ mutationFn: addTodo })
    
    try {
      const data = await mutateAsync('todo')
      console.log(data)
    } catch (error) {
      console.error(error)
    } finally {
      console.log('settled')
    }
    

### [](#the-object-syntax-for-usequery-now-uses-a-collapsed-config)[The object syntax for useQuery now uses a collapsed config:](#the-object-syntax-for-usequery-now-uses-a-collapsed-config)

    // Old:
    useQuery({
      queryKey: 'posts',
      queryFn: fetchPosts,
      config: { staleTime: Infinity },
    })
    
    // New:
    useQuery({
      queryKey: 'posts',
      queryFn: fetchPosts,
      staleTime: Infinity,
    })
    

    // Old:
    useQuery({
      queryKey: 'posts',
      queryFn: fetchPosts,
      config: { staleTime: Infinity },
    })
    
    // New:
    useQuery({
      queryKey: 'posts',
      queryFn: fetchPosts,
      staleTime: Infinity,
    })
    

### [](#if-set-the-queryoptionsenabled-option-must-be-a-boolean-truefalse)[If set, the QueryOptions.enabled option must be a boolean (true/false)](#if-set-the-queryoptionsenabled-option-must-be-a-boolean-truefalse)

The enabled query option will now only disable a query when the value is false. If needed, values can be casted with !!userId or Boolean(userId) and a handy error will be thrown if a non-boolean value is passed.

### [](#the-queryoptionsinitialstale-option-has-been-removed)[The QueryOptions.initialStale option has been removed](#the-queryoptionsinitialstale-option-has-been-removed)

The initialStale query option has been removed and initial data is now treated as regular data. Which means that if initialData is provided, the query will refetch on mount by default. If you do not want to refetch immediately, you can define a staleTime.

### [](#the-queryoptionsforcefetchonmount-option-has-been-replaced-by-refetchonmount-always)[The QueryOptions.forceFetchOnMount option has been replaced by refetchOnMount: 'always'](#the-queryoptionsforcefetchonmount-option-has-been-replaced-by-refetchonmount-always)

Honestly, we were accruing way too many refetchOn\_\_\_\_ options, so this should clean things up.

### [](#the-queryoptionsrefetchonmount-options-now-only-applies-to-its-parent-component-instead-of-all-query-observers)[The QueryOptions.refetchOnMount options now only applies to its parent component instead of all query observers](#the-queryoptionsrefetchonmount-options-now-only-applies-to-its-parent-component-instead-of-all-query-observers)

When refetchOnMount was set to false any additional components were prevented from refetching on mount. In version 3 only the component where the option has been set will not refetch on mount.

### [](#the-queryoptionsqueryfnparamsfilter-has-been-removed-in-favor-of-the-new-queryfunctioncontext-object)[The QueryOptions.queryFnParamsFilter has been removed in favor of the new QueryFunctionContext object.](#the-queryoptionsqueryfnparamsfilter-has-been-removed-in-favor-of-the-new-queryfunctioncontext-object)

The queryFnParamsFilter option has been removed because query functions now get a QueryFunctionContext object instead of the query key.

Parameters can still be filtered within the query function itself as the QueryFunctionContext also contains the query key.

### [](#the-queryoptionsnotifyonstatuschange-option-has-been-superseded-by-the-new-notifyonchangeprops-and-notifyonchangepropsexclusions-options)[The QueryOptions.notifyOnStatusChange option has been superseded by the new notifyOnChangeProps and notifyOnChangePropsExclusions options.](#the-queryoptionsnotifyonstatuschange-option-has-been-superseded-by-the-new-notifyonchangeprops-and-notifyonchangepropsexclusions-options)

With these new options it is possible to configure when a component should re-render on a granular level.

Only re-render when the data or error properties change:

    import { useQuery } from 'react-query'
    
    function User() {
      const { data } = useQuery(['user'], fetchUser, {
        notifyOnChangeProps: ['data', 'error'],
      })
      return <div>Username: {data.username}</div>
    }
    

    import { useQuery } from 'react-query'
    
    function User() {
      const { data } = useQuery(['user'], fetchUser, {
        notifyOnChangeProps: ['data', 'error'],
      })
      return <div>Username: {data.username}</div>
    }
    

Prevent re-render when the isStale property changes:

    import { useQuery } from 'react-query'
    
    function User() {
      const { data } = useQuery(['user'], fetchUser, {
        notifyOnChangePropsExclusions: ['isStale'],
      })
      return <div>Username: {data.username}</div>
    }
    

    import { useQuery } from 'react-query'
    
    function User() {
      const { data } = useQuery(['user'], fetchUser, {
        notifyOnChangePropsExclusions: ['isStale'],
      })
      return <div>Username: {data.username}</div>
    }
    

### [](#the-queryresultclear-function-has-been-renamed-to-queryresultremove)[The QueryResult.clear() function has been renamed to QueryResult.remove()](#the-queryresultclear-function-has-been-renamed-to-queryresultremove)

Although it was called clear, it really just removed the query from the cache. The name now matches the functionality.

### [](#the-queryresultupdatedat-property-has-been-split-into-queryresultdataupdatedat-and-queryresulterrorupdatedat-properties)[The QueryResult.updatedAt property has been split into QueryResult.dataUpdatedAt and QueryResult.errorUpdatedAt properties](#the-queryresultupdatedat-property-has-been-split-into-queryresultdataupdatedat-and-queryresulterrorupdatedat-properties)

Because data and errors can be present at the same time, the updatedAt property has been split into dataUpdatedAt and errorUpdatedAt.

### [](#setconsole-has-been-replaced-by-the-new-setlogger-function)[setConsole() has been replaced by the new setLogger() function](#setconsole-has-been-replaced-by-the-new-setlogger-function)

    import { setLogger } from 'react-query'
    
    // Log with Sentry
    setLogger({
      error: (error) => {
        Sentry.captureException(error)
      },
    })
    
    // Log with Winston
    setLogger(winston.createLogger())
    

    import { setLogger } from 'react-query'
    
    // Log with Sentry
    setLogger({
      error: (error) => {
        Sentry.captureException(error)
      },
    })
    
    // Log with Winston
    setLogger(winston.createLogger())
    

### [](#react-native-no-longer-requires-overriding-the-logger)[React Native no longer requires overriding the logger](#react-native-no-longer-requires-overriding-the-logger)

To prevent showing error screens in React Native when a query fails it was necessary to manually change the Console:

    import { setConsole } from 'react-query'
    
    setConsole({
      log: console.log,
      warn: console.warn,
      error: console.warn,
    })
    

    import { setConsole } from 'react-query'
    
    setConsole({
      log: console.log,
      warn: console.warn,
      error: console.warn,
    })
    

In version 3 **this is done automatically when React Query is used in React Native**.

### [](#typescript)[Typescript](#typescript)

#### [](#querystatus-has-been-changed-from-an-enum-to-a-union-type)[QueryStatus has been changed from an](#querystatus-has-been-changed-from-an-enum-to-a-union-type) [enum](https://www.typescriptlang.org/docs/handbook/enums.html#string-enums) to a [union type](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types)

So, if you were checking the status property of a query or mutation against a QueryStatus enum property you will have to check it now against the string literal the enum previously held for each property.

Therefore you have to change the enum properties to their equivalent string literal, like this:

*   QueryStatus.Idle -> 'idle'
*   QueryStatus.Loading -> 'loading'
*   QueryStatus.Error -> 'error'
*   QueryStatus.Success -> 'success'

Here is an example of the changes you would have to make:

    - import { useQuery, QueryStatus } from 'react-query'; // [!code --]
    + import { useQuery } from 'react-query'; // [!code ++]
    
    const { data, status } = useQuery(['post', id], () => fetchPost(id))
    
    - if (status === QueryStatus.Loading) { // [!code --]
    + if (status === 'loading') { // [!code ++]
      ...
    }
    
    - if (status === QueryStatus.Error) { // [!code --]
    + if (status === 'error') { // [!code ++]
      ...
    }
    

    - import { useQuery, QueryStatus } from 'react-query'; // [!code --]
    + import { useQuery } from 'react-query'; // [!code ++]
    
    const { data, status } = useQuery(['post', id], () => fetchPost(id))
    
    - if (status === QueryStatus.Loading) { // [!code --]
    + if (status === 'loading') { // [!code ++]
      ...
    }
    
    - if (status === QueryStatus.Error) { // [!code --]
    + if (status === 'error') { // [!code ++]
      ...
    }
    

[](#new-features)[New features](#new-features)
----------------------------------------------

#### [](#query-data-selectors)[Query Data Selectors](#query-data-selectors)

The useQuery and useInfiniteQuery hooks now have a select option to select or transform parts of the query result.

    import { useQuery } from 'react-query'
    
    function User() {
      const { data } = useQuery(['user'], fetchUser, {
        select: (user) => user.username,
      })
      return <div>Username: {data}</div>
    }
    

    import { useQuery } from 'react-query'
    
    function User() {
      const { data } = useQuery(['user'], fetchUser, {
        select: (user) => user.username,
      })
      return <div>Username: {data}</div>
    }
    

Set the notifyOnChangeProps option to \['data', 'error'\] to only re-render when the selected data changes.

#### [](#the-usequeries-hook-for-variable-length-parallel-query-execution)[The useQueries() hook, for variable-length parallel query execution](#the-usequeries-hook-for-variable-length-parallel-query-execution)

Wish you could run useQuery in a loop? The rules of hooks say no, but with the new useQueries() hook, you can!

    import { useQueries } from 'react-query'
    
    function Overview() {
      const results = useQueries([
        { queryKey: ['post', 1], queryFn: fetchPost },
        { queryKey: ['post', 2], queryFn: fetchPost },
      ])
      return (
        <ul>
          {results.map(({ data }) => data && <li key={data.id}>{data.title})</li>)}
        </ul>
      )
    }
    

    import { useQueries } from 'react-query'
    
    function Overview() {
      const results = useQueries([
        { queryKey: ['post', 1], queryFn: fetchPost },
        { queryKey: ['post', 2], queryFn: fetchPost },
      ])
      return (
        <ul>
          {results.map(({ data }) => data && <li key={data.id}>{data.title})</li>)}
        </ul>
      )
    }
    

#### [](#retryoffline-mutations)[Retry/offline mutations](#retryoffline-mutations)

By default React Query will not retry a mutation on error, but it is possible with the retry option:

    const mutation = useMutation({
      mutationFn: addTodo,
      retry: 3,
    })
    

    const mutation = useMutation({
      mutationFn: addTodo,
      retry: 3,
    })
    

If mutations fail because the device is offline, they will be retried in the same order when the device reconnects.

#### [](#persist-mutations)[Persist mutations](#persist-mutations)

Mutations can now be persisted to storage and resumed at a later point. More information can be found in the mutations documentation.

#### [](#queryobserver)[QueryObserver](#queryobserver)

A QueryObserver can be used to create and/or watch a query:

    const observer = new QueryObserver(queryClient, { queryKey: 'posts' })
    
    const unsubscribe = observer.subscribe((result) => {
      console.log(result)
      unsubscribe()
    })
    

    const observer = new QueryObserver(queryClient, { queryKey: 'posts' })
    
    const unsubscribe = observer.subscribe((result) => {
      console.log(result)
      unsubscribe()
    })
    

#### [](#infinitequeryobserver)[InfiniteQueryObserver](#infinitequeryobserver)

A InfiniteQueryObserver can be used to create and/or watch an infinite query:

    const observer = new InfiniteQueryObserver(queryClient, {
      queryKey: 'posts',
      queryFn: fetchPosts,
      getNextPageParam: (lastPage, allPages) => lastPage.nextCursor,
      getPreviousPageParam: (firstPage, allPages) => firstPage.prevCursor,
    })
    
    const unsubscribe = observer.subscribe((result) => {
      console.log(result)
      unsubscribe()
    })
    

    const observer = new InfiniteQueryObserver(queryClient, {
      queryKey: 'posts',
      queryFn: fetchPosts,
      getNextPageParam: (lastPage, allPages) => lastPage.nextCursor,
      getPreviousPageParam: (firstPage, allPages) => firstPage.prevCursor,
    })
    
    const unsubscribe = observer.subscribe((result) => {
      console.log(result)
      unsubscribe()
    })
    

#### [](#queriesobserver)[QueriesObserver](#queriesobserver)

A QueriesObserver can be used to create and/or watch multiple queries:

    const observer = new QueriesObserver(queryClient, [
      { queryKey: ['post', 1], queryFn: fetchPost },
      { queryKey: ['post', 2], queryFn: fetchPost },
    ])
    
    const unsubscribe = observer.subscribe((result) => {
      console.log(result)
      unsubscribe()
    })
    

    const observer = new QueriesObserver(queryClient, [
      { queryKey: ['post', 1], queryFn: fetchPost },
      { queryKey: ['post', 2], queryFn: fetchPost },
    ])
    
    const unsubscribe = observer.subscribe((result) => {
      console.log(result)
      unsubscribe()
    })
    

#### [](#set-default-options-for-specific-queries)[Set default options for specific queries](#set-default-options-for-specific-queries)

The QueryClient.setQueryDefaults() method can be used to set default options for specific queries:

    queryClient.setQueryDefaults(['posts'], { queryFn: fetchPosts })
    
    function Component() {
      const { data } = useQuery(['posts'])
    }
    

    queryClient.setQueryDefaults(['posts'], { queryFn: fetchPosts })
    
    function Component() {
      const { data } = useQuery(['posts'])
    }
    

#### [](#set-default-options-for-specific-mutations)[Set default options for specific mutations](#set-default-options-for-specific-mutations)

The QueryClient.setMutationDefaults() method can be used to set default options for specific mutations:

    queryClient.setMutationDefaults(['addPost'], { mutationFn: addPost })
    
    function Component() {
      const { mutate } = useMutation({ mutationKey: ['addPost'] })
    }
    

    queryClient.setMutationDefaults(['addPost'], { mutationFn: addPost })
    
    function Component() {
      const { mutate } = useMutation({ mutationKey: ['addPost'] })
    }
    

#### [](#useisfetching)[useIsFetching()](#useisfetching)

The useIsFetching() hook now accepts filters which can be used to for example only show a spinner for certain type of queries:

    const fetches = useIsFetching({ queryKey: ['posts'] })
    

    const fetches = useIsFetching({ queryKey: ['posts'] })
    

#### [](#core-separation)[Core separation](#core-separation)

The core of React Query is now fully separated from React, which means it can also be used standalone or in other frameworks. Use the react-query/core entry point to only import the core functionality:

    import { QueryClient } from 'react-query/core'
    

    import { QueryClient } from 'react-query/core'
    

### [](#devtools-are-now-part-of-the-main-repo-and-npm-package)[Devtools are now part of the main repo and npm package](#devtools-are-now-part-of-the-main-repo-and-npm-package)

The devtools are now included in the react-query package itself under the import react-query/devtools. Simply replace react-query-devtools imports with react-query/devtools</content>
</page>

<page>
  <title>Testing | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/testing</url>
  <content>React Query works by means of hooks - either the ones we offer or custom ones that wrap around them.

With React 17 or earlier, writing unit tests for these custom hooks can be done by means of the [React Hooks Testing Library](https://react-hooks-testing-library.com/) library.

Install this by running:

    npm install @testing-library/react-hooks react-test-renderer --save-dev
    

    npm install @testing-library/react-hooks react-test-renderer --save-dev
    

(The react-test-renderer library is needed as a peer dependency of @testing-library/react-hooks, and needs to correspond to the version of React that you are using.)

_Note_: when using React 18 or later, renderHook is available directly through the @testing-library/react package, and @testing-library/react-hooks is no longer required.

[](#our-first-test)[Our First Test](#our-first-test)
----------------------------------------------------

Once installed, a simple test can be written. Given the following custom hook:

    export function useCustomHook() {
      return useQuery({ queryKey: ['customHook'], queryFn: () => 'Hello' })
    }
    

    export function useCustomHook() {
      return useQuery({ queryKey: ['customHook'], queryFn: () => 'Hello' })
    }
    

We can write a test for this as follows:

    import { renderHook, waitFor } from '@testing-library/react'
    
    const queryClient = new QueryClient()
    const wrapper = ({ children }) => (
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    )
    
    const { result } = renderHook(() => useCustomHook(), { wrapper })
    
    await waitFor(() => expect(result.current.isSuccess).toBe(true))
    
    expect(result.current.data).toEqual('Hello')
    

    import { renderHook, waitFor } from '@testing-library/react'
    
    const queryClient = new QueryClient()
    const wrapper = ({ children }) => (
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    )
    
    const { result } = renderHook(() => useCustomHook(), { wrapper })
    
    await waitFor(() => expect(result.current.isSuccess).toBe(true))
    
    expect(result.current.data).toEqual('Hello')
    

Note that we provide a custom wrapper that builds the QueryClient and QueryClientProvider. This helps to ensure that our test is completely isolated from any other tests.

It is possible to write this wrapper only once, but if so we need to ensure that the QueryClient gets cleared before every test, and that tests don't run in parallel otherwise one test will influence the results of others.

[](#turn-off-retries)[Turn off retries](#turn-off-retries)
----------------------------------------------------------

The library defaults to three retries with exponential backoff, which means that your tests are likely to timeout if you want to test an erroneous query. The easiest way to turn retries off is via the QueryClientProvider. Let's extend the above example:

    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          // ‚úÖ turns retries off
          retry: false,
        },
      },
    })
    const wrapper = ({ children }) => (
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    )
    

    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          // ‚úÖ turns retries off
          retry: false,
        },
      },
    })
    const wrapper = ({ children }) => (
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    )
    

This will set the defaults for all queries in the component tree to "no retries". It is important to know that this will only work if your actual useQuery has no explicit retries set. If you have a query that wants 5 retries, this will still take precedence, because defaults are only taken as a fallback.

[](#set-gctime-to-infinity-with-jest)[Set gcTime to Infinity with Jest](#set-gctime-to-infinity-with-jest)
----------------------------------------------------------------------------------------------------------

If you use Jest, you can set the gcTime to Infinity to prevent "Jest did not exit one second after the test run completed" error message. This is the default behavior on the server, and is only necessary to set if you are explicitly setting a gcTime.

[](#testing-network-calls)[Testing Network Calls](#testing-network-calls)
-------------------------------------------------------------------------

The primary use for React Query is to cache network requests, so it's important that we can test our code is making the correct network requests in the first place.

There are plenty of ways that these can be tested, but for this example we are going to use [nock](https://www.npmjs.com/package/nock).

Given the following custom hook:

    function useFetchData() {
      return useQuery({
        queryKey: ['fetchData'],
        queryFn: () => request('/api/data'),
      })
    }
    

    function useFetchData() {
      return useQuery({
        queryKey: ['fetchData'],
        queryFn: () => request('/api/data'),
      })
    }
    

We can write a test for this as follows:

    const queryClient = new QueryClient()
    const wrapper = ({ children }) => (
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    )
    
    const expectation = nock('http://example.com').get('/api/data').reply(200, {
      answer: 42,
    })
    
    const { result } = renderHook(() => useFetchData(), { wrapper })
    
    await waitFor(() => expect(result.current.isSuccess).toBe(true))
    
    expect(result.current.data).toEqual({ answer: 42 })
    

    const queryClient = new QueryClient()
    const wrapper = ({ children }) => (
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    )
    
    const expectation = nock('http://example.com').get('/api/data').reply(200, {
      answer: 42,
    })
    
    const { result } = renderHook(() => useFetchData(), { wrapper })
    
    await waitFor(() => expect(result.current.isSuccess).toBe(true))
    
    expect(result.current.data).toEqual({ answer: 42 })
    

Here we are making use of waitFor and waiting until the query status indicates that the request has succeeded. This way we know that our hook has finished and should have the correct data. _Note_: when using React 18, the semantics of waitFor have changed as noted above.

First we need to mock our API response

    function generateMockedResponse(page) {
      return {
        page: page,
        items: [...]
      }
    }
    

    function generateMockedResponse(page) {
      return {
        page: page,
        items: [...]
      }
    }
    

Then, our nock configuration needs to differentiate responses based on the page, and we'll be using uri to do this. uri's value here will be something like "/?page=1 or /?page=2

    const expectation = nock('http://example.com')
      .persist()
      .query(true)
      .get('/api/data')
      .reply(200, (uri) => {
        const url = new URL(`http://example.com${uri}`)
        const { page } = Object.fromEntries(url.searchParams)
        return generateMockedResponse(page)
      })
    

    const expectation = nock('http://example.com')
      .persist()
      .query(true)
      .get('/api/data')
      .reply(200, (uri) => {
        const url = new URL(`http://example.com${uri}`)
        const { page } = Object.fromEntries(url.searchParams)
        return generateMockedResponse(page)
      })
    

(Notice the .persist(), because we'll be calling from this endpoint multiple times)

Now we can safely run our tests, the trick here is to await for the data assertion to pass:

    const { result } = renderHook(() => useInfiniteQueryCustomHook(), {
      wrapper,
    })
    
    await waitFor(() => expect(result.current.isSuccess).toBe(true))
    
    expect(result.current.data.pages).toStrictEqual(generateMockedResponse(1))
    
    result.current.fetchNextPage()
    
    await waitFor(() =>
      expect(result.current.data.pages).toStrictEqual([
        ...generateMockedResponse(1),
        ...generateMockedResponse(2),
      ]),
    )
    
    expectation.done()
    

    const { result } = renderHook(() => useInfiniteQueryCustomHook(), {
      wrapper,
    })
    
    await waitFor(() => expect(result.current.isSuccess).toBe(true))
    
    expect(result.current.data.pages).toStrictEqual(generateMockedResponse(1))
    
    result.current.fetchNextPage()
    
    await waitFor(() =>
      expect(result.current.data.pages).toStrictEqual([
        ...generateMockedResponse(1),
        ...generateMockedResponse(2),
      ]),
    )
    
    expectation.done()
    

_Note_: when using React 18, the semantics of waitFor have changed as noted above.

[](#further-reading)[Further reading](#further-reading)
-------------------------------------------------------

For additional tips and an alternative setup using mock-service-worker, have a look at [this article by TkDodo on Testing React Query](https://tkdodo.eu/blog/testing-react-query).</content>
</page>

<page>
  <title>Does TanStack Query replace Redux, MobX or other global state managers? | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/does-this-replace-client-state</url>
  <content>Well, let's start with a few important items:

*   TanStack Query is a **server-state** library, responsible for managing asynchronous operations between your server and client
*   Redux, MobX, Zustand, etc. are **client-state** libraries that _can be used to store asynchronous data, albeit inefficiently when compared to a tool like TanStack Query_

With those points in mind, the short answer is that TanStack Query **replaces the boilerplate code and related wiring used to manage cache data in your client-state and replaces it with just a few lines of code.**

For a vast majority of applications, the truly **globally accessible client state** that is left over after migrating all of your async code to TanStack Query is usually very tiny.

> There are still some circumstances where an application might indeed have a massive amount of synchronous client-only state (like a visual designer or music production application), in which case, you will probably still want a client state manager. In this situation it's important to note that **TanStack Query is not a replacement for local/client state management**. However, you can use TanStack Query alongside most client state managers with zero issues.

[](#a-contrived-example)[A Contrived Example](#a-contrived-example)
-------------------------------------------------------------------

Here we have some "global" state being managed by a global state library:

    const globalState = {
      projects,
      teams,
      tasks,
      users,
      themeMode,
      sidebarStatus,
    }
    

    const globalState = {
      projects,
      teams,
      tasks,
      users,
      themeMode,
      sidebarStatus,
    }
    

Currently, the global state manager is caching 4 types of server-state: projects, teams, tasks, and users. If we were to move these server-state assets to TanStack Query, our remaining global state would look more like this:

    const globalState = {
      themeMode,
      sidebarStatus,
    }
    

    const globalState = {
      themeMode,
      sidebarStatus,
    }
    

This also means that with a few hook calls to useQuery and useMutation, we also get to remove any boilerplate code that was used to manage our server state e.g.

*   Connectors
*   Action Creators
*   Middlewares
*   Reducers
*   Loading/Error/Result states
*   Contexts

With all of those things removed, you may ask yourself, **"Is it worth it to keep using our client state manager for this tiny global state?"**

**And that's up to you!**

But TanStack Query's role is clear. It removes asynchronous wiring and boilerplate from your application and replaces it with just a few lines of code.

What are you waiting for, give it a go already!</content>
</page>

<page>
  <title>Migrating to React Query 4 | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-react-query-4</url>
  <content>[](#breaking-changes)[Breaking Changes](#breaking-changes)
----------------------------------------------------------

v4 is a major version, so there are some breaking changes to be aware of:

### [](#react-query-is-now-tanstackreact-query)[react-query is now @tanstack/react-query](#react-query-is-now-tanstackreact-query)

You will need to un-/install dependencies and change the imports:

    npm uninstall react-query
    npm install @tanstack/react-query
    npm install @tanstack/react-query-devtools
    

    npm uninstall react-query
    npm install @tanstack/react-query
    npm install @tanstack/react-query-devtools
    

    - import { useQuery } from 'react-query' // [!code --]
    - import { ReactQueryDevtools } from 'react-query/devtools' // [!code --]
    
    + import { useQuery } from '@tanstack/react-query' // [!code ++]
    + import { ReactQueryDevtools } from '@tanstack/react-query-devtools' // [!code ++]
    

    - import { useQuery } from 'react-query' // [!code --]
    - import { ReactQueryDevtools } from 'react-query/devtools' // [!code --]
    
    + import { useQuery } from '@tanstack/react-query' // [!code ++]
    + import { ReactQueryDevtools } from '@tanstack/react-query-devtools' // [!code ++]
    

#### [](#codemod)[Codemod](#codemod)

To make the import migration easier, v4 comes with a codemod.

> The codemod is a best efforts attempt to help you migrate the breaking change. Please review the generated code thoroughly! Also, there are edge cases that cannot be found by the code mod, so please keep an eye on the log output.

You can easily apply it by using one (or both) of the following commands:

If you want to run it against .js or .jsx files, please use the command below:

    npx jscodeshift ./path/to/src/ \
      --extensions=js,jsx \
      --transform=./node_modules/@tanstack/react-query/codemods/v4/replace-import-specifier.js
    

    npx jscodeshift ./path/to/src/ \
      --extensions=js,jsx \
      --transform=./node_modules/@tanstack/react-query/codemods/v4/replace-import-specifier.js
    

If you want to run it against .ts or .tsx files, please use the command below:

    npx jscodeshift ./path/to/src/ \
      --extensions=ts,tsx \
      --parser=tsx \
      --transform=./node_modules/@tanstack/react-query/codemods/v4/replace-import-specifier.js
    

    npx jscodeshift ./path/to/src/ \
      --extensions=ts,tsx \
      --parser=tsx \
      --transform=./node_modules/@tanstack/react-query/codemods/v4/replace-import-specifier.js
    

Please note in the case of TypeScript you need to use tsx as the parser; otherwise, the codemod won't be applied properly!

**Note:** Applying the codemod might break your code formatting, so please don't forget to run prettier and/or eslint after you've applied the codemod!

**Note:** The codemod will _only_ change the imports - you still have to install the separate devtools package manually.

### [](#query-keys-and-mutation-keys-need-to-be-an-array)[Query Keys (and Mutation Keys) need to be an Array](#query-keys-and-mutation-keys-need-to-be-an-array)

In v3, Query and Mutation Keys could be a String or an Array. Internally, React Query has always worked with Array Keys only, and we've sometimes exposed this to consumers. For example, in the queryFn, you would always get the key as an Array to make working with [Default Query Functions](https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function) easier.

However, we have not followed this concept through to all apis. For example, when using the predicate function on [Query Filters](https://tanstack.com/query/latest/docs/framework/react/guides/filters) you would get the raw Query Key. This makes it difficult to work with such functions if you use Query Keys that are mixed Arrays and Strings. The same was true when using global callbacks.

To streamline all apis, we've decided to make all keys Arrays only:

    ;-useQuery('todos', fetchTodos) + // [!code --]
      useQuery(['todos'], fetchTodos) // [!code ++]
    

    ;-useQuery('todos', fetchTodos) + // [!code --]
      useQuery(['todos'], fetchTodos) // [!code ++]
    

#### [](#codemod-1)[Codemod](#codemod-1)

To make this migration easier, we decided to deliver a codemod.

> The codemod is a best efforts attempt to help you migrate the breaking change. Please review the generated code thoroughly! Also, there are edge cases that cannot be found by the code mod, so please keep an eye on the log output.

You can easily apply it by using one (or both) of the following commands:

If you want to run it against .js or .jsx files, please use the command below:

    npx jscodeshift ./path/to/src/ \
      --extensions=js,jsx \
      --transform=./node_modules/@tanstack/react-query/codemods/v4/key-transformation.js
    

    npx jscodeshift ./path/to/src/ \
      --extensions=js,jsx \
      --transform=./node_modules/@tanstack/react-query/codemods/v4/key-transformation.js
    

If you want to run it against .ts or .tsx files, please use the command below:

    npx jscodeshift ./path/to/src/ \
      --extensions=ts,tsx \
      --parser=tsx \
      --transform=./node_modules/@tanstack/react-query/codemods/v4/key-transformation.js
    

    npx jscodeshift ./path/to/src/ \
      --extensions=ts,tsx \
      --parser=tsx \
      --transform=./node_modules/@tanstack/react-query/codemods/v4/key-transformation.js
    

Please note in the case of TypeScript you need to use tsx as the parser; otherwise, the codemod won't be applied properly!

**Note:** Applying the codemod might break your code formatting, so please don't forget to run prettier and/or eslint after you've applied the codemod!

### [](#the-idle-state-has-been-removed)[The idle state has been removed](#the-idle-state-has-been-removed)

With the introduction of the new [fetchStatus](https://tanstack.com/query/latest/docs/framework/react/guides/queries#fetchstatus) for better offline support, the idle state became irrelevant, because fetchStatus: 'idle' captures the same state better. For more information, please read [Why two different states](https://tanstack.com/query/latest/docs/framework/react/guides/queries#why-two-different-states).

This will mostly affect disabled queries that don't have any data yet, as those were in idle state before:

    - status: 'idle' // [!code --]
    + status: 'loading'  // [!code ++]
    + fetchStatus: 'idle' // [!code ++]
    

    - status: 'idle' // [!code --]
    + status: 'loading'  // [!code ++]
    + fetchStatus: 'idle' // [!code ++]
    

Also, have a look at [the guide on dependent queries](https://tanstack.com/query/latest/docs/framework/react/guides/dependent-queries)

#### [](#disabled-queries)[disabled queries](#disabled-queries)

Due to this change, disabled queries (even temporarily disabled ones) will start in loading state. To make migration easier, especially for having a good flag to know when to display a loading spinner, you can check for isInitialLoading instead of isLoading:

    ;-isLoading + // [!code --]
      isInitialLoading // [!code ++]
    

    ;-isLoading + // [!code --]
      isInitialLoading // [!code ++]
    

See also the guide on [disabling queries](https://tanstack.com/query/latest/docs/framework/react/guides/disabling-queries#isInitialLoading)

### [](#new-api-for-usequeries)[new API for useQueries](#new-api-for-usequeries)

The useQueries hook now accepts an object with a queries prop as its input. The value of the queries prop is an array of queries (this array is identical to what was passed into useQueries in v3).

    ;-useQueries([
      { queryKey1, queryFn1, options1 },
      { queryKey2, queryFn2, options2 },
    ]) + // [!code --]
      useQueries({
        queries: [
          { queryKey1, queryFn1, options1 },
          { queryKey2, queryFn2, options2 },
        ],
      }) // [!code ++]
    

    ;-useQueries([
      { queryKey1, queryFn1, options1 },
      { queryKey2, queryFn2, options2 },
    ]) + // [!code --]
      useQueries({
        queries: [
          { queryKey1, queryFn1, options1 },
          { queryKey2, queryFn2, options2 },
        ],
      }) // [!code ++]
    

### [](#undefined-is-an-illegal-cache-value-for-successful-queries)[Undefined is an illegal cache value for successful queries](#undefined-is-an-illegal-cache-value-for-successful-queries)

In order to make bailing out of updates possible by returning undefined, we had to make undefined an illegal cache value. This is in-line with other concepts of react-query, for example, returning undefined from the [initialData function](https://tanstack.com/query/latest/docs/framework/react/guides/initial-query-data#initial-data-function) will also _not_ set data.

Further, it is an easy bug to produce Promise<void> by adding logging in the queryFn:

    useQuery(['key'], () =>
      axios.get(url).then((result) => console.log(result.data)),
    )
    

    useQuery(['key'], () =>
      axios.get(url).then((result) => console.log(result.data)),
    )
    

This is now disallowed on type level; at runtime, undefined will be transformed to a _failed Promise_, which means you will get an error, which will also be logged to the console in development mode.

### [](#queries-and-mutations-per-default-need-network-connection-to-run)[Queries and mutations, per default, need network connection to run](#queries-and-mutations-per-default-need-network-connection-to-run)

Please read the [New Features announcement](#proper-offline-support) about online / offline support, and also the dedicated page about [Network mode](https://tanstack.com/query/latest/docs/framework/react/guides/network-mode)

Even though React Query is an Async State Manager that can be used for anything that produces a Promise, it is most often used for data fetching in combination with data fetching libraries. That is why, per default, queries and mutations will be paused if there is no network connection. If you want to opt-in to the previous behavior, you can globally set networkMode: offlineFirst for both queries and mutations:

    new QueryClient({
      defaultOptions: {
        queries: {
          networkMode: 'offlineFirst',
        },
        mutations: {
          networkMode: 'offlineFirst',
        },
      },
    })
    

    new QueryClient({
      defaultOptions: {
        queries: {
          networkMode: 'offlineFirst',
        },
        mutations: {
          networkMode: 'offlineFirst',
        },
      },
    })
    

### [](#notifyonchangeprops-property-no-longer-accepts-tracked-as-a-value)[notifyOnChangeProps property no longer accepts "tracked" as a value](#notifyonchangeprops-property-no-longer-accepts-tracked-as-a-value)

The notifyOnChangeProps option no longer accepts a "tracked" value. Instead, useQuery defaults to tracking properties. All queries using notifyOnChangeProps: "tracked" should be updated by removing this option.

If you would like to bypass this in any queries to emulate the v3 default behavior of re-rendering whenever a query changes, notifyOnChangeProps now accepts an "all" value to opt-out of the default smart tracking optimization.

### [](#notifyonchangepropsexclusion-has-been-removed)[notifyOnChangePropsExclusion has been removed](#notifyonchangepropsexclusion-has-been-removed)

In v4, notifyOnChangeProps defaults to the "tracked" behavior of v3 instead of undefined. Now that "tracked" is the default behavior for v4, it no longer makes sense to include this config option.

### [](#consistent-behavior-for-cancelrefetch)[Consistent behavior for cancelRefetch](#consistent-behavior-for-cancelrefetch)

The cancelRefetch option can be passed to all functions that imperatively fetch a query, namely:

*   queryClient.refetchQueries
*   queryClient.invalidateQueries
*   queryClient.resetQueries
*   refetch returned from useQuery
*   fetchNextPage and fetchPreviousPage returned from useInfiniteQuery

Except for fetchNextPage and fetchPreviousPage, this flag was defaulting to false, which was inconsistent and potentially troublesome: Calling refetchQueries or invalidateQueries after a mutation might not yield the latest result if a previous slow fetch was already ongoing, because this refetch would have been skipped.

We believe that if a query is actively refetched by some code you write, it should, per default, re-start the fetch.

That is why this flag now defaults to _true_ for all methods mentioned above. It also means that if you call refetchQueries twice in a row, without awaiting it, it will now cancel the first fetch and re-start it with the second one:

    queryClient.refetchQueries({ queryKey: ['todos'] })
    // this will abort the previous refetch and start a new fetch
    queryClient.refetchQueries({ queryKey: ['todos'] })
    

    queryClient.refetchQueries({ queryKey: ['todos'] })
    // this will abort the previous refetch and start a new fetch
    queryClient.refetchQueries({ queryKey: ['todos'] })
    

You can opt-out of this behaviour by explicitly passing cancelRefetch:false:

    queryClient.refetchQueries({ queryKey: ['todos'] })
    // this will not abort the previous refetch - it will just be ignored
    queryClient.refetchQueries({ queryKey: ['todos'] }, { cancelRefetch: false })
    

    queryClient.refetchQueries({ queryKey: ['todos'] })
    // this will not abort the previous refetch - it will just be ignored
    queryClient.refetchQueries({ queryKey: ['todos'] }, { cancelRefetch: false })
    

> Note: There is no change in behaviour for automatically triggered fetches, e.g. because a query mounts or because of a window focus refetch.

### [](#query-filters)[Query Filters](#query-filters)

A [query filter](https://tanstack.com/query/latest/docs/framework/react/guides/filters) is an object with certain conditions to match a query. Historically, the filter options have mostly been a combination of boolean flags. However, combining those flags can lead to impossible states. Specifically:

    active?: boolean
      - When set to true it will match active queries.
      - When set to false it will match inactive queries.
    inactive?: boolean
      - When set to true it will match inactive queries.
      - When set to false it will match active queries.
    

    active?: boolean
      - When set to true it will match active queries.
      - When set to false it will match inactive queries.
    inactive?: boolean
      - When set to true it will match inactive queries.
      - When set to false it will match active queries.
    

Those flags don't work well when used together, because they are mutually exclusive. Setting false for both flags could match all queries, judging from the description, or no queries, which doesn't make much sense.

With v4, those filters have been combined into a single filter to better show the intent:

    - active?: boolean // [!code --]
    - inactive?: boolean // [!code --]
    + type?: 'active' | 'inactive' | 'all' // [!code ++]
    

    - active?: boolean // [!code --]
    - inactive?: boolean // [!code --]
    + type?: 'active' | 'inactive' | 'all' // [!code ++]
    

The filter defaults to all, and you can choose to only match active or inactive queries.

#### [](#refetchactive--refetchinactive)[refetchActive / refetchInactive](#refetchactive--refetchinactive)

[queryClient.invalidateQueries](https://tanstack.com/query/latest/docs/reference/QueryClient#queryclientinvalidatequeries) had two additional, similar flags:

    refetchActive: Boolean
      - Defaults to true
      - When set to false, queries that match the refetch predicate and are actively being rendered
        via useQuery and friends will NOT be refetched in the background, and only marked as invalid.
    refetchInactive: Boolean
      - Defaults to false
      - When set to true, queries that match the refetch predicate and are not being rendered
        via useQuery and friends will be both marked as invalid and also refetched in the background
    

    refetchActive: Boolean
      - Defaults to true
      - When set to false, queries that match the refetch predicate and are actively being rendered
        via useQuery and friends will NOT be refetched in the background, and only marked as invalid.
    refetchInactive: Boolean
      - Defaults to false
      - When set to true, queries that match the refetch predicate and are not being rendered
        via useQuery and friends will be both marked as invalid and also refetched in the background
    

For the same reason, those have also been combined:

    - refetchActive?: boolean // [!code --]
    - refetchInactive?: boolean // [!code --]
    + refetchType?: 'active' | 'inactive' | 'all' | 'none' // [!code ++]
    

    - refetchActive?: boolean // [!code --]
    - refetchInactive?: boolean // [!code --]
    + refetchType?: 'active' | 'inactive' | 'all' | 'none' // [!code ++]
    

This flag defaults to active because refetchActive defaulted to true. This means we also need a way to tell invalidateQueries to not refetch at all, which is why a fourth option (none) is also allowed here.

### [](#onsuccess-is-no-longer-called-from-setquerydata)[onSuccess is no longer called from setQueryData](#onsuccess-is-no-longer-called-from-setquerydata)

This was confusing to many and also created infinite loops if setQueryData was called from within onSuccess. It was also a frequent source of error when combined with staleTime, because if data was read from the cache only, onSuccess was _not_ called.

Similar to onError and onSettled, the onSuccess callback is now tied to a request being made. No request -> no callback.

If you want to listen to changes of the data field, you can best do this with a useEffect, where data is part of the dependency Array. Since React Query ensures stable data through structural sharing, the effect will not execute with every background refetch, but only if something within data has changed:

    const { data } = useQuery({ queryKey, queryFn })
    React.useEffect(() => mySideEffectHere(data), [data])
    

    const { data } = useQuery({ queryKey, queryFn })
    React.useEffect(() => mySideEffectHere(data), [data])
    

### [](#persistqueryclient-and-the-corresponding-persister-plugins-are-no-longer-experimental-and-have-been-renamed)[persistQueryClient and the corresponding persister plugins are no longer experimental and have been renamed](#persistqueryclient-and-the-corresponding-persister-plugins-are-no-longer-experimental-and-have-been-renamed)

The plugins createWebStoragePersistor and createAsyncStoragePersistor have been renamed to [createSyncStoragePersister](https://tanstack.com/query/latest/docs/framework/react/plugins/createSyncStoragePersister) and [createAsyncStoragePersister](https://tanstack.com/query/latest/docs/framework/react/plugins/createAsyncStoragePersister) respectively. The interface Persistor in persistQueryClient has also been renamed to Persister. Checkout [this stackexchange](https://english.stackexchange.com/questions/206893/persister-or-persistor) for the motivation of this change.

Since these plugins are no longer experimental, their import paths have also been updated:

    - import { persistQueryClient } from 'react-query/persistQueryClient-experimental' // [!code --]
    - import { createWebStoragePersistor } from 'react-query/createWebStoragePersistor-experimental' // [!code --]
    - import { createAsyncStoragePersistor } from 'react-query/createAsyncStoragePersistor-experimental' // [!code --]
    
    + import { persistQueryClient } from '@tanstack/react-query-persist-client' // [!code ++]
    + import { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister' // [!code ++]
    + import { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister'  // [!code ++]
    

    - import { persistQueryClient } from 'react-query/persistQueryClient-experimental' // [!code --]
    - import { createWebStoragePersistor } from 'react-query/createWebStoragePersistor-experimental' // [!code --]
    - import { createAsyncStoragePersistor } from 'react-query/createAsyncStoragePersistor-experimental' // [!code --]
    
    + import { persistQueryClient } from '@tanstack/react-query-persist-client' // [!code ++]
    + import { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister' // [!code ++]
    + import { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister'  // [!code ++]
    

### [](#the-cancel-method-on-promises-is-no-longer-supported)[The cancel method on promises is no longer supported](#the-cancel-method-on-promises-is-no-longer-supported)

The [old cancel method](https://tanstack.com/query/latest/docs/framework/react/guides/query-cancellation#old-cancel-function) that allowed you to define a cancel function on promises, which was then used by the library to support query cancellation, has been removed. We recommend to use the [newer API](https://tanstack.com/query/latest/docs/framework/react/guides/query-cancellation) (introduced with v3.30.0) for query cancellation that uses the [AbortController API](https://developer.mozilla.org/en-US/docs/Web/API/AbortController) internally and provides you with an [AbortSignal instance](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) for your query function to support query cancellation.

### [](#typescript)[TypeScript](#typescript)

Types now require using TypeScript v4.1 or greater

### [](#supported-browsers)[Supported Browsers](#supported-browsers)

As of v4, React Query is optimized for modern browsers. We have updated our browserslist to produce a more modern, performant and smaller bundle. You can read about the requirements [here](https://tanstack.com/query/latest/docs/framework/react/installation#requirements).

### [](#setlogger-is-removed)[setLogger is removed](#setlogger-is-removed)

It was possible to change the logger globally by calling setLogger. In v4, that function is replaced with an optional field when creating a QueryClient.

    - import { QueryClient, setLogger } from 'react-query'; // [!code --]
    + import { QueryClient } from '@tanstack/react-query'; // [!code ++]
    
    - setLogger(customLogger) // [!code --]
    - const queryClient = new QueryClient(); // [!code --]
    + const queryClient = new QueryClient({ logger: customLogger }) // [!code ++]
    

    - import { QueryClient, setLogger } from 'react-query'; // [!code --]
    + import { QueryClient } from '@tanstack/react-query'; // [!code ++]
    
    - setLogger(customLogger) // [!code --]
    - const queryClient = new QueryClient(); // [!code --]
    + const queryClient = new QueryClient({ logger: customLogger }) // [!code ++]
    

### [](#no-default-manual-garbage-collection-server-side)[No _default_ manual Garbage Collection server-side](#no-default-manual-garbage-collection-server-side)

In v3, React Query would cache query results for a default of 5 minutes, then manually garbage collect that data. This default was applied to server-side React Query as well.

This lead to high memory consumption and hanging processes waiting for this manual garbage collection to complete. In v4, by default the server-side cacheTime is now set to Infinity effectively disabling manual garbage collection (the NodeJS process will clear everything once a request is complete).

This change only impacts users of server-side React Query, such as with Next.js. If you are setting a cacheTime manually this will not impact you (although you may want to mirror behavior).

### [](#logging-in-production)[Logging in production](#logging-in-production)

Starting with v4, react-query will no longer log errors (e.g. failed fetches) to the console in production mode, as this was confusing to many. Errors will still show up in development mode.

### [](#esm-support)[ESM Support](#esm-support)

React Query now supports [package.json "exports"](https://nodejs.org/api/packages.html#exports) and is fully compatible with Node's native resolution for both CommonJS and ESM. We don't expect this to be a breaking change for most users, but this restricts the files you can import into your project to only the entry points we officially support.

### [](#streamlined-notifyevents)[Streamlined NotifyEvents](#streamlined-notifyevents)

Subscribing manually to the QueryCache has always given you a QueryCacheNotifyEvent, but this was not true for the MutationCache. We have streamlined the behavior and also adapted event names accordingly.

#### [](#querycachenotifyevent)[QueryCacheNotifyEvent](#querycachenotifyevent)

    - type: 'queryAdded' // [!code --]
    + type: 'added' // [!code ++]
    - type: 'queryRemoved' // [!code --]
    + type: 'removed' // [!code ++]
    - type: 'queryUpdated' // [!code --]
    + type: 'updated' // [!code ++]
    

    - type: 'queryAdded' // [!code --]
    + type: 'added' // [!code ++]
    - type: 'queryRemoved' // [!code --]
    + type: 'removed' // [!code ++]
    - type: 'queryUpdated' // [!code --]
    + type: 'updated' // [!code ++]
    

#### [](#mutationcachenotifyevent)[MutationCacheNotifyEvent](#mutationcachenotifyevent)

The MutationCacheNotifyEvent uses the same types as the QueryCacheNotifyEvent.

> Note: This is only relevant if you manually subscribe to the caches via queryCache.subscribe or mutationCache.subscribe

### [](#separate-hydration-exports-have-been-removed)[Separate hydration exports have been removed](#separate-hydration-exports-have-been-removed)

With version [3.22.0](https://github.com/tannerlinsley/react-query/releases/tag/v3.22.0), hydration utilities moved into the React Query core. With v3, you could still use the old exports from react-query/hydration, but these exports have been removed with v4.

    - import { dehydrate, hydrate, useHydrate, Hydrate } from 'react-query/hydration' // [!code --]
    + import { dehydrate, hydrate, useHydrate, Hydrate } from '@tanstack/react-query' // [!code ++]
    

    - import { dehydrate, hydrate, useHydrate, Hydrate } from 'react-query/hydration' // [!code --]
    + import { dehydrate, hydrate, useHydrate, Hydrate } from '@tanstack/react-query' // [!code ++]
    

### [](#removed-undocumented-methods-from-the-queryclient-query-and-mutation)[Removed undocumented methods from the queryClient, query and mutation](#removed-undocumented-methods-from-the-queryclient-query-and-mutation)

The methods cancelMutations and executeMutation on the QueryClient were undocumented and unused internally, so we removed them. Since it was just a wrapper around a method available on the mutationCache, you can still use the functionality of executeMutation

    - executeMutation< // [!code --]
    -   TData = unknown, // [!code --]
    -   TError = unknown, // [!code --]
    -   TVariables = void, // [!code --]
    -   TContext = unknown // [!code --]
    - >( // [!code --]
    -   options: MutationOptions<TData, TError, TVariables, TContext> // [!code --]
    - ): Promise<TData> { // [!code --]
    -   return this.mutationCache.build(this, options).execute() // [!code --]
    - } // [!code --]
    

    - executeMutation< // [!code --]
    -   TData = unknown, // [!code --]
    -   TError = unknown, // [!code --]
    -   TVariables = void, // [!code --]
    -   TContext = unknown // [!code --]
    - >( // [!code --]
    -   options: MutationOptions<TData, TError, TVariables, TContext> // [!code --]
    - ): Promise<TData> { // [!code --]
    -   return this.mutationCache.build(this, options).execute() // [!code --]
    - } // [!code --]
    

Additionally, query.setDefaultOptions was removed because it was also unused. mutation.cancel was removed because it didn't actually cancel the outgoing request.

### [](#the-srcreact-directory-was-renamed-to-srcreactjs)[The src/react directory was renamed to src/reactjs](#the-srcreact-directory-was-renamed-to-srcreactjs)

Previously, React Query had a directory named react which imported from the react module. This could cause problems with some Jest configurations, resulting in errors when running tests like:

    TypeError: Cannot read property 'createContext' of undefined
    

    TypeError: Cannot read property 'createContext' of undefined
    

With the renamed directory this no longer is an issue.

If you were importing anything from 'react-query/react' directly in your project (as opposed to just 'react-query'), then you need to update your imports:

    - import { QueryClientProvider } from 'react-query/react'; // [!code --]
    + import { QueryClientProvider } from '@tanstack/react-query/reactjs'; // [!code ++]
    

    - import { QueryClientProvider } from 'react-query/react'; // [!code --]
    + import { QueryClientProvider } from '@tanstack/react-query/reactjs'; // [!code ++]
    

[](#new-features-)[New Features üöÄ](#new-features-)
---------------------------------------------------

v4 comes with an awesome set of new features:

### [](#support-for-react-18)[Support for React 18](#support-for-react-18)

React 18 was released earlier this year, and v4 now has first class support for it and the new concurrent features it brings.

### [](#proper-offline-support)[Proper offline support](#proper-offline-support)

In v3, React Query has always fired off queries and mutations, but then taken the assumption that if you want to retry it, you need to be connected to the internet. This has led to several confusing situations:

*   You are offline and mount a query - it goes to loading state, the request fails, and it stays in loading state until you go online again, even though it is not really fetching.
*   Similarly, if you are offline and have retries turned off, your query will just fire and fail, and the query goes to error state.
*   You are offline and want to fire off a query that doesn't necessarily need network connection (because you _can_ use React Query for something other than data fetching), but it fails for some other reason. That query will now be paused until you go online again.
*   Window focus refetching didn't do anything at all if you were offline.

With v4, React Query introduces a new networkMode to tackle all these issues. Please read the dedicated page about the new [Network mode](https://tanstack.com/query/latest/docs/framework/react/guides/network-mode) for more information.

### [](#tracked-queries-per-default)[Tracked Queries per default](#tracked-queries-per-default)

React Query defaults to "tracking" query properties, which should give you a nice boost in render optimization. The feature has existed since [v3.6.0](https://github.com/tannerlinsley/react-query/releases/tag/v3.6.0) and has now become the default behavior with v4.

### [](#bailing-out-of-updates-with-setquerydata)[Bailing out of updates with setQueryData](#bailing-out-of-updates-with-setquerydata)

When using the [functional updater form of setQueryData](https://tanstack.com/query/latest/docs/reference/QueryClient#queryclientsetquerydata), you can now bail out of the update by returning undefined. This is helpful if undefined is given to you as previousValue, which means that currently, no cached entry exists and you don't want to / cannot create one, like in the example of toggling a todo:

    queryClient.setQueryData(['todo', id], (previousTodo) =>
      previousTodo ? { ...previousTodo, done: true } : undefined,
    )
    

    queryClient.setQueryData(['todo', id], (previousTodo) =>
      previousTodo ? { ...previousTodo, done: true } : undefined,
    )
    

### [](#mutation-cache-garbage-collection)[Mutation Cache Garbage Collection](#mutation-cache-garbage-collection)

Mutations can now also be garbage collected automatically, just like queries. The default cacheTime for mutations is also set to 5 minutes.

### [](#custom-contexts-for-multiple-providers)[Custom Contexts for Multiple Providers](#custom-contexts-for-multiple-providers)

Custom contexts can now be specified to pair hooks with their matching Provider. This is critical when there may be multiple React Query Provider instances in the component tree, and you need to ensure your hook uses the correct Provider instance.

An example:

1.  Create a data package.

    // Our first data package: @my-scope/container-data
    
    const context = React.createContext<QueryClient | undefined>(undefined)
    const queryClient = new QueryClient()
    
    export const useUser = () => {
      return useQuery(USER_KEY, USER_FETCHER, {
        context,
      })
    }
    
    export const ContainerDataProvider = ({
      children,
    }: {
      children: React.ReactNode
    }) => {
      return (
        <QueryClientProvider client={queryClient} context={context}>
          {children}
        </QueryClientProvider>
      )
    }
    

    // Our first data package: @my-scope/container-data
    
    const context = React.createContext<QueryClient | undefined>(undefined)
    const queryClient = new QueryClient()
    
    export const useUser = () => {
      return useQuery(USER_KEY, USER_FETCHER, {
        context,
      })
    }
    
    export const ContainerDataProvider = ({
      children,
    }: {
      children: React.ReactNode
    }) => {
      return (
        <QueryClientProvider client={queryClient} context={context}>
          {children}
        </QueryClientProvider>
      )
    }
    

2.  Create a second data package.

    // Our second data package: @my-scope/my-component-data
    
    const context = React.createContext<QueryClient | undefined>(undefined)
    const queryClient = new QueryClient()
    
    export const useItems = () => {
      return useQuery(ITEMS_KEY, ITEMS_FETCHER, {
        context,
      })
    }
    
    export const MyComponentDataProvider = ({
      children,
    }: {
      children: React.ReactNode
    }) => {
      return (
        <QueryClientProvider client={queryClient} context={context}>
          {children}
        </QueryClientProvider>
      )
    }
    

    // Our second data package: @my-scope/my-component-data
    
    const context = React.createContext<QueryClient | undefined>(undefined)
    const queryClient = new QueryClient()
    
    export const useItems = () => {
      return useQuery(ITEMS_KEY, ITEMS_FETCHER, {
        context,
      })
    }
    
    export const MyComponentDataProvider = ({
      children,
    }: {
      children: React.ReactNode
    }) => {
      return (
        <QueryClientProvider client={queryClient} context={context}>
          {children}
        </QueryClientProvider>
      )
    }
    

3.  Use these two data packages in your application.

    // Our application
    
    import { ContainerDataProvider, useUser } from "@my-scope/container-data";
    import { AppDataProvider } from "@my-scope/app-data";
    import { MyComponentDataProvider, useItems } from "@my-scope/my-component-data";
    
    <ContainerDataProvider> // <-- Provides container data (like "user") using its own React Query provider
      ...
      <AppDataProvider> // <-- Provides app data using its own React Query provider (unused in this example)
        ...
          <MyComponentDataProvider> // <-- Provides component data (like "items") using its own React Query provider
            <MyComponent />
          </MyComponentDataProvider>
        ...
      </AppDataProvider>
      ...
    </ContainerDataProvider>
    
    // Example of hooks provided by the "DataProvider" components above:
    const MyComponent = () => {
      const user = useUser() // <-- Uses the context specified in ContainerDataProvider.
      const items = useItems() // <-- Uses the context specified in MyComponentDataProvider
      ...
    }
    

    // Our application
    
    import { ContainerDataProvider, useUser } from "@my-scope/container-data";
    import { AppDataProvider } from "@my-scope/app-data";
    import { MyComponentDataProvider, useItems } from "@my-scope/my-component-data";
    
    <ContainerDataProvider> // <-- Provides container data (like "user") using its own React Query provider
      ...
      <AppDataProvider> // <-- Provides app data using its own React Query provider (unused in this example)
        ...
          <MyComponentDataProvider> // <-- Provides component data (like "items") using its own React Query provider
            <MyComponent />
          </MyComponentDataProvider>
        ...
      </AppDataProvider>
      ...
    </ContainerDataProvider>
    
    // Example of hooks provided by the "DataProvider" components above:
    const MyComponent = () => {
      const user = useUser() // <-- Uses the context specified in ContainerDataProvider.
      const items = useItems() // <-- Uses the context specified in MyComponentDataProvider
      ...
    }</content>
</page>

<page>
  <title>QueryClient | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/reference/QueryClient</url>
  <content>[](#queryclient)[QueryClient](#queryclient)
-------------------------------------------

The QueryClient can be used to interact with a cache:

    import { QueryClient } from '@tanstack/react-query'
    
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          staleTime: Infinity,
        },
      },
    })
    
    await queryClient.prefetchQuery({ queryKey: ['posts'], queryFn: fetchPosts })
    

    import { QueryClient } from '@tanstack/react-query'
    
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          staleTime: Infinity,
        },
      },
    })
    
    await queryClient.prefetchQuery({ queryKey: ['posts'], queryFn: fetchPosts })
    

Its available methods are:

*   [queryClient.fetchQuery](#queryclientfetchquery)
*   [queryClient.fetchInfiniteQuery](#queryclientfetchinfinitequery)
*   [queryClient.prefetchQuery](#queryclientprefetchquery)
*   [queryClient.prefetchInfiniteQuery](#queryclientprefetchinfinitequery)
*   [queryClient.getQueryData](#queryclientgetquerydata)
*   [queryClient.ensureQueryData](#queryclientensurequerydata)
*   [queryClient.ensureInfiniteQueryData](#queryclientensureinfinitequerydata)
*   [queryClient.getQueriesData](#queryclientgetqueriesdata)
*   [queryClient.setQueryData](#queryclientsetquerydata)
*   [queryClient.getQueryState](#queryclientgetquerystate)
*   [queryClient.setQueriesData](#queryclientsetqueriesdata)
*   [queryClient.invalidateQueries](#queryclientinvalidatequeries)
*   [queryClient.refetchQueries](#queryclientrefetchqueries)
*   [queryClient.cancelQueries](#queryclientcancelqueries)
*   [queryClient.removeQueries](#queryclientremovequeries)
*   [queryClient.resetQueries](#queryclientresetqueries)
*   [queryClient.isFetching](#queryclientisfetching)
*   [queryClient.isMutating](#queryclientismutating)
*   [queryClient.getDefaultOptions](#queryclientgetdefaultoptions)
*   [queryClient.setDefaultOptions](#queryclientsetdefaultoptions)
*   [queryClient.getQueryDefaults](#queryclientgetquerydefaults)
*   [queryClient.setQueryDefaults](#queryclientsetquerydefaults)
*   [queryClient.getMutationDefaults](#queryclientgetmutationdefaults)
*   [queryClient.setMutationDefaults](#queryclientsetmutationdefaults)
*   [queryClient.getQueryCache](#queryclientgetquerycache)
*   [queryClient.getMutationCache](#queryclientgetmutationcache)
*   [queryClient.clear](#queryclientclear)
*   [queryClient.resumePausedMutations](#queryclientresumepausedmutations)

**Options**

*   queryCache?: QueryCache
    *   Optional
    *   The query cache this client is connected to.
*   mutationCache?: MutationCache
    *   Optional
    *   The mutation cache this client is connected to.
*   defaultOptions?: DefaultOptions
    *   Optional
    *   Define defaults for all queries and mutations using this queryClient.
    *   You can also define defaults to be used for [hydration](https://tanstack.com/query/latest/docs/framework/react/reference/hydration)

[](#queryclientfetchquery)[queryClient.fetchQuery](#queryclientfetchquery)
--------------------------------------------------------------------------

fetchQuery is an asynchronous method that can be used to fetch and cache a query. It will either resolve with the data or throw with the error. Use the prefetchQuery method if you just want to fetch a query without needing the result.

If the query exists and the data is not invalidated or older than the given staleTime, then the data from the cache will be returned. Otherwise it will try to fetch the latest data.

    try {
      const data = await queryClient.fetchQuery({ queryKey, queryFn })
    } catch (error) {
      console.log(error)
    }
    

    try {
      const data = await queryClient.fetchQuery({ queryKey, queryFn })
    } catch (error) {
      console.log(error)
    }
    

Specify a staleTime to only fetch when the data is older than a certain amount of time:

    try {
      const data = await queryClient.fetchQuery({
        queryKey,
        queryFn,
        staleTime: 10000,
      })
    } catch (error) {
      console.log(error)
    }
    

    try {
      const data = await queryClient.fetchQuery({
        queryKey,
        queryFn,
        staleTime: 10000,
      })
    } catch (error) {
      console.log(error)
    }
    

**Options**

The options for fetchQuery are exactly the same as those of [useQuery](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery), except the following: enabled, refetchInterval, refetchIntervalInBackground, refetchOnWindowFocus, refetchOnReconnect, refetchOnMount, notifyOnChangeProps, throwOnError, select, suspense, placeholderData; which are strictly for useQuery and useInfiniteQuery. You can check the [source code](https://github.com/TanStack/query/blob/7cd2d192e6da3df0b08e334ea1cf04cd70478827/packages/query-core/src/types.ts#L119) for more clarity.

**Returns**

*   Promise<TData>

[](#queryclientfetchinfinitequery)[queryClient.fetchInfiniteQuery](#queryclientfetchinfinitequery)
--------------------------------------------------------------------------------------------------

fetchInfiniteQuery is similar to fetchQuery but can be used to fetch and cache an infinite query.

    try {
      const data = await queryClient.fetchInfiniteQuery({ queryKey, queryFn })
      console.log(data.pages)
    } catch (error) {
      console.log(error)
    }
    

    try {
      const data = await queryClient.fetchInfiniteQuery({ queryKey, queryFn })
      console.log(data.pages)
    } catch (error) {
      console.log(error)
    }
    

**Options**

The options for fetchInfiniteQuery are exactly the same as those of [fetchQuery](#queryclientfetchquery).

**Returns**

*   Promise<InfiniteData<TData, TPageParam>>

[](#queryclientprefetchquery)[queryClient.prefetchQuery](#queryclientprefetchquery)
-----------------------------------------------------------------------------------

prefetchQuery is an asynchronous method that can be used to prefetch a query before it is needed or rendered with useQuery and friends. The method works the same as fetchQuery except that it will not throw or return any data.

    await queryClient.prefetchQuery({ queryKey, queryFn })
    

    await queryClient.prefetchQuery({ queryKey, queryFn })
    

You can even use it with a default queryFn in your config!

    await queryClient.prefetchQuery({ queryKey })
    

    await queryClient.prefetchQuery({ queryKey })
    

**Options**

The options for prefetchQuery are exactly the same as those of [fetchQuery](#queryclientfetchquery).

**Returns**

*   Promise<void>
    *   A promise is returned that will either immediately resolve if no fetch is needed or after the query has been executed. It will not return any data or throw any errors.

[](#queryclientprefetchinfinitequery)[queryClient.prefetchInfiniteQuery](#queryclientprefetchinfinitequery)
-----------------------------------------------------------------------------------------------------------

prefetchInfiniteQuery is similar to prefetchQuery but can be used to prefetch and cache an infinite query.

    await queryClient.prefetchInfiniteQuery({ queryKey, queryFn })
    

    await queryClient.prefetchInfiniteQuery({ queryKey, queryFn })
    

**Options**

The options for prefetchInfiniteQuery are exactly the same as those of [fetchQuery](#queryclientfetchquery).

**Returns**

*   Promise<void>
    *   A promise is returned that will either immediately resolve if no fetch is needed or after the query has been executed. It will not return any data or throw any errors.

[](#queryclientgetquerydata)[queryClient.getQueryData](#queryclientgetquerydata)
--------------------------------------------------------------------------------

getQueryData is a synchronous function that can be used to get an existing query's cached data. If the query does not exist, undefined will be returned.

    const data = queryClient.getQueryData(queryKey)
    

    const data = queryClient.getQueryData(queryKey)
    

**Options**

*   queryKey: QueryKey: [Query Keys](https://tanstack.com/query/latest/docs/framework/react/guides/query-keys)

**Returns**

*   data: TQueryFnData | undefined
    *   The data for the cached query, or undefined if the query does not exist.

[](#queryclientensurequerydata)[queryClient.ensureQueryData](#queryclientensurequerydata)
-----------------------------------------------------------------------------------------

ensureQueryData is an asynchronous function that can be used to get an existing query's cached data. If the query does not exist, queryClient.fetchQuery will be called and its results returned.

    const data = await queryClient.ensureQueryData({ queryKey, queryFn })
    

    const data = await queryClient.ensureQueryData({ queryKey, queryFn })
    

**Options**

*   the same options as [fetchQuery](#queryclientfetchquery)
*   revalidateIfStale: boolean
    *   Optional
    *   Defaults to false
    *   If set to true, stale data will be refetched in the background, but cached data will be returned immediately.

**Returns**

*   Promise<TData>

[](#queryclientensureinfinitequerydata)[queryClient.ensureInfiniteQueryData](#queryclientensureinfinitequerydata)
-----------------------------------------------------------------------------------------------------------------

ensureInfiniteQueryData is an asynchronous function that can be used to get an existing infinite query's cached data. If the query does not exist, queryClient.fetchInfiniteQuery will be called and its results returned.

    const data = await queryClient.ensureInfiniteQueryData({
      queryKey,
      queryFn,
      initialPageParam,
      getNextPageParam,
    })
    

    const data = await queryClient.ensureInfiniteQueryData({
      queryKey,
      queryFn,
      initialPageParam,
      getNextPageParam,
    })
    

**Options**

*   the same options as [fetchInfiniteQuery](#queryclientfetchinfinitequery)
*   revalidateIfStale: boolean
    *   Optional
    *   Defaults to false
    *   If set to true, stale data will be refetched in the background, but cached data will be returned immediately.

**Returns**

*   Promise<InfiniteData<TData, TPageParam>>

[](#queryclientgetqueriesdata)[queryClient.getQueriesData](#queryclientgetqueriesdata)
--------------------------------------------------------------------------------------

getQueriesData is a synchronous function that can be used to get the cached data of multiple queries. Only queries that match the passed queryKey or queryFilter will be returned. If there are no matching queries, an empty array will be returned.

    const data = queryClient.getQueriesData(filters)
    

    const data = queryClient.getQueriesData(filters)
    

**Options**

*   filters: QueryFilters: [Query Filters](https://tanstack.com/query/latest/docs/framework/react/guides/filters#query-filters)
    *   if a filter is passed, the data with queryKeys matching the filter will be returned

**Returns**

*   \[queryKey: QueryKey, data: TQueryFnData | undefined\]\[\]
    *   An array of tuples for the matched query keys, or \[\] if there are no matches. The tuples are the query key and its associated data.

**Caveats**

Because the returned data in each tuple can be of varying structures (i.e. using a filter to return "active" queries can return different data types), the TData generic defaults to unknown. If you provide a more specific type to TData it is assumed that you are certain each tuple's data entry is all the same type.

This distinction is more a "convenience" for ts devs that know which structure will be returned.

[](#queryclientsetquerydata)[queryClient.setQueryData](#queryclientsetquerydata)
--------------------------------------------------------------------------------

setQueryData is a synchronous function that can be used to immediately update a query's cached data. If the query does not exist, it will be created. **If the query is not utilized by a query hook in the default gcTime of 5 minutes, the query will be garbage collected**. To update multiple queries at once and match query keys partially, you need to use [queryClient.setQueriesData](#queryclientsetqueriesdata) instead.

> The difference between using setQueryData and fetchQuery is that setQueryData is sync and assumes that you already synchronously have the data available. If you need to fetch the data asynchronously, it's suggested that you either refetch the query key or use fetchQuery to handle the asynchronous fetch.

    queryClient.setQueryData(queryKey, updater)
    

    queryClient.setQueryData(queryKey, updater)
    

**Options**

*   queryKey: QueryKey: [Query Keys](https://tanstack.com/query/latest/docs/framework/react/guides/query-keys)
*   updater: TQueryFnData | undefined | ((oldData: TQueryFnData | undefined) => TQueryFnData | undefined)
    *   If non-function is passed, the data will be updated to this value
    *   If a function is passed, it will receive the old data value and be expected to return a new one.

**Using an updater value**

    setQueryData(queryKey, newData)
    

    setQueryData(queryKey, newData)
    

If the value is undefined, the query data is not updated.

**Using an updater function**

For convenience in syntax, you can also pass an updater function which receives the current data value and returns the new one:

    setQueryData(queryKey, (oldData) => newData)
    

    setQueryData(queryKey, (oldData) => newData)
    

If the updater function returns undefined, the query data will not be updated. If the updater function receives undefined as input, you can return undefined to bail out of the update and thus _not_ create a new cache entry.

**Immutability**

Updates via setQueryData must be performed in an _immutable_ way. **DO NOT** attempt to write directly to the cache by mutating oldData or data that you retrieved via getQueryData in place.

[](#queryclientgetquerystate)[queryClient.getQueryState](#queryclientgetquerystate)
-----------------------------------------------------------------------------------

getQueryState is a synchronous function that can be used to get an existing query's state. If the query does not exist, undefined will be returned.

    const state = queryClient.getQueryState(queryKey)
    console.log(state.dataUpdatedAt)
    

    const state = queryClient.getQueryState(queryKey)
    console.log(state.dataUpdatedAt)
    

**Options**

*   queryKey: QueryKey: [Query Keys](https://tanstack.com/query/latest/docs/framework/react/guides/query-keys)

[](#queryclientsetqueriesdata)[queryClient.setQueriesData](#queryclientsetqueriesdata)
--------------------------------------------------------------------------------------

setQueriesData is a synchronous function that can be used to immediately update cached data of multiple queries by using filter function or partially matching the query key. Only queries that match the passed queryKey or queryFilter will be updated - no new cache entries will be created. Under the hood, [setQueryData](#queryclientsetquerydata) is called for each existing query.

    queryClient.setQueriesData(filters, updater)
    

    queryClient.setQueriesData(filters, updater)
    

**Options**

*   filters: QueryFilters: [Query Filters](https://tanstack.com/query/latest/docs/framework/react/guides/filters#query-filters)
    *   if a filter is passed, queryKeys matching the filter will be updated
*   updater: TQueryFnData | (oldData: TQueryFnData | undefined) => TQueryFnData
    *   the [setQueryData](#queryclientsetquerydata) updater function or new data, will be called for each matching queryKey

[](#queryclientinvalidatequeries)[queryClient.invalidateQueries](#queryclientinvalidatequeries)
-----------------------------------------------------------------------------------------------

The invalidateQueries method can be used to invalidate and refetch single or multiple queries in the cache based on their query keys or any other functionally accessible property/state of the query. By default, all matching queries are immediately marked as invalid and active queries are refetched in the background.

*   If you **do not want active queries to refetch**, and simply be marked as invalid, you can use the refetchType: 'none' option.
*   If you **want inactive queries to refetch** as well, use the refetchType: 'all' option
*   For refetching, [queryClient.refetchQueries](#queryclientrefetchqueries) is called.

    await queryClient.invalidateQueries(
      {
        queryKey: ['posts'],
        exact,
        refetchType: 'active',
      },
      { throwOnError, cancelRefetch },
    )
    

    await queryClient.invalidateQueries(
      {
        queryKey: ['posts'],
        exact,
        refetchType: 'active',
      },
      { throwOnError, cancelRefetch },
    )
    

**Options**

*   filters?: QueryFilters: [Query Filters](https://tanstack.com/query/latest/docs/framework/react/guides/filters#query-filters)
    *   queryKey?: QueryKey: [Query Keys](https://tanstack.com/query/latest/docs/framework/react/guides/query-keys)
    *   refetchType?: 'active' | 'inactive' | 'all' | 'none'
        *   Defaults to 'active'
        *   When set to active, only queries that match the refetch predicate and are actively being rendered via useQuery and friends will be refetched in the background.
        *   When set to inactive, only queries that match the refetch predicate and are NOT actively being rendered via useQuery and friends will be refetched in the background.
        *   When set to all, all queries that match the refetch predicate will be refetched in the background.
        *   When set to none, no queries will be refetched, and those that match the refetch predicate will be marked as invalid only.
*   options?: InvalidateOptions:
    *   throwOnError?: boolean
        *   When set to true, this method will throw if any of the query refetch tasks fail.
    *   cancelRefetch?: boolean
        *   Defaults to true
            *   Per default, a currently running request will be cancelled before a new request is made
        *   When set to false, no refetch will be made if there is already a request running.

[](#queryclientrefetchqueries)[queryClient.refetchQueries](#queryclientrefetchqueries)
--------------------------------------------------------------------------------------

The refetchQueries method can be used to refetch queries based on certain conditions.

Examples:

    // refetch all queries:
    await queryClient.refetchQueries()
    
    // refetch all stale queries:
    await queryClient.refetchQueries({ stale: true })
    
    // refetch all active queries partially matching a query key:
    await queryClient.refetchQueries({ queryKey: ['posts'], type: 'active' })
    
    // refetch all active queries exactly matching a query key:
    await queryClient.refetchQueries({
      queryKey: ['posts', 1],
      type: 'active',
      exact: true,
    })
    

    // refetch all queries:
    await queryClient.refetchQueries()
    
    // refetch all stale queries:
    await queryClient.refetchQueries({ stale: true })
    
    // refetch all active queries partially matching a query key:
    await queryClient.refetchQueries({ queryKey: ['posts'], type: 'active' })
    
    // refetch all active queries exactly matching a query key:
    await queryClient.refetchQueries({
      queryKey: ['posts', 1],
      type: 'active',
      exact: true,
    })
    

**Options**

*   filters?: QueryFilters: [Query Filters](https://tanstack.com/query/latest/docs/framework/react/guides/filters#query-filters)
*   options?: RefetchOptions:
    *   throwOnError?: boolean
        *   When set to true, this method will throw if any of the query refetch tasks fail.
    *   cancelRefetch?: boolean
        *   Defaults to true
            *   Per default, a currently running request will be cancelled before a new request is made
        *   When set to false, no refetch will be made if there is already a request running.

**Returns**

This function returns a promise that will resolve when all of the queries are done being refetched. By default, it **will not** throw an error if any of those queries refetches fail, but this can be configured by setting the throwOnError option to true

**Notes**

*   Queries that are "disabled" because they only have disabled Observers will never be refetched.
*   Queries that are "static" because they only have Observers with a Static StaleTime will never be refetched.

[](#queryclientcancelqueries)[queryClient.cancelQueries](#queryclientcancelqueries)
-----------------------------------------------------------------------------------

The cancelQueries method can be used to cancel outgoing queries based on their query keys or any other functionally accessible property/state of the query.

This is most useful when performing optimistic updates since you will likely need to cancel any outgoing query refetches so they don't clobber your optimistic update when they resolve.

    await queryClient.cancelQueries(
      { queryKey: ['posts'], exact: true },
      { silent: true },
    )
    

    await queryClient.cancelQueries(
      { queryKey: ['posts'], exact: true },
      { silent: true },
    )
    

**Options**

*   filters?: QueryFilters: [Query Filters](https://tanstack.com/query/latest/docs/framework/react/guides/filters#query-filters)
*   cancelOptions?: CancelOptions: [Cancel Options](https://tanstack.com/query/latest/docs/framework/react/guides/query-cancellation#cancel-options)

**Returns**

This method does not return anything

[](#queryclientremovequeries)[queryClient.removeQueries](#queryclientremovequeries)
-----------------------------------------------------------------------------------

The removeQueries method can be used to remove queries from the cache based on their query keys or any other functionally accessible property/state of the query.

    queryClient.removeQueries({ queryKey, exact: true })
    

    queryClient.removeQueries({ queryKey, exact: true })
    

**Options**

*   filters?: QueryFilters: [Query Filters](https://tanstack.com/query/latest/docs/framework/react/guides/filters#query-filters)

**Returns**

This method does not return anything

[](#queryclientresetqueries)[queryClient.resetQueries](#queryclientresetqueries)
--------------------------------------------------------------------------------

The resetQueries method can be used to reset queries in the cache to their initial state based on their query keys or any other functionally accessible property/state of the query.

This will notify subscribers ‚Äî unlike clear, which removes all subscribers ‚Äî and reset the query to its pre-loaded state ‚Äî unlike invalidateQueries. If a query has initialData, the query's data will be reset to that. If a query is active, it will be refetched.

    queryClient.resetQueries({ queryKey, exact: true })
    

    queryClient.resetQueries({ queryKey, exact: true })
    

**Options**

*   filters?: QueryFilters: [Query Filters](https://tanstack.com/query/latest/docs/framework/react/guides/filters#query-filters)
*   options?: ResetOptions:
    *   throwOnError?: boolean
        *   When set to true, this method will throw if any of the query refetch tasks fail.
    *   cancelRefetch?: boolean
        *   Defaults to true
            *   Per default, a currently running request will be cancelled before a new request is made
        *   When set to false, no refetch will be made if there is already a request running.

**Returns**

This method returns a promise that resolves when all active queries have been refetched.

[](#queryclientisfetching)[queryClient.isFetching](#queryclientisfetching)
--------------------------------------------------------------------------

This isFetching method returns an integer representing how many queries, if any, in the cache are currently fetching (including background-fetching, loading new pages, or loading more infinite query results)

    if (queryClient.isFetching()) {
      console.log('At least one query is fetching!')
    }
    

    if (queryClient.isFetching()) {
      console.log('At least one query is fetching!')
    }
    

TanStack Query also exports a handy [useIsFetching](https://tanstack.com/query/latest/docs/framework/react/reference/useIsFetching) hook that will let you subscribe to this state in your components without creating a manual subscription to the query cache.

**Options**

*   filters?: QueryFilters: [Query Filters](https://tanstack.com/query/latest/docs/framework/react/guides/filters#query-filters)

**Returns**

This method returns the number of fetching queries.

[](#queryclientismutating)[queryClient.isMutating](#queryclientismutating)
--------------------------------------------------------------------------

This isMutating method returns an integer representing how many mutations, if any, in the cache are currently fetching.

    if (queryClient.isMutating()) {
      console.log('At least one mutation is fetching!')
    }
    

    if (queryClient.isMutating()) {
      console.log('At least one mutation is fetching!')
    }
    

TanStack Query also exports a handy [useIsMutating](https://tanstack.com/query/latest/docs/framework/react/reference/useIsMutating) hook that will let you subscribe to this state in your components without creating a manual subscription to the mutation cache.

**Options**

*   filters: MutationFilters: [Mutation Filters](https://tanstack.com/query/latest/docs/framework/react/guides/filters#mutation-filters)

**Returns**

This method returns the number of fetching mutations.

[](#queryclientgetdefaultoptions)[queryClient.getDefaultOptions](#queryclientgetdefaultoptions)
-----------------------------------------------------------------------------------------------

The getDefaultOptions method returns the default options which have been set when creating the client or with setDefaultOptions.

    const defaultOptions = queryClient.getDefaultOptions()
    

    const defaultOptions = queryClient.getDefaultOptions()
    

[](#queryclientsetdefaultoptions)[queryClient.setDefaultOptions](#queryclientsetdefaultoptions)
-----------------------------------------------------------------------------------------------

The setDefaultOptions method can be used to dynamically set the default options for this queryClient. Previously defined default options will be overwritten.

    queryClient.setDefaultOptions({
      queries: {
        staleTime: Infinity,
      },
    })
    

    queryClient.setDefaultOptions({
      queries: {
        staleTime: Infinity,
      },
    })
    

[](#queryclientgetquerydefaults)[queryClient.getQueryDefaults](#queryclientgetquerydefaults)
--------------------------------------------------------------------------------------------

The getQueryDefaults method returns the default options which have been set for specific queries:

    const defaultOptions = queryClient.getQueryDefaults(['posts'])
    

    const defaultOptions = queryClient.getQueryDefaults(['posts'])
    

> Note that if several query defaults match the given query key, they will be merged together based on the order of registration. See [setQueryDefaults](#queryclientsetquerydefaults).

[](#queryclientsetquerydefaults)[queryClient.setQueryDefaults](#queryclientsetquerydefaults)
--------------------------------------------------------------------------------------------

setQueryDefaults can be used to set default options for specific queries:

    queryClient.setQueryDefaults(['posts'], { queryFn: fetchPosts })
    
    function Component() {
      const { data } = useQuery({ queryKey: ['posts'] })
    }
    

    queryClient.setQueryDefaults(['posts'], { queryFn: fetchPosts })
    
    function Component() {
      const { data } = useQuery({ queryKey: ['posts'] })
    }
    

**Options**

*   queryKey: QueryKey: [Query Keys](https://tanstack.com/query/latest/docs/framework/react/guides/query-keys)
*   options: QueryOptions

> As stated in [getQueryDefaults](#queryclientgetquerydefaults), the order of registration of query defaults does matter. Since the matching defaults are merged by getQueryDefaults, the registration should be made in the following order: from the **most generic key** to the **least generic one** . This way, more specific defaults will override more generic defaults.

[](#queryclientgetmutationdefaults)[queryClient.getMutationDefaults](#queryclientgetmutationdefaults)
-----------------------------------------------------------------------------------------------------

The getMutationDefaults method returns the default options which have been set for specific mutations:

    const defaultOptions = queryClient.getMutationDefaults(['addPost'])
    

    const defaultOptions = queryClient.getMutationDefaults(['addPost'])
    

[](#queryclientsetmutationdefaults)[queryClient.setMutationDefaults](#queryclientsetmutationdefaults)
-----------------------------------------------------------------------------------------------------

setMutationDefaults can be used to set default options for specific mutations:

    queryClient.setMutationDefaults(['addPost'], { mutationFn: addPost })
    
    function Component() {
      const { data } = useMutation({ mutationKey: ['addPost'] })
    }
    

    queryClient.setMutationDefaults(['addPost'], { mutationFn: addPost })
    
    function Component() {
      const { data } = useMutation({ mutationKey: ['addPost'] })
    }
    

**Options**

*   mutationKey: unknown\[\]
*   options: MutationOptions

> Similar to [setQueryDefaults](#queryclientsetquerydefaults), the order of registration does matter here.

[](#queryclientgetquerycache)[queryClient.getQueryCache](#queryclientgetquerycache)
-----------------------------------------------------------------------------------

The getQueryCache method returns the query cache this client is connected to.

    const queryCache = queryClient.getQueryCache()
    

    const queryCache = queryClient.getQueryCache()
    

[](#queryclientgetmutationcache)[queryClient.getMutationCache](#queryclientgetmutationcache)
--------------------------------------------------------------------------------------------

The getMutationCache method returns the mutation cache this client is connected to.

    const mutationCache = queryClient.getMutationCache()
    

    const mutationCache = queryClient.getMutationCache()
    

[](#queryclientclear)[queryClient.clear](#queryclientclear)
-----------------------------------------------------------

The clear method clears all connected caches.

    queryClient.clear()
    

    queryClient.clear()
    

[](#queryclientresumepausedmutations)[queryClient.resumePausedMutations](#queryclientresumepausedmutations)
-----------------------------------------------------------------------------------------------------------

Can be used to resume mutations that have been paused because there was no network connection.

    queryClient.resumePausedMutations()
    

    queryClient.resumePausedMutations()</content>
</page>

<page>
  <title>QueryCache | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/reference/QueryCache</url>
  <content>The QueryCache is the storage mechanism for TanStack Query. It stores all the data, meta information and state of queries it contains.

**Normally, you will not interact with the QueryCache directly and instead use the QueryClient for a specific cache.**

    import { QueryCache } from '@tanstack/react-query'
    
    const queryCache = new QueryCache({
      onError: (error) => {
        console.log(error)
      },
      onSuccess: (data) => {
        console.log(data)
      },
      onSettled: (data, error) => {
        console.log(data, error)
      },
    })
    
    const query = queryCache.find(['posts'])
    

    import { QueryCache } from '@tanstack/react-query'
    
    const queryCache = new QueryCache({
      onError: (error) => {
        console.log(error)
      },
      onSuccess: (data) => {
        console.log(data)
      },
      onSettled: (data, error) => {
        console.log(data, error)
      },
    })
    
    const query = queryCache.find(['posts'])
    

Its available methods are:

*   [queryCache.find](#querycachefind)
*   [queryCache.findAll](#querycachefindall)
*   [queryCache.subscribe](#querycachesubscribe)
*   [queryCache.clear](#querycacheclear)
*   [Further reading](#further-reading)

**Options**

*   onError?: (error: unknown, query: Query) => void
    *   Optional
    *   This function will be called if some query encounters an error.
*   onSuccess?: (data: unknown, query: Query) => void
    *   Optional
    *   This function will be called if some query is successful.
*   onSettled?: (data: unknown | undefined, error: unknown | null, query: Query) => void
    *   Optional
    *   This function will be called if some query is settled (either successful or errored).

[](#querycachefind)[queryCache.find](#querycachefind)
-----------------------------------------------------

find is a slightly more advanced synchronous method that can be used to get an existing query instance from the cache. This instance not only contains **all** the state for the query, but all of the instances, and underlying guts of the query as well. If the query does not exist, undefined will be returned.

> Note: This is not typically needed for most applications, but can come in handy when needing more information about a query in rare scenarios (eg. Looking at the query.state.dataUpdatedAt timestamp to decide whether a query is fresh enough to be used as an initial value)

    const query = queryCache.find(queryKey)
    

    const query = queryCache.find(queryKey)
    

**Options**

*   filters?: QueryFilters: [Query Filters](https://tanstack.com/query/latest/docs/framework/react/guides/filters#query-filters)

**Returns**

*   Query
    *   The query instance from the cache

[](#querycachefindall)[queryCache.findAll](#querycachefindall)
--------------------------------------------------------------

findAll is even more advanced synchronous method that can be used to get existing query instances from the cache that partially match query key. If queries do not exist, empty array will be returned.

> Note: This is not typically needed for most applications, but can come in handy when needing more information about a query in rare scenarios

    const queries = queryCache.findAll(queryKey)
    

    const queries = queryCache.findAll(queryKey)
    

**Options**

*   queryKey?: QueryKey: [Query Keys](https://tanstack.com/query/latest/docs/framework/react/guides/query-keys)
*   filters?: QueryFilters: [Query Filters](https://tanstack.com/query/latest/docs/framework/react/guides/filters#query-filters)

**Returns**

*   Query\[\]
    *   Query instances from the cache

[](#querycachesubscribe)[queryCache.subscribe](#querycachesubscribe)
--------------------------------------------------------------------

The subscribe method can be used to subscribe to the query cache as a whole and be informed of safe/known updates to the cache like query states changing or queries being updated, added or removed

    const callback = (event) => {
      console.log(event.type, event.query)
    }
    
    const unsubscribe = queryCache.subscribe(callback)
    

    const callback = (event) => {
      console.log(event.type, event.query)
    }
    
    const unsubscribe = queryCache.subscribe(callback)
    

**Options**

*   callback: (event: QueryCacheNotifyEvent) => void
    *   This function will be called with the query cache any time it is updated via its tracked update mechanisms (eg, query.setState, queryClient.removeQueries, etc). Out of scope mutations to the cache are not encouraged and will not fire subscription callbacks

**Returns**

*   unsubscribe: Function => void
    *   This function will unsubscribe the callback from the query cache.

[](#querycacheclear)[queryCache.clear](#querycacheclear)
--------------------------------------------------------

The clear method can be used to clear the cache entirely and start fresh.

    queryCache.clear()
    

    queryCache.clear()
    

[](#further-reading)[Further reading](#further-reading)
-------------------------------------------------------

To get a better understanding how the QueryCache works internally, have a look at [the Inside React Query article by TkDodo](https://tkdodo.eu/blog/inside-react-query).</content>
</page>

<page>
  <title>Migrating to TanStack Query v5 | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-v5</url>
  <content>[](#breaking-changes)[Breaking Changes](#breaking-changes)
----------------------------------------------------------

v5 is a major version, so there are some breaking changes to be aware of:

### [](#supports-a-single-signature-one-object)[Supports a single signature, one object](#supports-a-single-signature-one-object)

useQuery and friends used to have many overloads in TypeScript: different ways how the function could be invoked. Not only was this tough to maintain, type wise, it also required a runtime check to see which types the first and the second parameter were, to correctly create options.

now we only support the object format.

    useQuery(key, fn, options) // [!code --]
    useQuery({ queryKey, queryFn, ...options }) // [!code ++]
    useInfiniteQuery(key, fn, options) // [!code --]
    useInfiniteQuery({ queryKey, queryFn, ...options }) // [!code ++]
    useMutation(fn, options) // [!code --]
    useMutation({ mutationFn, ...options }) // [!code ++]
    useIsFetching(key, filters) // [!code --]
    useIsFetching({ queryKey, ...filters }) // [!code ++]
    useIsMutating(key, filters) // [!code --]
    useIsMutating({ mutationKey, ...filters }) // [!code ++]
    

    useQuery(key, fn, options) // [!code --]
    useQuery({ queryKey, queryFn, ...options }) // [!code ++]
    useInfiniteQuery(key, fn, options) // [!code --]
    useInfiniteQuery({ queryKey, queryFn, ...options }) // [!code ++]
    useMutation(fn, options) // [!code --]
    useMutation({ mutationFn, ...options }) // [!code ++]
    useIsFetching(key, filters) // [!code --]
    useIsFetching({ queryKey, ...filters }) // [!code ++]
    useIsMutating(key, filters) // [!code --]
    useIsMutating({ mutationKey, ...filters }) // [!code ++]
    

    queryClient.isFetching(key, filters) // [!code --]
    queryClient.isFetching({ queryKey, ...filters }) // [!code ++]
    queryClient.ensureQueryData(key, filters) // [!code --]
    queryClient.ensureQueryData({ queryKey, ...filters }) // [!code ++]
    queryClient.getQueriesData(key, filters) // [!code --]
    queryClient.getQueriesData({ queryKey, ...filters }) // [!code ++]
    queryClient.setQueriesData(key, updater, filters, options) // [!code --]
    queryClient.setQueriesData({ queryKey, ...filters }, updater, options) // [!code ++]
    queryClient.removeQueries(key, filters) // [!code --]
    queryClient.removeQueries({ queryKey, ...filters }) // [!code ++]
    queryClient.resetQueries(key, filters, options) // [!code --]
    queryClient.resetQueries({ queryKey, ...filters }, options) // [!code ++]
    queryClient.cancelQueries(key, filters, options) // [!code --]
    queryClient.cancelQueries({ queryKey, ...filters }, options) // [!code ++]
    queryClient.invalidateQueries(key, filters, options) // [!code --]
    queryClient.invalidateQueries({ queryKey, ...filters }, options) // [!code ++]
    queryClient.refetchQueries(key, filters, options) // [!code --]
    queryClient.refetchQueries({ queryKey, ...filters }, options) // [!code ++]
    queryClient.fetchQuery(key, fn, options) // [!code --]
    queryClient.fetchQuery({ queryKey, queryFn, ...options }) // [!code ++]
    queryClient.prefetchQuery(key, fn, options) // [!code --]
    queryClient.prefetchQuery({ queryKey, queryFn, ...options }) // [!code ++]
    queryClient.fetchInfiniteQuery(key, fn, options) // [!code --]
    queryClient.fetchInfiniteQuery({ queryKey, queryFn, ...options }) // [!code ++]
    queryClient.prefetchInfiniteQuery(key, fn, options) // [!code --]
    queryClient.prefetchInfiniteQuery({ queryKey, queryFn, ...options }) // [!code ++]
    

    queryClient.isFetching(key, filters) // [!code --]
    queryClient.isFetching({ queryKey, ...filters }) // [!code ++]
    queryClient.ensureQueryData(key, filters) // [!code --]
    queryClient.ensureQueryData({ queryKey, ...filters }) // [!code ++]
    queryClient.getQueriesData(key, filters) // [!code --]
    queryClient.getQueriesData({ queryKey, ...filters }) // [!code ++]
    queryClient.setQueriesData(key, updater, filters, options) // [!code --]
    queryClient.setQueriesData({ queryKey, ...filters }, updater, options) // [!code ++]
    queryClient.removeQueries(key, filters) // [!code --]
    queryClient.removeQueries({ queryKey, ...filters }) // [!code ++]
    queryClient.resetQueries(key, filters, options) // [!code --]
    queryClient.resetQueries({ queryKey, ...filters }, options) // [!code ++]
    queryClient.cancelQueries(key, filters, options) // [!code --]
    queryClient.cancelQueries({ queryKey, ...filters }, options) // [!code ++]
    queryClient.invalidateQueries(key, filters, options) // [!code --]
    queryClient.invalidateQueries({ queryKey, ...filters }, options) // [!code ++]
    queryClient.refetchQueries(key, filters, options) // [!code --]
    queryClient.refetchQueries({ queryKey, ...filters }, options) // [!code ++]
    queryClient.fetchQuery(key, fn, options) // [!code --]
    queryClient.fetchQuery({ queryKey, queryFn, ...options }) // [!code ++]
    queryClient.prefetchQuery(key, fn, options) // [!code --]
    queryClient.prefetchQuery({ queryKey, queryFn, ...options }) // [!code ++]
    queryClient.fetchInfiniteQuery(key, fn, options) // [!code --]
    queryClient.fetchInfiniteQuery({ queryKey, queryFn, ...options }) // [!code ++]
    queryClient.prefetchInfiniteQuery(key, fn, options) // [!code --]
    queryClient.prefetchInfiniteQuery({ queryKey, queryFn, ...options }) // [!code ++]
    

    queryCache.find(key, filters) // [!code --]
    queryCache.find({ queryKey, ...filters }) // [!code ++]
    queryCache.findAll(key, filters) // [!code --]
    queryCache.findAll({ queryKey, ...filters }) // [!code ++]
    

    queryCache.find(key, filters) // [!code --]
    queryCache.find({ queryKey, ...filters }) // [!code ++]
    queryCache.findAll(key, filters) // [!code --]
    queryCache.findAll({ queryKey, ...filters }) // [!code ++]
    

### [](#queryclientgetquerydata-now-accepts-querykey-only-as-an-argument)[queryClient.getQueryData now accepts queryKey only as an Argument](#queryclientgetquerydata-now-accepts-querykey-only-as-an-argument)

queryClient.getQueryData argument is changed to accept only a queryKey

    queryClient.getQueryData(queryKey, filters) // [!code --]
    queryClient.getQueryData(queryKey) // [!code ++]
    

    queryClient.getQueryData(queryKey, filters) // [!code --]
    queryClient.getQueryData(queryKey) // [!code ++]
    

### [](#queryclientgetquerystate-now-accepts-querykey-only-as-an-argument)[queryClient.getQueryState now accepts queryKey only as an Argument](#queryclientgetquerystate-now-accepts-querykey-only-as-an-argument)

queryClient.getQueryState argument is changed to accept only a queryKey

    queryClient.getQueryState(queryKey, filters) // [!code --]
    queryClient.getQueryState(queryKey) // [!code ++]
    

    queryClient.getQueryState(queryKey, filters) // [!code --]
    queryClient.getQueryState(queryKey) // [!code ++]
    

#### [](#codemod)[Codemod](#codemod)

To make the remove overloads migration easier, v5 comes with a codemod.

> The codemod is a best efforts attempt to help you migrate the breaking change. Please review the generated code thoroughly! Also, there are edge cases that cannot be found by the code mod, so please keep an eye on the log output.

If you want to run it against .js or .jsx files, please use the command below:

    npx jscodeshift@latest ./path/to/src/ \
      --extensions=js,jsx \
      --transform=./node_modules/@tanstack/react-query/build/codemods/src/v5/remove-overloads/remove-overloads.cjs
    

    npx jscodeshift@latest ./path/to/src/ \
      --extensions=js,jsx \
      --transform=./node_modules/@tanstack/react-query/build/codemods/src/v5/remove-overloads/remove-overloads.cjs
    

If you want to run it against .ts or .tsx files, please use the command below:

    npx jscodeshift@latest ./path/to/src/ \
      --extensions=ts,tsx \
      --parser=tsx \
      --transform=./node_modules/@tanstack/react-query/build/codemods/src/v5/remove-overloads/remove-overloads.cjs
    

    npx jscodeshift@latest ./path/to/src/ \
      --extensions=ts,tsx \
      --parser=tsx \
      --transform=./node_modules/@tanstack/react-query/build/codemods/src/v5/remove-overloads/remove-overloads.cjs
    

Please note in the case of TypeScript you need to use tsx as the parser; otherwise, the codemod won't be applied properly!

**Note:** Applying the codemod might break your code formatting, so please don't forget to run prettier and/or eslint after you've applied the codemod!

A few notes about how codemod works:

*   Generally, we're looking for the lucky case, when the first parameter is an object expression and contains the "queryKey" or "mutationKey" property (depending on which hook/method call is being transformed). If this is the case, your code already matches the new signature, so the codemod won't touch it. üéâ
*   If the condition above is not fulfilled, then the codemod will check whether the first parameter is an array expression or an identifier that references an array expression. If this is the case, the codemod will put it into an object expression, then it will be the first parameter.
*   If object parameters can be inferred, the codemod will attempt to copy the already existing properties to the newly created one.
*   If the codemod cannot infer the usage, then it will leave a message on the console. The message contains the file name and the line number of the usage. In this case, you need to do the migration manually.
*   If the transformation results in an error, you will also see a message on the console. This message will notify you something unexpected happened, please do the migration manually.

### [](#callbacks-on-usequery-and-queryobserver-have-been-removed)[Callbacks on useQuery (and QueryObserver) have been removed](#callbacks-on-usequery-and-queryobserver-have-been-removed)

onSuccess, onError and onSettled have been removed from Queries. They haven't been touched for Mutations. Please see [this RFC](https://github.com/TanStack/query/discussions/5279) for motivations behind this change and what to do instead.

### [](#the-refetchinterval-callback-function-only-gets-query-passed)[The refetchInterval callback function only gets query passed](#the-refetchinterval-callback-function-only-gets-query-passed)

This streamlines how callbacks are invoked (the refetchOnWindowFocus, refetchOnMount and refetchOnReconnect callbacks all only get the query passed as well), and it fixes some typing issues when callbacks get data transformed by select.

    - refetchInterval: number | false | ((data: TData | undefined, query: Query) => number | false | undefined) // [!code --]
    + refetchInterval: number | false | ((query: Query) => number | false | undefined) // [!code ++]
    

    - refetchInterval: number | false | ((data: TData | undefined, query: Query) => number | false | undefined) // [!code --]
    + refetchInterval: number | false | ((query: Query) => number | false | undefined) // [!code ++]
    

You can still access data with query.state.data, however, it will not be data that has been transformed by select. If you need to access the transformed data, you can call the transformation again on query.state.data.

### [](#the-remove-method-has-been-removed-from-usequery)[The remove method has been removed from useQuery](#the-remove-method-has-been-removed-from-usequery)

Previously, remove method used to remove the query from the queryCache without informing observers about it. It was best used to remove data imperatively that is no longer needed, e.g. when logging a user out.

But It doesn't make much sense to do this while a query is still active, because it will just trigger a hard loading state with the next re-render.

if you still need to remove a query, you can use queryClient.removeQueries({queryKey: key})

    const queryClient = useQueryClient()
    const query = useQuery({ queryKey, queryFn })
    
    query.remove() // [!code --]
    queryClient.removeQueries({ queryKey }) // [!code ++]
    

    const queryClient = useQueryClient()
    const query = useQuery({ queryKey, queryFn })
    
    query.remove() // [!code --]
    queryClient.removeQueries({ queryKey }) // [!code ++]
    

### [](#the-minimum-required-typescript-version-is-now-47)[The minimum required TypeScript version is now 4.7](#the-minimum-required-typescript-version-is-now-47)

Mainly because an important fix was shipped around type inference. Please see this [TypeScript issue](https://github.com/microsoft/TypeScript/issues/43371) for more information.

### [](#the-isdataequal-option-has-been-removed-from-usequery)[The isDataEqual option has been removed from useQuery](#the-isdataequal-option-has-been-removed-from-usequery)

Previously, This function was used to indicate whether to use previous data (true) or new data (false) as a resolved data for the query.

You can achieve the same functionality by passing a function to structuralSharing instead:

    import { replaceEqualDeep } from '@tanstack/react-query'
    
    - isDataEqual: (oldData, newData) => customCheck(oldData, newData) // [!code --]
    + structuralSharing: (oldData, newData) => customCheck(oldData, newData) ? oldData : replaceEqualDeep(oldData, newData) // [!code ++]
    

    import { replaceEqualDeep } from '@tanstack/react-query'
    
    - isDataEqual: (oldData, newData) => customCheck(oldData, newData) // [!code --]
    + structuralSharing: (oldData, newData) => customCheck(oldData, newData) ? oldData : replaceEqualDeep(oldData, newData) // [!code ++]
    

### [](#the-deprecated-custom-logger-has-been-removed)[The deprecated custom logger has been removed](#the-deprecated-custom-logger-has-been-removed)

Custom loggers were already deprecated in 4 and have been removed in this version. Logging only had an effect in development mode, where passing a custom logger is not necessary.

### [](#supported-browsers)[Supported Browsers](#supported-browsers)

We have updated our browserslist to produce a more modern, performant and smaller bundle. You can read about the requirements [here](https://tanstack.com/query/latest/docs/framework/react/installation#requirements).

### [](#private-class-fields-and-methods)[Private class fields and methods](#private-class-fields-and-methods)

TanStack Query has always had private fields and methods on classes, but they weren't really private - they were just private in TypeScript. We now use [ECMAScript Private class features](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields), which means those fields are now truly private and can't be accessed from the outside at runtime.

### [](#rename-cachetime-to-gctime)[Rename cacheTime to gcTime](#rename-cachetime-to-gctime)

Almost everyone gets cacheTime wrong. It sounds like "the amount of time that data is cached for", but that is not correct.

cacheTime does nothing as long as a query is still in use. It only kicks in as soon as the query becomes unused. After the time has passed, data will be "garbage collected" to avoid the cache from growing.

gc is referring to "garbage collect" time. It's a bit more technical, but also a quite [well known abbreviation](https://en.wikipedia.org/wiki/Garbage_collection_\(computer_science\)) in computer science.

    const MINUTE = 1000 * 60;
    
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
    -      cacheTime: 10 * MINUTE, // [!code --]
    +      gcTime: 10 * MINUTE, // [!code ++]
        },
      },
    })
    

    const MINUTE = 1000 * 60;
    
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
    -      cacheTime: 10 * MINUTE, // [!code --]
    +      gcTime: 10 * MINUTE, // [!code ++]
        },
      },
    })
    

### [](#the-useerrorboundary-option-has-been-renamed-to-throwonerror)[The useErrorBoundary option has been renamed to throwOnError](#the-useerrorboundary-option-has-been-renamed-to-throwonerror)

To make the useErrorBoundary option more framework-agnostic and avoid confusion with the established React function prefix "use" for hooks and the "ErrorBoundary" component name, it has been renamed to throwOnError to more accurately reflect its functionality.

### [](#typescript-error-is-now-the-default-type-for-errors-instead-of-unknown)[TypeScript: Error is now the default type for errors instead of unknown](#typescript-error-is-now-the-default-type-for-errors-instead-of-unknown)

Even though in JavaScript, you can throw anything (which makes unknown the most correct type), almost always, Errors (or subclasses of Error) are thrown. This change makes it easier to work with the error field in TypeScript for most cases.

If you want to throw something that isn't an Error, you'll now have to set the generic for yourself:

    useQuery<number, string>({
      queryKey: ['some-query'],
      queryFn: async () => {
        if (Math.random() > 0.5) {
          throw 'some error'
        }
        return 42
      },
    })
    

    useQuery<number, string>({
      queryKey: ['some-query'],
      queryFn: async () => {
        if (Math.random() > 0.5) {
          throw 'some error'
        }
        return 42
      },
    })
    

For a way to set a different kind of Error globally, see [the TypeScript Guide](https://tanstack.com/query/latest/docs/framework/react/typescript#registering-a-global-error).

### [](#eslint-prefer-query-object-syntax-rule-is-removed)[eslint prefer-query-object-syntax rule is removed](#eslint-prefer-query-object-syntax-rule-is-removed)

Since the only supported syntax now is the object syntax, this rule is no longer needed

### [](#removed-keeppreviousdata-in-favor-of-placeholderdata-identity-function)[Removed keepPreviousData in favor of placeholderData identity function](#removed-keeppreviousdata-in-favor-of-placeholderdata-identity-function)

We have removed the keepPreviousData option and isPreviousData flag as they were doing mostly the same thing as placeholderData and isPlaceholderData flag.

To achieve the same functionality as keepPreviousData, we have added previous query data as an argument to placeholderData which accepts an identity function. Therefore you just need to provide an identity function to placeholderData or use the included keepPreviousData function from Tanstack Query.

> A note here is that useQueries would not receive previousData in the placeholderData function as argument. This is due to a dynamic nature of queries passed in the array, which may lead to a different shape of result from placeholder and queryFn.

    import {
       useQuery,
    +  keepPreviousData // [!code ++]
    } from "@tanstack/react-query";
    
    const {
       data,
    -  isPreviousData, // [!code --]
    +  isPlaceholderData, // [!code ++]
    } = useQuery({
      queryKey,
      queryFn,
    - keepPreviousData: true, // [!code --]
    + placeholderData: keepPreviousData // [!code ++]
    });
    

    import {
       useQuery,
    +  keepPreviousData // [!code ++]
    } from "@tanstack/react-query";
    
    const {
       data,
    -  isPreviousData, // [!code --]
    +  isPlaceholderData, // [!code ++]
    } = useQuery({
      queryKey,
      queryFn,
    - keepPreviousData: true, // [!code --]
    + placeholderData: keepPreviousData // [!code ++]
    });
    

An identity function, in the context of Tanstack Query, refers to a function that always returns its provided argument (i.e. data) unchanged.

    useQuery({
      queryKey,
      queryFn,
      placeholderData: (previousData, previousQuery) => previousData, // identity function with the same behaviour as `keepPreviousData`
    })
    

    useQuery({
      queryKey,
      queryFn,
      placeholderData: (previousData, previousQuery) => previousData, // identity function with the same behaviour as `keepPreviousData`
    })
    

There are some caveats to this change however, which you must be aware of:

*   placeholderData will always put you into success state, while keepPreviousData gave you the status of the previous query. That status could be error if we have data fetched successfully and then got a background refetch error. However, the error itself was not shared, so we decided to stick with behavior of placeholderData.
    
*   keepPreviousData gave you the dataUpdatedAt timestamp of the previous data, while with placeholderData, dataUpdatedAt will stay at 0. This might be annoying if you want to show that timestamp continuously on screen. However you might get around it with useEffect.
    
        const [updatedAt, setUpdatedAt] = useState(0)
        
        const { data, dataUpdatedAt } = useQuery({
          queryKey: ['projects', page],
          queryFn: () => fetchProjects(page),
        })
        
        useEffect(() => {
          if (dataUpdatedAt > updatedAt) {
            setUpdatedAt(dataUpdatedAt)
          }
        }, [dataUpdatedAt])
        
    
        const [updatedAt, setUpdatedAt] = useState(0)
        
        const { data, dataUpdatedAt } = useQuery({
          queryKey: ['projects', page],
          queryFn: () => fetchProjects(page),
        })
        
        useEffect(() => {
          if (dataUpdatedAt > updatedAt) {
            setUpdatedAt(dataUpdatedAt)
          }
        }, [dataUpdatedAt])
        
    

### [](#window-focus-refetching-no-longer-listens-to-the-focus-event)[Window focus refetching no longer listens to the focus event](#window-focus-refetching-no-longer-listens-to-the-focus-event)

The visibilitychange event is used exclusively now. This is possible because we only support browsers that support the visibilitychange event. This fixes a bunch of issues [as listed here](https://github.com/TanStack/query/pull/4805).

### [](#network-status-no-longer-relies-on-the-navigatoronline-property)[Network status no longer relies on the navigator.onLine property](#network-status-no-longer-relies-on-the-navigatoronline-property)

navigator.onLine doesn't work well in Chromium based browsers. There are [a lot of issues](https://bugs.chromium.org/p/chromium/issues/list?q=navigator.online) around false negatives, which lead to Queries being wrongfully marked as offline.

To circumvent this, we now always start with online: true and only listen to online and offline events to update the status.

This should reduce the likelihood of false negatives, however, it might mean false positives for offline apps that load via serviceWorkers, which can work even without an internet connection.

### [](#removed-custom-context-prop-in-favor-of-custom-queryclient-instance)[Removed custom context prop in favor of custom queryClient instance](#removed-custom-context-prop-in-favor-of-custom-queryclient-instance)

In v4, we introduced the possibility to pass a custom context to all react-query hooks. This allowed for proper isolation when using MicroFrontends.

However, context is a react-only feature. All that context does is give us access to the queryClient. We could achieve the same isolation by allowing to pass in a custom queryClient directly. This in turn will enable other frameworks to have the same functionality in a framework-agnostic way.

    import { queryClient } from './my-client'
    
    const { data } = useQuery(
      {
        queryKey: ['users', id],
        queryFn: () => fetch(...),
    -   context: customContext // [!code --]
      },
    +  queryClient, // [!code ++]
    )
    

    import { queryClient } from './my-client'
    
    const { data } = useQuery(
      {
        queryKey: ['users', id],
        queryFn: () => fetch(...),
    -   context: customContext // [!code --]
      },
    +  queryClient, // [!code ++]
    )
    

### [](#removed-refetchpage-in-favor-of-maxpages)[Removed refetchPage in favor of maxPages](#removed-refetchpage-in-favor-of-maxpages)

In v4, we introduced the possibility to define the pages to refetch for infinite queries with the refetchPage function.

However, refetching all pages might lead to UI inconsistencies. Also, this option is available on e.g. queryClient.refetchQueries, but it only does something for infinite queries, not "normal" queries.

The v5 includes a new maxPages option for infinite queries to limit the number of pages to store in the query data and to refetch. This new feature handles the use cases initially identified for the refetchPage page feature without the related issues.

### [](#new-dehydrate-api)[New dehydrate API](#new-dehydrate-api)

The options you can pass to dehydrate have been simplified. Queries and Mutations are always dehydrated (according to the default function implementation). To change this behaviour, instead of using the removed boolean options dehydrateMutations and dehydrateQueries you can implement the function equivalents shouldDehydrateQuery or shouldDehydrateMutation instead. To get the old behaviour of not hydrating queries/mutations at all, pass in () => false.

    - dehydrateMutations?: boolean // [!code --]
    - dehydrateQueries?: boolean // [!code --]
    

    - dehydrateMutations?: boolean // [!code --]
    - dehydrateQueries?: boolean // [!code --]
    

### [](#infinite-queries-now-need-a-initialpageparam)[Infinite queries now need a initialPageParam](#infinite-queries-now-need-a-initialpageparam)

Previously, we've passed undefined to the queryFn as pageParam, and you could assign a default value to the pageParam parameter in the queryFn function signature. This had the drawback of storing undefined in the queryCache, which is not serializable.

Instead, you now have to pass an explicit initialPageParam to the infinite query options. This will be used as the pageParam for the first page:

    useInfiniteQuery({
       queryKey,
    -  queryFn: ({ pageParam = 0 }) => fetchSomething(pageParam), // [!code --]
    +  queryFn: ({ pageParam }) => fetchSomething(pageParam), // [!code ++]
    +  initialPageParam: 0, // [!code ++]
       getNextPageParam: (lastPage) => lastPage.next,
    })
    

    useInfiniteQuery({
       queryKey,
    -  queryFn: ({ pageParam = 0 }) => fetchSomething(pageParam), // [!code --]
    +  queryFn: ({ pageParam }) => fetchSomething(pageParam), // [!code ++]
    +  initialPageParam: 0, // [!code ++]
       getNextPageParam: (lastPage) => lastPage.next,
    })
    

### [](#manual-mode-for-infinite-queries-has-been-removed)[Manual mode for infinite queries has been removed](#manual-mode-for-infinite-queries-has-been-removed)

Previously, we've allowed to overwrite the pageParams that would be returned from getNextPageParam or getPreviousPageParam by passing a pageParam value directly to fetchNextPage or fetchPreviousPage. This feature didn't work at all with refetches and wasn't widely known or used. This also means that getNextPageParam is now required for infinite queries.

### [](#returning-null-from-getnextpageparam-or-getpreviouspageparam-now-indicates-that-there-is-no-further-page-available)[Returning null from getNextPageParam or getPreviousPageParam now indicates that there is no further page available](#returning-null-from-getnextpageparam-or-getpreviouspageparam-now-indicates-that-there-is-no-further-page-available)

In v4, you needed to explicitly return undefined to indicate that there is no further page available. We've widened this check to include null.

### [](#no-retries-on-the-server)[No retries on the server](#no-retries-on-the-server)

On the server, retry now defaults to 0 instead of 3. For prefetching, we have always defaulted to 0 retries, but since queries that have suspense enabled can now execute directly on the server as well (since React18), we have to make sure that we don't retry on the server at all.

### [](#status-loading-has-been-changed-to-status-pending-and-isloading-has-been-changed-to-ispending-and-isinitialloading-has-now-been-renamed-to-isloading)[status: loading has been changed to status: pending and isLoading has been changed to isPending and isInitialLoading has now been renamed to isLoading](#status-loading-has-been-changed-to-status-pending-and-isloading-has-been-changed-to-ispending-and-isinitialloading-has-now-been-renamed-to-isloading)

The loading status has been renamed to pending, and similarly the derived isLoading flag has been renamed to isPending.

For mutations as well the status has been changed from loading to pending and the isLoading flag has been changed to isPending.

Lastly, a new derived isLoading flag has been added to the queries that is implemented as isPending && isFetching. This means that isLoading and isInitialLoading have the same thing, but isInitialLoading is deprecated now and will be removed in the next major version.

To understand the reasoning behind this change checkout the [v5 roadmap discussion](https://github.com/TanStack/query/discussions/4252).

### [](#hashquerykey-has-been-renamed-to-hashkey)[hashQueryKey has been renamed to hashKey](#hashquerykey-has-been-renamed-to-hashkey)

because it also hashes mutation keys and can be used inside the predicate functions of useIsMutating and useMutationState, which gets mutations passed.

### [](#the-minimum-required-react-version-is-now-180)[The minimum required React version is now 18.0](#the-minimum-required-react-version-is-now-180)

React Query v5 requires React 18.0 or later. This is because we are using the new useSyncExternalStore hook, which is only available in React 18.0 and later. Previously, we have been using the shim provided by React.

### [](#the-contextsharing-prop-has-been-removed-from-queryclientprovider)[The contextSharing prop has been removed from QueryClientProvider](#the-contextsharing-prop-has-been-removed-from-queryclientprovider)

You could previously use the contextSharing property to share the first (and at least one) instance of the query client context across the window. This ensured that if TanStack Query was used across different bundles or microfrontends then they will all use the same instance of the context, regardless of module scoping.

With the removal of the custom context prop in v5, refer to the section on [Removed custom context prop in favor of custom queryClient instance](#removed-custom-context-prop-in-favor-of-custom-queryclient-instance). If you wish to share the same query client across multiple packages of an application, you can directly pass a shared custom queryClient instance.

### [](#no-longer-using-unstable_batchedupdates-as-the-batching-function-in-react-and-react-native)[No longer using unstable\_batchedUpdates as the batching function in React and React Native](#no-longer-using-unstable_batchedupdates-as-the-batching-function-in-react-and-react-native)

Since the function unstable\_batchedUpdates is noop in React 18, it will no longer be automatically set as the batching function in react-query.

If your framework supports a custom batching function, you can let TanStack Query know about it by calling notifyManager.setBatchNotifyFunction.

For example, this is how the batch function is set in solid-query:

    import { notifyManager } from '@tanstack/query-core'
    import { batch } from 'solid-js'
    
    notifyManager.setBatchNotifyFunction(batch)
    

    import { notifyManager } from '@tanstack/query-core'
    import { batch } from 'solid-js'
    
    notifyManager.setBatchNotifyFunction(batch)
    

### [](#hydration-api-changes)[Hydration API changes](#hydration-api-changes)

To better support concurrent features and transitions we've made some changes to the hydration APIs. The Hydrate component has been renamed to HydrationBoundary and the useHydrate hook has been removed.

The HydrationBoundary no longer hydrates mutations, only queries. To hydrate mutations, use the low level hydrate API or the persistQueryClient plugin.

Finally, as a technical detail, the timing for when queries are hydrated have changed slightly. New queries are still hydrated in the render phase so that SSR works as usual, but any queries that already exist in the cache are now hydrated in an effect instead (as long as their data is fresher than what is in the cache). If you are hydrating just once at the start of your application as is common, this wont affect you, but if you are using Server Components and pass down fresh data for hydration on a page navigation, you might notice a flash of the old data before the page immediately rerenders.

This last change is technically a breaking one, and was made so we don't prematurely update content on the _existing_ page before a page transition has been fully committed. No action is required on your part.

    - import { Hydrate } from '@tanstack/react-query' // [!code --]
    + import { HydrationBoundary } from '@tanstack/react-query' // [!code ++]
    
    
    - <Hydrate state={dehydratedState}> // [!code --]
    + <HydrationBoundary state={dehydratedState}> // [!code ++]
      <App />
    - </Hydrate> // [!code --]
    + </HydrationBoundary> // [!code ++]
    

    - import { Hydrate } from '@tanstack/react-query' // [!code --]
    + import { HydrationBoundary } from '@tanstack/react-query' // [!code ++]
    
    
    - <Hydrate state={dehydratedState}> // [!code --]
    + <HydrationBoundary state={dehydratedState}> // [!code ++]
      <App />
    - </Hydrate> // [!code --]
    + </HydrationBoundary> // [!code ++]
    

### [](#query-defaults-changes)[Query defaults changes](#query-defaults-changes)

queryClient.getQueryDefaults will now merge together all matching registrations instead of returning only the first matching registration.

As a result, calls to queryClient.setQueryDefaults should now be ordered with _increasing_ specificity. That is, registrations should be made from the **most generic key** to the **least generic one**.

For example:

    + queryClient.setQueryDefaults(['todo'], {   // [!code ++]
    +   retry: false,  // [!code ++]
    +   staleTime: 60_000,  // [!code ++]
    + })  // [!code ++]
    queryClient.setQueryDefaults(['todo', 'detail'], {
    +   retry: true,  // [!code --]
      retryDelay: 1_000,
      staleTime: 10_000,
    })
    - queryClient.setQueryDefaults(['todo'], { // [!code --]
    -   retry: false, // [!code --]
    -   staleTime: 60_000, // [!code --]
    - }) // [!code --]
    

    + queryClient.setQueryDefaults(['todo'], {   // [!code ++]
    +   retry: false,  // [!code ++]
    +   staleTime: 60_000,  // [!code ++]
    + })  // [!code ++]
    queryClient.setQueryDefaults(['todo', 'detail'], {
    +   retry: true,  // [!code --]
      retryDelay: 1_000,
      staleTime: 10_000,
    })
    - queryClient.setQueryDefaults(['todo'], { // [!code --]
    -   retry: false, // [!code --]
    -   staleTime: 60_000, // [!code --]
    - }) // [!code --]
    

Note that in this specific example, retry: true was added to the \['todo', 'detail'\] registration to counteract it now inheriting retry: false from the more general registration. The specific changes needed to maintain exact behavior will vary depending on your defaults.

[](#new-features-)[New Features üöÄ](#new-features-)
---------------------------------------------------

v5 also comes with new features:

### [](#simplified-optimistic-updates)[Simplified optimistic updates](#simplified-optimistic-updates)

We have a new, simplified way to perform optimistic updates by leveraging the returned variables from useMutation:

    const queryInfo = useTodos()
    const addTodoMutation = useMutation({
      mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
      onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
    })
    
    if (queryInfo.data) {
      return (
        <ul>
          {queryInfo.data.items.map((todo) => (
            <li key={todo.id}>{todo.text}</li>
          ))}
          {addTodoMutation.isPending && (
            <li key={String(addTodoMutation.submittedAt)} style={{ opacity: 0.5 }}>
              {addTodoMutation.variables}
            </li>
          )}
        </ul>
      )
    }
    

    const queryInfo = useTodos()
    const addTodoMutation = useMutation({
      mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
      onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
    })
    
    if (queryInfo.data) {
      return (
        <ul>
          {queryInfo.data.items.map((todo) => (
            <li key={todo.id}>{todo.text}</li>
          ))}
          {addTodoMutation.isPending && (
            <li key={String(addTodoMutation.submittedAt)} style={{ opacity: 0.5 }}>
              {addTodoMutation.variables}
            </li>
          )}
        </ul>
      )
    }
    

Here, we are only changing how the UI looks when the mutation is running instead of writing data directly to the cache. This works best if we only have one place where we need to show the optimistic update. For more details, have a look at the [optimistic updates documentation](https://tanstack.com/query/latest/docs/framework/react/guides/optimistic-updates).

### [](#limited-infinite-queries-with-new-maxpages-option)[Limited, Infinite Queries with new maxPages option](#limited-infinite-queries-with-new-maxpages-option)

Infinite queries are great when infinite scroll or pagination are needed. However, the more pages you fetch, the more memory you consume, and this also slows down the query refetching process as all the pages are sequentially refetched.

Version 5 has a new maxPages option for infinite queries, which allows developers to limit the number of pages that are stored in the query data and subsequently refetched. You can adjust the maxPages value according to the UX and refetching performance you want to deliver.

Note that the infinite list must be bi-directional, which requires both getNextPageParam and getPreviousPageParam to be defined.

### [](#infinite-queries-can-prefetch-multiple-pages)[Infinite Queries can prefetch multiple pages](#infinite-queries-can-prefetch-multiple-pages)

Infinite Queries can be prefetched like regular Queries. Per default, only the first page of the Query will be prefetched and will be stored under the given QueryKey. If you want to prefetch more than one page, you can use the pages option. Read the [prefetching guide](https://tanstack.com/query/latest/docs/framework/react/guides/prefetching) for more information.

### [](#new-combine-option-for-usequeries)[New combine option for useQueries](#new-combine-option-for-usequeries)

See the [useQueries docs](https://tanstack.com/query/latest/docs/framework/react/reference/useQueries#combine) for more details.

### [](#experimental-fine-grained-storage-persister)[Experimental fine grained storage persister](#experimental-fine-grained-storage-persister)

See the [experimental\_createPersister docs](https://tanstack.com/query/latest/docs/framework/react/plugins/createPersister) for more details.

### [](#typesafe-way-to-create-query-options)[Typesafe way to create Query Options](#typesafe-way-to-create-query-options)

See the [TypeScript docs](https://tanstack.com/query/latest/docs/framework/react/typescript#typing-query-options) for more details.

### [](#new-hooks-for-suspense)[new hooks for suspense](#new-hooks-for-suspense)

With v5, suspense for data fetching finally becomes "stable". We've added dedicated useSuspenseQuery, useSuspenseInfiniteQuery and useSuspenseQueries hooks. With these hooks, data will never be potentially undefined on type level:

    const { data: post } = useSuspenseQuery({
      // ^? const post: Post
      queryKey: ['post', postId],
      queryFn: () => fetchPost(postId),
    })
    

    const { data: post } = useSuspenseQuery({
      // ^? const post: Post
      queryKey: ['post', postId],
      queryFn: () => fetchPost(postId),
    })
    

The experimental suspense: boolean flag on the query hooks has been removed.

You can read more about them in the [suspense docs](https://tanstack.com/query/latest/docs/framework/react/guides/suspense).</content>
</page>

<page>
  <title>MutationCache | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/reference/MutationCache</url>
  <content>The MutationCache is the storage for mutations.

**Normally, you will not interact with the MutationCache directly and instead use the QueryClient.**

    import { MutationCache } from '@tanstack/react-query'
    
    const mutationCache = new MutationCache({
      onError: (error) => {
        console.log(error)
      },
      onSuccess: (data) => {
        console.log(data)
      },
    })
    

    import { MutationCache } from '@tanstack/react-query'
    
    const mutationCache = new MutationCache({
      onError: (error) => {
        console.log(error)
      },
      onSuccess: (data) => {
        console.log(data)
      },
    })
    

Its available methods are:

*   [getAll](#mutationcachegetall)
*   [subscribe](#mutationcachesubscribe)
*   [clear](#mutationcacheclear)

**Options**

*   onError?: (error: unknown, variables: unknown, onMutateResult: unknown, mutation: Mutation, mutationFnContext: MutationFunctionContext) => Promise<unknown> | unknown
    *   Optional
    *   This function will be called if some mutation encounters an error.
    *   If you return a Promise from it, it will be awaited
*   onSuccess?: (data: unknown, variables: unknown, onMutateResult: unknown, mutation: Mutation, mutationFnContext: MutationFunctionContext) => Promise<unknown> | unknown
    *   Optional
    *   This function will be called if some mutation is successful.
    *   If you return a Promise from it, it will be awaited
*   onSettled?: (data: unknown | undefined, error: unknown | null, variables: unknown, onMutateResult: unknown, mutation: Mutation, mutationFnContext: MutationFunctionContext) => Promise<unknown> | unknown
    *   Optional
    *   This function will be called if some mutation is settled (either successful or errored).
    *   If you return a Promise from it, it will be awaited
*   onMutate?: (variables: unknown, mutation: Mutation, mutationFnContext: MutationFunctionContext) => Promise<unknown> | unknown
    *   Optional
    *   This function will be called before some mutation executes.
    *   If you return a Promise from it, it will be awaited

[](#global-callbacks)[Global callbacks](#global-callbacks)
----------------------------------------------------------

The onError, onSuccess, onSettled and onMutate callbacks on the MutationCache can be used to handle these events on a global level. They are different to defaultOptions provided to the QueryClient because:

*   defaultOptions can be overridden by each Mutation - the global callbacks will **always** be called.
*   onMutate does not allow returning a result.

[](#mutationcachegetall)[mutationCache.getAll](#mutationcachegetall)
--------------------------------------------------------------------

getAll returns all mutations within the cache.

> Note: This is not typically needed for most applications, but can come in handy when needing more information about a mutation in rare scenarios

    const mutations = mutationCache.getAll()
    

    const mutations = mutationCache.getAll()
    

**Returns**

*   Mutation\[\]
    *   Mutation instances from the cache

[](#mutationcachesubscribe)[mutationCache.subscribe](#mutationcachesubscribe)
-----------------------------------------------------------------------------

The subscribe method can be used to subscribe to the mutation cache as a whole and be informed of safe/known updates to the cache like mutation states changing or mutations being updated, added or removed.

    const callback = (event) => {
      console.log(event.type, event.mutation)
    }
    
    const unsubscribe = mutationCache.subscribe(callback)
    

    const callback = (event) => {
      console.log(event.type, event.mutation)
    }
    
    const unsubscribe = mutationCache.subscribe(callback)
    

**Options**

*   callback: (mutation?: MutationCacheNotifyEvent) => void
    *   This function will be called with the mutation cache any time it is updated.

**Returns**

*   unsubscribe: Function => void
    *   This function will unsubscribe the callback from the mutation cache.

[](#mutationcacheclear)[mutationCache.clear](#mutationcacheclear)
-----------------------------------------------------------------

The clear method can be used to clear the cache entirely and start fresh.

    mutationCache.clear()
    

    mutationCache.clear()</content>
</page>

<page>
  <title>QueryObserver | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/reference/QueryObserver</url>
  <content>The QueryObserver can be used to observe and switch between queries.

    const observer = new QueryObserver(queryClient, { queryKey: ['posts'] })
    
    const unsubscribe = observer.subscribe((result) => {
      console.log(result)
      unsubscribe()
    })
    

    const observer = new QueryObserver(queryClient, { queryKey: ['posts'] })
    
    const unsubscribe = observer.subscribe((result) => {
      console.log(result)
      unsubscribe()
    })
    

**Options**

The options for the QueryObserver are exactly the same as those of [useQuery](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery).</content>
</page>

<page>
  <title>QueriesObserver | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/reference/QueriesObserver</url>
  <content>[](#queriesobserver)[QueriesObserver](#queriesobserver)
-------------------------------------------------------

The QueriesObserver can be used to observe multiple queries.

    const observer = new QueriesObserver(queryClient, [
      { queryKey: ['post', 1], queryFn: fetchPost },
      { queryKey: ['post', 2], queryFn: fetchPost },
    ])
    
    const unsubscribe = observer.subscribe((result) => {
      console.log(result)
      unsubscribe()
    })
    

    const observer = new QueriesObserver(queryClient, [
      { queryKey: ['post', 1], queryFn: fetchPost },
      { queryKey: ['post', 2], queryFn: fetchPost },
    ])
    
    const unsubscribe = observer.subscribe((result) => {
      console.log(result)
      unsubscribe()
    })
    

**Options**

The options for the QueriesObserver are exactly the same as those of [useQueries](https://tanstack.com/query/latest/docs/framework/react/reference/useQueries).</content>
</page>

<page>
  <title>streamedQuery | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/reference/streamedQuery</url>
  <content>streamedQuery is a helper function to create a query function that streams data from an [AsyncIterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncIterator). Data will be an Array of all the chunks received. The query will be in a pending state until the first chunk of data is received, but will go to success after that. The query will stay in fetchStatus fetching until the stream ends.

To see streamedQuery in action, take a look at our chat example in the [examples/react/chat directory on GitHub](https://github.com/TanStack/query/tree/main/examples/react/chat).

    import { experimental_streamedQuery as streamedQuery } from '@tanstack/react-query'
    
    const query = queryOptions({
      queryKey: ['data'],
      queryFn: streamedQuery({
        streamFn: fetchDataInChunks,
      }),
    })
    

    import { experimental_streamedQuery as streamedQuery } from '@tanstack/react-query'
    
    const query = queryOptions({
      queryKey: ['data'],
      queryFn: streamedQuery({
        streamFn: fetchDataInChunks,
      }),
    })
    

> Note: streamedQuery is currently marked as experimental because we want to gather feedback from the community. If you've tried out the API and have feedback for us, please provide it in this [GitHub discussion](https://github.com/TanStack/query/discussions/9065).

**Options**

*   streamFn: (context: QueryFunctionContext) => Promise<AsyncIterable<TData>>
    *   **Required**
    *   The function that returns a Promise of an AsyncIterable with data to stream in.
    *   Receives a [QueryFunctionContext](https://tanstack.com/query/latest/docs/framework/react/guides/query-functions#queryfunctioncontext)
*   refetchMode?: 'append' | 'reset' | 'replace'
    *   Optional
    *   Defines how refetches are handled.
    *   Defaults to 'reset'
    *   When set to 'reset', the query will erase all data and go back into pending state.
    *   When set to 'append', data will be appended to existing data.
    *   When set to 'replace', all data will be written to the cache once the stream ends.
*   reducer?: (accumulator: TData, chunk: TQueryFnData) => TData
    *   Optional
    *   Reduces streamed chunks (TQueryFnData) into the final data shape (TData).
    *   Default: appends each chunk to the end of the accumulator when TData is an array.
    *   If TData is not an array, you must provide a custom reducer.
*   initialValue?: TData = TQueryFnData
    *   Optional
    *   Defines the initial data to be used while the first chunk is being fetched, and it is also returned when the stream yields no values.
    *   It is mandatory when custom reducer is provided.
    *   Defaults to an empty array.</content>
</page>

<page>
  <title>InfiniteQueryObserver | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver</url>
  <content>[](#infinitequeryobserver)[InfiniteQueryObserver](#infinitequeryobserver)
-------------------------------------------------------------------------

The InfiniteQueryObserver can be used to observe and switch between infinite queries.

    const observer = new InfiniteQueryObserver(queryClient, {
      queryKey: ['posts'],
      queryFn: fetchPosts,
      getNextPageParam: (lastPage, allPages) => lastPage.nextCursor,
      getPreviousPageParam: (firstPage, allPages) => firstPage.prevCursor,
    })
    
    const unsubscribe = observer.subscribe((result) => {
      console.log(result)
      unsubscribe()
    })
    

    const observer = new InfiniteQueryObserver(queryClient, {
      queryKey: ['posts'],
      queryFn: fetchPosts,
      getNextPageParam: (lastPage, allPages) => lastPage.nextCursor,
      getPreviousPageParam: (firstPage, allPages) => firstPage.prevCursor,
    })
    
    const unsubscribe = observer.subscribe((result) => {
      console.log(result)
      unsubscribe()
    })
    

**Options**

The options for the InfiniteQueryObserver are exactly the same as those of [useInfiniteQuery](https://tanstack.com/query/latest/docs/framework/react/reference/useInfiniteQuery).</content>
</page>

<page>
  <title>FocusManager | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/reference/focusManager</url>
  <content>The FocusManager manages the focus state within TanStack Query.

It can be used to change the default event listeners or to manually change the focus state.

Its available methods are:

*   [setEventListener](#focusmanagerseteventlistener)
*   [subscribe](#focusmanagersubscribe)
*   [setFocused](#focusmanagersetfocused)
*   [isFocused](#focusmanagerisfocused)

[](#focusmanagerseteventlistener)[focusManager.setEventListener](#focusmanagerseteventlistener)
-----------------------------------------------------------------------------------------------

setEventListener can be used to set a custom event listener:

    import { focusManager } from '@tanstack/react-query'
    
    focusManager.setEventListener((handleFocus) => {
      // Listen to visibilitychange
      if (typeof window !== 'undefined' && window.addEventListener) {
        window.addEventListener('visibilitychange', handleFocus, false)
      }
    
      return () => {
        // Be sure to unsubscribe if a new handler is set
        window.removeEventListener('visibilitychange', handleFocus)
      }
    })
    

    import { focusManager } from '@tanstack/react-query'
    
    focusManager.setEventListener((handleFocus) => {
      // Listen to visibilitychange
      if (typeof window !== 'undefined' && window.addEventListener) {
        window.addEventListener('visibilitychange', handleFocus, false)
      }
    
      return () => {
        // Be sure to unsubscribe if a new handler is set
        window.removeEventListener('visibilitychange', handleFocus)
      }
    })
    

[](#focusmanagersubscribe)[focusManager.subscribe](#focusmanagersubscribe)
--------------------------------------------------------------------------

subscribe can be used to subscribe to changes in the visibility state. It returns an unsubscribe function:

    import { focusManager } from '@tanstack/react-query'
    
    const unsubscribe = focusManager.subscribe((isVisible) => {
      console.log('isVisible', isVisible)
    })
    

    import { focusManager } from '@tanstack/react-query'
    
    const unsubscribe = focusManager.subscribe((isVisible) => {
      console.log('isVisible', isVisible)
    })
    

[](#focusmanagersetfocused)[focusManager.setFocused](#focusmanagersetfocused)
-----------------------------------------------------------------------------

setFocused can be used to manually set the focus state. Set undefined to fall back to the default focus check.

    import { focusManager } from '@tanstack/react-query'
    
    // Set focused
    focusManager.setFocused(true)
    
    // Set unfocused
    focusManager.setFocused(false)
    
    // Fallback to the default focus check
    focusManager.setFocused(undefined)
    

    import { focusManager } from '@tanstack/react-query'
    
    // Set focused
    focusManager.setFocused(true)
    
    // Set unfocused
    focusManager.setFocused(false)
    
    // Fallback to the default focus check
    focusManager.setFocused(undefined)
    

**Options**

*   focused: boolean | undefined

[](#focusmanagerisfocused)[focusManager.isFocused](#focusmanagerisfocused)
--------------------------------------------------------------------------

isFocused can be used to get the current focus state.

    const isFocused = focusManager.isFocused()
    

    const isFocused = focusManager.isFocused()</content>
</page>

<page>
  <title>OnlineManager | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/reference/onlineManager</url>
  <content>The OnlineManager manages the online state within TanStack Query. It can be used to change the default event listeners or to manually change the online state.

> Per default, the onlineManager assumes an active network connection, and listens to the online and offline events on the window object to detect changes.

> In previous versions, navigator.onLine was used to determine the network status. However, it doesn't work well in Chromium based browsers. There are [a lot of issues](https://bugs.chromium.org/p/chromium/issues/list?q=navigator.online) around false negatives, which lead to Queries being wrongfully marked as offline.

> To circumvent this, we now always start with online: true and only listen to online and offline events to update the status.

> This should reduce the likelihood of false negatives, however, it might mean false positives for offline apps that load via serviceWorkers, which can work even without an internet connection.

Its available methods are:

*   [setEventListener](#onlinemanagerseteventlistener)
*   [subscribe](#onlinemanagersubscribe)
*   [setOnline](#onlinemanagersetonline)
*   [isOnline](#onlinemanagerisonline)

[](#onlinemanagerseteventlistener)[onlineManager.setEventListener](#onlinemanagerseteventlistener)
--------------------------------------------------------------------------------------------------

setEventListener can be used to set a custom event listener:

    import NetInfo from '@react-native-community/netinfo'
    import { onlineManager } from '@tanstack/react-query'
    
    onlineManager.setEventListener((setOnline) => {
      return NetInfo.addEventListener((state) => {
        setOnline(!!state.isConnected)
      })
    })
    

    import NetInfo from '@react-native-community/netinfo'
    import { onlineManager } from '@tanstack/react-query'
    
    onlineManager.setEventListener((setOnline) => {
      return NetInfo.addEventListener((state) => {
        setOnline(!!state.isConnected)
      })
    })
    

[](#onlinemanagersubscribe)[onlineManager.subscribe](#onlinemanagersubscribe)
-----------------------------------------------------------------------------

subscribe can be used to subscribe to changes in the online state. It returns an unsubscribe function:

    import { onlineManager } from '@tanstack/react-query'
    
    const unsubscribe = onlineManager.subscribe((isOnline) => {
      console.log('isOnline', isOnline)
    })
    

    import { onlineManager } from '@tanstack/react-query'
    
    const unsubscribe = onlineManager.subscribe((isOnline) => {
      console.log('isOnline', isOnline)
    })
    

[](#onlinemanagersetonline)[onlineManager.setOnline](#onlinemanagersetonline)
-----------------------------------------------------------------------------

setOnline can be used to manually set the online state.

    import { onlineManager } from '@tanstack/react-query'
    
    // Set to online
    onlineManager.setOnline(true)
    
    // Set to offline
    onlineManager.setOnline(false)
    

    import { onlineManager } from '@tanstack/react-query'
    
    // Set to online
    onlineManager.setOnline(true)
    
    // Set to offline
    onlineManager.setOnline(false)
    

**Options**

*   online: boolean

[](#onlinemanagerisonline)[onlineManager.isOnline](#onlinemanagerisonline)
--------------------------------------------------------------------------

isOnline can be used to get the current online state.

    const isOnline = onlineManager.isOnline()
    

    const isOnline = onlineManager.isOnline()</content>
</page>

<page>
  <title>NotifyManager | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/reference/notifyManager</url>
  <content>The notifyManager handles scheduling and batching callbacks in Tanstack Query.

It exposes the following methods:

*   [batch](#notifymanagerbatch)
*   [batchCalls](#notifymanagerbatchcalls)
*   [schedule](#notifymanagerschedule)
*   [setNotifyFunction](#notifymanagersetnotifyfunction)
*   [setBatchNotifyFunction](#notifymanagersetbatchnotifyfunction)
*   [setScheduler](#notifymanagersetscheduler)

[](#notifymanagerbatch)[notifyManager.batch](#notifymanagerbatch)
-----------------------------------------------------------------

batch can be used to batch all updates scheduled inside the passed callback. This is mainly used internally to optimize queryClient updating.

    function batch<T>(callback: () => T): T
    

    function batch<T>(callback: () => T): T
    

[](#notifymanagerbatchcalls)[notifyManager.batchCalls](#notifymanagerbatchcalls)
--------------------------------------------------------------------------------

batchCalls is a higher-order function that takes a callback and wraps it. All calls to the wrapped function schedule the callback to be run on the next batch.

    type BatchCallsCallback<T extends Array<unknown>> = (...args: T) => void
    
    function batchCalls<T extends Array<unknown>>(
      callback: BatchCallsCallback<T>,
    ): BatchCallsCallback<T>
    

    type BatchCallsCallback<T extends Array<unknown>> = (...args: T) => void
    
    function batchCalls<T extends Array<unknown>>(
      callback: BatchCallsCallback<T>,
    ): BatchCallsCallback<T>
    

[](#notifymanagerschedule)[notifyManager.schedule](#notifymanagerschedule)
--------------------------------------------------------------------------

schedule schedules a function to be run on the next batch. By default, the batch is run with a setTimeout, but this can be configured.

    function schedule(callback: () => void): void
    

    function schedule(callback: () => void): void
    

[](#notifymanagersetnotifyfunction)[notifyManager.setNotifyFunction](#notifymanagersetnotifyfunction)
-----------------------------------------------------------------------------------------------------

setNotifyFunction overrides the notify function. This function is passed the callback when it should be executed. The default notifyFunction just calls it.

This can be used to for example wrap notifications with React.act while running tests:

    import { notifyManager } from '@tanstack/react-query'
    import { act } from 'react-dom/test-utils'
    
    notifyManager.setNotifyFunction(act)
    

    import { notifyManager } from '@tanstack/react-query'
    import { act } from 'react-dom/test-utils'
    
    notifyManager.setNotifyFunction(act)
    

[](#notifymanagersetbatchnotifyfunction)[notifyManager.setBatchNotifyFunction](#notifymanagersetbatchnotifyfunction)
--------------------------------------------------------------------------------------------------------------------

setBatchNotifyFunction sets the function to use for batched updates

If your framework supports a custom batching function, you can let TanStack Query know about it by calling notifyManager.setBatchNotifyFunction.

For example, this is how the batch function is set in solid-query:

    import { notifyManager } from '@tanstack/query-core'
    import { batch } from 'solid-js'
    
    notifyManager.setBatchNotifyFunction(batch)
    

    import { notifyManager } from '@tanstack/query-core'
    import { batch } from 'solid-js'
    
    notifyManager.setBatchNotifyFunction(batch)
    

[](#notifymanagersetscheduler)[notifyManager.setScheduler](#notifymanagersetscheduler)
--------------------------------------------------------------------------------------

setScheduler configures a custom callback that should schedules when the next batch runs. The default behaviour is setTimeout(callback, 0).

    import { notifyManager } from '@tanstack/react-query'
    
    // Schedule batches in the next microtask
    notifyManager.setScheduler(queueMicrotask)
    
    // Schedule batches before the next frame is rendered
    notifyManager.setScheduler(requestAnimationFrame)
    
    // Schedule batches some time in the future
    notifyManager.setScheduler((cb) => setTimeout(cb, 10))
    

    import { notifyManager } from '@tanstack/react-query'
    
    // Schedule batches in the next microtask
    notifyManager.setScheduler(queueMicrotask)
    
    // Schedule batches before the next frame is rendered
    notifyManager.setScheduler(requestAnimationFrame)
    
    // Schedule batches some time in the future
    notifyManager.setScheduler((cb) => setTimeout(cb, 10))</content>
</page>

<page>
  <title>TimeoutManager | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/reference/timeoutManager</url>
  <content>The TimeoutManager handles setTimeout and setInterval timers in TanStack Query.

TanStack Query uses timers to implement features like query staleTime and gcTime, as well as retries, throttling, and debouncing.

By default, TimeoutManager uses the global setTimeout and setInterval, but it can be configured to use custom implementations instead.

Its available methods are:

*   [timeoutManager.setTimeoutProvider](#timeoutmanagersettimeoutprovider)
    *   [TimeoutProvider](#timeoutprovider)
*   [timeoutManager.setTimeout](#timeoutmanagersettimeout)
*   [timeoutManager.clearTimeout](#timeoutmanagercleartimeout)
*   [timeoutManager.setInterval](#timeoutmanagersetinterval)
*   [timeoutManager.clearInterval](#timeoutmanagerclearinterval)

[](#timeoutmanagersettimeoutprovider)[timeoutManager.setTimeoutProvider](#timeoutmanagersettimeoutprovider)
-----------------------------------------------------------------------------------------------------------

setTimeoutProvider can be used to set a custom implementation of the setTimeout, clearTimeout, setInterval, clearInterval functions, called a TimeoutProvider.

This may be useful if you notice event loop performance issues with thousands of queries. A custom TimeoutProvider could also support timer delays longer than the global setTimeout maximum delay value of about [24 days](https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout#maximum_delay_value).

It is important to call setTimeoutProvider before creating a QueryClient or queries, so that the same provider is used consistently for all timers in the application, since different TimeoutProviders cannot cancel each others' timers.

    import { timeoutManager, QueryClient } from '@tanstack/react-query'
    import { CustomTimeoutProvider } from './CustomTimeoutProvider'
    
    timeoutManager.setTimeoutProvider(new CustomTimeoutProvider())
    
    export const queryClient = new QueryClient()
    

    import { timeoutManager, QueryClient } from '@tanstack/react-query'
    import { CustomTimeoutProvider } from './CustomTimeoutProvider'
    
    timeoutManager.setTimeoutProvider(new CustomTimeoutProvider())
    
    export const queryClient = new QueryClient()
    

### [](#timeoutprovider)[TimeoutProvider](#timeoutprovider)

Timers are very performance sensitive. Short term timers (such as those with delays less than 5 seconds) tend to be latency sensitive, where long-term timers may benefit more from [timer coalescing](https://en.wikipedia.org/wiki/Timer_coalescing) - batching timers with similar deadlines together - using a data structure like a [hierarchical time wheel](https://www.npmjs.com/package/timer-wheel).

The TimeoutProvider type requires that implementations handle timer ID objects that can be converted to number via [Symbol.toPrimitive](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive) because runtimes like NodeJS return [objects](https://nodejs.org/api/timers.html#class-timeout) from their global setTimeout and setInterval functions. TimeoutProvider implementations are free to coerce timer IDs to number internally, or to return their own custom object type that implements { \[Symbol.toPrimitive\]: () => number }.

    type ManagedTimerId = number | { [Symbol.toPrimitive]: () => number }
    
    type TimeoutProvider<TTimerId extends ManagedTimerId = ManagedTimerId> = {
      readonly setTimeout: (callback: TimeoutCallback, delay: number) => TTimerId
      readonly clearTimeout: (timeoutId: TTimerId | undefined) => void
    
      readonly setInterval: (callback: TimeoutCallback, delay: number) => TTimerId
      readonly clearInterval: (intervalId: TTimerId | undefined) => void
    }
    

    type ManagedTimerId = number | { [Symbol.toPrimitive]: () => number }
    
    type TimeoutProvider<TTimerId extends ManagedTimerId = ManagedTimerId> = {
      readonly setTimeout: (callback: TimeoutCallback, delay: number) => TTimerId
      readonly clearTimeout: (timeoutId: TTimerId | undefined) => void
    
      readonly setInterval: (callback: TimeoutCallback, delay: number) => TTimerId
      readonly clearInterval: (intervalId: TTimerId | undefined) => void
    }
    

[](#timeoutmanagersettimeout)[timeoutManager.setTimeout](#timeoutmanagersettimeout)
-----------------------------------------------------------------------------------

setTimeout(callback, delayMs) schedules a callback to run after approximately delay milliseconds, like the global [setTimeout function](https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout).The callback can be canceled with timeoutManager.clearTimeout.

It returns a timer ID, which may be a number or an object that can be coerced to a number via [Symbol.toPrimitive](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive).

    import { timeoutManager } from '@tanstack/react-query'
    
    const timeoutId = timeoutManager.setTimeout(
      () => console.log('ran at:', new Date()),
      1000,
    )
    
    const timeoutIdNumber: number = Number(timeoutId)
    

    import { timeoutManager } from '@tanstack/react-query'
    
    const timeoutId = timeoutManager.setTimeout(
      () => console.log('ran at:', new Date()),
      1000,
    )
    
    const timeoutIdNumber: number = Number(timeoutId)
    

[](#timeoutmanagercleartimeout)[timeoutManager.clearTimeout](#timeoutmanagercleartimeout)
-----------------------------------------------------------------------------------------

clearTimeout(timerId) cancels a timeout callback scheduled with setTimeout, like the global [clearTimeout function](https://developer.mozilla.org/en-US/docs/Web/API/Window/clearTimeout). It should be called with a timer ID returned by timeoutManager.setTimeout.

    import { timeoutManager } from '@tanstack/react-query'
    
    const timeoutId = timeoutManager.setTimeout(
      () => console.log('ran at:', new Date()),
      1000,
    )
    
    timeoutManager.clearTimeout(timeoutId)
    

    import { timeoutManager } from '@tanstack/react-query'
    
    const timeoutId = timeoutManager.setTimeout(
      () => console.log('ran at:', new Date()),
      1000,
    )
    
    timeoutManager.clearTimeout(timeoutId)
    

[](#timeoutmanagersetinterval)[timeoutManager.setInterval](#timeoutmanagersetinterval)
--------------------------------------------------------------------------------------

setInterval(callback, intervalMs) schedules a callback to be called approximately every intervalMs, like the global [setInterval function](https://developer.mozilla.org/en-US/docs/Web/API/Window/setInterval).

Like setTimeout, it returns a timer ID, which may be a number or an object that can be coerced to a number via [Symbol.toPrimitive](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive).

    import { timeoutManager } from '@tanstack/react-query'
    
    const intervalId = timeoutManager.setInterval(
      () => console.log('ran at:', new Date()),
      1000,
    )
    

    import { timeoutManager } from '@tanstack/react-query'
    
    const intervalId = timeoutManager.setInterval(
      () => console.log('ran at:', new Date()),
      1000,
    )
    

[](#timeoutmanagerclearinterval)[timeoutManager.clearInterval](#timeoutmanagerclearinterval)
--------------------------------------------------------------------------------------------

clearInterval(intervalId) can be used to cancel an interval, like the global [clearInterval function](https://developer.mozilla.org/en-US/docs/Web/API/Window/clearInterval). It should be called with an interval ID returned by timeoutManager.setInterval.

    import { timeoutManager } from '@tanstack/react-query'
    
    const intervalId = timeoutManager.setInterval(
      () => console.log('ran at:', new Date()),
      1000,
    )
    
    timeoutManager.clearInterval(intervalId)
    

    import { timeoutManager } from '@tanstack/react-query'
    
    const intervalId = timeoutManager.setInterval(
      () => console.log('ran at:', new Date()),
      1000,
    )
    
    timeoutManager.clearInterval(intervalId)</content>
</page>

<page>
  <title>useQueries | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/reference/useQueries</url>
  <content>The useQueries hook can be used to fetch a variable number of queries:

    const ids = [1, 2, 3]
    const results = useQueries({
      queries: ids.map((id) => ({
        queryKey: ['post', id],
        queryFn: () => fetchPost(id),
        staleTime: Infinity,
      })),
    })
    

    const ids = [1, 2, 3]
    const results = useQueries({
      queries: ids.map((id) => ({
        queryKey: ['post', id],
        queryFn: () => fetchPost(id),
        staleTime: Infinity,
      })),
    })
    

**Options**

The useQueries hook accepts an options object with a **queries** key whose value is an array with query option objects identical to the [useQuery hook](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery) (excluding the queryClient option - because the QueryClient can be passed in on the top level).

*   queryClient?: QueryClient
    *   Use this to provide a custom QueryClient. Otherwise, the one from the nearest context will be used.
*   combine?: (result: UseQueriesResults) => TCombinedResult
    *   Use this to combine the results of the queries into a single value.

> Having the same query key more than once in the array of query objects may cause some data to be shared between queries. To avoid this, consider de-duplicating the queries and map the results back to the desired structure.

**placeholderData**

The placeholderData option exists for useQueries as well, but it doesn't get information passed from previously rendered Queries like useQuery does, because the input to useQueries can be a different number of Queries on each render.

**Returns**

The useQueries hook returns an array with all the query results. The order returned is the same as the input order.

[](#combine)[Combine](#combine)
-------------------------------

If you want to combine data (or other Query information) from the results into a single value, you can use the combine option. The result will be structurally shared to be as referentially stable as possible.

    const ids = [1, 2, 3]
    const combinedQueries = useQueries({
      queries: ids.map((id) => ({
        queryKey: ['post', id],
        queryFn: () => fetchPost(id),
      })),
      combine: (results) => {
        return {
          data: results.map((result) => result.data),
          pending: results.some((result) => result.isPending),
        }
      },
    })
    

    const ids = [1, 2, 3]
    const combinedQueries = useQueries({
      queries: ids.map((id) => ({
        queryKey: ['post', id],
        queryFn: () => fetchPost(id),
      })),
      combine: (results) => {
        return {
          data: results.map((result) => result.data),
          pending: results.some((result) => result.isPending),
        }
      },
    })
    

In the above example, combinedQueries will be an object with a data and a pending property. Note that all other properties of the Query results will be lost.

### [](#memoization)[Memoization](#memoization)

The combine function will only re-run if:

*   the combine function itself changed referentially
*   any of the query results changed

This means that an inlined combine function, as shown above, will run on every render. To avoid this, you can wrap the combine function in useCallback, or extract it to a stable function reference if it doesn't have any dependencies.</content>
</page>

<page>
  <title>useInfiniteQuery | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/reference/useInfiniteQuery</url>
  <content>    const {
      fetchNextPage,
      fetchPreviousPage,
      hasNextPage,
      hasPreviousPage,
      isFetchingNextPage,
      isFetchingPreviousPage,
      promise,
      ...result
    } = useInfiniteQuery({
      queryKey,
      queryFn: ({ pageParam }) => fetchPage(pageParam),
      initialPageParam: 1,
      ...options,
      getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) =>
        lastPage.nextCursor,
      getPreviousPageParam: (firstPage, allPages, firstPageParam, allPageParams) =>
        firstPage.prevCursor,
    })
    

    const {
      fetchNextPage,
      fetchPreviousPage,
      hasNextPage,
      hasPreviousPage,
      isFetchingNextPage,
      isFetchingPreviousPage,
      promise,
      ...result
    } = useInfiniteQuery({
      queryKey,
      queryFn: ({ pageParam }) => fetchPage(pageParam),
      initialPageParam: 1,
      ...options,
      getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) =>
        lastPage.nextCursor,
      getPreviousPageParam: (firstPage, allPages, firstPageParam, allPageParams) =>
        firstPage.prevCursor,
    })
    

**Options**

The options for useInfiniteQuery are identical to the [useQuery hook](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery) with the addition of the following:

*   queryFn: (context: QueryFunctionContext) => Promise<TData>
    *   **Required, but only if no default query function has been defined** [defaultQueryFn](https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function)
    *   The function that the query will use to request data.
    *   Receives a [QueryFunctionContext](https://tanstack.com/query/latest/docs/framework/react/guides/query-functions#queryfunctioncontext)
    *   Must return a promise that will either resolve data or throw an error.
*   initialPageParam: TPageParam
    *   **Required**
    *   The default page param to use when fetching the first page.
*   getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => TPageParam | undefined | null
    *   **Required**
    *   When new data is received for this query, this function receives both the last page of the infinite list of data and the full array of all pages, as well as pageParam information.
    *   It should return a **single variable** that will be passed as the last optional parameter to your query function.
    *   Return undefined or null to indicate there is no next page available.
*   getPreviousPageParam: (firstPage, allPages, firstPageParam, allPageParams) => TPageParam | undefined | null
    *   When new data is received for this query, this function receives both the first page of the infinite list of data and the full array of all pages, as well as pageParam information.
    *   It should return a **single variable** that will be passed as the last optional parameter to your query function.
    *   Return undefined or nullto indicate there is no previous page available.
*   maxPages: number | undefined
    *   The maximum number of pages to store in the infinite query data.
    *   When the maximum number of pages is reached, fetching a new page will result in the removal of either the first or last page from the pages array, depending on the specified direction.
    *   If undefined or equals 0, the number of pages is unlimited
    *   Default value is undefined
    *   getNextPageParam and getPreviousPageParam must be properly defined if maxPages value is greater than 0 to allow fetching a page in both directions when needed.

**Returns**

The returned properties for useInfiniteQuery are identical to the [useQuery hook](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery), with the addition of the following properties and a small difference in isRefetching and isRefetchError:

*   data.pages: TData\[\]
    *   Array containing all pages.
*   data.pageParams: unknown\[\]
    *   Array containing all page params.
*   isFetchingNextPage: boolean
    *   Will be true while fetching the next page with fetchNextPage.
*   isFetchingPreviousPage: boolean
    *   Will be true while fetching the previous page with fetchPreviousPage.
*   fetchNextPage: (options?: FetchNextPageOptions) => Promise<UseInfiniteQueryResult>
    *   This function allows you to fetch the next "page" of results.
    *   options.cancelRefetch: boolean if set to true, calling fetchNextPage repeatedly will invoke queryFn every time, whether the previous invocation has resolved or not. Also, the result from previous invocations will be ignored. If set to false, calling fetchNextPage repeatedly won't have any effect until the first invocation has resolved. Default is true.
*   fetchPreviousPage: (options?: FetchPreviousPageOptions) => Promise<UseInfiniteQueryResult>
    *   This function allows you to fetch the previous "page" of results.
    *   options.cancelRefetch: boolean same as for fetchNextPage.
*   hasNextPage: boolean
    *   Will be true if there is a next page to be fetched (known via the getNextPageParam option).
*   hasPreviousPage: boolean
    *   Will be true if there is a previous page to be fetched (known via the getPreviousPageParam option).
*   isFetchNextPageError: boolean
    *   Will be true if the query failed while fetching the next page.
*   isFetchPreviousPageError: boolean
    *   Will be true if the query failed while fetching the previous page.
*   isRefetching: boolean
    *   Will be true whenever a background refetch is in-flight, which _does not_ include initial pending or fetching of next or previous page
    *   Is the same as isFetching && !isPending && !isFetchingNextPage && !isFetchingPreviousPage
*   isRefetchError: boolean
    *   Will be true if the query failed while refetching a page.
*   promise: Promise<TData>
    *   A stable promise that resolves to the query result.
    *   This can be used with React.use() to fetch data
    *   Requires the experimental\_prefetchInRender feature flag to be enabled on the QueryClient.

Keep in mind that imperative fetch calls, such as fetchNextPage, may interfere with the default refetch behaviour, resulting in outdated data. Make sure to call these functions only in response to user actions, or add conditions like hasNextPage && !isFetching.</content>
</page>

<page>
  <title>useMutation | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/reference/useMutation</url>
  <content>    const {
      data,
      error,
      isError,
      isIdle,
      isPending,
      isPaused,
      isSuccess,
      failureCount,
      failureReason,
      mutate,
      mutateAsync,
      reset,
      status,
      submittedAt,
      variables,
    } = useMutation(
      {
        mutationFn,
        gcTime,
        meta,
        mutationKey,
        networkMode,
        onError,
        onMutate,
        onSettled,
        onSuccess,
        retry,
        retryDelay,
        scope,
        throwOnError,
      },
      queryClient,
    )
    
    mutate(variables, {
      onError,
      onSettled,
      onSuccess,
    })
    

    const {
      data,
      error,
      isError,
      isIdle,
      isPending,
      isPaused,
      isSuccess,
      failureCount,
      failureReason,
      mutate,
      mutateAsync,
      reset,
      status,
      submittedAt,
      variables,
    } = useMutation(
      {
        mutationFn,
        gcTime,
        meta,
        mutationKey,
        networkMode,
        onError,
        onMutate,
        onSettled,
        onSuccess,
        retry,
        retryDelay,
        scope,
        throwOnError,
      },
      queryClient,
    )
    
    mutate(variables, {
      onError,
      onSettled,
      onSuccess,
    })</content>
</page>

<page>
  <title>useIsFetching | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/reference/useIsFetching</url>
  <content>useIsFetching is an optional hook that returns the number of the queries that your application is loading or fetching in the background (useful for app-wide loading indicators).

    import { useIsFetching } from '@tanstack/react-query'
    // How many queries are fetching?
    const isFetching = useIsFetching()
    // How many queries matching the posts prefix are fetching?
    const isFetchingPosts = useIsFetching({ queryKey: ['posts'] })
    

    import { useIsFetching } from '@tanstack/react-query'
    // How many queries are fetching?
    const isFetching = useIsFetching()
    // How many queries matching the posts prefix are fetching?
    const isFetchingPosts = useIsFetching({ queryKey: ['posts'] })
    

**Options**

*   filters?: QueryFilters: [Query Filters](https://tanstack.com/query/latest/docs/framework/react/guides/filters#query-filters)
*   queryClient?: QueryClient
    *   Use this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.

**Returns**

*   isFetching: number
    *   Will be the number of the queries that your application is currently loading or fetching in the background.</content>
</page>

<page>
  <title>useIsMutating | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/reference/useIsMutating</url>
  <content>useIsMutating is an optional hook that returns the number of mutations that your application is fetching (useful for app-wide loading indicators).

    import { useIsMutating } from '@tanstack/react-query'
    // How many mutations are fetching?
    const isMutating = useIsMutating()
    // How many mutations matching the posts prefix are fetching?
    const isMutatingPosts = useIsMutating({ mutationKey: ['posts'] })
    

    import { useIsMutating } from '@tanstack/react-query'
    // How many mutations are fetching?
    const isMutating = useIsMutating()
    // How many mutations matching the posts prefix are fetching?
    const isMutatingPosts = useIsMutating({ mutationKey: ['posts'] })
    

**Options**

*   filters?: MutationFilters: [Mutation Filters](https://tanstack.com/query/latest/docs/framework/react/guides/filters#mutation-filters)
*   queryClient?: QueryClient
    *   Use this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.

**Returns**

*   isMutating: number
    *   Will be the number of the mutations that your application is currently fetching.</content>
</page>

<page>
  <title>useQuery | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/reference/useQuery</url>
  <content>    const {
      data,
      dataUpdatedAt,
      error,
      errorUpdatedAt,
      failureCount,
      failureReason,
      fetchStatus,
      isError,
      isFetched,
      isFetchedAfterMount,
      isFetching,
      isInitialLoading,
      isLoading,
      isLoadingError,
      isPaused,
      isPending,
      isPlaceholderData,
      isRefetchError,
      isRefetching,
      isStale,
      isSuccess,
      isEnabled,
      promise,
      refetch,
      status,
    } = useQuery(
      {
        queryKey,
        queryFn,
        gcTime,
        enabled,
        networkMode,
        initialData,
        initialDataUpdatedAt,
        meta,
        notifyOnChangeProps,
        placeholderData,
        queryKeyHashFn,
        refetchInterval,
        refetchIntervalInBackground,
        refetchOnMount,
        refetchOnReconnect,
        refetchOnWindowFocus,
        retry,
        retryOnMount,
        retryDelay,
        select,
        staleTime,
        structuralSharing,
        subscribed,
        throwOnError,
      },
      queryClient,
    )
    

    const {
      data,
      dataUpdatedAt,
      error,
      errorUpdatedAt,
      failureCount,
      failureReason,
      fetchStatus,
      isError,
      isFetched,
      isFetchedAfterMount,
      isFetching,
      isInitialLoading,
      isLoading,
      isLoadingError,
      isPaused,
      isPending,
      isPlaceholderData,
      isRefetchError,
      isRefetching,
      isStale,
      isSuccess,
      isEnabled,
      promise,
      refetch,
      status,
    } = useQuery(
      {
        queryKey,
        queryFn,
        gcTime,
        enabled,
        networkMode,
        initialData,
        initialDataUpdatedAt,
        meta,
        notifyOnChangeProps,
        placeholderData,
        queryKeyHashFn,
        refetchInterval,
        refetchIntervalInBackground,
        refetchOnMount,
        refetchOnReconnect,
        refetchOnWindowFocus,
        retry,
        retryOnMount,
        retryDelay,
        select,
        staleTime,
        structuralSharing,
        subscribed,
        throwOnError,
      },
      queryClient,
    )</content>
</page>

<page>
  <title>useMutationState | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/reference/useMutationState</url>
  <content>useMutationState is a hook that gives you access to all mutations in the MutationCache. You can pass filters to it to narrow down your mutations, and select to transform the mutation state.

**Example 1: Get all variables of all running mutations**

    import { useMutationState } from '@tanstack/react-query'
    
    const variables = useMutationState({
      filters: { status: 'pending' },
      select: (mutation) => mutation.state.variables,
    })
    

    import { useMutationState } from '@tanstack/react-query'
    
    const variables = useMutationState({
      filters: { status: 'pending' },
      select: (mutation) => mutation.state.variables,
    })
    

**Example 2: Get all data for specific mutations via the mutationKey**

    import { useMutation, useMutationState } from '@tanstack/react-query'
    
    const mutationKey = ['posts']
    
    // Some mutation that we want to get the state for
    const mutation = useMutation({
      mutationKey,
      mutationFn: (newPost) => {
        return axios.post('/posts', newPost)
      },
    })
    
    const data = useMutationState({
      // this mutation key needs to match the mutation key of the given mutation (see above)
      filters: { mutationKey },
      select: (mutation) => mutation.state.data,
    })
    

    import { useMutation, useMutationState } from '@tanstack/react-query'
    
    const mutationKey = ['posts']
    
    // Some mutation that we want to get the state for
    const mutation = useMutation({
      mutationKey,
      mutationFn: (newPost) => {
        return axios.post('/posts', newPost)
      },
    })
    
    const data = useMutationState({
      // this mutation key needs to match the mutation key of the given mutation (see above)
      filters: { mutationKey },
      select: (mutation) => mutation.state.data,
    })
    

**Example 3: Access the latest mutation data via the mutationKey**. Each invocation of mutate adds a new entry to the mutation cache for gcTime milliseconds.

To access the latest invocation, you can check for the last item that useMutationState returns.

    import { useMutation, useMutationState } from '@tanstack/react-query'
    
    const mutationKey = ['posts']
    
    // Some mutation that we want to get the state for
    const mutation = useMutation({
      mutationKey,
      mutationFn: (newPost) => {
        return axios.post('/posts', newPost)
      },
    })
    
    const data = useMutationState({
      // this mutation key needs to match the mutation key of the given mutation (see above)
      filters: { mutationKey },
      select: (mutation) => mutation.state.data,
    })
    
    // Latest mutation data
    const latest = data[data.length - 1]
    

    import { useMutation, useMutationState } from '@tanstack/react-query'
    
    const mutationKey = ['posts']
    
    // Some mutation that we want to get the state for
    const mutation = useMutation({
      mutationKey,
      mutationFn: (newPost) => {
        return axios.post('/posts', newPost)
      },
    })
    
    const data = useMutationState({
      // this mutation key needs to match the mutation key of the given mutation (see above)
      filters: { mutationKey },
      select: (mutation) => mutation.state.data,
    })
    
    // Latest mutation data
    const latest = data[data.length - 1]
    

**Options**

*   options
    *   filters?: MutationFilters: [Mutation Filters](https://tanstack.com/query/latest/docs/framework/react/guides/filters#mutation-filters)
    *   select?: (mutation: Mutation) => TResult
        *   Use this to transform the mutation state.
*   queryClient?: QueryClient
    *   Use this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.

**Returns**

*   Array<TResult>
    *   Will be an Array of whatever select returns for each matching mutation.</content>
</page>

<page>
  <title>useSuspenseInfiniteQuery | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseInfiniteQuery</url>
  <content>tsx

    const result = useSuspenseInfiniteQuery(options)
    

    const result = useSuspenseInfiniteQuery(options)
    

**Options**

The same as for [useInfiniteQuery](https://tanstack.com/query/latest/docs/framework/react/reference/useInfiniteQuery), except for:

*   suspense
*   throwOnError
*   enabled
*   placeholderData

**Returns**

Same object as [useInfiniteQuery](https://tanstack.com/query/latest/docs/framework/react/reference/useInfiniteQuery), except that:

*   data is guaranteed to be defined
*   isPlaceholderData is missing
*   status is either success or error
    *   the derived flags are set accordingly.

**Caveat**

[Cancellation](https://tanstack.com/query/latest/docs/framework/react/guides/query-cancellation) does not work.</content>
</page>

<page>
  <title>useSuspenseQueries | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseQueries</url>
  <content>    const result = useSuspenseQueries(options)
    

    const result = useSuspenseQueries(options)
    

**Options**

The same as for [useQueries](https://tanstack.com/query/latest/docs/framework/react/reference/useQueries), except that each query can't have:

*   suspense
*   throwOnError
*   enabled
*   placeholderData

**Returns**

Same structure as [useQueries](https://tanstack.com/query/latest/docs/framework/react/reference/useQueries), except that for each query:

*   data is guaranteed to be defined
*   isPlaceholderData is missing
*   status is either success or error
    *   the derived flags are set accordingly.

**Caveats**

Keep in mind that the component will only re-mount after **all queries** have finished loading. Hence, if a query has gone stale in the time it took for all the queries to complete, it will be fetched again at re-mount. To avoid this, make sure to set a high enough staleTime.

[Cancellation](https://tanstack.com/query/latest/docs/framework/react/guides/query-cancellation) does not work.</content>
</page>

<page>
  <title>useQueryClient | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/reference/useQueryClient</url>
  <content>Documentation

Framework

Version

Menu

*   [
    
    Home
    
    
    
    ](https://tanstack.com/query/latest)
*   [
    
    Frameworks
    
    
    
    ](https://tanstack.com/query/latest/docs/framework)
*   [
    
    Contributors
    
    
    
    ](https://tanstack.com/query/latest/docs/contributors)
*   [
    
    Community Resources
    
    
    
    ](https://tanstack.com/query/latest/docs/community-resources)
*   [
    
    GitHub
    
    
    
    ](https://github.com/tanstack/query)
*   [
    
    Discord
    
    
    
    ](https://tlinz.com/discord)

Getting Started

*   [
    
    Overview
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/overview)
*   [
    
    Installation
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/installation)
*   [
    
    Quick Start
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/quick-start)
*   [
    
    Devtools
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/devtools)
*   [
    
    Comparison
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/comparison)
*   [
    
    TypeScript
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/typescript)
*   [
    
    GraphQL
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/graphql)
*   [
    
    React Native
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/react-native)

Guides & Concepts

*   [
    
    Important Defaults
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/important-defaults)
*   [
    
    Queries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/queries)
*   [
    
    Query Keys
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/query-keys)
*   [
    
    Query Functions
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/query-functions)
*   [
    
    Query Options
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/query-options)
*   [
    
    Network Mode
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/network-mode)
*   [
    
    Parallel Queries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/parallel-queries)
*   [
    
    Dependent Queries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/disabling-queries)
*   [
    
    Query Retries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/query-retries)
*   [
    
    Paginated Queries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/paginated-queries)
*   [
    
    Infinite Queries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/infinite-queries)
*   [
    
    Initial Query Data
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/placeholder-query-data)
*   [
    
    Mutations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/mutations)
*   [
    
    Query Invalidation
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/invalidations-from-mutations)
*   [
    
    Updates from Mutation Responses
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/updates-from-mutation-responses)
*   [
    
    Optimistic Updates
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/optimistic-updates)
*   [
    
    Query Cancellation
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/query-cancellation)
*   [
    
    Scroll Restoration
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/scroll-restoration)
*   [
    
    Filters
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/filters)
*   [
    
    Performance & Request Waterfalls
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/request-waterfalls)
*   [
    
    Prefetching & Router Integration
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/prefetching)
*   [
    
    Server Rendering & Hydration
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/ssr)
*   [
    
    Advanced Server Rendering
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/advanced-ssr)
*   [
    
    Caching
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/caching)
*   [
    
    Render Optimizations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/render-optimizations)
*   [
    
    Default Query Fn
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function)
*   [
    
    Suspense
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/suspense)
*   [
    
    Testing
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/testing)
*   [
    
    Does this replace \[Redux, MobX, etc\]?
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/does-this-replace-client-state)
*   [
    
    Migrating to v3
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-react-query-3)
*   [
    
    Migrating to v4
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-react-query-4)
*   [
    
    Migrating to v5
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-v5)

API Reference

*   [
    
    QueryClient
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [
    
    QueryCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [
    
    MutationCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [
    
    QueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [
    
    QueriesObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [
    
    streamedQuery
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [
    
    focusManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [
    
    onlineManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [
    
    notifyManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [
    
    timeoutManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [
    
    useQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery)
*   [
    
    useQueries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useQueries)
*   [
    
    useInfiniteQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useInfiniteQuery)
*   [
    
    useMutation
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useMutation)
*   [
    
    useIsFetching
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useIsFetching)
*   [
    
    useIsMutating
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useIsMutating)
*   [
    
    useMutationState
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useMutationState)
*   [
    
    useSuspenseQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseQuery)
*   [
    
    useSuspenseInfiniteQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseInfiniteQuery)
*   [
    
    useSuspenseQueries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseQueries)
*   [
    
    QueryClientProvider
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/QueryClientProvider)
*   [
    
    useQueryClient
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useQueryClient)
*   [
    
    queryOptions
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/queryOptions)
*   [
    
    infiniteQueryOptions
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/infiniteQueryOptions)
*   [
    
    mutationOptions
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/mutationOptions)
*   [
    
    usePrefetchQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/usePrefetchQuery)
*   [
    
    usePrefetchInfiniteQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/usePrefetchInfiniteQuery)
*   [
    
    QueryErrorResetBoundary
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/QueryErrorResetBoundary)
*   [
    
    useQueryErrorResetBoundary
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useQueryErrorResetBoundary)
*   [
    
    hydration
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/hydration)

ESLint

*   [
    
    ESLint Plugin Query
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [
    
    Exhaustive Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [
    
    Stable Query Client
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [
    
    No Unstable Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Examples

*   [
    
    Simple
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/simple)
*   [
    
    Basic
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/basic)
*   [
    
    Basic w/ GraphQL-Request
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/basic-graphql-request)
*   [
    
    Auto Refetching / Polling / Realtime
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/auto-refetching)
*   [
    
    Optimistic Updates (UI)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/optimistic-updates-ui)
*   [
    
    Optimistic Updates (Cache)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/optimistic-updates-cache)
*   [
    
    Pagination
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/pagination)
*   [
    
    Load-More & Infinite Scroll
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/load-more-infinite-scroll)
*   [
    
    Infinite query with Max pages
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/infinite-query-with-max-pages)
*   [
    
    Suspense
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/suspense)
*   [
    
    Default Query Function
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/default-query-function)
*   [
    
    Playground
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/playground)
*   [
    
    Prefetching
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/prefetching)
*   [
    
    Star Wars
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/star-wars)
*   [
    
    Rick And Morty
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/rick-morty)
*   [
    
    Next.js Pages
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/nextjs)
*   [
    
    Next.js app with prefetching
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/nextjs-app-prefetching)
*   [
    
    Next.js app with streaming
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/nextjs-suspense-streaming)
*   [
    
    React Native
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/react-native)
*   [
    
    React Router
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/react-router)
*   [
    
    Offline Queries and Mutations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/offline)
*   [
    
    Algolia
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/algolia)
*   [
    
    Shadow DOM
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/shadow-dom)
*   [
    
    Devtools Embedded Panel
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/devtools-panel)
*   [
    
    Chat example (streaming)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/chat)

Plugins

*   [
    
    persistQueryClient
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/persistQueryClient)
*   [
    
    createSyncStoragePersister
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/createSyncStoragePersister)
*   [
    
    createAsyncStoragePersister
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/createAsyncStoragePersister)
*   [
    
    broadcastQueryClient (Experimental)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/broadcastQueryClient)
*   [
    
    createPersister (Experimental)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/createPersister)

Framework

Version

Menu

*   [
    
    Home
    
    
    
    ](https://tanstack.com/query/latest)
*   [
    
    Frameworks
    
    
    
    ](https://tanstack.com/query/latest/docs/framework)
*   [
    
    Contributors
    
    
    
    ](https://tanstack.com/query/latest/docs/contributors)
*   [
    
    Community Resources
    
    
    
    ](https://tanstack.com/query/latest/docs/community-resources)
*   [
    
    GitHub
    
    
    
    ](https://github.com/tanstack/query)
*   [
    
    Discord
    
    
    
    ](https://tlinz.com/discord)

Getting Started

*   [
    
    Overview
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/overview)
*   [
    
    Installation
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/installation)
*   [
    
    Quick Start
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/quick-start)
*   [
    
    Devtools
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/devtools)
*   [
    
    Comparison
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/comparison)
*   [
    
    TypeScript
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/typescript)
*   [
    
    GraphQL
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/graphql)
*   [
    
    React Native
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/react-native)

Guides & Concepts

*   [
    
    Important Defaults
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/important-defaults)
*   [
    
    Queries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/queries)
*   [
    
    Query Keys
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/query-keys)
*   [
    
    Query Functions
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/query-functions)
*   [
    
    Query Options
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/query-options)
*   [
    
    Network Mode
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/network-mode)
*   [
    
    Parallel Queries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/parallel-queries)
*   [
    
    Dependent Queries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/disabling-queries)
*   [
    
    Query Retries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/query-retries)
*   [
    
    Paginated Queries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/paginated-queries)
*   [
    
    Infinite Queries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/infinite-queries)
*   [
    
    Initial Query Data
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/placeholder-query-data)
*   [
    
    Mutations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/mutations)
*   [
    
    Query Invalidation
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/invalidations-from-mutations)
*   [
    
    Updates from Mutation Responses
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/updates-from-mutation-responses)
*   [
    
    Optimistic Updates
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/optimistic-updates)
*   [
    
    Query Cancellation
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/query-cancellation)
*   [
    
    Scroll Restoration
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/scroll-restoration)
*   [
    
    Filters
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/filters)
*   [
    
    Performance & Request Waterfalls
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/request-waterfalls)
*   [
    
    Prefetching & Router Integration
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/prefetching)
*   [
    
    Server Rendering & Hydration
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/ssr)
*   [
    
    Advanced Server Rendering
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/advanced-ssr)
*   [
    
    Caching
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/caching)
*   [
    
    Render Optimizations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/render-optimizations)
*   [
    
    Default Query Fn
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function)
*   [
    
    Suspense
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/suspense)
*   [
    
    Testing
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/testing)
*   [
    
    Does this replace \[Redux, MobX, etc\]?
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/does-this-replace-client-state)
*   [
    
    Migrating to v3
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-react-query-3)
*   [
    
    Migrating to v4
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-react-query-4)
*   [
    
    Migrating to v5
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-v5)

API Reference

*   [
    
    QueryClient
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [
    
    QueryCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [
    
    MutationCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [
    
    QueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [
    
    QueriesObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [
    
    streamedQuery
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [
    
    focusManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [
    
    onlineManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [
    
    notifyManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [
    
    timeoutManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [
    
    useQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery)
*   [
    
    useQueries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useQueries)
*   [
    
    useInfiniteQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useInfiniteQuery)
*   [
    
    useMutation
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useMutation)
*   [
    
    useIsFetching
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useIsFetching)
*   [
    
    useIsMutating
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useIsMutating)
*   [
    
    useMutationState
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useMutationState)
*   [
    
    useSuspenseQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseQuery)
*   [
    
    useSuspenseInfiniteQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseInfiniteQuery)
*   [
    
    useSuspenseQueries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseQueries)
*   [
    
    QueryClientProvider
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/QueryClientProvider)
*   [
    
    useQueryClient
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useQueryClient)
*   [
    
    queryOptions
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/queryOptions)
*   [
    
    infiniteQueryOptions
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/infiniteQueryOptions)
*   [
    
    mutationOptions
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/mutationOptions)
*   [
    
    usePrefetchQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/usePrefetchQuery)
*   [
    
    usePrefetchInfiniteQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/usePrefetchInfiniteQuery)
*   [
    
    QueryErrorResetBoundary
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/QueryErrorResetBoundary)
*   [
    
    useQueryErrorResetBoundary
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useQueryErrorResetBoundary)
*   [
    
    hydration
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/hydration)

ESLint

*   [
    
    ESLint Plugin Query
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [
    
    Exhaustive Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [
    
    Stable Query Client
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [
    
    No Unstable Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Examples

*   [
    
    Simple
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/simple)
*   [
    
    Basic
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/basic)
*   [
    
    Basic w/ GraphQL-Request
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/basic-graphql-request)
*   [
    
    Auto Refetching / Polling / Realtime
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/auto-refetching)
*   [
    
    Optimistic Updates (UI)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/optimistic-updates-ui)
*   [
    
    Optimistic Updates (Cache)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/optimistic-updates-cache)
*   [
    
    Pagination
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/pagination)
*   [
    
    Load-More & Infinite Scroll
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/load-more-infinite-scroll)
*   [
    
    Infinite query with Max pages
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/infinite-query-with-max-pages)
*   [
    
    Suspense
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/suspense)
*   [
    
    Default Query Function
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/default-query-function)
*   [
    
    Playground
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/playground)
*   [
    
    Prefetching
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/prefetching)
*   [
    
    Star Wars
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/star-wars)
*   [
    
    Rick And Morty
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/rick-morty)
*   [
    
    Next.js Pages
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/nextjs)
*   [
    
    Next.js app with prefetching
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/nextjs-app-prefetching)
*   [
    
    Next.js app with streaming
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/nextjs-suspense-streaming)
*   [
    
    React Native
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/react-native)
*   [
    
    React Router
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/react-router)
*   [
    
    Offline Queries and Mutations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/offline)
*   [
    
    Algolia
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/algolia)
*   [
    
    Shadow DOM
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/shadow-dom)
*   [
    
    Devtools Embedded Panel
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/devtools-panel)
*   [
    
    Chat example (streaming)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/chat)

Plugins

*   [
    
    persistQueryClient
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/persistQueryClient)
*   [
    
    createSyncStoragePersister
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/createSyncStoragePersister)
*   [
    
    createAsyncStoragePersister
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/createAsyncStoragePersister)
*   [
    
    broadcastQueryClient (Experimental)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/broadcastQueryClient)
*   [
    
    createPersister (Experimental)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/createPersister)

[Learn about TanStack Ads](https://tanstack.com/ads)[Hide Ads](https://tanstack.com/ads#hide-ads)

The useQueryClient hook returns the current QueryClient instance.

tsx

    import { useQueryClient } from '@tanstack/react-query'
    
    const queryClient = useQueryClient(queryClient?: QueryClient)
    

    import { useQueryClient } from '@tanstack/react-query'
    
    const queryClient = useQueryClient(queryClient?: QueryClient)
    

**Options**

*   queryClient?: QueryClient
    *   Use this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.

[Edit on GitHub](https://github.com/tanstack/query/edit/main/docs/framework/react/reference/useQueryClient.md)

[Learn about TanStack Ads](https://tanstack.com/ads)[Hide Ads](https://tanstack.com/ads#hide-ads)

[

QueryClientProvider



](https://tanstack.com/query/latest/docs/framework/react/reference/QueryClientProvider)

[

queryOptions



](https://tanstack.com/query/latest/docs/framework/react/reference/queryOptions)

[Partners](https://tanstack.com/partners)[Become a Partner](https://docs.google.com/document/d/1Hg2MzY2TU6U3hFEZ3MLe2oEOM3JS4-eByti3kdJU3I8)

[](https://coderabbit.link/tanstack?utm_source=tanstack&via=tanstack)[](https://www.cloudflare.com/?utm_source=tanstack)[](https://ag-grid.com/react-data-grid/?utm_source=reacttable&utm_campaign=githubreacttable)[](https://netlify.com/?utm_source=tanstack)[](https://neon.tech/?utm_source=tanstack)[](https://workos.com/?utm_source=tanstack)[](https://go.clerk.com/wOwHtuJ)[](https://convex.dev/?utm_source=tanstack)[](https://electric-sql.com/)[](https://sentry.io/?utm_source=tanstack)[](https://www.prisma.io/?utm_source=tanstack&via=tanstack)[](https://strapi.link/tanstack-start)[](https://www.unkey.com/?utm_source=tanstack)

[Learn about TanStack Ads](https://tanstack.com/ads)[Hide Ads](https://tanstack.com/ads#hide-ads)

[

###### Want to Skip the Docs?

Query.gg - The Official React Query Course

Black Friday Sale
-----------------

Get 50% off through December 6th

01

days

:

22

hours

:

51

minutes









](https://query.gg/?s=tanstack)</content>
</page>

<page>
  <title>useSuspenseQuery | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseQuery</url>
  <content>tsx

    const result = useSuspenseQuery(options)
    

    const result = useSuspenseQuery(options)
    

**Options**

The same as for [useQuery](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery), except for:

*   throwOnError
*   enabled
*   placeholderData

**Returns**

Same object as [useQuery](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery), except that:

*   data is guaranteed to be defined
*   isPlaceholderData is missing
*   status is either success or error
    *   the derived flags are set accordingly.

**Caveat**

[Cancellation](https://tanstack.com/query/latest/docs/framework/react/guides/query-cancellation) does not work.</content>
</page>

<page>
  <title>QueryClientProvider | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/reference/QueryClientProvider</url>
  <content>Use the QueryClientProvider component to connect and provide a QueryClient to your application:

    import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
    
    const queryClient = new QueryClient()
    
    function App() {
      return <QueryClientProvider client={queryClient}>...</QueryClientProvider>
    }
    

    import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
    
    const queryClient = new QueryClient()
    
    function App() {
      return <QueryClientProvider client={queryClient}>...</QueryClientProvider>
    }
    

**Options**

*   client: QueryClient
    *   **Required**
    *   the QueryClient instance to provide</content>
</page>

<page>
  <title>queryOptions | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/reference/queryOptions</url>
  <content>    queryOptions({
      queryKey,
      ...options,
    })
    

    queryOptions({
      queryKey,
      ...options,
    })
    

**Options**

You can generally pass everything to queryOptions that you can also pass to [useQuery](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery). Some options will have no effect when then forwarded to a function like queryClient.prefetchQuery, but TypeScript will still be fine with those excess properties.

*   queryKey: QueryKey
    *   **Required**
    *   The query key to generate options for.
*   experimental\_prefetchInRender?: boolean
    *   Optional
    *   Defaults to false
    *   When set to true, queries will be prefetched during render, which can be useful for certain optimization scenarios
    *   Needs to be turned on for the experimental useQuery().promise functionality

[](#further-reading)[Further reading](#further-reading)
-------------------------------------------------------

To learn more about QueryOptions, have a look at [this article by TkDodo The Query Options API](https://tkdodo.eu/blog/the-query-options-api).</content>
</page>

<page>
  <title>infiniteQueryOptions | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/reference/infiniteQueryOptions</url>
  <content>tsx

    infiniteQueryOptions({
      queryKey,
      ...options,
    })
    

    infiniteQueryOptions({
      queryKey,
      ...options,
    })
    

**Options**

You can generally pass everything to infiniteQueryOptions that you can also pass to [useInfiniteQuery](https://tanstack.com/query/latest/docs/framework/react/reference/useInfiniteQuery). Some options will have no effect when then forwarded to a function like queryClient.prefetchInfiniteQuery, but TypeScript will still be fine with those excess properties.

*   queryKey: QueryKey
    *   **Required**
    *   The query key to generate options for.

See [useInfiniteQuery](https://tanstack.com/query/latest/docs/framework/react/reference/useInfiniteQuery) for more information.</content>
</page>

<page>
  <title>mutationOptions | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/reference/mutationOptions</url>
  <content>    mutationOptions({
      mutationFn,
      ...options,
    })
    

    mutationOptions({
      mutationFn,
      ...options,
    })
    

**Options**

You can generally pass everything to mutationOptions that you can also pass to [useMutation](https://tanstack.com/query/latest/docs/framework/react/reference/useMutation).</content>
</page>

<page>
  <title>usePrefetchInfiniteQuery | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/reference/usePrefetchInfiniteQuery</url>
  <content>    usePrefetchInfiniteQuery(options)
    

    usePrefetchInfiniteQuery(options)
    

**Options**

You can pass everything to usePrefetchInfiniteQuery that you can pass to [queryClient.prefetchInfiniteQuery](https://tanstack.com/query/latest/docs/reference/QueryClient#queryclientprefetchinfinitequery). Remember that some of them are required as below:

*   queryKey: QueryKey
    
    *   **Required**
    *   The query key to prefetch during render
*   queryFn: (context: QueryFunctionContext) => Promise<TData>
    
    *   **Required, but only if no default query function has been defined** See [Default Query Function](https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function) for more information.
*   initialPageParam: TPageParam
    
    *   **Required**
    *   The default page param to use when fetching the first page.
*   getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => TPageParam | undefined | null
    
    *   **Required**
    *   When new data is received for this query, this function receives both the last page of the infinite list of data and the full array of all pages, as well as pageParam information.
    *   It should return a **single variable** that will be passed as the last optional parameter to your query function.
    *   Return undefined or null to indicate there is no next page available.
*   **Returns**
    

The usePrefetchInfiniteQuery does not return anything, it should be used just to fire a prefetch during render, before a suspense boundary that wraps a component that uses [useSuspenseInfiniteQuery](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseInfiniteQuery)</content>
</page>

<page>
  <title>QueryErrorResetBoundary | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/reference/QueryErrorResetBoundary</url>
  <content>When using **suspense** or **throwOnError** in your queries, you need a way to let queries know that you want to try again when re-rendering after some error occurred. With the QueryErrorResetBoundary component you can reset any query errors within the boundaries of the component.

    import { QueryErrorResetBoundary } from '@tanstack/react-query'
    import { ErrorBoundary } from 'react-error-boundary'
    
    const App = () => (
      <QueryErrorResetBoundary>
        {({ reset }) => (
          <ErrorBoundary
            onReset={reset}
            fallbackRender={({ resetErrorBoundary }) => (
              <div>
                There was an error!
                <Button onClick={() => resetErrorBoundary()}>Try again</Button>
              </div>
            )}
          >
            <Page />
          </ErrorBoundary>
        )}
      </QueryErrorResetBoundary>
    )
    

    import { QueryErrorResetBoundary } from '@tanstack/react-query'
    import { ErrorBoundary } from 'react-error-boundary'
    
    const App = () => (
      <QueryErrorResetBoundary>
        {({ reset }) => (
          <ErrorBoundary
            onReset={reset}
            fallbackRender={({ resetErrorBoundary }) => (
              <div>
                There was an error!
                <Button onClick={() => resetErrorBoundary()}>Try again</Button>
              </div>
            )}
          >
            <Page />
          </ErrorBoundary>
        )}
      </QueryErrorResetBoundary>
    )</content>
</page>

<page>
  <title>usePrefetchQuery | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/reference/usePrefetchQuery</url>
  <content>    usePrefetchQuery(options)
    

    usePrefetchQuery(options)
    

**Options**

You can pass everything to usePrefetchQuery that you can pass to [queryClient.prefetchQuery](https://tanstack.com/query/latest/docs/reference/QueryClient#queryclientprefetchquery). Remember that some of them are required as below:

*   queryKey: QueryKey
    
    *   **Required**
    *   The query key to prefetch during render
*   queryFn: (context: QueryFunctionContext) => Promise<TData>
    
    *   **Required, but only if no default query function has been defined** See [Default Query Function](https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function) for more information.

**Returns**

The usePrefetchQuery does not return anything, it should be used just to fire a prefetch during render, before a suspense boundary that wraps a component that uses [useSuspenseQuery](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseQuery).</content>
</page>

<page>
  <title>useQueryErrorResetBoundary | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/reference/useQueryErrorResetBoundary</url>
  <content>This hook will reset any query errors within the closest QueryErrorResetBoundary. If there is no boundary defined it will reset them globally:

    import { useQueryErrorResetBoundary } from '@tanstack/react-query'
    import { ErrorBoundary } from 'react-error-boundary'
    
    const App = () => {
      const { reset } = useQueryErrorResetBoundary()
      return (
        <ErrorBoundary
          onReset={reset}
          fallbackRender={({ resetErrorBoundary }) => (
            <div>
              There was an error!
              <Button onClick={() => resetErrorBoundary()}>Try again</Button>
            </div>
          )}
        >
          <Page />
        </ErrorBoundary>
      )
    }
    

    import { useQueryErrorResetBoundary } from '@tanstack/react-query'
    import { ErrorBoundary } from 'react-error-boundary'
    
    const App = () => {
      const { reset } = useQueryErrorResetBoundary()
      return (
        <ErrorBoundary
          onReset={reset}
          fallbackRender={({ resetErrorBoundary }) => (
            <div>
              There was an error!
              <Button onClick={() => resetErrorBoundary()}>Try again</Button>
            </div>
          )}
        >
          <Page />
        </ErrorBoundary>
      )
    }</content>
</page>

<page>
  <title>hydration | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/reference/hydration</url>
  <content>[](#dehydrate)[dehydrate](#dehydrate)
-------------------------------------

dehydrate creates a frozen representation of a cache that can later be hydrated with HydrationBoundary or hydrate. This is useful for passing prefetched queries from server to client or persisting queries to localStorage or other persistent locations. It only includes currently successful queries by default.

    import { dehydrate } from '@tanstack/react-query'
    
    const dehydratedState = dehydrate(queryClient, {
      shouldDehydrateQuery,
      shouldDehydrateMutation,
    })
    

    import { dehydrate } from '@tanstack/react-query'
    
    const dehydratedState = dehydrate(queryClient, {
      shouldDehydrateQuery,
      shouldDehydrateMutation,
    })
    

**Options**

*   client: QueryClient
    *   **Required**
    *   The queryClient that should be dehydrated
*   options: DehydrateOptions
    *   Optional
    *   shouldDehydrateMutation: (mutation: Mutation) => boolean
        *   Optional
        *   Whether to dehydrate mutations.
        *   The function is called for each mutation in the cache
            *   Return true to include this mutation in dehydration, or false otherwise
        *   Defaults to only including paused mutations
        *   If you would like to extend the function while retaining the default behavior, import and execute defaultShouldDehydrateMutation as part of the return statement
    *   shouldDehydrateQuery: (query: Query) => boolean
        *   Optional
        *   Whether to dehydrate queries.
        *   The function is called for each query in the cache
            *   Return true to include this query in dehydration, or false otherwise
        *   Defaults to only including successful queries
        *   If you would like to extend the function while retaining the default behavior, import and execute defaultShouldDehydrateQuery as part of the return statement
    *   serializeData?: (data: any) => any A function to transform (serialize) data during dehydration.
    *   shouldRedactErrors?: (error: unknown) => boolean
        *   Optional
        *   Whether to redact errors from the server during dehydration.
        *   The function is called for each error in the cache
            *   Return true to redact this error, or false otherwise
        *   Defaults to redacting all errors

**Returns**

*   dehydratedState: DehydratedState
    *   This includes everything that is needed to hydrate the queryClient at a later point
    *   You **should not** rely on the exact format of this response, it is not part of the public API and can change at any time
    *   This result is not in serialized form, you need to do that yourself if desired

### [](#limitations)[Limitations](#limitations)

Some storage systems (such as browser [Web Storage API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API)) require values to be JSON serializable. If you need to dehydrate values that are not automatically serializable to JSON (like Error or undefined), you have to serialize them for yourself. Since only successful queries are included per default, to also include Errors, you have to provide shouldDehydrateQuery, e.g.:

    // server
    const state = dehydrate(client, { shouldDehydrateQuery: () => true }) // to also include Errors
    const serializedState = mySerialize(state) // transform Error instances to objects
    
    // client
    const state = myDeserialize(serializedState) // transform objects back to Error instances
    hydrate(client, state)
    

    // server
    const state = dehydrate(client, { shouldDehydrateQuery: () => true }) // to also include Errors
    const serializedState = mySerialize(state) // transform Error instances to objects
    
    // client
    const state = myDeserialize(serializedState) // transform objects back to Error instances
    hydrate(client, state)
    

[](#hydrate)[hydrate](#hydrate)
-------------------------------

hydrate adds a previously dehydrated state into a cache.

    import { hydrate } from '@tanstack/react-query'
    
    hydrate(queryClient, dehydratedState, options)
    

    import { hydrate } from '@tanstack/react-query'
    
    hydrate(queryClient, dehydratedState, options)
    

**Options**

*   client: QueryClient
    *   **Required**
    *   The queryClient to hydrate the state into
*   dehydratedState: DehydratedState
    *   **Required**
    *   The state to hydrate into the client
*   options: HydrateOptions
    *   Optional
    *   defaultOptions: DefaultOptions
        *   Optional
        *   mutations: MutationOptions The default mutation options to use for the hydrated mutations.
        *   queries: QueryOptions The default query options to use for the hydrated queries.
        *   deserializeData?: (data: any) => any A function to transform (deserialize) data before it is put into the cache.
    *   queryClient?: QueryClient
        *   Use this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.

### [](#limitations-1)[Limitations](#limitations-1)

If the queries you're trying to hydrate already exist in the queryCache, hydrate will only overwrite them if the data is newer than the data present in the cache. Otherwise, it will **not** get applied.

[](#hydrationboundary)[HydrationBoundary](#hydrationboundary)
-------------------------------------------------------------

HydrationBoundary adds a previously dehydrated state into the queryClient that would be returned by useQueryClient(). If the client already contains data, the new queries will be intelligently merged based on update timestamp.

    import { HydrationBoundary } from '@tanstack/react-query'
    
    function App() {
      return <HydrationBoundary state={dehydratedState}>...</HydrationBoundary>
    }
    

    import { HydrationBoundary } from '@tanstack/react-query'
    
    function App() {
      return <HydrationBoundary state={dehydratedState}>...</HydrationBoundary>
    }
    

> Note: Only queries can be dehydrated with an HydrationBoundary.

**Options**

*   state: DehydratedState
    *   The state to hydrate
*   options: HydrateOptions
    *   Optional
    *   defaultOptions: QueryOptions
        *   The default query options to use for the hydrated queries.
    *   queryClient?: QueryClient
        *   Use this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.</content>
</page>

<page>
  <title>ESLint Plugin Query | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query</url>
  <content>TanStack Query comes with its own ESLint plugin. This plugin is used to enforce best practices and to help you avoid common mistakes.

[](#installation)[Installation](#installation)
----------------------------------------------

The plugin is a separate package that you need to install:

    npm i -D @tanstack/eslint-plugin-query
    

    npm i -D @tanstack/eslint-plugin-query
    

or

    pnpm add -D @tanstack/eslint-plugin-query
    

    pnpm add -D @tanstack/eslint-plugin-query
    

or

    yarn add -D @tanstack/eslint-plugin-query
    

    yarn add -D @tanstack/eslint-plugin-query
    

or

    bun add -D @tanstack/eslint-plugin-query
    

    bun add -D @tanstack/eslint-plugin-query
    

[](#flat-config-eslintconfigjs)[Flat Config (eslint.config.js)](#flat-config-eslintconfigjs)
--------------------------------------------------------------------------------------------

### [](#recommended-setup)[Recommended setup](#recommended-setup)

To enable all of the recommended rules for our plugin, add the following config:

    import pluginQuery from '@tanstack/eslint-plugin-query'
    
    export default [
      ...pluginQuery.configs['flat/recommended'],
      // Any other config...
    ]
    

    import pluginQuery from '@tanstack/eslint-plugin-query'
    
    export default [
      ...pluginQuery.configs['flat/recommended'],
      // Any other config...
    ]
    

### [](#custom-setup)[Custom setup](#custom-setup)

Alternatively, you can load the plugin and configure only the rules you want to use:

    import pluginQuery from '@tanstack/eslint-plugin-query'
    
    export default [
      {
        plugins: {
          '@tanstack/query': pluginQuery,
        },
        rules: {
          '@tanstack/query/exhaustive-deps': 'error',
        },
      },
      // Any other config...
    ]
    

    import pluginQuery from '@tanstack/eslint-plugin-query'
    
    export default [
      {
        plugins: {
          '@tanstack/query': pluginQuery,
        },
        rules: {
          '@tanstack/query/exhaustive-deps': 'error',
        },
      },
      // Any other config...
    ]
    

[](#legacy-config-eslintrc)[Legacy Config (.eslintrc)](#legacy-config-eslintrc)
-------------------------------------------------------------------------------

### [](#recommended-setup-1)[Recommended setup](#recommended-setup-1)

To enable all of the recommended rules for our plugin, add plugin:@tanstack/query/recommended in extends:

    {
      "extends": ["plugin:@tanstack/query/recommended"]
    }
    

    {
      "extends": ["plugin:@tanstack/query/recommended"]
    }
    

### [](#custom-setup-1)[Custom setup](#custom-setup-1)

Alternatively, add @tanstack/query to the plugins section, and configure the rules you want to use:

    {
      "plugins": ["@tanstack/query"],
      "rules": {
        "@tanstack/query/exhaustive-deps": "error"
      }
    }
    

    {
      "plugins": ["@tanstack/query"],
      "rules": {
        "@tanstack/query/exhaustive-deps": "error"
      }
    }
    

[](#rules)[Rules](#rules)
-------------------------

*   [@tanstack/query/exhaustive-deps](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [@tanstack/query/no-rest-destructuring](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [@tanstack/query/stable-query-client](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [@tanstack/query/no-unstable-deps](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [@tanstack/query/infinite-query-property-order](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)
*   [@tanstack/query/no-void-query-fn](https://tanstack.com/query/latest/docs/eslint/no-void-query-fn)
*   [@tanstack/query/mutation-property-order](https://tanstack.com/query/latest/docs/eslint/mutation-property-order)</content>
</page>

<page>
  <title>Exhaustive dependencies for query keys | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/eslint/exhaustive-deps</url>
  <content>Query keys should be seen like a dependency array to your query function: Every variable that is used inside the queryFn should be added to the query key. This makes sure that queries are cached independently and that queries are refetched automatically when the variables changes.

[](#rule-details)[Rule Details](#rule-details)
----------------------------------------------

Examples of **incorrect** code for this rule:

    /* eslint "@tanstack/query/exhaustive-deps": "error" */
    
    useQuery({
      queryKey: ['todo'],
      queryFn: () => api.getTodo(todoId),
    })
    
    const todoQueries = {
      detail: (id) => ({ queryKey: ['todo'], queryFn: () => api.getTodo(id) }),
    }
    

    /* eslint "@tanstack/query/exhaustive-deps": "error" */
    
    useQuery({
      queryKey: ['todo'],
      queryFn: () => api.getTodo(todoId),
    })
    
    const todoQueries = {
      detail: (id) => ({ queryKey: ['todo'], queryFn: () => api.getTodo(id) }),
    }
    

Examples of **correct** code for this rule:

    useQuery({
      queryKey: ['todo', todoId],
      queryFn: () => api.getTodo(todoId),
    })
    
    const todoQueries = {
      detail: (id) => ({ queryKey: ['todo', id], queryFn: () => api.getTodo(id) }),
    }
    

    useQuery({
      queryKey: ['todo', todoId],
      queryFn: () => api.getTodo(todoId),
    })
    
    const todoQueries = {
      detail: (id) => ({ queryKey: ['todo', id], queryFn: () => api.getTodo(id) }),
    }
    

[](#when-not-to-use-it)[When Not To Use It](#when-not-to-use-it)
----------------------------------------------------------------

If you don't care about the rules of the query keys, then you will not need this rule.

[](#attributes)[Attributes](#attributes)
----------------------------------------

*   ‚úÖ Recommended
*   üîß Fixable</content>
</page>

<page>
  <title>Stable Query Client | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/eslint/stable-query-client</url>
  <content>The QueryClient contains the QueryCache, so you'd only want to create one instance of the QueryClient for the lifecycle of your application - _not_ a new instance on every render.

> Exception: It's allowed to create a new QueryClient inside an async Server Component, because the async function is only called once on the server.

[](#rule-details)[Rule Details](#rule-details)
----------------------------------------------

Examples of **incorrect** code for this rule:

    /* eslint "@tanstack/query/stable-query-client": "error" */
    
    function App() {
      const queryClient = new QueryClient()
      return (
        <QueryClientProvider client={queryClient}>
          <Home />
        </QueryClientProvider>
      )
    }
    

    /* eslint "@tanstack/query/stable-query-client": "error" */
    
    function App() {
      const queryClient = new QueryClient()
      return (
        <QueryClientProvider client={queryClient}>
          <Home />
        </QueryClientProvider>
      )
    }
    

Examples of **correct** code for this rule:

    function App() {
      const [queryClient] = useState(() => new QueryClient())
      return (
        <QueryClientProvider client={queryClient}>
          <Home />
        </QueryClientProvider>
      )
    }
    

    function App() {
      const [queryClient] = useState(() => new QueryClient())
      return (
        <QueryClientProvider client={queryClient}>
          <Home />
        </QueryClientProvider>
      )
    }
    

    const queryClient = new QueryClient()
    function App() {
      return (
        <QueryClientProvider client={queryClient}>
          <Home />
        </QueryClientProvider>
      )
    }
    

    const queryClient = new QueryClient()
    function App() {
      return (
        <QueryClientProvider client={queryClient}>
          <Home />
        </QueryClientProvider>
      )
    }
    

    async function App() {
      const queryClient = new QueryClient()
      await queryClient.prefetchQuery(options)
    }
    

    async function App() {
      const queryClient = new QueryClient()
      await queryClient.prefetchQuery(options)
    }
    

[](#attributes)[Attributes](#attributes)
----------------------------------------

*   ‚úÖ Recommended
*   üîß Fixable</content>
</page>

<page>
  <title>Disallow object rest destructuring on query results | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring</url>
  <content>Use object rest destructuring on query results automatically subscribes to every field of the query result, which may cause unnecessary re-renders. This makes sure that you only subscribe to the fields that you actually need.

[](#rule-details)[Rule Details](#rule-details)
----------------------------------------------

Examples of **incorrect** code for this rule:

    /* eslint "@tanstack/query/no-rest-destructuring": "warn" */
    
    const useTodos = () => {
      const { data: todos, ...rest } = useQuery({
        queryKey: ['todos'],
        queryFn: () => api.getTodos(),
      })
      return { todos, ...rest }
    }
    

    /* eslint "@tanstack/query/no-rest-destructuring": "warn" */
    
    const useTodos = () => {
      const { data: todos, ...rest } = useQuery({
        queryKey: ['todos'],
        queryFn: () => api.getTodos(),
      })
      return { todos, ...rest }
    }
    

Examples of **correct** code for this rule:

    const todosQuery = useQuery({
      queryKey: ['todos'],
      queryFn: () => api.getTodos(),
    })
    
    // normal object destructuring is fine
    const { data: todos } = todosQuery
    

    const todosQuery = useQuery({
      queryKey: ['todos'],
      queryFn: () => api.getTodos(),
    })
    
    // normal object destructuring is fine
    const { data: todos } = todosQuery
    

[](#when-not-to-use-it)[When Not To Use It](#when-not-to-use-it)
----------------------------------------------------------------

If you set the notifyOnChangeProps options manually, you can disable this rule. Since you are not using tracked queries, you are responsible for specifying which props should trigger a re-render.

[](#attributes)[Attributes](#attributes)
----------------------------------------

*   ‚úÖ Recommended
*   üîß Fixable</content>
</page>

<page>
  <title>Disallow putting the result of query hooks directly in a React hook dependency array | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/eslint/no-unstable-deps</url>
  <content>The object returned from the following query hooks is **not** referentially stable:

*   useQuery
*   useSuspenseQuery
*   useQueries
*   useSuspenseQueries
*   useInfiniteQuery
*   useSuspenseInfiniteQuery
*   useMutation

The object returned from those hooks should **not** be put directly into the dependency array of a React hook (e.g. useEffect, useMemo, useCallback). Instead, destructure the return value of the query hook and pass the destructured values into the dependency array of the React hook.

[](#rule-details)[Rule Details](#rule-details)
----------------------------------------------

Examples of **incorrect** code for this rule:

    /* eslint "@tanstack/query/no-unstable-deps": "warn" */
    import { useCallback } from 'React'
    import { useMutation } from '@tanstack/react-query'
    
    function Component() {
      const mutation = useMutation({ mutationFn: (value: string) => value })
      const callback = useCallback(() => {
        mutation.mutate('hello')
      }, [mutation])
      return null
    }
    

    /* eslint "@tanstack/query/no-unstable-deps": "warn" */
    import { useCallback } from 'React'
    import { useMutation } from '@tanstack/react-query'
    
    function Component() {
      const mutation = useMutation({ mutationFn: (value: string) => value })
      const callback = useCallback(() => {
        mutation.mutate('hello')
      }, [mutation])
      return null
    }
    

Examples of **correct** code for this rule:

    /* eslint "@tanstack/query/no-unstable-deps": "warn" */
    import { useCallback } from 'React'
    import { useMutation } from '@tanstack/react-query'
    
    function Component() {
      const { mutate } = useMutation({ mutationFn: (value: string) => value })
      const callback = useCallback(() => {
        mutate('hello')
      }, [mutate])
      return null
    }
    

    /* eslint "@tanstack/query/no-unstable-deps": "warn" */
    import { useCallback } from 'React'
    import { useMutation } from '@tanstack/react-query'
    
    function Component() {
      const { mutate } = useMutation({ mutationFn: (value: string) => value })
      const callback = useCallback(() => {
        mutate('hello')
      }, [mutate])
      return null
    }
    

[](#attributes)[Attributes](#attributes)
----------------------------------------

*   ‚úÖ Recommended
*   üîß Fixable</content>
</page>

<page>
  <title>Ensure correct order of inference sensitive properties for infinite queries | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order</url>
  <content>For the following functions, the property order of the passed in object matters due to type inference:

*   useInfiniteQuery
*   useSuspenseInfiniteQuery
*   infiniteQueryOptions

The correct property order is as follows:

*   queryFn
*   getPreviousPageParam
*   getNextPageParam

All other properties are insensitive to the order as they do not depend on type inference.

[](#rule-details)[Rule Details](#rule-details)
----------------------------------------------

Examples of **incorrect** code for this rule:

    /* eslint "@tanstack/query/infinite-query-property-order": "warn" */
    import { useInfiniteQuery } from '@tanstack/react-query'
    
    const query = useInfiniteQuery({
      queryKey: ['projects'],
      getNextPageParam: (lastPage) => lastPage.nextId ?? undefined,
      queryFn: async ({ pageParam }) => {
        const response = await fetch(`/api/projects?cursor=${pageParam}`)
        return await response.json()
      },
      initialPageParam: 0,
      getPreviousPageParam: (firstPage) => firstPage.previousId ?? undefined,
      maxPages: 3,
    })
    

    /* eslint "@tanstack/query/infinite-query-property-order": "warn" */
    import { useInfiniteQuery } from '@tanstack/react-query'
    
    const query = useInfiniteQuery({
      queryKey: ['projects'],
      getNextPageParam: (lastPage) => lastPage.nextId ?? undefined,
      queryFn: async ({ pageParam }) => {
        const response = await fetch(`/api/projects?cursor=${pageParam}`)
        return await response.json()
      },
      initialPageParam: 0,
      getPreviousPageParam: (firstPage) => firstPage.previousId ?? undefined,
      maxPages: 3,
    })
    

Examples of **correct** code for this rule:

    /* eslint "@tanstack/query/infinite-query-property-order": "warn" */
    import { useInfiniteQuery } from '@tanstack/react-query'
    
    const query = useInfiniteQuery({
      queryKey: ['projects'],
      queryFn: async ({ pageParam }) => {
        const response = await fetch(`/api/projects?cursor=${pageParam}`)
        return await response.json()
      },
      initialPageParam: 0,
      getPreviousPageParam: (firstPage) => firstPage.previousId ?? undefined,
      getNextPageParam: (lastPage) => lastPage.nextId ?? undefined,
      maxPages: 3,
    })
    

    /* eslint "@tanstack/query/infinite-query-property-order": "warn" */
    import { useInfiniteQuery } from '@tanstack/react-query'
    
    const query = useInfiniteQuery({
      queryKey: ['projects'],
      queryFn: async ({ pageParam }) => {
        const response = await fetch(`/api/projects?cursor=${pageParam}`)
        return await response.json()
      },
      initialPageParam: 0,
      getPreviousPageParam: (firstPage) => firstPage.previousId ?? undefined,
      getNextPageParam: (lastPage) => lastPage.nextId ?? undefined,
      maxPages: 3,
    })
    

[](#attributes)[Attributes](#attributes)
----------------------------------------

*   ‚úÖ Recommended
*   üîß Fixable</content>
</page>

<page>
  <title>React TanStack Query Simple Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/examples/simple</url>
  <content>    import React from 'react'
    import ReactDOM from 'react-dom/client'
    import {
      QueryClient,
      QueryClientProvider,
      useQuery,
    } from '@tanstack/react-query'
    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    
    const queryClient = new QueryClient()
    
    export default function App() {
      return (
        <QueryClientProvider client={queryClient}>
          <ReactQueryDevtools />
          <Example />
        </QueryClientProvider>
      )
    }
    
    function Example() {
      const { isPending, error, data, isFetching } = useQuery({
        queryKey: ['repoData'],
        queryFn: async () => {
          const response = await fetch(
            'https://api.github.com/repos/TanStack/query',
          )
          return await response.json()
        },
      })
    
      if (isPending) return 'Loading...'
    
      if (error) return 'An error has occurred: ' + error.message
    
      return (
        <div>
          <h1>{data.full_name}</h1>
          <p>{data.description}</p>
          <strong>üëÄ {data.subscribers_count}</strong>{' '}
          <strong>‚ú® {data.stargazers_count}</strong>{' '}
          <strong>üç¥ {data.forks_count}</strong>
          <div>{isFetching ? 'Updating...' : ''}</div>
        </div>
      )
    }
    
    const rootElement = document.getElementById('root') as HTMLElement
    ReactDOM.createRoot(rootElement).render(<App />)
    

    import React from 'react'
    import ReactDOM from 'react-dom/client'
    import {
      QueryClient,
      QueryClientProvider,
      useQuery,
    } from '@tanstack/react-query'
    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    
    const queryClient = new QueryClient()
    
    export default function App() {
      return (
        <QueryClientProvider client={queryClient}>
          <ReactQueryDevtools />
          <Example />
        </QueryClientProvider>
      )
    }
    
    function Example() {
      const { isPending, error, data, isFetching } = useQuery({
        queryKey: ['repoData'],
        queryFn: async () => {
          const response = await fetch(
            'https://api.github.com/repos/TanStack/query',
          )
          return await response.json()
        },
      })
    
      if (isPending) return 'Loading...'
    
      if (error) return 'An error has occurred: ' + error.message
    
      return (
        <div>
          <h1>{data.full_name}</h1>
          <p>{data.description}</p>
          <strong>üëÄ {data.subscribers_count}</strong>{' '}
          <strong>‚ú® {data.stargazers_count}</strong>{' '}
          <strong>üç¥ {data.forks_count}</strong>
          <div>{isFetching ? 'Updating...' : ''}</div>
        </div>
      )
    }
    
    const rootElement = document.getElementById('root') as HTMLElement
    ReactDOM.createRoot(rootElement).render(<App />)</content>
</page>

<page>
  <title>React TanStack Query Basic Graphql Request Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/examples/basic-graphql-request</url>
  <content>    import React from 'react'
    import ReactDOM from 'react-dom/client'
    import {
      QueryClient,
      QueryClientProvider,
      useQuery,
      useQueryClient,
    } from '@tanstack/react-query'
    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    import { gql, request } from 'graphql-request'
    
    const endpoint = 'https://graphqlzero.almansi.me/api'
    
    const queryClient = new QueryClient()
    
    type Post = {
      id: number
      title: string
      body: string
    }
    
    function App() {
      const [postId, setPostId] = React.useState(-1)
    
      return (
        <QueryClientProvider client={queryClient}>
          <p>
            As you visit the posts below, you will notice them in a loading state
            the first time you load them. However, after you return to this list and
            click on any posts you have already visited again, you will see them
            load instantly and background refresh right before your eyes!{' '}
            <strong>
              (You may need to throttle your network speed to simulate longer
              loading sequences)
            </strong>
          </p>
          {postId > -1 ? (
            <Post postId={postId} setPostId={setPostId} />
          ) : (
            <Posts setPostId={setPostId} />
          )}
          <ReactQueryDevtools initialIsOpen />
        </QueryClientProvider>
      )
    }
    
    function usePosts() {
      return useQuery({
        queryKey: ['posts'],
        queryFn: async () => {
          const {
            posts: { data },
          } = await request<{ posts: { data: Array<Post> } }>(
            endpoint,
            gql`
              query {
                posts {
                  data {
                    id
                    title
                  }
                }
              }
            `,
          )
          return data
        },
      })
    }
    
    function Posts({
      setPostId,
    }: {
      setPostId: React.Dispatch<React.SetStateAction<number>>
    }) {
      const queryClient = useQueryClient()
      const { status, data, error, isFetching } = usePosts()
    
      return (
        <div>
          <h1>Posts</h1>
          <div>
            {status === 'pending' ? (
              'Loading...'
            ) : status === 'error' ? (
              <span>Error: {error.message}</span>
            ) : (
              <>
                <div>
                  {data.map((post) => (
                    <p key={post.id}>
                      <a
                        onClick={() => setPostId(post.id)}
                        href="#"
                        style={
                          // We can find the existing query data here to show bold links for
                          // ones that are cached
                          queryClient.getQueryData(['post', post.id])
                            ? {
                                fontWeight: 'bold',
                                color: 'green',
                              }
                            : {}
                        }
                      >
                        {post.title}
                      </a>
                    </p>
                  ))}
                </div>
                <div>{isFetching ? 'Background Updating...' : ' '}</div>
              </>
            )}
          </div>
        </div>
      )
    }
    
    function usePost(postId: number) {
      return useQuery({
        queryKey: ['post', postId],
        queryFn: async () => {
          const { post } = await request<{ post: Post }>(
            endpoint,
            gql`
            query {
              post(id: ${postId}) {
                id
                title
                body
              }
            }
            `,
          )
    
          return post
        },
        enabled: !!postId,
      })
    }
    
    function Post({
      postId,
      setPostId,
    }: {
      postId: number
      setPostId: React.Dispatch<React.SetStateAction<number>>
    }) {
      const { status, data, error, isFetching } = usePost(postId)
    
      return (
        <div>
          <div>
            <a onClick={() => setPostId(-1)} href="#">
              Back
            </a>
          </div>
          {!postId || status === 'pending' ? (
            'Loading...'
          ) : status === 'error' ? (
            <span>Error: {error.message}</span>
          ) : (
            <>
              <h1>{data.title}</h1>
              <div>
                <p>{data.body}</p>
              </div>
              <div>{isFetching ? 'Background Updating...' : ' '}</div>
            </>
          )}
        </div>
      )
    }
    
    const rootElement = document.getElementById('root') as HTMLElement
    ReactDOM.createRoot(rootElement).render(<App />)
    

    import React from 'react'
    import ReactDOM from 'react-dom/client'
    import {
      QueryClient,
      QueryClientProvider,
      useQuery,
      useQueryClient,
    } from '@tanstack/react-query'
    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    import { gql, request } from 'graphql-request'
    
    const endpoint = 'https://graphqlzero.almansi.me/api'
    
    const queryClient = new QueryClient()
    
    type Post = {
      id: number
      title: string
      body: string
    }
    
    function App() {
      const [postId, setPostId] = React.useState(-1)
    
      return (
        <QueryClientProvider client={queryClient}>
          <p>
            As you visit the posts below, you will notice them in a loading state
            the first time you load them. However, after you return to this list and
            click on any posts you have already visited again, you will see them
            load instantly and background refresh right before your eyes!{' '}
            <strong>
              (You may need to throttle your network speed to simulate longer
              loading sequences)
            </strong>
          </p>
          {postId > -1 ? (
            <Post postId={postId} setPostId={setPostId} />
          ) : (
            <Posts setPostId={setPostId} />
          )}
          <ReactQueryDevtools initialIsOpen />
        </QueryClientProvider>
      )
    }
    
    function usePosts() {
      return useQuery({
        queryKey: ['posts'],
        queryFn: async () => {
          const {
            posts: { data },
          } = await request<{ posts: { data: Array<Post> } }>(
            endpoint,
            gql`
              query {
                posts {
                  data {
                    id
                    title
                  }
                }
              }
            `,
          )
          return data
        },
      })
    }
    
    function Posts({
      setPostId,
    }: {
      setPostId: React.Dispatch<React.SetStateAction<number>>
    }) {
      const queryClient = useQueryClient()
      const { status, data, error, isFetching } = usePosts()
    
      return (
        <div>
          <h1>Posts</h1>
          <div>
            {status === 'pending' ? (
              'Loading...'
            ) : status === 'error' ? (
              <span>Error: {error.message}</span>
            ) : (
              <>
                <div>
                  {data.map((post) => (
                    <p key={post.id}>
                      <a
                        onClick={() => setPostId(post.id)}
                        href="#"
                        style={
                          // We can find the existing query data here to show bold links for
                          // ones that are cached
                          queryClient.getQueryData(['post', post.id])
                            ? {
                                fontWeight: 'bold',
                                color: 'green',
                              }
                            : {}
                        }
                      >
                        {post.title}
                      </a>
                    </p>
                  ))}
                </div>
                <div>{isFetching ? 'Background Updating...' : ' '}</div>
              </>
            )}
          </div>
        </div>
      )
    }
    
    function usePost(postId: number) {
      return useQuery({
        queryKey: ['post', postId],
        queryFn: async () => {
          const { post } = await request<{ post: Post }>(
            endpoint,
            gql`
            query {
              post(id: ${postId}) {
                id
                title
                body
              }
            }
            `,
          )
    
          return post
        },
        enabled: !!postId,
      })
    }
    
    function Post({
      postId,
      setPostId,
    }: {
      postId: number
      setPostId: React.Dispatch<React.SetStateAction<number>>
    }) {
      const { status, data, error, isFetching } = usePost(postId)
    
      return (
        <div>
          <div>
            <a onClick={() => setPostId(-1)} href="#">
              Back
            </a>
          </div>
          {!postId || status === 'pending' ? (
            'Loading...'
          ) : status === 'error' ? (
            <span>Error: {error.message}</span>
          ) : (
            <>
              <h1>{data.title}</h1>
              <div>
                <p>{data.body}</p>
              </div>
              <div>{isFetching ? 'Background Updating...' : ' '}</div>
            </>
          )}
        </div>
      )
    }
    
    const rootElement = document.getElementById('root') as HTMLElement
    ReactDOM.createRoot(rootElement).render(<App />)</content>
</page>

<page>
  <title>React TanStack Query Optimistic Updates Cache Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/examples/optimistic-updates-cache</url>
  <content>    import * as React from 'react'
    
    import {
      QueryClient,
      QueryClientProvider,
      queryOptions,
      useMutation,
      useQuery,
      useQueryClient,
    } from '@tanstack/react-query'
    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    
    const client = new QueryClient()
    
    type Todos = {
      items: ReadonlyArray<{
        id: string
        text: string
      }>
      ts: number
    }
    
    async function fetchTodos({ signal }: { signal: AbortSignal }): Promise<Todos> {
      const response = await fetch('/api/data', { signal })
      return await response.json()
    }
    
    const todoListOptions = queryOptions({
      queryKey: ['todos'],
      queryFn: fetchTodos,
    })
    
    function Example() {
      const queryClient = useQueryClient()
      const [text, setText] = React.useState('')
      const { isFetching, ...queryInfo } = useQuery(todoListOptions)
    
      const addTodoMutation = useMutation({
        mutationFn: async (newTodo: string) => {
          const response = await fetch('/api/data', {
            method: 'POST',
            body: JSON.stringify({ text: newTodo }),
            headers: { 'Content-Type': 'application/json' },
          })
          return await response.json()
        },
        // When mutate is called:
        onMutate: async (newTodo, context) => {
          setText('')
          // Cancel any outgoing refetch
          // (so they don't overwrite our optimistic update)
          await context.client.cancelQueries(todoListOptions)
    
          // Snapshot the previous value
          const previousTodos = context.client.getQueryData(
            todoListOptions.queryKey,
          )
    
          // Optimistically update to the new value
          if (previousTodos) {
            context.client.setQueryData(todoListOptions.queryKey, {
              ...previousTodos,
              items: [
                ...previousTodos.items,
                { id: Math.random().toString(), text: newTodo },
              ],
            })
          }
    
          return { previousTodos }
        },
        // If the mutation fails,
        // use the result returned from onMutate to roll back
        onError: (err, variables, onMutateResult, context) => {
          if (onMutateResult?.previousTodos) {
            context.client.setQueryData<Todos>(
              ['todos'],
              onMutateResult.previousTodos,
            )
          }
        },
        // Always refetch after error or success:
        onSettled: (data, error, variables, onMutateResult, context) =>
          context.client.invalidateQueries({ queryKey: ['todos'] }),
      })
    
      return (
        <div>
          <p>
            In this example, new items can be created using a mutation. The new item
            will be optimistically added to the list in hopes that the server
            accepts the item. If it does, the list is refetched with the true items
            from the list. Every now and then, the mutation may fail though. When
            that happens, the previous list of items is restored and the list is
            again refetched from the server.
          </p>
          <form
            onSubmit={(e) => {
              e.preventDefault()
              addTodoMutation.mutate(text)
            }}
          >
            <input
              type="text"
              onChange={(event) => setText(event.target.value)}
              value={text}
            />
            <button disabled={addTodoMutation.isPending}>Create</button>
          </form>
          <br />
          {queryInfo.isSuccess && (
            <>
              <div>
                {/* The type of queryInfo.data will be narrowed because we check for isSuccess first */}
                Updated At: {new Date(queryInfo.data.ts).toLocaleTimeString()}
              </div>
              <ul>
                {queryInfo.data.items.map((todo) => (
                  <li key={todo.id}>{todo.text}</li>
                ))}
              </ul>
              {isFetching && <div>Updating in background...</div>}
            </>
          )}
          {queryInfo.isLoading && 'Loading'}
          {queryInfo.error instanceof Error && queryInfo.error.message}
        </div>
      )
    }
    
    export default function App() {
      return (
        <QueryClientProvider client={client}>
          <Example />
          <ReactQueryDevtools initialIsOpen />
        </QueryClientProvider>
      )
    }
    

    import * as React from 'react'
    
    import {
      QueryClient,
      QueryClientProvider,
      queryOptions,
      useMutation,
      useQuery,
      useQueryClient,
    } from '@tanstack/react-query'
    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    
    const client = new QueryClient()
    
    type Todos = {
      items: ReadonlyArray<{
        id: string
        text: string
      }>
      ts: number
    }
    
    async function fetchTodos({ signal }: { signal: AbortSignal }): Promise<Todos> {
      const response = await fetch('/api/data', { signal })
      return await response.json()
    }
    
    const todoListOptions = queryOptions({
      queryKey: ['todos'],
      queryFn: fetchTodos,
    })
    
    function Example() {
      const queryClient = useQueryClient()
      const [text, setText] = React.useState('')
      const { isFetching, ...queryInfo } = useQuery(todoListOptions)
    
      const addTodoMutation = useMutation({
        mutationFn: async (newTodo: string) => {
          const response = await fetch('/api/data', {
            method: 'POST',
            body: JSON.stringify({ text: newTodo }),
            headers: { 'Content-Type': 'application/json' },
          })
          return await response.json()
        },
        // When mutate is called:
        onMutate: async (newTodo, context) => {
          setText('')
          // Cancel any outgoing refetch
          // (so they don't overwrite our optimistic update)
          await context.client.cancelQueries(todoListOptions)
    
          // Snapshot the previous value
          const previousTodos = context.client.getQueryData(
            todoListOptions.queryKey,
          )
    
          // Optimistically update to the new value
          if (previousTodos) {
            context.client.setQueryData(todoListOptions.queryKey, {
              ...previousTodos,
              items: [
                ...previousTodos.items,
                { id: Math.random().toString(), text: newTodo },
              ],
            })
          }
    
          return { previousTodos }
        },
        // If the mutation fails,
        // use the result returned from onMutate to roll back
        onError: (err, variables, onMutateResult, context) => {
          if (onMutateResult?.previousTodos) {
            context.client.setQueryData<Todos>(
              ['todos'],
              onMutateResult.previousTodos,
            )
          }
        },
        // Always refetch after error or success:
        onSettled: (data, error, variables, onMutateResult, context) =>
          context.client.invalidateQueries({ queryKey: ['todos'] }),
      })
    
      return (
        <div>
          <p>
            In this example, new items can be created using a mutation. The new item
            will be optimistically added to the list in hopes that the server
            accepts the item. If it does, the list is refetched with the true items
            from the list. Every now and then, the mutation may fail though. When
            that happens, the previous list of items is restored and the list is
            again refetched from the server.
          </p>
          <form
            onSubmit={(e) => {
              e.preventDefault()
              addTodoMutation.mutate(text)
            }}
          >
            <input
              type="text"
              onChange={(event) => setText(event.target.value)}
              value={text}
            />
            <button disabled={addTodoMutation.isPending}>Create</button>
          </form>
          <br />
          {queryInfo.isSuccess && (
            <>
              <div>
                {/* The type of queryInfo.data will be narrowed because we check for isSuccess first */}
                Updated At: {new Date(queryInfo.data.ts).toLocaleTimeString()}
              </div>
              <ul>
                {queryInfo.data.items.map((todo) => (
                  <li key={todo.id}>{todo.text}</li>
                ))}
              </ul>
              {isFetching && <div>Updating in background...</div>}
            </>
          )}
          {queryInfo.isLoading && 'Loading'}
          {queryInfo.error instanceof Error && queryInfo.error.message}
        </div>
      )
    }
    
    export default function App() {
      return (
        <QueryClientProvider client={client}>
          <Example />
          <ReactQueryDevtools initialIsOpen />
        </QueryClientProvider>
      )
    }</content>
</page>

<page>
  <title>React TanStack Query Auto Refetching Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/examples/auto-refetching</url>
  <content>    import React from 'react'
    
    import {
      QueryClient,
      QueryClientProvider,
      useMutation,
      useQuery,
      useQueryClient,
    } from '@tanstack/react-query'
    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    
    const queryClient = new QueryClient()
    
    export default function App() {
      return (
        <QueryClientProvider client={queryClient}>
          <Example />
        </QueryClientProvider>
      )
    }
    
    function Example() {
      const queryClient = useQueryClient()
      const [intervalMs, setIntervalMs] = React.useState(1000)
      const [value, setValue] = React.useState('')
    
      const { status, data, error, isFetching } = useQuery({
        queryKey: ['todos'],
        queryFn: async (): Promise<Array<string>> => {
          const response = await fetch('/api/data')
          return await response.json()
        },
        // Refetch the data every second
        refetchInterval: intervalMs,
      })
    
      const addMutation = useMutation({
        mutationFn: (add: string) => fetch(`/api/data?add=${add}`),
        onSuccess: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
      })
    
      const clearMutation = useMutation({
        mutationFn: () => fetch(`/api/data?clear=1`),
        onSuccess: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
      })
    
      if (status === 'pending') return <h1>Loading...</h1>
      if (status === 'error') return <span>Error: {error.message}</span>
    
      return (
        <div>
          <h1>Auto Refetch with stale-time set to {intervalMs}ms</h1>
          <p>
            This example is best experienced on your own machine, where you can open
            multiple tabs to the same localhost server and see your changes
            propagate between the two.
          </p>
          <label>
            Query Interval speed (ms):{' '}
            <input
              value={intervalMs}
              onChange={(ev) => setIntervalMs(Number(ev.target.value))}
              type="number"
              step="100"
            />{' '}
            <span
              style={{
                display: 'inline-block',
                marginLeft: '.5rem',
                width: 10,
                height: 10,
                background: isFetching ? 'green' : 'transparent',
                transition: !isFetching ? 'all .3s ease' : 'none',
                borderRadius: '100%',
                transform: 'scale(2)',
              }}
            />
          </label>
          <h2>Todo List</h2>
          <form
            onSubmit={(event) => {
              event.preventDefault()
              addMutation.mutate(value, {
                onSuccess: () => {
                  setValue('')
                },
              })
            }}
          >
            <input
              placeholder="enter something"
              value={value}
              onChange={(ev) => setValue(ev.target.value)}
            />
          </form>
          <ul>
            {data.map((item) => (
              <li key={item}>{item}</li>
            ))}
          </ul>
          <div>
            <button
              onClick={() => {
                clearMutation.mutate()
              }}
            >
              Clear All
            </button>
          </div>
          <ReactQueryDevtools initialIsOpen />
        </div>
      )
    }
    

    import React from 'react'
    
    import {
      QueryClient,
      QueryClientProvider,
      useMutation,
      useQuery,
      useQueryClient,
    } from '@tanstack/react-query'
    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    
    const queryClient = new QueryClient()
    
    export default function App() {
      return (
        <QueryClientProvider client={queryClient}>
          <Example />
        </QueryClientProvider>
      )
    }
    
    function Example() {
      const queryClient = useQueryClient()
      const [intervalMs, setIntervalMs] = React.useState(1000)
      const [value, setValue] = React.useState('')
    
      const { status, data, error, isFetching } = useQuery({
        queryKey: ['todos'],
        queryFn: async (): Promise<Array<string>> => {
          const response = await fetch('/api/data')
          return await response.json()
        },
        // Refetch the data every second
        refetchInterval: intervalMs,
      })
    
      const addMutation = useMutation({
        mutationFn: (add: string) => fetch(`/api/data?add=${add}`),
        onSuccess: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
      })
    
      const clearMutation = useMutation({
        mutationFn: () => fetch(`/api/data?clear=1`),
        onSuccess: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
      })
    
      if (status === 'pending') return <h1>Loading...</h1>
      if (status === 'error') return <span>Error: {error.message}</span>
    
      return (
        <div>
          <h1>Auto Refetch with stale-time set to {intervalMs}ms</h1>
          <p>
            This example is best experienced on your own machine, where you can open
            multiple tabs to the same localhost server and see your changes
            propagate between the two.
          </p>
          <label>
            Query Interval speed (ms):{' '}
            <input
              value={intervalMs}
              onChange={(ev) => setIntervalMs(Number(ev.target.value))}
              type="number"
              step="100"
            />{' '}
            <span
              style={{
                display: 'inline-block',
                marginLeft: '.5rem',
                width: 10,
                height: 10,
                background: isFetching ? 'green' : 'transparent',
                transition: !isFetching ? 'all .3s ease' : 'none',
                borderRadius: '100%',
                transform: 'scale(2)',
              }}
            />
          </label>
          <h2>Todo List</h2>
          <form
            onSubmit={(event) => {
              event.preventDefault()
              addMutation.mutate(value, {
                onSuccess: () => {
                  setValue('')
                },
              })
            }}
          >
            <input
              placeholder="enter something"
              value={value}
              onChange={(ev) => setValue(ev.target.value)}
            />
          </form>
          <ul>
            {data.map((item) => (
              <li key={item}>{item}</li>
            ))}
          </ul>
          <div>
            <button
              onClick={() => {
                clearMutation.mutate()
              }}
            >
              Clear All
            </button>
          </div>
          <ReactQueryDevtools initialIsOpen />
        </div>
      )
    }</content>
</page>

<page>
  <title>React TanStack Query Optimistic Updates Ui Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/examples/optimistic-updates-ui</url>
  <content>    import * as React from 'react'
    import {
      QueryClient,
      QueryClientProvider,
      useMutation,
      useQuery,
      useQueryClient,
    } from '@tanstack/react-query'
    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    
    const client = new QueryClient()
    
    type Todos = {
      items: ReadonlyArray<{
        id: string
        text: string
      }>
      ts: number
    }
    
    async function fetchTodos(): Promise<Todos> {
      const response = await fetch('/api/data')
      return await response.json()
    }
    
    function useTodos() {
      return useQuery({ queryKey: ['todos'], queryFn: fetchTodos })
    }
    
    function Example() {
      const queryClient = useQueryClient()
      const [text, setText] = React.useState('')
      const todoQuery = useTodos()
    
      const addTodoMutation = useMutation({
        mutationFn: async (newTodo: string) => {
          const response = await fetch('/api/data', {
            method: 'POST',
            body: JSON.stringify({ text: newTodo }),
            headers: { 'Content-Type': 'application/json' },
          })
          if (!response.ok) {
            throw new Error('Something went wrong.')
          }
          return await response.json()
        },
        onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
      })
    
      return (
        <div>
          <p>
            In this example, new items can be created using a mutation. The new item
            will be optimistically added to the list in hopes that the server
            accepts the item. If it does, the list is refetched with the true items
            from the list. Every now and then, the mutation may fail though. When
            that happens, the previous list of items is restored and the list is
            again refetched from the server.
          </p>
          <form
            onSubmit={(e) => {
              e.preventDefault()
              setText('')
              addTodoMutation.mutate(text)
            }}
          >
            <input
              type="text"
              onChange={(event) => setText(event.target.value)}
              value={text}
            />
            <button disabled={addTodoMutation.isPending}>Create</button>
          </form>
          <br />
          {todoQuery.isSuccess && (
            <>
              <div>
                {/* The type of queryInfo.data will be narrowed because we check for isSuccess first */}
                Updated At: {new Date(todoQuery.data.ts).toLocaleTimeString()}
              </div>
              <ul>
                {todoQuery.data.items.map((todo) => (
                  <li key={todo.id}>{todo.text}</li>
                ))}
                {addTodoMutation.isPending && (
                  <li style={{ opacity: 0.5 }}>{addTodoMutation.variables}</li>
                )}
                {addTodoMutation.isError && (
                  <li style={{ color: 'red' }}>
                    {addTodoMutation.variables}
                    <button
                      onClick={() =>
                        addTodoMutation.mutate(addTodoMutation.variables)
                      }
                    >
                      Retry
                    </button>
                  </li>
                )}
              </ul>
              {todoQuery.isFetching && <div>Updating in background...</div>}
            </>
          )}
          {todoQuery.isPending && 'Loading'}
          {todoQuery.error instanceof Error && todoQuery.error.message}
        </div>
      )
    }
    
    export default function App() {
      return (
        <QueryClientProvider client={client}>
          <Example />
          <ReactQueryDevtools initialIsOpen />
        </QueryClientProvider>
      )
    }
    

    import * as React from 'react'
    import {
      QueryClient,
      QueryClientProvider,
      useMutation,
      useQuery,
      useQueryClient,
    } from '@tanstack/react-query'
    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    
    const client = new QueryClient()
    
    type Todos = {
      items: ReadonlyArray<{
        id: string
        text: string
      }>
      ts: number
    }
    
    async function fetchTodos(): Promise<Todos> {
      const response = await fetch('/api/data')
      return await response.json()
    }
    
    function useTodos() {
      return useQuery({ queryKey: ['todos'], queryFn: fetchTodos })
    }
    
    function Example() {
      const queryClient = useQueryClient()
      const [text, setText] = React.useState('')
      const todoQuery = useTodos()
    
      const addTodoMutation = useMutation({
        mutationFn: async (newTodo: string) => {
          const response = await fetch('/api/data', {
            method: 'POST',
            body: JSON.stringify({ text: newTodo }),
            headers: { 'Content-Type': 'application/json' },
          })
          if (!response.ok) {
            throw new Error('Something went wrong.')
          }
          return await response.json()
        },
        onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
      })
    
      return (
        <div>
          <p>
            In this example, new items can be created using a mutation. The new item
            will be optimistically added to the list in hopes that the server
            accepts the item. If it does, the list is refetched with the true items
            from the list. Every now and then, the mutation may fail though. When
            that happens, the previous list of items is restored and the list is
            again refetched from the server.
          </p>
          <form
            onSubmit={(e) => {
              e.preventDefault()
              setText('')
              addTodoMutation.mutate(text)
            }}
          >
            <input
              type="text"
              onChange={(event) => setText(event.target.value)}
              value={text}
            />
            <button disabled={addTodoMutation.isPending}>Create</button>
          </form>
          <br />
          {todoQuery.isSuccess && (
            <>
              <div>
                {/* The type of queryInfo.data will be narrowed because we check for isSuccess first */}
                Updated At: {new Date(todoQuery.data.ts).toLocaleTimeString()}
              </div>
              <ul>
                {todoQuery.data.items.map((todo) => (
                  <li key={todo.id}>{todo.text}</li>
                ))}
                {addTodoMutation.isPending && (
                  <li style={{ opacity: 0.5 }}>{addTodoMutation.variables}</li>
                )}
                {addTodoMutation.isError && (
                  <li style={{ color: 'red' }}>
                    {addTodoMutation.variables}
                    <button
                      onClick={() =>
                        addTodoMutation.mutate(addTodoMutation.variables)
                      }
                    >
                      Retry
                    </button>
                  </li>
                )}
              </ul>
              {todoQuery.isFetching && <div>Updating in background...</div>}
            </>
          )}
          {todoQuery.isPending && 'Loading'}
          {todoQuery.error instanceof Error && todoQuery.error.message}
        </div>
      )
    }
    
    export default function App() {
      return (
        <QueryClientProvider client={client}>
          <Example />
          <ReactQueryDevtools initialIsOpen />
        </QueryClientProvider>
      )
    }</content>
</page>

<page>
  <title>React TanStack Query Load More Infinite Scroll Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/examples/load-more-infinite-scroll</url>
  <content>    import React from 'react'
    import Link from 'next/link'
    import { useInView } from 'react-intersection-observer'
    import {
      useInfiniteQuery,
      QueryClient,
      QueryClientProvider,
    } from '@tanstack/react-query'
    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    
    const queryClient = new QueryClient()
    
    export default function App() {
      return (
        <QueryClientProvider client={queryClient}>
          <Example />
        </QueryClientProvider>
      )
    }
    
    function Example() {
      const { ref, inView } = useInView()
    
      const {
        status,
        data,
        error,
        isFetching,
        isFetchingNextPage,
        isFetchingPreviousPage,
        fetchNextPage,
        fetchPreviousPage,
        hasNextPage,
        hasPreviousPage,
      } = useInfiniteQuery({
        queryKey: ['projects'],
        queryFn: async ({
          pageParam,
        }): Promise<{
          data: Array<{ name: string; id: number }>
          previousId: number
          nextId: number
        }> => {
          const response = await fetch(`/api/projects?cursor=${pageParam}`)
          return await response.json()
        },
        initialPageParam: 0,
        getPreviousPageParam: (firstPage) => firstPage.previousId,
        getNextPageParam: (lastPage) => lastPage.nextId,
      })
    
      React.useEffect(() => {
        if (inView && hasNextPage && !isFetchingNextPage) {
          fetchNextPage()
        }
      }, [inView, hasNextPage, isFetchingNextPage, fetchNextPage])
    
      return (
        <div>
          <h1>Infinite Loading</h1>
          {status === 'pending' ? (
            <p>Loading...</p>
          ) : status === 'error' ? (
            <span>Error: {error.message}</span>
          ) : (
            <>
              <div>
                <button
                  onClick={() => fetchPreviousPage()}
                  disabled={!hasPreviousPage || isFetchingPreviousPage}
                >
                  {isFetchingPreviousPage
                    ? 'Loading more...'
                    : hasPreviousPage
                      ? 'Load Older'
                      : 'Nothing more to load'}
                </button>
              </div>
              {data.pages.map((page) => (
                <React.Fragment key={page.nextId}>
                  {page.data.map((project) => (
                    <p
                      style={{
                        border: '1px solid gray',
                        borderRadius: '5px',
                        padding: '10rem 1rem',
                        background: `hsla(${project.id * 30}, 60%, 80%, 1)`,
                      }}
                      key={project.id}
                    >
                      {project.name}
                    </p>
                  ))}
                </React.Fragment>
              ))}
              <div>
                <button
                  ref={ref}
                  onClick={() => fetchNextPage()}
                  disabled={!hasNextPage || isFetchingNextPage}
                >
                  {isFetchingNextPage
                    ? 'Loading more...'
                    : hasNextPage
                      ? 'Load Newer'
                      : 'Nothing more to load'}
                </button>
              </div>
              <div>
                {isFetching && !isFetchingNextPage
                  ? 'Background Updating...'
                  : null}
              </div>
            </>
          )}
          <hr />
          <Link href="/about">Go to another page</Link>
          <ReactQueryDevtools initialIsOpen />
        </div>
      )
    }
    

    import React from 'react'
    import Link from 'next/link'
    import { useInView } from 'react-intersection-observer'
    import {
      useInfiniteQuery,
      QueryClient,
      QueryClientProvider,
    } from '@tanstack/react-query'
    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    
    const queryClient = new QueryClient()
    
    export default function App() {
      return (
        <QueryClientProvider client={queryClient}>
          <Example />
        </QueryClientProvider>
      )
    }
    
    function Example() {
      const { ref, inView } = useInView()
    
      const {
        status,
        data,
        error,
        isFetching,
        isFetchingNextPage,
        isFetchingPreviousPage,
        fetchNextPage,
        fetchPreviousPage,
        hasNextPage,
        hasPreviousPage,
      } = useInfiniteQuery({
        queryKey: ['projects'],
        queryFn: async ({
          pageParam,
        }): Promise<{
          data: Array<{ name: string; id: number }>
          previousId: number
          nextId: number
        }> => {
          const response = await fetch(`/api/projects?cursor=${pageParam}`)
          return await response.json()
        },
        initialPageParam: 0,
        getPreviousPageParam: (firstPage) => firstPage.previousId,
        getNextPageParam: (lastPage) => lastPage.nextId,
      })
    
      React.useEffect(() => {
        if (inView && hasNextPage && !isFetchingNextPage) {
          fetchNextPage()
        }
      }, [inView, hasNextPage, isFetchingNextPage, fetchNextPage])
    
      return (
        <div>
          <h1>Infinite Loading</h1>
          {status === 'pending' ? (
            <p>Loading...</p>
          ) : status === 'error' ? (
            <span>Error: {error.message}</span>
          ) : (
            <>
              <div>
                <button
                  onClick={() => fetchPreviousPage()}
                  disabled={!hasPreviousPage || isFetchingPreviousPage}
                >
                  {isFetchingPreviousPage
                    ? 'Loading more...'
                    : hasPreviousPage
                      ? 'Load Older'
                      : 'Nothing more to load'}
                </button>
              </div>
              {data.pages.map((page) => (
                <React.Fragment key={page.nextId}>
                  {page.data.map((project) => (
                    <p
                      style={{
                        border: '1px solid gray',
                        borderRadius: '5px',
                        padding: '10rem 1rem',
                        background: `hsla(${project.id * 30}, 60%, 80%, 1)`,
                      }}
                      key={project.id}
                    >
                      {project.name}
                    </p>
                  ))}
                </React.Fragment>
              ))}
              <div>
                <button
                  ref={ref}
                  onClick={() => fetchNextPage()}
                  disabled={!hasNextPage || isFetchingNextPage}
                >
                  {isFetchingNextPage
                    ? 'Loading more...'
                    : hasNextPage
                      ? 'Load Newer'
                      : 'Nothing more to load'}
                </button>
              </div>
              <div>
                {isFetching && !isFetchingNextPage
                  ? 'Background Updating...'
                  : null}
              </div>
            </>
          )}
          <hr />
          <Link href="/about">Go to another page</Link>
          <ReactQueryDevtools initialIsOpen />
        </div>
      )
    }</content>
</page>

<page>
  <title>React TanStack Query Pagination Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/examples/pagination</url>
  <content>    import React from 'react'
    import {
      QueryClient,
      QueryClientProvider,
      keepPreviousData,
      useQuery,
      useQueryClient,
    } from '@tanstack/react-query'
    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    
    const queryClient = new QueryClient()
    
    export default function App() {
      return (
        <QueryClientProvider client={queryClient}>
          <Example />
        </QueryClientProvider>
      )
    }
    
    const fetchProjects = async (
      page = 0,
    ): Promise<{
      projects: Array<{ name: string; id: number }>
      hasMore: boolean
    }> => {
      const response = await fetch(`/api/projects?page=${page}`)
      return await response.json()
    }
    
    function Example() {
      const queryClient = useQueryClient()
      const [page, setPage] = React.useState(0)
    
      const { status, data, error, isFetching, isPlaceholderData } = useQuery({
        queryKey: ['projects', page],
        queryFn: () => fetchProjects(page),
        placeholderData: keepPreviousData,
        staleTime: 5000,
      })
    
      // Prefetch the next page!
      React.useEffect(() => {
        if (!isPlaceholderData && data?.hasMore) {
          queryClient.prefetchQuery({
            queryKey: ['projects', page + 1],
            queryFn: () => fetchProjects(page + 1),
          })
        }
      }, [data, isPlaceholderData, page, queryClient])
    
      return (
        <div>
          <p>
            In this example, each page of data remains visible as the next page is
            fetched. The buttons and capability to proceed to the next page are also
            supressed until the next page cursor is known. Each page is cached as a
            normal query too, so when going to previous pages, you'll see them
            instantaneously while they are also refetched invisibly in the
            background.
          </p>
          {status === 'pending' ? (
            <div>Loading...</div>
          ) : status === 'error' ? (
            <div>Error: {error.message}</div>
          ) : (
            // `data` will either resolve to the latest page's data
            // or if fetching a new page, the last successful page's data
            <div>
              {data.projects.map((project) => (
                <p key={project.id}>{project.name}</p>
              ))}
            </div>
          )}
          <div>Current Page: {page + 1}</div>
          <button
            onClick={() => setPage((old) => Math.max(old - 1, 0))}
            disabled={page === 0}
          >
            Previous Page
          </button>{' '}
          <button
            onClick={() => {
              setPage((old) => (data?.hasMore ? old + 1 : old))
            }}
            disabled={isPlaceholderData || !data?.hasMore}
          >
            Next Page
          </button>
          {
            // Since the last page's data potentially sticks around between page requests,
            // we can use `isFetching` to show a background loading
            // indicator since our `status === 'pending'` state won't be triggered
            isFetching ? <span> Loading...</span> : null
          }{' '}
          <ReactQueryDevtools initialIsOpen />
        </div>
      )
    }
    

    import React from 'react'
    import {
      QueryClient,
      QueryClientProvider,
      keepPreviousData,
      useQuery,
      useQueryClient,
    } from '@tanstack/react-query'
    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    
    const queryClient = new QueryClient()
    
    export default function App() {
      return (
        <QueryClientProvider client={queryClient}>
          <Example />
        </QueryClientProvider>
      )
    }
    
    const fetchProjects = async (
      page = 0,
    ): Promise<{
      projects: Array<{ name: string; id: number }>
      hasMore: boolean
    }> => {
      const response = await fetch(`/api/projects?page=${page}`)
      return await response.json()
    }
    
    function Example() {
      const queryClient = useQueryClient()
      const [page, setPage] = React.useState(0)
    
      const { status, data, error, isFetching, isPlaceholderData } = useQuery({
        queryKey: ['projects', page],
        queryFn: () => fetchProjects(page),
        placeholderData: keepPreviousData,
        staleTime: 5000,
      })
    
      // Prefetch the next page!
      React.useEffect(() => {
        if (!isPlaceholderData && data?.hasMore) {
          queryClient.prefetchQuery({
            queryKey: ['projects', page + 1],
            queryFn: () => fetchProjects(page + 1),
          })
        }
      }, [data, isPlaceholderData, page, queryClient])
    
      return (
        <div>
          <p>
            In this example, each page of data remains visible as the next page is
            fetched. The buttons and capability to proceed to the next page are also
            supressed until the next page cursor is known. Each page is cached as a
            normal query too, so when going to previous pages, you'll see them
            instantaneously while they are also refetched invisibly in the
            background.
          </p>
          {status === 'pending' ? (
            <div>Loading...</div>
          ) : status === 'error' ? (
            <div>Error: {error.message}</div>
          ) : (
            // `data` will either resolve to the latest page's data
            // or if fetching a new page, the last successful page's data
            <div>
              {data.projects.map((project) => (
                <p key={project.id}>{project.name}</p>
              ))}
            </div>
          )}
          <div>Current Page: {page + 1}</div>
          <button
            onClick={() => setPage((old) => Math.max(old - 1, 0))}
            disabled={page === 0}
          >
            Previous Page
          </button>{' '}
          <button
            onClick={() => {
              setPage((old) => (data?.hasMore ? old + 1 : old))
            }}
            disabled={isPlaceholderData || !data?.hasMore}
          >
            Next Page
          </button>
          {
            // Since the last page's data potentially sticks around between page requests,
            // we can use `isFetching` to show a background loading
            // indicator since our `status === 'pending'` state won't be triggered
            isFetching ? <span> Loading...</span> : null
          }{' '}
          <ReactQueryDevtools initialIsOpen />
        </div>
      )
    }</content>
</page>

<page>
  <title>React TanStack Query Infinite Query With Max Pages Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/examples/infinite-query-with-max-pages</url>
  <content>    import React from 'react'
    import {
      QueryClient,
      QueryClientProvider,
      useInfiniteQuery,
    } from '@tanstack/react-query'
    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    
    const queryClient = new QueryClient()
    
    export default function App() {
      return (
        <QueryClientProvider client={queryClient}>
          <Example />
        </QueryClientProvider>
      )
    }
    
    function Example() {
      const {
        status,
        data,
        error,
        isFetching,
        isFetchingNextPage,
        isFetchingPreviousPage,
        fetchNextPage,
        fetchPreviousPage,
        hasNextPage,
        hasPreviousPage,
      } = useInfiniteQuery({
        queryKey: ['projects'],
        queryFn: async ({ pageParam }) => {
          const response = await fetch(`/api/projects?cursor=${pageParam}`)
          return await response.json()
        },
        initialPageParam: 0,
        getPreviousPageParam: (firstPage) => firstPage.previousId ?? undefined,
        getNextPageParam: (lastPage) => lastPage.nextId ?? undefined,
        maxPages: 3,
      })
    
      return (
        <div>
          <h1>Infinite Query with max pages</h1>
          <h3>4 projects per page</h3>
          <h3>3 pages max</h3>
          {status === 'pending' ? (
            <p>Loading...</p>
          ) : status === 'error' ? (
            <span>Error: {error.message}</span>
          ) : (
            <>
              <div>
                <button
                  onClick={() => fetchPreviousPage()}
                  disabled={!hasPreviousPage || isFetchingPreviousPage}
                >
                  {isFetchingPreviousPage
                    ? 'Loading more...'
                    : hasPreviousPage
                      ? 'Load Older'
                      : 'Nothing more to load'}
                </button>
              </div>
              {data.pages.map((page) => (
                <React.Fragment key={page.nextId}>
                  {page.data.map((project) => (
                    <p
                      style={{
                        border: '1px solid gray',
                        borderRadius: '5px',
                        padding: '8px',
                        fontSize: '14px',
                        background: `hsla(${project.id * 30}, 60%, 80%, 1)`,
                      }}
                      key={project.id}
                    >
                      {project.name}
                    </p>
                  ))}
                </React.Fragment>
              ))}
              <div>
                <button
                  onClick={() => fetchNextPage()}
                  disabled={!hasNextPage || isFetchingNextPage}
                >
                  {isFetchingNextPage
                    ? 'Loading more...'
                    : hasNextPage
                      ? 'Load Newer'
                      : 'Nothing more to load'}
                </button>
              </div>
              <div>
                {isFetching && !isFetchingNextPage
                  ? 'Background Updating...'
                  : null}
              </div>
            </>
          )}
          <hr />
          <ReactQueryDevtools initialIsOpen />
        </div>
      )
    }
    

    import React from 'react'
    import {
      QueryClient,
      QueryClientProvider,
      useInfiniteQuery,
    } from '@tanstack/react-query'
    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    
    const queryClient = new QueryClient()
    
    export default function App() {
      return (
        <QueryClientProvider client={queryClient}>
          <Example />
        </QueryClientProvider>
      )
    }
    
    function Example() {
      const {
        status,
        data,
        error,
        isFetching,
        isFetchingNextPage,
        isFetchingPreviousPage,
        fetchNextPage,
        fetchPreviousPage,
        hasNextPage,
        hasPreviousPage,
      } = useInfiniteQuery({
        queryKey: ['projects'],
        queryFn: async ({ pageParam }) => {
          const response = await fetch(`/api/projects?cursor=${pageParam}`)
          return await response.json()
        },
        initialPageParam: 0,
        getPreviousPageParam: (firstPage) => firstPage.previousId ?? undefined,
        getNextPageParam: (lastPage) => lastPage.nextId ?? undefined,
        maxPages: 3,
      })
    
      return (
        <div>
          <h1>Infinite Query with max pages</h1>
          <h3>4 projects per page</h3>
          <h3>3 pages max</h3>
          {status === 'pending' ? (
            <p>Loading...</p>
          ) : status === 'error' ? (
            <span>Error: {error.message}</span>
          ) : (
            <>
              <div>
                <button
                  onClick={() => fetchPreviousPage()}
                  disabled={!hasPreviousPage || isFetchingPreviousPage}
                >
                  {isFetchingPreviousPage
                    ? 'Loading more...'
                    : hasPreviousPage
                      ? 'Load Older'
                      : 'Nothing more to load'}
                </button>
              </div>
              {data.pages.map((page) => (
                <React.Fragment key={page.nextId}>
                  {page.data.map((project) => (
                    <p
                      style={{
                        border: '1px solid gray',
                        borderRadius: '5px',
                        padding: '8px',
                        fontSize: '14px',
                        background: `hsla(${project.id * 30}, 60%, 80%, 1)`,
                      }}
                      key={project.id}
                    >
                      {project.name}
                    </p>
                  ))}
                </React.Fragment>
              ))}
              <div>
                <button
                  onClick={() => fetchNextPage()}
                  disabled={!hasNextPage || isFetchingNextPage}
                >
                  {isFetchingNextPage
                    ? 'Loading more...'
                    : hasNextPage
                      ? 'Load Newer'
                      : 'Nothing more to load'}
                </button>
              </div>
              <div>
                {isFetching && !isFetchingNextPage
                  ? 'Background Updating...'
                  : null}
              </div>
            </>
          )}
          <hr />
          <ReactQueryDevtools initialIsOpen />
        </div>
      )
    }</content>
</page>

<page>
  <title>React TanStack Query Suspense Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/examples/suspense</url>
  <content>    import 'font-awesome/css/font-awesome.min.css'
    import React, { lazy } from 'react'
    import ReactDOM from 'react-dom/client'
    import {
      QueryClient,
      QueryClientProvider,
      QueryErrorResetBoundary,
      useQueryClient,
    } from '@tanstack/react-query'
    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    import { ErrorBoundary } from 'react-error-boundary'
    
    import { fetchProjects } from './queries'
    
    import Button from './components/Button'
    
    const Projects = lazy(() => import('./components/Projects'))
    const Project = lazy(() => import('./components/Project'))
    
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          retry: 0,
        },
      },
    })
    
    function App() {
      return (
        <QueryClientProvider client={queryClient}>
          <Example />
        </QueryClientProvider>
      )
    }
    
    function Example() {
      const queryClient = useQueryClient()
      const [showProjects, setShowProjects] = React.useState(false)
      const [activeProject, setActiveProject] = React.useState<string | null>(null)
    
      return (
        <>
          <Button
            onClick={() => {
              setShowProjects((old) => {
                if (!old) {
                  queryClient.prefetchQuery({
                    queryKey: ['projects'],
                    queryFn: fetchProjects,
                  })
                }
                return !old
              })
            }}
          >
            {showProjects ? 'Hide Projects' : 'Show Projects'}
          </Button>
    
          <hr />
    
          <QueryErrorResetBoundary>
            {({ reset }) => (
              <ErrorBoundary
                fallbackRender={({ error, resetErrorBoundary }) => (
                  <div>
                    There was an error!{' '}
                    <Button onClick={() => resetErrorBoundary()}>Try again</Button>
                    <pre style={{ whiteSpace: 'normal' }}>{error.message}</pre>
                  </div>
                )}
                onReset={reset}
              >
                {showProjects ? (
                  <React.Suspense fallback={<h1>Loading projects...</h1>}>
                    {activeProject ? (
                      <Project
                        activeProject={activeProject}
                        setActiveProject={setActiveProject}
                      />
                    ) : (
                      <Projects setActiveProject={setActiveProject} />
                    )}
                  </React.Suspense>
                ) : null}
              </ErrorBoundary>
            )}
          </QueryErrorResetBoundary>
          <ReactQueryDevtools initialIsOpen />
        </>
      )
    }
    
    const rootElement = document.getElementById('root') as HTMLElement
    ReactDOM.createRoot(rootElement).render(<App />)
    

    import 'font-awesome/css/font-awesome.min.css'
    import React, { lazy } from 'react'
    import ReactDOM from 'react-dom/client'
    import {
      QueryClient,
      QueryClientProvider,
      QueryErrorResetBoundary,
      useQueryClient,
    } from '@tanstack/react-query'
    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    import { ErrorBoundary } from 'react-error-boundary'
    
    import { fetchProjects } from './queries'
    
    import Button from './components/Button'
    
    const Projects = lazy(() => import('./components/Projects'))
    const Project = lazy(() => import('./components/Project'))
    
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          retry: 0,
        },
      },
    })
    
    function App() {
      return (
        <QueryClientProvider client={queryClient}>
          <Example />
        </QueryClientProvider>
      )
    }
    
    function Example() {
      const queryClient = useQueryClient()
      const [showProjects, setShowProjects] = React.useState(false)
      const [activeProject, setActiveProject] = React.useState<string | null>(null)
    
      return (
        <>
          <Button
            onClick={() => {
              setShowProjects((old) => {
                if (!old) {
                  queryClient.prefetchQuery({
                    queryKey: ['projects'],
                    queryFn: fetchProjects,
                  })
                }
                return !old
              })
            }}
          >
            {showProjects ? 'Hide Projects' : 'Show Projects'}
          </Button>
    
          <hr />
    
          <QueryErrorResetBoundary>
            {({ reset }) => (
              <ErrorBoundary
                fallbackRender={({ error, resetErrorBoundary }) => (
                  <div>
                    There was an error!{' '}
                    <Button onClick={() => resetErrorBoundary()}>Try again</Button>
                    <pre style={{ whiteSpace: 'normal' }}>{error.message}</pre>
                  </div>
                )}
                onReset={reset}
              >
                {showProjects ? (
                  <React.Suspense fallback={<h1>Loading projects...</h1>}>
                    {activeProject ? (
                      <Project
                        activeProject={activeProject}
                        setActiveProject={setActiveProject}
                      />
                    ) : (
                      <Projects setActiveProject={setActiveProject} />
                    )}
                  </React.Suspense>
                ) : null}
              </ErrorBoundary>
            )}
          </QueryErrorResetBoundary>
          <ReactQueryDevtools initialIsOpen />
        </>
      )
    }
    
    const rootElement = document.getElementById('root') as HTMLElement
    ReactDOM.createRoot(rootElement).render(<App />)</content>
</page>

<page>
  <title>React TanStack Query Default Query Function Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/examples/default-query-function</url>
  <content>    import React from 'react'
    import ReactDOM from 'react-dom/client'
    import {
      QueryClient,
      QueryClientProvider,
      useQuery,
      useQueryClient,
    } from '@tanstack/react-query'
    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    import type { QueryKey } from '@tanstack/react-query'
    
    type Post = {
      id: number
      title: string
      body: string
    }
    
    // Define a default query function that will receive the query key
    const defaultQueryFn = async ({ queryKey }: { queryKey: QueryKey }) => {
      const response = await fetch(
        `https://jsonplaceholder.typicode.com${queryKey[0]}`,
      )
      return await response.json()
    }
    
    // provide the default query function to your app via the query client
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          queryFn: defaultQueryFn,
        },
      },
    })
    
    function App() {
      const [postId, setPostId] = React.useState(-1)
    
      return (
        <QueryClientProvider client={queryClient}>
          <p>
            As you visit the posts below, you will notice them in a loading state
            the first time you load them. However, after you return to this list and
            click on any posts you have already visited again, you will see them
            load instantly and background refresh right before your eyes!{' '}
            <strong>
              (You may need to throttle your network speed to simulate longer
              loading sequences)
            </strong>
          </p>
          {postId > -1 ? (
            <Post postId={postId} setPostId={setPostId} />
          ) : (
            <Posts setPostId={setPostId} />
          )}
          <ReactQueryDevtools initialIsOpen />
        </QueryClientProvider>
      )
    }
    
    function Posts({
      setPostId,
    }: {
      setPostId: React.Dispatch<React.SetStateAction<number>>
    }) {
      const queryClient = useQueryClient()
    
      // All you have to do now is pass a key!
      const { status, data, error, isFetching } = useQuery<Array<Post>>({
        queryKey: ['/posts'],
      })
    
      return (
        <div>
          <h1>Posts</h1>
          <div>
            {status === 'pending' ? (
              'Loading...'
            ) : status === 'error' ? (
              <span>Error: {error.message}</span>
            ) : (
              <>
                <div>
                  {data.map((post) => (
                    <p key={post.id}>
                      <a
                        onClick={() => setPostId(post.id)}
                        href="#"
                        style={
                          // We can use the queryCache here to show bold links for
                          // ones that are cached
                          queryClient.getQueryData([`/posts/${post.id}`])
                            ? {
                                fontWeight: 'bold',
                                color: 'green',
                              }
                            : {}
                        }
                      >
                        {post.title}
                      </a>
                    </p>
                  ))}
                </div>
                <div>{isFetching ? 'Background Updating...' : ' '}</div>
              </>
            )}
          </div>
        </div>
      )
    }
    
    function Post({
      postId,
      setPostId,
    }: {
      postId: number
      setPostId: React.Dispatch<React.SetStateAction<number>>
    }) {
      // You can even leave out the queryFn and just go straight into options
      const { status, data, error, isFetching } = useQuery<Post>({
        queryKey: [`/posts/${postId}`],
        enabled: !!postId,
      })
    
      return (
        <div>
          <div>
            <a onClick={() => setPostId(-1)} href="#">
              Back
            </a>
          </div>
          {!postId || status === 'pending' ? (
            'Loading...'
          ) : status === 'error' ? (
            <span>Error: {error.message}</span>
          ) : (
            <>
              <h1>{data.title}</h1>
              <div>
                <p>{data.body}</p>
              </div>
              <div>{isFetching ? 'Background Updating...' : ' '}</div>
            </>
          )}
        </div>
      )
    }
    
    const rootElement = document.getElementById('root') as HTMLElement
    ReactDOM.createRoot(rootElement).render(<App />)
    

    import React from 'react'
    import ReactDOM from 'react-dom/client'
    import {
      QueryClient,
      QueryClientProvider,
      useQuery,
      useQueryClient,
    } from '@tanstack/react-query'
    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    import type { QueryKey } from '@tanstack/react-query'
    
    type Post = {
      id: number
      title: string
      body: string
    }
    
    // Define a default query function that will receive the query key
    const defaultQueryFn = async ({ queryKey }: { queryKey: QueryKey }) => {
      const response = await fetch(
        `https://jsonplaceholder.typicode.com${queryKey[0]}`,
      )
      return await response.json()
    }
    
    // provide the default query function to your app via the query client
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          queryFn: defaultQueryFn,
        },
      },
    })
    
    function App() {
      const [postId, setPostId] = React.useState(-1)
    
      return (
        <QueryClientProvider client={queryClient}>
          <p>
            As you visit the posts below, you will notice them in a loading state
            the first time you load them. However, after you return to this list and
            click on any posts you have already visited again, you will see them
            load instantly and background refresh right before your eyes!{' '}
            <strong>
              (You may need to throttle your network speed to simulate longer
              loading sequences)
            </strong>
          </p>
          {postId > -1 ? (
            <Post postId={postId} setPostId={setPostId} />
          ) : (
            <Posts setPostId={setPostId} />
          )}
          <ReactQueryDevtools initialIsOpen />
        </QueryClientProvider>
      )
    }
    
    function Posts({
      setPostId,
    }: {
      setPostId: React.Dispatch<React.SetStateAction<number>>
    }) {
      const queryClient = useQueryClient()
    
      // All you have to do now is pass a key!
      const { status, data, error, isFetching } = useQuery<Array<Post>>({
        queryKey: ['/posts'],
      })
    
      return (
        <div>
          <h1>Posts</h1>
          <div>
            {status === 'pending' ? (
              'Loading...'
            ) : status === 'error' ? (
              <span>Error: {error.message}</span>
            ) : (
              <>
                <div>
                  {data.map((post) => (
                    <p key={post.id}>
                      <a
                        onClick={() => setPostId(post.id)}
                        href="#"
                        style={
                          // We can use the queryCache here to show bold links for
                          // ones that are cached
                          queryClient.getQueryData([`/posts/${post.id}`])
                            ? {
                                fontWeight: 'bold',
                                color: 'green',
                              }
                            : {}
                        }
                      >
                        {post.title}
                      </a>
                    </p>
                  ))}
                </div>
                <div>{isFetching ? 'Background Updating...' : ' '}</div>
              </>
            )}
          </div>
        </div>
      )
    }
    
    function Post({
      postId,
      setPostId,
    }: {
      postId: number
      setPostId: React.Dispatch<React.SetStateAction<number>>
    }) {
      // You can even leave out the queryFn and just go straight into options
      const { status, data, error, isFetching } = useQuery<Post>({
        queryKey: [`/posts/${postId}`],
        enabled: !!postId,
      })
    
      return (
        <div>
          <div>
            <a onClick={() => setPostId(-1)} href="#">
              Back
            </a>
          </div>
          {!postId || status === 'pending' ? (
            'Loading...'
          ) : status === 'error' ? (
            <span>Error: {error.message}</span>
          ) : (
            <>
              <h1>{data.title}</h1>
              <div>
                <p>{data.body}</p>
              </div>
              <div>{isFetching ? 'Background Updating...' : ' '}</div>
            </>
          )}
        </div>
      )
    }
    
    const rootElement = document.getElementById('root') as HTMLElement
    ReactDOM.createRoot(rootElement).render(<App />)</content>
</page>

<page>
  <title>React TanStack Query Playground Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/examples/playground</url>
  <content>    import React from 'react'
    import ReactDOM from 'react-dom/client'
    import {
      QueryClient,
      QueryClientProvider,
      useMutation,
      useQuery,
      useQueryClient,
    } from '@tanstack/react-query'
    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    import './styles.css'
    
    let id = 0
    let list = [
      'apple',
      'banana',
      'pineapple',
      'grapefruit',
      'dragonfruit',
      'grapes',
    ].map((d) => ({ id: id++, name: d, notes: 'These are some notes' }))
    
    type Todos = typeof list
    type Todo = Todos[0]
    
    let errorRate = 0.05
    let queryTimeMin = 1000
    let queryTimeMax = 2000
    
    const queryClient = new QueryClient()
    
    function Root() {
      const [staleTime, setStaleTime] = React.useState(1000)
      const [gcTime, setGcTime] = React.useState(3000)
      const [localErrorRate, setErrorRate] = React.useState(errorRate)
      const [localFetchTimeMin, setLocalFetchTimeMin] = React.useState(queryTimeMin)
      const [localFetchTimeMax, setLocalFetchTimeMax] = React.useState(queryTimeMax)
    
      React.useEffect(() => {
        errorRate = localErrorRate
        queryTimeMin = localFetchTimeMin
        queryTimeMax = localFetchTimeMax
      }, [localErrorRate, localFetchTimeMax, localFetchTimeMin])
    
      React.useEffect(() => {
        queryClient.setDefaultOptions({
          queries: {
            staleTime,
            gcTime,
          },
        })
      }, [gcTime, staleTime])
    
      return (
        <QueryClientProvider client={queryClient}>
          <p>
            The "staleTime" and "gcTime" durations have been altered in this example
            to show how query stale-ness and query caching work on a granular level
          </p>
          <div>
            Stale Time:{' '}
            <input
              type="number"
              min="0"
              step="1000"
              value={staleTime}
              onChange={(e) => setStaleTime(parseFloat(e.target.value))}
              style={{ width: '100px' }}
            />
          </div>
          <div>
            Garbage collection Time:{' '}
            <input
              type="number"
              min="0"
              step="1000"
              value={gcTime}
              onChange={(e) => setGcTime(parseFloat(e.target.value))}
              style={{ width: '100px' }}
            />
          </div>
          <br />
          <div>
            Error Rate:{' '}
            <input
              type="number"
              min="0"
              max="1"
              step=".05"
              value={localErrorRate}
              onChange={(e) => setErrorRate(parseFloat(e.target.value))}
              style={{ width: '100px' }}
            />
          </div>
          <div>
            Fetch Time Min:{' '}
            <input
              type="number"
              min="1"
              step="500"
              value={localFetchTimeMin}
              onChange={(e) => setLocalFetchTimeMin(parseFloat(e.target.value))}
              style={{ width: '60px' }}
            />{' '}
          </div>
          <div>
            Fetch Time Max:{' '}
            <input
              type="number"
              min="1"
              step="500"
              value={localFetchTimeMax}
              onChange={(e) => setLocalFetchTimeMax(parseFloat(e.target.value))}
              style={{ width: '60px' }}
            />
          </div>
          <br />
          <App />
          <br />
          <ReactQueryDevtools initialIsOpen />
        </QueryClientProvider>
      )
    }
    
    function App() {
      const queryClient = useQueryClient()
      const [editingIndex, setEditingIndex] = React.useState<number | null>(null)
      const [views, setViews] = React.useState(['', 'fruit', 'grape'])
      // const [views, setViews] = React.useState([""]);
    
      return (
        <div className="App">
          <div>
            <button onClick={() => queryClient.invalidateQueries()}>
              Force Refetch All
            </button>
          </div>
          <br />
          <hr />
          {views.map((view, index) => (
            <div key={index}>
              <Todos
                initialFilter={view}
                setEditingIndex={setEditingIndex}
                onRemove={() => {
                  setViews((old) => [...old, ''])
                }}
              />
              <br />
            </div>
          ))}
          <button
            onClick={() => {
              setViews((old) => [...old, ''])
            }}
          >
            Add Filter List
          </button>
          <hr />
          {editingIndex !== null ? (
            <>
              <EditTodo
                editingIndex={editingIndex}
                setEditingIndex={setEditingIndex}
              />
              <hr />
            </>
          ) : null}
          <AddTodo />
        </div>
      )
    }
    
    function Todos({
      initialFilter = '',
      setEditingIndex,
    }: {
      initialFilter: string
      setEditingIndex: React.Dispatch<React.SetStateAction<number | null>>
    }) {
      const [filter, setFilter] = React.useState(initialFilter)
    
      const { status, data, isFetching, error, failureCount, refetch } = useQuery({
        queryKey: ['todos', { filter }],
        queryFn: fetchTodos,
      })
    
      return (
        <div>
          <div>
            <label>
              Filter:{' '}
              <input value={filter} onChange={(e) => setFilter(e.target.value)} />
            </label>
          </div>
          {status === 'pending' ? (
            <span>Loading... (Attempt: {failureCount + 1})</span>
          ) : status === 'error' ? (
            <span>
              Error: {error.message}
              <br />
              <button onClick={() => refetch()}>Retry</button>
            </span>
          ) : (
            <>
              <ul>
                {data
                  ? data.map((todo) => (
                      <li key={todo.id}>
                        {todo.name}{' '}
                        <button onClick={() => setEditingIndex(todo.id)}>
                          Edit
                        </button>
                      </li>
                    ))
                  : null}
              </ul>
              <div>
                {isFetching ? (
                  <span>
                    Background Refreshing... (Attempt: {failureCount + 1})
                  </span>
                ) : (
                  <span>&nbsp;</span>
                )}
              </div>
            </>
          )}
        </div>
      )
    }
    
    function EditTodo({
      editingIndex,
      setEditingIndex,
    }: {
      editingIndex: number
      setEditingIndex: React.Dispatch<React.SetStateAction<number | null>>
    }) {
      const queryClient = useQueryClient()
    
      // Don't attempt to query until editingIndex is truthy
      const { status, data, isFetching, error, failureCount, refetch } = useQuery({
        queryKey: ['todo', { id: editingIndex }],
        queryFn: () => fetchTodoById({ id: editingIndex }),
      })
    
      const [todo, setTodo] = React.useState(data || {})
    
      React.useEffect(() => {
        if (editingIndex !== null && data) {
          setTodo(data)
        } else {
          setTodo({})
        }
      }, [data, editingIndex])
    
      const saveMutation = useMutation({
        mutationFn: patchTodo,
        onSuccess: (data) => {
          // Update `todos` and the individual todo queries when this mutation succeeds
          queryClient.invalidateQueries({ queryKey: ['todos'] })
          queryClient.setQueryData(['todo', { id: editingIndex }], data)
        },
      })
    
      const onSave = () => {
        saveMutation.mutate(todo)
      }
    
      const disableEditSave =
        status === 'pending' || saveMutation.status === 'pending'
    
      return (
        <div>
          <div>
            {data ? (
              <>
                <button onClick={() => setEditingIndex(null)}>Back</button> Editing
                Todo "{data.name}" (#
                {editingIndex})
              </>
            ) : null}
          </div>
          {status === 'pending' ? (
            <span>Loading... (Attempt: {failureCount + 1})</span>
          ) : error ? (
            <span>
              Error! <button onClick={() => refetch()}>Retry</button>
            </span>
          ) : (
            <>
              <label>
                Name:{' '}
                <input
                  value={todo.name}
                  onChange={(e) =>
                    e.persist() ||
                    setTodo((old) => ({ ...old, name: e.target.value }))
                  }
                  disabled={disableEditSave}
                />
              </label>
              <label>
                Notes:{' '}
                <input
                  value={todo.notes}
                  onChange={(e) =>
                    e.persist() ||
                    setTodo((old) => ({ ...old, notes: e.target.value }))
                  }
                  disabled={disableEditSave}
                />
              </label>
              <div>
                <button onClick={onSave} disabled={disableEditSave}>
                  Save
                </button>
              </div>
              <div>
                {saveMutation.status === 'pending'
                  ? 'Saving...'
                  : saveMutation.status === 'error'
                    ? saveMutation.error.message
                    : 'Saved!'}
              </div>
              <div>
                {isFetching ? (
                  <span>
                    Background Refreshing... (Attempt: {failureCount + 1})
                  </span>
                ) : (
                  <span>&nbsp;</span>
                )}
              </div>
            </>
          )}
        </div>
      )
    }
    
    function AddTodo() {
      const queryClient = useQueryClient()
      const [name, setName] = React.useState('')
    
      const addMutation = useMutation({
        mutationFn: postTodo,
        onSuccess: () => {
          queryClient.invalidateQueries({ queryKey: ['todos'] })
        },
      })
    
      return (
        <div>
          <input
            value={name}
            onChange={(e) => setName(e.target.value)}
            disabled={addMutation.status === 'pending'}
          />
          <button
            onClick={() => {
              addMutation.mutate({ name, notes: 'These are some notes' })
            }}
            disabled={addMutation.status === 'pending' || !name}
          >
            Add Todo
          </button>
          <div>
            {addMutation.status === 'pending'
              ? 'Saving...'
              : addMutation.status === 'error'
                ? addMutation.error.message
                : 'Saved!'}
          </div>
        </div>
      )
    }
    
    function fetchTodos({ signal, queryKey: [, { filter }] }): Promise<Todos> {
      console.info('fetchTodos', { filter })
    
      if (signal) {
        signal.addEventListener('abort', () => {
          console.info('cancelled', filter)
        })
      }
    
      return new Promise((resolve, reject) => {
        setTimeout(
          () => {
            if (Math.random() < errorRate) {
              return reject(
                new Error(JSON.stringify({ fetchTodos: { filter } }, null, 2)),
              )
            }
            resolve(list.filter((d) => d.name.includes(filter)))
          },
          queryTimeMin + Math.random() * (queryTimeMax - queryTimeMin),
        )
      })
    }
    
    function fetchTodoById({ id }: { id: number }): Promise<Todo> {
      console.info('fetchTodoById', { id })
      return new Promise((resolve, reject) => {
        setTimeout(
          () => {
            if (Math.random() < errorRate) {
              return reject(
                new Error(JSON.stringify({ fetchTodoById: { id } }, null, 2)),
              )
            }
            resolve(list.find((d) => d.id === id))
          },
          queryTimeMin + Math.random() * (queryTimeMax - queryTimeMin),
        )
      })
    }
    
    function postTodo({ name, notes }: Omit<Todo, 'id'>) {
      console.info('postTodo', { name, notes })
      return new Promise((resolve, reject) => {
        setTimeout(
          () => {
            if (Math.random() < errorRate) {
              return reject(
                new Error(JSON.stringify({ postTodo: { name, notes } }, null, 2)),
              )
            }
            const todo = { name, notes, id: id++ }
            list = [...list, todo]
            resolve(todo)
          },
          queryTimeMin + Math.random() * (queryTimeMax - queryTimeMin),
        )
      })
    }
    
    function patchTodo(todo?: Todo): Promise<Todo> {
      console.info('patchTodo', todo)
      return new Promise((resolve, reject) => {
        setTimeout(
          () => {
            if (Math.random() < errorRate) {
              return reject(new Error(JSON.stringify({ patchTodo: todo }, null, 2)))
            }
            list = list.map((d) => {
              if (d.id === todo.id) {
                return todo
              }
              return d
            })
            resolve(todo)
          },
          queryTimeMin + Math.random() * (queryTimeMax - queryTimeMin),
        )
      })
    }
    
    const rootElement = document.getElementById('root') as HTMLElement
    ReactDOM.createRoot(rootElement).render(<Root />)
    

    import React from 'react'
    import ReactDOM from 'react-dom/client'
    import {
      QueryClient,
      QueryClientProvider,
      useMutation,
      useQuery,
      useQueryClient,
    } from '@tanstack/react-query'
    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    import './styles.css'
    
    let id = 0
    let list = [
      'apple',
      'banana',
      'pineapple',
      'grapefruit',
      'dragonfruit',
      'grapes',
    ].map((d) => ({ id: id++, name: d, notes: 'These are some notes' }))
    
    type Todos = typeof list
    type Todo = Todos[0]
    
    let errorRate = 0.05
    let queryTimeMin = 1000
    let queryTimeMax = 2000
    
    const queryClient = new QueryClient()
    
    function Root() {
      const [staleTime, setStaleTime] = React.useState(1000)
      const [gcTime, setGcTime] = React.useState(3000)
      const [localErrorRate, setErrorRate] = React.useState(errorRate)
      const [localFetchTimeMin, setLocalFetchTimeMin] = React.useState(queryTimeMin)
      const [localFetchTimeMax, setLocalFetchTimeMax] = React.useState(queryTimeMax)
    
      React.useEffect(() => {
        errorRate = localErrorRate
        queryTimeMin = localFetchTimeMin
        queryTimeMax = localFetchTimeMax
      }, [localErrorRate, localFetchTimeMax, localFetchTimeMin])
    
      React.useEffect(() => {
        queryClient.setDefaultOptions({
          queries: {
            staleTime,
            gcTime,
          },
        })
      }, [gcTime, staleTime])
    
      return (
        <QueryClientProvider client={queryClient}>
          <p>
            The "staleTime" and "gcTime" durations have been altered in this example
            to show how query stale-ness and query caching work on a granular level
          </p>
          <div>
            Stale Time:{' '}
            <input
              type="number"
              min="0"
              step="1000"
              value={staleTime}
              onChange={(e) => setStaleTime(parseFloat(e.target.value))}
              style={{ width: '100px' }}
            />
          </div>
          <div>
            Garbage collection Time:{' '}
            <input
              type="number"
              min="0"
              step="1000"
              value={gcTime}
              onChange={(e) => setGcTime(parseFloat(e.target.value))}
              style={{ width: '100px' }}
            />
          </div>
          <br />
          <div>
            Error Rate:{' '}
            <input
              type="number"
              min="0"
              max="1"
              step=".05"
              value={localErrorRate}
              onChange={(e) => setErrorRate(parseFloat(e.target.value))}
              style={{ width: '100px' }}
            />
          </div>
          <div>
            Fetch Time Min:{' '}
            <input
              type="number"
              min="1"
              step="500"
              value={localFetchTimeMin}
              onChange={(e) => setLocalFetchTimeMin(parseFloat(e.target.value))}
              style={{ width: '60px' }}
            />{' '}
          </div>
          <div>
            Fetch Time Max:{' '}
            <input
              type="number"
              min="1"
              step="500"
              value={localFetchTimeMax}
              onChange={(e) => setLocalFetchTimeMax(parseFloat(e.target.value))}
              style={{ width: '60px' }}
            />
          </div>
          <br />
          <App />
          <br />
          <ReactQueryDevtools initialIsOpen />
        </QueryClientProvider>
      )
    }
    
    function App() {
      const queryClient = useQueryClient()
      const [editingIndex, setEditingIndex] = React.useState<number | null>(null)
      const [views, setViews] = React.useState(['', 'fruit', 'grape'])
      // const [views, setViews] = React.useState([""]);
    
      return (
        <div className="App">
          <div>
            <button onClick={() => queryClient.invalidateQueries()}>
              Force Refetch All
            </button>
          </div>
          <br />
          <hr />
          {views.map((view, index) => (
            <div key={index}>
              <Todos
                initialFilter={view}
                setEditingIndex={setEditingIndex}
                onRemove={() => {
                  setViews((old) => [...old, ''])
                }}
              />
              <br />
            </div>
          ))}
          <button
            onClick={() => {
              setViews((old) => [...old, ''])
            }}
          >
            Add Filter List
          </button>
          <hr />
          {editingIndex !== null ? (
            <>
              <EditTodo
                editingIndex={editingIndex}
                setEditingIndex={setEditingIndex}
              />
              <hr />
            </>
          ) : null}
          <AddTodo />
        </div>
      )
    }
    
    function Todos({
      initialFilter = '',
      setEditingIndex,
    }: {
      initialFilter: string
      setEditingIndex: React.Dispatch<React.SetStateAction<number | null>>
    }) {
      const [filter, setFilter] = React.useState(initialFilter)
    
      const { status, data, isFetching, error, failureCount, refetch } = useQuery({
        queryKey: ['todos', { filter }],
        queryFn: fetchTodos,
      })
    
      return (
        <div>
          <div>
            <label>
              Filter:{' '}
              <input value={filter} onChange={(e) => setFilter(e.target.value)} />
            </label>
          </div>
          {status === 'pending' ? (
            <span>Loading... (Attempt: {failureCount + 1})</span>
          ) : status === 'error' ? (
            <span>
              Error: {error.message}
              <br />
              <button onClick={() => refetch()}>Retry</button>
            </span>
          ) : (
            <>
              <ul>
                {data
                  ? data.map((todo) => (
                      <li key={todo.id}>
                        {todo.name}{' '}
                        <button onClick={() => setEditingIndex(todo.id)}>
                          Edit
                        </button>
                      </li>
                    ))
                  : null}
              </ul>
              <div>
                {isFetching ? (
                  <span>
                    Background Refreshing... (Attempt: {failureCount + 1})
                  </span>
                ) : (
                  <span>&nbsp;</span>
                )}
              </div>
            </>
          )}
        </div>
      )
    }
    
    function EditTodo({
      editingIndex,
      setEditingIndex,
    }: {
      editingIndex: number
      setEditingIndex: React.Dispatch<React.SetStateAction<number | null>>
    }) {
      const queryClient = useQueryClient()
    
      // Don't attempt to query until editingIndex is truthy
      const { status, data, isFetching, error, failureCount, refetch } = useQuery({
        queryKey: ['todo', { id: editingIndex }],
        queryFn: () => fetchTodoById({ id: editingIndex }),
      })
    
      const [todo, setTodo] = React.useState(data || {})
    
      React.useEffect(() => {
        if (editingIndex !== null && data) {
          setTodo(data)
        } else {
          setTodo({})
        }
      }, [data, editingIndex])
    
      const saveMutation = useMutation({
        mutationFn: patchTodo,
        onSuccess: (data) => {
          // Update `todos` and the individual todo queries when this mutation succeeds
          queryClient.invalidateQueries({ queryKey: ['todos'] })
          queryClient.setQueryData(['todo', { id: editingIndex }], data)
        },
      })
    
      const onSave = () => {
        saveMutation.mutate(todo)
      }
    
      const disableEditSave =
        status === 'pending' || saveMutation.status === 'pending'
    
      return (
        <div>
          <div>
            {data ? (
              <>
                <button onClick={() => setEditingIndex(null)}>Back</button> Editing
                Todo "{data.name}" (#
                {editingIndex})
              </>
            ) : null}
          </div>
          {status === 'pending' ? (
            <span>Loading... (Attempt: {failureCount + 1})</span>
          ) : error ? (
            <span>
              Error! <button onClick={() => refetch()}>Retry</button>
            </span>
          ) : (
            <>
              <label>
                Name:{' '}
                <input
                  value={todo.name}
                  onChange={(e) =>
                    e.persist() ||
                    setTodo((old) => ({ ...old, name: e.target.value }))
                  }
                  disabled={disableEditSave}
                />
              </label>
              <label>
                Notes:{' '}
                <input
                  value={todo.notes}
                  onChange={(e) =>
                    e.persist() ||
                    setTodo((old) => ({ ...old, notes: e.target.value }))
                  }
                  disabled={disableEditSave}
                />
              </label>
              <div>
                <button onClick={onSave} disabled={disableEditSave}>
                  Save
                </button>
              </div>
              <div>
                {saveMutation.status === 'pending'
                  ? 'Saving...'
                  : saveMutation.status === 'error'
                    ? saveMutation.error.message
                    : 'Saved!'}
              </div>
              <div>
                {isFetching ? (
                  <span>
                    Background Refreshing... (Attempt: {failureCount + 1})
                  </span>
                ) : (
                  <span>&nbsp;</span>
                )}
              </div>
            </>
          )}
        </div>
      )
    }
    
    function AddTodo() {
      const queryClient = useQueryClient()
      const [name, setName] = React.useState('')
    
      const addMutation = useMutation({
        mutationFn: postTodo,
        onSuccess: () => {
          queryClient.invalidateQueries({ queryKey: ['todos'] })
        },
      })
    
      return (
        <div>
          <input
            value={name}
            onChange={(e) => setName(e.target.value)}
            disabled={addMutation.status === 'pending'}
          />
          <button
            onClick={() => {
              addMutation.mutate({ name, notes: 'These are some notes' })
            }}
            disabled={addMutation.status === 'pending' || !name}
          >
            Add Todo
          </button>
          <div>
            {addMutation.status === 'pending'
              ? 'Saving...'
              : addMutation.status === 'error'
                ? addMutation.error.message
                : 'Saved!'}
          </div>
        </div>
      )
    }
    
    function fetchTodos({ signal, queryKey: [, { filter }] }): Promise<Todos> {
      console.info('fetchTodos', { filter })
    
      if (signal) {
        signal.addEventListener('abort', () => {
          console.info('cancelled', filter)
        })
      }
    
      return new Promise((resolve, reject) => {
        setTimeout(
          () => {
            if (Math.random() < errorRate) {
              return reject(
                new Error(JSON.stringify({ fetchTodos: { filter } }, null, 2)),
              )
            }
            resolve(list.filter((d) => d.name.includes(filter)))
          },
          queryTimeMin + Math.random() * (queryTimeMax - queryTimeMin),
        )
      })
    }
    
    function fetchTodoById({ id }: { id: number }): Promise<Todo> {
      console.info('fetchTodoById', { id })
      return new Promise((resolve, reject) => {
        setTimeout(
          () => {
            if (Math.random() < errorRate) {
              return reject(
                new Error(JSON.stringify({ fetchTodoById: { id } }, null, 2)),
              )
            }
            resolve(list.find((d) => d.id === id))
          },
          queryTimeMin + Math.random() * (queryTimeMax - queryTimeMin),
        )
      })
    }
    
    function postTodo({ name, notes }: Omit<Todo, 'id'>) {
      console.info('postTodo', { name, notes })
      return new Promise((resolve, reject) => {
        setTimeout(
          () => {
            if (Math.random() < errorRate) {
              return reject(
                new Error(JSON.stringify({ postTodo: { name, notes } }, null, 2)),
              )
            }
            const todo = { name, notes, id: id++ }
            list = [...list, todo]
            resolve(todo)
          },
          queryTimeMin + Math.random() * (queryTimeMax - queryTimeMin),
        )
      })
    }
    
    function patchTodo(todo?: Todo): Promise<Todo> {
      console.info('patchTodo', todo)
      return new Promise((resolve, reject) => {
        setTimeout(
          () => {
            if (Math.random() < errorRate) {
              return reject(new Error(JSON.stringify({ patchTodo: todo }, null, 2)))
            }
            list = list.map((d) => {
              if (d.id === todo.id) {
                return todo
              }
              return d
            })
            resolve(todo)
          },
          queryTimeMin + Math.random() * (queryTimeMax - queryTimeMin),
        )
      })
    }
    
    const rootElement = document.getElementById('root') as HTMLElement
    ReactDOM.createRoot(rootElement).render(<Root />)</content>
</page>

<page>
  <title>React TanStack Query Star Wars Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/examples/star-wars</url>
  <content>tsx

    import ReactDOM from 'react-dom/client'
    import App from './App'
    
    const rootElement = document.getElementById('root') as HTMLElement
    ReactDOM.createRoot(rootElement).render(<App />)
    

    import ReactDOM from 'react-dom/client'
    import App from './App'
    
    const rootElement = document.getElementById('root') as HTMLElement
    ReactDOM.createRoot(rootElement).render(<App />)</content>
</page>

<page>
  <title>React TanStack Query Nextjs App Prefetching Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/examples/nextjs-app-prefetching</url>
  <content>    import React from 'react'
    import { HydrationBoundary, dehydrate } from '@tanstack/react-query'
    import { pokemonOptions } from '@/app/pokemon'
    import { getQueryClient } from '@/app/get-query-client'
    import { PokemonInfo } from './pokemon-info'
    
    export default function Home() {
      const queryClient = getQueryClient()
    
      void queryClient.prefetchQuery(pokemonOptions)
    
      return (
        <main>
          <h1>Pokemon Info</h1>
          <HydrationBoundary state={dehydrate(queryClient)}>
            <PokemonInfo />
          </HydrationBoundary>
        </main>
      )
    }
    

    import React from 'react'
    import { HydrationBoundary, dehydrate } from '@tanstack/react-query'
    import { pokemonOptions } from '@/app/pokemon'
    import { getQueryClient } from '@/app/get-query-client'
    import { PokemonInfo } from './pokemon-info'
    
    export default function Home() {
      const queryClient = getQueryClient()
    
      void queryClient.prefetchQuery(pokemonOptions)
    
      return (
        <main>
          <h1>Pokemon Info</h1>
          <HydrationBoundary state={dehydrate(queryClient)}>
            <PokemonInfo />
          </HydrationBoundary>
        </main>
      )
    }</content>
</page>

<page>
  <title>React TanStack Query Prefetching Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/examples/prefetching</url>
  <content>    import React from 'react'
    import { useQuery, useQueryClient } from '@tanstack/react-query'
    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    
    const getCharacters = async (): Promise<{
      results: Array<{ id: number; name: string }>
    }> => {
      await new Promise((r) => setTimeout(r, 500))
      const response = await fetch('https://rickandmortyapi.com/api/character/')
      return await response.json()
    }
    
    const getCharacter = async (selectedChar: number) => {
      await new Promise((r) => setTimeout(r, 500))
      const response = await fetch(
        `https://rickandmortyapi.com/api/character/${selectedChar}`,
      )
      return await response.json()
    }
    
    export default function Example() {
      const queryClient = useQueryClient()
      const rerender = React.useState(0)[1]
      const [selectedChar, setSelectedChar] = React.useState(1)
    
      const charactersQuery = useQuery({
        queryKey: ['characters'],
        queryFn: getCharacters,
      })
    
      const characterQuery = useQuery({
        queryKey: ['character', selectedChar],
        queryFn: () => getCharacter(selectedChar),
      })
    
      return (
        <div className="App">
          <p>
            Hovering over a character will prefetch it, and when it's been
            prefetched it will turn <strong>bold</strong>. Clicking on a prefetched
            character will show their stats below immediately.
          </p>
          <h2>Characters</h2>
          {charactersQuery.isPending ? (
            'Loading...'
          ) : (
            <>
              <ul>
                {charactersQuery.data?.results.map((char) => (
                  <li
                    key={char.id}
                    onClick={() => {
                      setSelectedChar(char.id)
                    }}
                    onMouseEnter={async () => {
                      await queryClient.prefetchQuery({
                        queryKey: ['character', char.id],
                        queryFn: () => getCharacter(char.id),
                        staleTime: 10 * 1000, // only prefetch if older than 10 seconds
                      })
    
                      setTimeout(() => {
                        rerender({})
                      }, 1)
                    }}
                  >
                    <div
                      style={
                        queryClient.getQueryData(['character', char.id])
                          ? {
                              fontWeight: 'bold',
                            }
                          : {}
                      }
                    >
                      {char.id} - {char.name}
                    </div>
                  </li>
                ))}
              </ul>
    
              <h3>Selected Character</h3>
              {characterQuery.isPending ? (
                'Loading...'
              ) : (
                <>
                  <pre>{JSON.stringify(characterQuery.data, null, 2)}</pre>
                </>
              )}
              <ReactQueryDevtools initialIsOpen />
            </>
          )}
        </div>
      )
    }
    

    import React from 'react'
    import { useQuery, useQueryClient } from '@tanstack/react-query'
    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    
    const getCharacters = async (): Promise<{
      results: Array<{ id: number; name: string }>
    }> => {
      await new Promise((r) => setTimeout(r, 500))
      const response = await fetch('https://rickandmortyapi.com/api/character/')
      return await response.json()
    }
    
    const getCharacter = async (selectedChar: number) => {
      await new Promise((r) => setTimeout(r, 500))
      const response = await fetch(
        `https://rickandmortyapi.com/api/character/${selectedChar}`,
      )
      return await response.json()
    }
    
    export default function Example() {
      const queryClient = useQueryClient()
      const rerender = React.useState(0)[1]
      const [selectedChar, setSelectedChar] = React.useState(1)
    
      const charactersQuery = useQuery({
        queryKey: ['characters'],
        queryFn: getCharacters,
      })
    
      const characterQuery = useQuery({
        queryKey: ['character', selectedChar],
        queryFn: () => getCharacter(selectedChar),
      })
    
      return (
        <div className="App">
          <p>
            Hovering over a character will prefetch it, and when it's been
            prefetched it will turn <strong>bold</strong>. Clicking on a prefetched
            character will show their stats below immediately.
          </p>
          <h2>Characters</h2>
          {charactersQuery.isPending ? (
            'Loading...'
          ) : (
            <>
              <ul>
                {charactersQuery.data?.results.map((char) => (
                  <li
                    key={char.id}
                    onClick={() => {
                      setSelectedChar(char.id)
                    }}
                    onMouseEnter={async () => {
                      await queryClient.prefetchQuery({
                        queryKey: ['character', char.id],
                        queryFn: () => getCharacter(char.id),
                        staleTime: 10 * 1000, // only prefetch if older than 10 seconds
                      })
    
                      setTimeout(() => {
                        rerender({})
                      }, 1)
                    }}
                  >
                    <div
                      style={
                        queryClient.getQueryData(['character', char.id])
                          ? {
                              fontWeight: 'bold',
                            }
                          : {}
                      }
                    >
                      {char.id} - {char.name}
                    </div>
                  </li>
                ))}
              </ul>
    
              <h3>Selected Character</h3>
              {characterQuery.isPending ? (
                'Loading...'
              ) : (
                <>
                  <pre>{JSON.stringify(characterQuery.data, null, 2)}</pre>
                </>
              )}
              <ReactQueryDevtools initialIsOpen />
            </>
          )}
        </div>
      )
    }</content>
</page>

<page>
  <title>React TanStack Query Nextjs Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/examples/nextjs</url>
  <content>    import React from 'react'
    import { QueryClient, dehydrate } from '@tanstack/react-query'
    import { Header, InfoBox, Layout, PostList } from '../components'
    import { fetchPosts } from '../hooks/usePosts'
    
    const Home = () => {
      return (
        <Layout>
          <Header />
          <InfoBox>‚ÑπÔ∏è This page shows how to use SSG with React-Query.</InfoBox>
          <PostList />
        </Layout>
      )
    }
    
    export async function getStaticProps() {
      const queryClient = new QueryClient()
    
      await queryClient.prefetchQuery({
        queryKey: ['posts', 10],
        queryFn: () => fetchPosts(10),
      })
    
      return {
        props: {
          dehydratedState: dehydrate(queryClient),
        },
      }
    }
    
    export default Home
    

    import React from 'react'
    import { QueryClient, dehydrate } from '@tanstack/react-query'
    import { Header, InfoBox, Layout, PostList } from '../components'
    import { fetchPosts } from '../hooks/usePosts'
    
    const Home = () => {
      return (
        <Layout>
          <Header />
          <InfoBox>‚ÑπÔ∏è This page shows how to use SSG with React-Query.</InfoBox>
          <PostList />
        </Layout>
      )
    }
    
    export async function getStaticProps() {
      const queryClient = new QueryClient()
    
      await queryClient.prefetchQuery({
        queryKey: ['posts', 10],
        queryFn: () => fetchPosts(10),
      })
    
      return {
        props: {
          dehydratedState: dehydrate(queryClient),
        },
      }
    }
    
    export default Home</content>
</page>

<page>
  <title>React TanStack Query React Router Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/examples/react-router</url>
  <content>    export default function Index() {
      return (
        <p id="zero-state">
          This is a demo for integrating React Router with React Query.
          <br />
          Check out{' '}
          <a href="https://reactrouter.com/">
            the docs at reactrouter.com
          </a> and{' '}
          <a href="https://tanstack.com/query/v5/docs/">the docs at tanstack.com</a>
          .
        </p>
      )
    }
    

    export default function Index() {
      return (
        <p id="zero-state">
          This is a demo for integrating React Router with React Query.
          <br />
          Check out{' '}
          <a href="https://reactrouter.com/">
            the docs at reactrouter.com
          </a> and{' '}
          <a href="https://tanstack.com/query/v5/docs/">the docs at tanstack.com</a>
          .
        </p>
      )
    }</content>
</page>

<page>
  <title>React TanStack Query Rick Morty Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/examples/rick-morty</url>
  <content>tsx

    import ReactDOM from 'react-dom/client'
    import App from './App'
    
    const rootElement = document.getElementById('root') as HTMLElement
    ReactDOM.createRoot(rootElement).render(<App />)
    

    import ReactDOM from 'react-dom/client'
    import App from './App'
    
    const rootElement = document.getElementById('root') as HTMLElement
    ReactDOM.createRoot(rootElement).render(<App />)</content>
</page>

<page>
  <title>React TanStack Query Nextjs Suspense Streaming Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/examples/nextjs-suspense-streaming</url>
  <content>    'use client'
    import { isServer, useSuspenseQuery } from '@tanstack/react-query'
    import { Suspense } from 'react'
    
    export const runtime = 'edge' // 'nodejs' (default) | 'edge'
    
    function getBaseURL() {
      if (!isServer) {
        return ''
      }
      if (process.env.VERCEL_URL) {
        return `https://${process.env.VERCEL_URL}`
      }
      return 'http://localhost:3000'
    }
    const baseUrl = getBaseURL()
    function useWaitQuery(props: { wait: number }) {
      const query = useSuspenseQuery({
        queryKey: ['wait', props.wait],
        queryFn: async () => {
          const path = `/api/wait?wait=${props.wait}`
          const url = baseUrl + path
    
          const res: string = await (
            await fetch(url, {
              cache: 'no-store',
            })
          ).json()
          return res
        },
      })
    
      return [query.data as string, query] as const
    }
    
    function MyComponent(props: { wait: number }) {
      const [data] = useWaitQuery(props)
    
      return <div>result: {data}</div>
    }
    
    export default function MyPage() {
      return (
        <>
          <Suspense fallback={<div>waiting 100....</div>}>
            <MyComponent wait={100} />
          </Suspense>
          <Suspense fallback={<div>waiting 200....</div>}>
            <MyComponent wait={200} />
          </Suspense>
          <Suspense fallback={<div>waiting 300....</div>}>
            <MyComponent wait={300} />
          </Suspense>
          <Suspense fallback={<div>waiting 400....</div>}>
            <MyComponent wait={400} />
          </Suspense>
          <Suspense fallback={<div>waiting 500....</div>}>
            <MyComponent wait={500} />
          </Suspense>
          <Suspense fallback={<div>waiting 600....</div>}>
            <MyComponent wait={600} />
          </Suspense>
          <Suspense fallback={<div>waiting 700....</div>}>
            <MyComponent wait={700} />
          </Suspense>
    
          <fieldset>
            <legend>
              combined <code>Suspense</code>-container
            </legend>
            <Suspense
              fallback={
                <>
                  <div>waiting 800....</div>
                  <div>waiting 900....</div>
                  <div>waiting 1000....</div>
                </>
              }
            >
              <MyComponent wait={800} />
              <MyComponent wait={900} />
              <MyComponent wait={1000} />
            </Suspense>
          </fieldset>
        </>
      )
    }
    

    'use client'
    import { isServer, useSuspenseQuery } from '@tanstack/react-query'
    import { Suspense } from 'react'
    
    export const runtime = 'edge' // 'nodejs' (default) | 'edge'
    
    function getBaseURL() {
      if (!isServer) {
        return ''
      }
      if (process.env.VERCEL_URL) {
        return `https://${process.env.VERCEL_URL}`
      }
      return 'http://localhost:3000'
    }
    const baseUrl = getBaseURL()
    function useWaitQuery(props: { wait: number }) {
      const query = useSuspenseQuery({
        queryKey: ['wait', props.wait],
        queryFn: async () => {
          const path = `/api/wait?wait=${props.wait}`
          const url = baseUrl + path
    
          const res: string = await (
            await fetch(url, {
              cache: 'no-store',
            })
          ).json()
          return res
        },
      })
    
      return [query.data as string, query] as const
    }
    
    function MyComponent(props: { wait: number }) {
      const [data] = useWaitQuery(props)
    
      return <div>result: {data}</div>
    }
    
    export default function MyPage() {
      return (
        <>
          <Suspense fallback={<div>waiting 100....</div>}>
            <MyComponent wait={100} />
          </Suspense>
          <Suspense fallback={<div>waiting 200....</div>}>
            <MyComponent wait={200} />
          </Suspense>
          <Suspense fallback={<div>waiting 300....</div>}>
            <MyComponent wait={300} />
          </Suspense>
          <Suspense fallback={<div>waiting 400....</div>}>
            <MyComponent wait={400} />
          </Suspense>
          <Suspense fallback={<div>waiting 500....</div>}>
            <MyComponent wait={500} />
          </Suspense>
          <Suspense fallback={<div>waiting 600....</div>}>
            <MyComponent wait={600} />
          </Suspense>
          <Suspense fallback={<div>waiting 700....</div>}>
            <MyComponent wait={700} />
          </Suspense>
    
          <fieldset>
            <legend>
              combined <code>Suspense</code>-container
            </legend>
            <Suspense
              fallback={
                <>
                  <div>waiting 800....</div>
                  <div>waiting 900....</div>
                  <div>waiting 1000....</div>
                </>
              }
            >
              <MyComponent wait={800} />
              <MyComponent wait={900} />
              <MyComponent wait={1000} />
            </Suspense>
          </fieldset>
        </>
      )
    }</content>
</page>

<page>
  <title>React TanStack Query React Native Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/examples/react-native</url>
  <content>    import * as React from 'react'
    import { AppStateStatus, Platform } from 'react-native'
    import { NavigationContainer } from '@react-navigation/native'
    import {
      QueryClient,
      QueryClientProvider,
      focusManager,
    } from '@tanstack/react-query'
    
    import { useAppState } from './src/hooks/useAppState'
    import { MoviesStack } from './src/navigation/MoviesStack'
    import { useOnlineManager } from './src/hooks/useOnlineManager'
    
    function onAppStateChange(status: AppStateStatus) {
      // React Query already supports in web browser refetch on window focus by default
      if (Platform.OS !== 'web') {
        focusManager.setFocused(status === 'active')
      }
    }
    
    const queryClient = new QueryClient({
      defaultOptions: { queries: { retry: 2 } },
    })
    
    export default function App() {
      useOnlineManager()
    
      useAppState(onAppStateChange)
    
      return (
        <QueryClientProvider client={queryClient}>
          <NavigationContainer>
            <MoviesStack />
          </NavigationContainer>
        </QueryClientProvider>
      )
    }
    

    import * as React from 'react'
    import { AppStateStatus, Platform } from 'react-native'
    import { NavigationContainer } from '@react-navigation/native'
    import {
      QueryClient,
      QueryClientProvider,
      focusManager,
    } from '@tanstack/react-query'
    
    import { useAppState } from './src/hooks/useAppState'
    import { MoviesStack } from './src/navigation/MoviesStack'
    import { useOnlineManager } from './src/hooks/useOnlineManager'
    
    function onAppStateChange(status: AppStateStatus) {
      // React Query already supports in web browser refetch on window focus by default
      if (Platform.OS !== 'web') {
        focusManager.setFocused(status === 'active')
      }
    }
    
    const queryClient = new QueryClient({
      defaultOptions: { queries: { retry: 2 } },
    })
    
    export default function App() {
      useOnlineManager()
    
      useAppState(onAppStateChange)
    
      return (
        <QueryClientProvider client={queryClient}>
          <NavigationContainer>
            <MoviesStack />
          </NavigationContainer>
        </QueryClientProvider>
      )
    }</content>
</page>

<page>
  <title>React TanStack Query Offline Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/examples/offline</url>
  <content>    import React from 'react'
    import ReactDOM from 'react-dom/client'
    import App from './App'
    import { worker } from './api'
    
    worker.start()
    
    const rootElement = document.getElementById('root') as HTMLElement
    ReactDOM.createRoot(rootElement).render(
      <div style={{ padding: '16px' }}>
        <App />
      </div>,
    )
    

    import React from 'react'
    import ReactDOM from 'react-dom/client'
    import App from './App'
    import { worker } from './api'
    
    worker.start()
    
    const rootElement = document.getElementById('root') as HTMLElement
    ReactDOM.createRoot(rootElement).render(
      <div style={{ padding: '16px' }}>
        <App />
      </div>,
    )</content>
</page>

<page>
  <title>persistQueryClient | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/plugins/persistQueryClient</url>
  <content>This is set of utilities for interacting with "persisters" which save your queryClient for later use. Different **persisters** can be used to store your client and cache to many different storage layers.

[](#build-persisters)[Build Persisters](#build-persisters)
----------------------------------------------------------

*   [createSyncStoragePersister](https://tanstack.com/query/latest/docs/framework/react/plugins/createSyncStoragePersister)
*   [createAsyncStoragePersister](https://tanstack.com/query/latest/docs/framework/react/plugins/createAsyncStoragePersister)
*   [create a custom persister](#persisters)

[](#how-it-works)[How It Works](#how-it-works)
----------------------------------------------

**IMPORTANT** - for persist to work properly, you probably want to pass QueryClient a gcTime value to override the default during hydration (as shown above).

If it is not set when creating the QueryClient instance, it will default to 300000 (5 minutes) for hydration, and the stored cache will be discarded after 5 minutes of inactivity. This is the default garbage collection behavior.

It should be set as the same value or higher than persistQueryClient's maxAge option. E.g. if maxAge is 24 hours (the default) then gcTime should be 24 hours or higher. If lower than maxAge, garbage collection will kick in and discard the stored cache earlier than expected.

You can also pass it Infinity to disable garbage collection behavior entirely.

Due to a JavaScript limitation, the maximum allowed gcTime is about [24 days](https://developer.mozilla.org/en-US/docs/Web/API/setTimeout#maximum_delay_value), although it is possible to work around this limit using [timeoutManager.setTimeoutProvider](https://tanstack.com/query/latest/docs/reference/timeoutManager#timeoutmanagersettimeoutprovider).

    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          gcTime: 1000 * 60 * 60 * 24, // 24 hours
        },
      },
    })
    

    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          gcTime: 1000 * 60 * 60 * 24, // 24 hours
        },
      },
    })
    

### [](#cache-busting)[Cache Busting](#cache-busting)

Sometimes you may make changes to your application or data that immediately invalidate any and all cached data. If and when this happens, you can pass a buster string option. If the cache that is found does not also have that buster string, it will be discarded. The following several functions accept this option:

    persistQueryClient({ queryClient, persister, buster: buildHash })
    persistQueryClientSave({ queryClient, persister, buster: buildHash })
    persistQueryClientRestore({ queryClient, persister, buster: buildHash })
    

    persistQueryClient({ queryClient, persister, buster: buildHash })
    persistQueryClientSave({ queryClient, persister, buster: buildHash })
    persistQueryClientRestore({ queryClient, persister, buster: buildHash })
    

### [](#removal)[Removal](#removal)

If data is found to be any of the following:

1.  expired (see maxAge)
2.  busted (see buster)
3.  error (ex: throws ...)
4.  empty (ex: undefined)

the persister removeClient() is called and the cache is immediately discarded.

[](#api)[API](#api)
-------------------

### [](#persistqueryclientsave)[persistQueryClientSave](#persistqueryclientsave)

*   Your query/mutation are [dehydrated](https://tanstack.com/query/latest/docs/framework/react/reference/hydration#dehydrate) and stored by the persister you provided.
*   createSyncStoragePersister and createAsyncStoragePersister throttle this action to happen at most every 1 second to save on potentially expensive writes. Review their documentation to see how to customize their throttle timing.

You can use this to explicitly persist the cache at the moment(s) you choose.

    persistQueryClientSave({
      queryClient,
      persister,
      buster = '',
      dehydrateOptions = undefined,
    })
    

    persistQueryClientSave({
      queryClient,
      persister,
      buster = '',
      dehydrateOptions = undefined,
    })
    

### [](#persistqueryclientsubscribe)[persistQueryClientSubscribe](#persistqueryclientsubscribe)

Runs persistQueryClientSave whenever the cache changes for your queryClient. For example: you might initiate the subscribe when a user logs-in and checks "Remember me".

*   It returns an unsubscribe function which you can use to discontinue the monitor; ending the updates to the persisted cache.
*   If you want to erase the persisted cache after the unsubscribe, you can send a new buster to persistQueryClientRestore which will trigger the persister's removeClient function and discard the persisted cache.

    persistQueryClientSubscribe({
      queryClient,
      persister,
      buster = '',
      dehydrateOptions = undefined,
    })
    

    persistQueryClientSubscribe({
      queryClient,
      persister,
      buster = '',
      dehydrateOptions = undefined,
    })
    

### [](#persistqueryclientrestore)[persistQueryClientRestore](#persistqueryclientrestore)

*   Attempts to [hydrate](https://tanstack.com/query/latest/docs/framework/react/reference/hydration#hydrate) a previously persisted dehydrated query/mutation cache from the persister back into the query cache of the passed query client.
*   If a cache is found that is older than the maxAge (which by default is 24 hours), it will be discarded. This timing can be customized as you see fit.

You can use this to restore the cache at moment(s) you choose.

    persistQueryClientRestore({
      queryClient,
      persister,
      maxAge = 1000 * 60 * 60 * 24, // 24 hours
      buster = '',
      hydrateOptions = undefined,
    })
    

    persistQueryClientRestore({
      queryClient,
      persister,
      maxAge = 1000 * 60 * 60 * 24, // 24 hours
      buster = '',
      hydrateOptions = undefined,
    })
    

### [](#persistqueryclient)[persistQueryClient](#persistqueryclient)

Takes the following actions:

1.  Immediately restores any persisted cache ([see persistQueryClientRestore](#persistqueryclientrestore))
2.  Subscribes to the query cache and returns the unsubscribe function ([see persistQueryClientSubscribe](#persistqueryclientsubscribe)).

This functionality is preserved from version 3.x.

    persistQueryClient({
      queryClient,
      persister,
      maxAge = 1000 * 60 * 60 * 24, // 24 hours
      buster = '',
      hydrateOptions = undefined,
      dehydrateOptions = undefined,
    })
    

    persistQueryClient({
      queryClient,
      persister,
      maxAge = 1000 * 60 * 60 * 24, // 24 hours
      buster = '',
      hydrateOptions = undefined,
      dehydrateOptions = undefined,
    })
    

### [](#options)[Options](#options)

All options available are as follows:

    interface PersistQueryClientOptions {
      /** The QueryClient to persist */
      queryClient: QueryClient
      /** The Persister interface for storing and restoring the cache
       * to/from a persisted location */
      persister: Persister
      /** The max-allowed age of the cache in milliseconds.
       * If a persisted cache is found that is older than this
       * time, it will be **silently** discarded
       * (defaults to 24 hours) */
      maxAge?: number
      /** A unique string that can be used to forcefully
       * invalidate existing caches if they do not share the same buster string */
      buster?: string
      /** The options passed to the hydrate function
       * Not used on `persistQueryClientSave` or `persistQueryClientSubscribe` */
      hydrateOptions?: HydrateOptions
      /** The options passed to the dehydrate function
       * Not used on `persistQueryClientRestore` */
      dehydrateOptions?: DehydrateOptions
    }
    

    interface PersistQueryClientOptions {
      /** The QueryClient to persist */
      queryClient: QueryClient
      /** The Persister interface for storing and restoring the cache
       * to/from a persisted location */
      persister: Persister
      /** The max-allowed age of the cache in milliseconds.
       * If a persisted cache is found that is older than this
       * time, it will be **silently** discarded
       * (defaults to 24 hours) */
      maxAge?: number
      /** A unique string that can be used to forcefully
       * invalidate existing caches if they do not share the same buster string */
      buster?: string
      /** The options passed to the hydrate function
       * Not used on `persistQueryClientSave` or `persistQueryClientSubscribe` */
      hydrateOptions?: HydrateOptions
      /** The options passed to the dehydrate function
       * Not used on `persistQueryClientRestore` */
      dehydrateOptions?: DehydrateOptions
    }
    

There are actually three interfaces available:

*   PersistedQueryClientSaveOptions is used for persistQueryClientSave and persistQueryClientSubscribe (doesn't use hydrateOptions).
*   PersistedQueryClientRestoreOptions is used for persistQueryClientRestore (doesn't use dehydrateOptions).
*   PersistQueryClientOptions is used for persistQueryClient

[](#usage-with-react)[Usage with React](#usage-with-react)
----------------------------------------------------------

[persistQueryClient](#persistQueryClient) will try to restore the cache and automatically subscribes to further changes, thus syncing your client to the provided storage.

However, restoring is asynchronous, because all persisters are async by nature, which means that if you render your App while you are restoring, you might get into race conditions if a query mounts and fetches at the same time.

Further, if you subscribe to changes outside of the React component lifecycle, you have no way of unsubscribing:

    // üö® never unsubscribes from syncing
    persistQueryClient({
      queryClient,
      persister: localStoragePersister,
    })
    
    // üö® happens at the same time as restoring
    ReactDOM.createRoot(rootElement).render(<App />)
    

    // üö® never unsubscribes from syncing
    persistQueryClient({
      queryClient,
      persister: localStoragePersister,
    })
    
    // üö® happens at the same time as restoring
    ReactDOM.createRoot(rootElement).render(<App />)
    

### [](#persistqueryclientprovider)[PersistQueryClientProvider](#persistqueryclientprovider)

For this use-case, you can use the PersistQueryClientProvider. It will make sure to subscribe / unsubscribe correctly according to the React component lifecycle, and it will also make sure that queries will not start fetching while we are still restoring. Queries will still render though, they will just be put into fetchingState: 'idle' until data has been restored. Then, they will refetch unless the restored data is _fresh_ enough, and _initialData_ will also be respected. It can be used _instead of_ the normal [QueryClientProvider](https://tanstack.com/query/latest/docs/framework/react/reference/QueryClientProvider):

    import { PersistQueryClientProvider } from '@tanstack/react-query-persist-client'
    import { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister'
    
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          gcTime: 1000 * 60 * 60 * 24, // 24 hours
        },
      },
    })
    
    const persister = createAsyncStoragePersister({
      storage: window.localStorage,
    })
    
    ReactDOM.createRoot(rootElement).render(
      <PersistQueryClientProvider
        client={queryClient}
        persistOptions={{ persister }}
      >
        <App />
      </PersistQueryClientProvider>,
    )
    

    import { PersistQueryClientProvider } from '@tanstack/react-query-persist-client'
    import { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister'
    
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          gcTime: 1000 * 60 * 60 * 24, // 24 hours
        },
      },
    })
    
    const persister = createAsyncStoragePersister({
      storage: window.localStorage,
    })
    
    ReactDOM.createRoot(rootElement).render(
      <PersistQueryClientProvider
        client={queryClient}
        persistOptions={{ persister }}
      >
        <App />
      </PersistQueryClientProvider>,
    )
    

#### [](#props)[Props](#props)

PersistQueryClientProvider takes the same props as [QueryClientProvider](https://tanstack.com/query/latest/docs/framework/react/reference/QueryClientProvider), and additionally:

*   persistOptions: PersistQueryClientOptions
    *   all [options](#options) you can pass to [persistQueryClient](#persistqueryclient) minus the QueryClient itself
*   onSuccess?: () => Promise<unknown> | unknown
    *   optional
    *   will be called when the initial restore is finished
    *   can be used to [resumePausedMutations](https://tanstack.com/query/latest/docs/reference/QueryClient#queryclientresumepausedmutations)
    *   if a Promise is returned, it will be awaited; restoring is seen as ongoing until then
*   onError?: () => Promise<unknown> | unknown
    *   optional
    *   will be called when an error is thrown during restoration
    *   if a Promise is returned, it will be awaited

### [](#useisrestoring)[useIsRestoring](#useisrestoring)

If you are using the PersistQueryClientProvider, you can also use the useIsRestoring hook alongside it to check if a restore is currently in progress. useQuery and friends also check this internally to avoid race conditions between the restore and mounting queries.

[](#persisters)[Persisters](#persisters)
----------------------------------------

### [](#persisters-interface)[Persisters Interface](#persisters-interface)

Persisters have the following interfaces:

    export interface Persister {
      persistClient(persistClient: PersistedClient): Promisable<void>
      restoreClient(): Promisable<PersistedClient | undefined>
      removeClient(): Promisable<void>
    }
    

    export interface Persister {
      persistClient(persistClient: PersistedClient): Promisable<void>
      restoreClient(): Promisable<PersistedClient | undefined>
      removeClient(): Promisable<void>
    }
    

Persisted Client entries have the following interface:

    export interface PersistedClient {
      timestamp: number
      buster: string
      clientState: DehydratedState
    }
    

    export interface PersistedClient {
      timestamp: number
      buster: string
      clientState: DehydratedState
    }
    

You can import these (to build a persister):

    import {
      PersistedClient,
      Persister,
    } from '@tanstack/react-query-persist-client'
    

    import {
      PersistedClient,
      Persister,
    } from '@tanstack/react-query-persist-client'
    

### [](#building-a-persister)[Building A Persister](#building-a-persister)

You can persist however you like. Here is an example of how to build an [Indexed DB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API) persister. Compared to Web Storage API, Indexed DB is faster, stores more than 5MB, and doesn't require serialization. That means it can readily store Javascript native types, such as Date and File.

    import { get, set, del } from 'idb-keyval'
    import {
      PersistedClient,
      Persister,
    } from '@tanstack/react-query-persist-client'
    
    /**
     * Creates an Indexed DB persister
     * @see https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API
     */
    export function createIDBPersister(idbValidKey: IDBValidKey = 'reactQuery') {
      return {
        persistClient: async (client: PersistedClient) => {
          await set(idbValidKey, client)
        },
        restoreClient: async () => {
          return await get<PersistedClient>(idbValidKey)
        },
        removeClient: async () => {
          await del(idbValidKey)
        },
      } satisfies Persister
    }
    

    import { get, set, del } from 'idb-keyval'
    import {
      PersistedClient,
      Persister,
    } from '@tanstack/react-query-persist-client'
    
    /**
     * Creates an Indexed DB persister
     * @see https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API
     */
    export function createIDBPersister(idbValidKey: IDBValidKey = 'reactQuery') {
      return {
        persistClient: async (client: PersistedClient) => {
          await set(idbValidKey, client)
        },
        restoreClient: async () => {
          return await get<PersistedClient>(idbValidKey)
        },
        removeClient: async () => {
          await del(idbValidKey)
        },
      } satisfies Persister
    }</content>
</page>

<page>
  <title>createSyncStoragePersister | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/plugins/createSyncStoragePersister</url>
  <content>[](#deprecated)[Deprecated](#deprecated)
----------------------------------------

This plugin is deprecated and will be removed in the next major version. You can simply use ['@tanstack/query-async-storage-persister'](https://tanstack.com/query/latest/docs/framework/react/plugins/createAsyncStoragePersister) instead.

[](#installation)[Installation](#installation)
----------------------------------------------

This utility comes as a separate package and is available under the '@tanstack/query-sync-storage-persister' import.

    npm install @tanstack/query-sync-storage-persister @tanstack/react-query-persist-client
    

    npm install @tanstack/query-sync-storage-persister @tanstack/react-query-persist-client
    

or

    pnpm add @tanstack/query-sync-storage-persister @tanstack/react-query-persist-client
    

    pnpm add @tanstack/query-sync-storage-persister @tanstack/react-query-persist-client
    

or

    yarn add @tanstack/query-sync-storage-persister @tanstack/react-query-persist-client
    

    yarn add @tanstack/query-sync-storage-persister @tanstack/react-query-persist-client
    

or

    bun add @tanstack/query-sync-storage-persister @tanstack/react-query-persist-client
    

    bun add @tanstack/query-sync-storage-persister @tanstack/react-query-persist-client
    

[](#usage)[Usage](#usage)
-------------------------

*   Import the createSyncStoragePersister function
*   Create a new syncStoragePersister
*   Pass it to the [persistQueryClient](https://tanstack.com/query/latest/docs/framework/react/plugins/persistQueryClient) function

    import { persistQueryClient } from '@tanstack/react-query-persist-client'
    import { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister'
    
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          gcTime: 1000 * 60 * 60 * 24, // 24 hours
        },
      },
    })
    
    const localStoragePersister = createSyncStoragePersister({
      storage: window.localStorage,
    })
    // const sessionStoragePersister = createSyncStoragePersister({ storage: window.sessionStorage })
    
    persistQueryClient({
      queryClient,
      persister: localStoragePersister,
    })
    

    import { persistQueryClient } from '@tanstack/react-query-persist-client'
    import { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister'
    
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          gcTime: 1000 * 60 * 60 * 24, // 24 hours
        },
      },
    })
    
    const localStoragePersister = createSyncStoragePersister({
      storage: window.localStorage,
    })
    // const sessionStoragePersister = createSyncStoragePersister({ storage: window.sessionStorage })
    
    persistQueryClient({
      queryClient,
      persister: localStoragePersister,
    })
    

[](#retries)[Retries](#retries)
-------------------------------

Persistence can fail, e.g. if the size exceeds the available space on the storage. Errors can be handled gracefully by providing a retry function to the persister.

The retry function receives the persistedClient it tried to save, as well as the error and the errorCount as input. It is expected to return a _new_ PersistedClient, with which it tries to persist again. If _undefined_ is returned, there will be no further attempt to persist.

    export type PersistRetryer = (props: {
      persistedClient: PersistedClient
      error: Error
      errorCount: number
    }) => PersistedClient | undefined
    

    export type PersistRetryer = (props: {
      persistedClient: PersistedClient
      error: Error
      errorCount: number
    }) => PersistedClient | undefined
    

### [](#predefined-strategies)[Predefined strategies](#predefined-strategies)

Per default, no retry will occur. You can use one of the predefined strategies to handle retries. They can be imported from '@tanstack/react-query-persist-client':

*   removeOldestQuery
    *   will return a new PersistedClient with the oldest query removed.

    const localStoragePersister = createSyncStoragePersister({
      storage: window.localStorage,
      retry: removeOldestQuery,
    })
    

    const localStoragePersister = createSyncStoragePersister({
      storage: window.localStorage,
      retry: removeOldestQuery,
    })
    

[](#api)[API](#api)
-------------------

### [](#createsyncstoragepersister)[createSyncStoragePersister](#createsyncstoragepersister)

Call this function to create a syncStoragePersister that you can use later with persistQueryClient.

    createSyncStoragePersister(options: CreateSyncStoragePersisterOptions)
    

    createSyncStoragePersister(options: CreateSyncStoragePersisterOptions)
    

### [](#options)[Options](#options)

    interface CreateSyncStoragePersisterOptions {
      /** The storage client used for setting an retrieving items from cache (window.localStorage or window.sessionStorage) */
      storage: Storage | undefined | null
      /** The key to use when storing the cache */
      key?: string
      /** To avoid spamming,
       * pass a time in ms to throttle saving the cache to disk */
      throttleTime?: number
      /** How to serialize the data to storage */
      serialize?: (client: PersistedClient) => string
      /** How to deserialize the data from storage */
      deserialize?: (cachedString: string) => PersistedClient
      /** How to retry persistence on error **/
      retry?: PersistRetryer
    }
    

    interface CreateSyncStoragePersisterOptions {
      /** The storage client used for setting an retrieving items from cache (window.localStorage or window.sessionStorage) */
      storage: Storage | undefined | null
      /** The key to use when storing the cache */
      key?: string
      /** To avoid spamming,
       * pass a time in ms to throttle saving the cache to disk */
      throttleTime?: number
      /** How to serialize the data to storage */
      serialize?: (client: PersistedClient) => string
      /** How to deserialize the data from storage */
      deserialize?: (cachedString: string) => PersistedClient
      /** How to retry persistence on error **/
      retry?: PersistRetryer
    }
    

The default options are:

    {
      key = `REACT_QUERY_OFFLINE_CACHE`,
      throttleTime = 1000,
      serialize = JSON.stringify,
      deserialize = JSON.parse,
    }
    

    {
      key = `REACT_QUERY_OFFLINE_CACHE`,
      throttleTime = 1000,
      serialize = JSON.stringify,
      deserialize = JSON.parse,
    }
    

#### [](#serialize-and-deserialize-options)[serialize and deserialize options](#serialize-and-deserialize-options)

There is a limit to the amount of data which can be stored in localStorage. If you need to store more data in localStorage, you can override the serialize and deserialize functions to compress and decompress the data using a library like [lz-string](https://github.com/pieroxy/lz-string/).

    import { QueryClient } from '@tanstack/react-query'
    import { persistQueryClient } from '@tanstack/react-query-persist-client'
    import { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister'
    
    import { compress, decompress } from 'lz-string'
    
    const queryClient = new QueryClient({
      defaultOptions: { queries: { staleTime: Infinity } },
    })
    
    persistQueryClient({
      queryClient: queryClient,
      persister: createSyncStoragePersister({
        storage: window.localStorage,
        serialize: (data) => compress(JSON.stringify(data)),
        deserialize: (data) => JSON.parse(decompress(data)),
      }),
      maxAge: Infinity,
    })
    

    import { QueryClient } from '@tanstack/react-query'
    import { persistQueryClient } from '@tanstack/react-query-persist-client'
    import { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister'
    
    import { compress, decompress } from 'lz-string'
    
    const queryClient = new QueryClient({
      defaultOptions: { queries: { staleTime: Infinity } },
    })
    
    persistQueryClient({
      queryClient: queryClient,
      persister: createSyncStoragePersister({
        storage: window.localStorage,
        serialize: (data) => compress(JSON.stringify(data)),
        deserialize: (data) => JSON.parse(decompress(data)),
      }),
      maxAge: Infinity,
    })</content>
</page>

<page>
  <title>React TanStack Query Algolia Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/examples/algolia</url>
  <content>tsx

    import ReactDOM from 'react-dom/client'
    
    import App from './App'
    
    const rootElement = document.getElementById('root') as HTMLElement
    ReactDOM.createRoot(rootElement).render(<App />)
    

    import ReactDOM from 'react-dom/client'
    
    import App from './App'
    
    const rootElement = document.getElementById('root') as HTMLElement
    ReactDOM.createRoot(rootElement).render(<App />)</content>
</page>

<page>
  <title>React TanStack Query Devtools Panel Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/examples/devtools-panel</url>
  <content>    import React from 'react'
    import ReactDOM from 'react-dom/client'
    import {
      QueryClient,
      QueryClientProvider,
      useQuery,
    } from '@tanstack/react-query'
    import { ReactQueryDevtoolsPanel } from '@tanstack/react-query-devtools'
    
    const queryClient = new QueryClient()
    
    export default function App() {
      const [isOpen, setIsOpen] = React.useState(false)
    
      return (
        <QueryClientProvider client={queryClient}>
          <Example />
          <button
            onClick={() => setIsOpen(!isOpen)}
          >{`${isOpen ? 'Close' : 'Open'} the devtools panel`}</button>
          {isOpen && <ReactQueryDevtoolsPanel onClose={() => setIsOpen(false)} />}
        </QueryClientProvider>
      )
    }
    
    function Example() {
      const { isPending, error, data, isFetching } = useQuery({
        queryKey: ['repoData'],
        queryFn: async () => {
          const response = await fetch(
            'https://api.github.com/repos/TanStack/query',
          )
          return await response.json()
        },
      })
    
      if (isPending) return 'Loading...'
    
      if (error) return 'An error has occurred: ' + error.message
    
      return (
        <div
          style={{
            paddingBottom: 20,
          }}
        >
          <h1>{data.full_name}</h1>
          <p>{data.description}</p>
          <strong>üëÄ {data.subscribers_count}</strong>{' '}
          <strong>‚ú® {data.stargazers_count}</strong>{' '}
          <strong>üç¥ {data.forks_count}</strong>
          <div>{isFetching ? 'Updating...' : ''}</div>
        </div>
      )
    }
    
    const rootElement = document.getElementById('root') as HTMLElement
    ReactDOM.createRoot(rootElement).render(<App />)
    

    import React from 'react'
    import ReactDOM from 'react-dom/client'
    import {
      QueryClient,
      QueryClientProvider,
      useQuery,
    } from '@tanstack/react-query'
    import { ReactQueryDevtoolsPanel } from '@tanstack/react-query-devtools'
    
    const queryClient = new QueryClient()
    
    export default function App() {
      const [isOpen, setIsOpen] = React.useState(false)
    
      return (
        <QueryClientProvider client={queryClient}>
          <Example />
          <button
            onClick={() => setIsOpen(!isOpen)}
          >{`${isOpen ? 'Close' : 'Open'} the devtools panel`}</button>
          {isOpen && <ReactQueryDevtoolsPanel onClose={() => setIsOpen(false)} />}
        </QueryClientProvider>
      )
    }
    
    function Example() {
      const { isPending, error, data, isFetching } = useQuery({
        queryKey: ['repoData'],
        queryFn: async () => {
          const response = await fetch(
            'https://api.github.com/repos/TanStack/query',
          )
          return await response.json()
        },
      })
    
      if (isPending) return 'Loading...'
    
      if (error) return 'An error has occurred: ' + error.message
    
      return (
        <div
          style={{
            paddingBottom: 20,
          }}
        >
          <h1>{data.full_name}</h1>
          <p>{data.description}</p>
          <strong>üëÄ {data.subscribers_count}</strong>{' '}
          <strong>‚ú® {data.stargazers_count}</strong>{' '}
          <strong>üç¥ {data.forks_count}</strong>
          <div>{isFetching ? 'Updating...' : ''}</div>
        </div>
      )
    }
    
    const rootElement = document.getElementById('root') as HTMLElement
    ReactDOM.createRoot(rootElement).render(<App />)</content>
</page>

<page>
  <title>createAsyncStoragePersister | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/plugins/createAsyncStoragePersister</url>
  <content>[](#installation)[Installation](#installation)
----------------------------------------------

This utility comes as a separate package and is available under the '@tanstack/query-async-storage-persister' import.

    npm install @tanstack/query-async-storage-persister @tanstack/react-query-persist-client
    

    npm install @tanstack/query-async-storage-persister @tanstack/react-query-persist-client
    

or

    pnpm add @tanstack/query-async-storage-persister @tanstack/react-query-persist-client
    

    pnpm add @tanstack/query-async-storage-persister @tanstack/react-query-persist-client
    

or

    yarn add @tanstack/query-async-storage-persister @tanstack/react-query-persist-client
    

    yarn add @tanstack/query-async-storage-persister @tanstack/react-query-persist-client
    

or

    bun add @tanstack/query-async-storage-persister @tanstack/react-query-persist-client
    

    bun add @tanstack/query-async-storage-persister @tanstack/react-query-persist-client
    

[](#usage)[Usage](#usage)
-------------------------

*   Import the createAsyncStoragePersister function
*   Create a new asyncStoragePersister
    *   you can pass any storage to it that adheres to the AsyncStorage interface - the example below uses the async-storage from React Native.
    *   storages that read and write synchronously, like window.localstorage, also adhere to the AsyncStorage interface and can therefore also be used with createAsyncStoragePersister.
*   Wrap your app by using [PersistQueryClientProvider](https://tanstack.com/query/latest/docs/framework/react/plugins/persistQueryClient#persistqueryclientprovider) component.

    import AsyncStorage from '@react-native-async-storage/async-storage'
    import { QueryClient } from '@tanstack/react-query'
    import { PersistQueryClientProvider } from '@tanstack/react-query-persist-client'
    import { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister'
    
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          gcTime: 1000 * 60 * 60 * 24, // 24 hours
        },
      },
    })
    
    const asyncStoragePersister = createAsyncStoragePersister({
      storage: AsyncStorage,
    })
    
    const Root = () => (
      <PersistQueryClientProvider
        client={queryClient}
        persistOptions={{ persister: asyncStoragePersister }}
      >
        <App />
      </PersistQueryClientProvider>
    )
    
    export default Root
    

    import AsyncStorage from '@react-native-async-storage/async-storage'
    import { QueryClient } from '@tanstack/react-query'
    import { PersistQueryClientProvider } from '@tanstack/react-query-persist-client'
    import { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister'
    
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          gcTime: 1000 * 60 * 60 * 24, // 24 hours
        },
      },
    })
    
    const asyncStoragePersister = createAsyncStoragePersister({
      storage: AsyncStorage,
    })
    
    const Root = () => (
      <PersistQueryClientProvider
        client={queryClient}
        persistOptions={{ persister: asyncStoragePersister }}
      >
        <App />
      </PersistQueryClientProvider>
    )
    
    export default Root
    

[](#retries)[Retries](#retries)
-------------------------------

Retries work the same as for a [SyncStoragePersister](https://tanstack.com/query/latest/docs/framework/react/plugins/createSyncStoragePersister), except that they can also be asynchronous. You can also use all the predefined retry handlers.

[](#api)[API](#api)
-------------------

### [](#createasyncstoragepersister)[createAsyncStoragePersister](#createasyncstoragepersister)

Call this function to create an asyncStoragePersister that you can use later with persistQueryClient.

    createAsyncStoragePersister(options: CreateAsyncStoragePersisterOptions)
    

    createAsyncStoragePersister(options: CreateAsyncStoragePersisterOptions)
    

### [](#options)[Options](#options)

    interface CreateAsyncStoragePersisterOptions {
      /** The storage client used for setting an retrieving items from cache */
      storage: AsyncStorage | undefined | null
      /** The key to use when storing the cache to localStorage */
      key?: string
      /** To avoid localStorage spamming,
       * pass a time in ms to throttle saving the cache to disk */
      throttleTime?: number
      /** How to serialize the data to storage */
      serialize?: (client: PersistedClient) => string
      /** How to deserialize the data from storage */
      deserialize?: (cachedString: string) => PersistedClient
      /** How to retry persistence on error **/
      retry?: AsyncPersistRetryer
    }
    
    interface AsyncStorage<TStorageValue = string> {
      getItem: (key: string) => MaybePromise<TStorageValue | undefined | null>
      setItem: (key: string, value: TStorageValue) => MaybePromise<unknown>
      removeItem: (key: string) => MaybePromise<void>
      entries?: () => MaybePromise<Array<[key: string, value: TStorageValue]>>
    }
    

    interface CreateAsyncStoragePersisterOptions {
      /** The storage client used for setting an retrieving items from cache */
      storage: AsyncStorage | undefined | null
      /** The key to use when storing the cache to localStorage */
      key?: string
      /** To avoid localStorage spamming,
       * pass a time in ms to throttle saving the cache to disk */
      throttleTime?: number
      /** How to serialize the data to storage */
      serialize?: (client: PersistedClient) => string
      /** How to deserialize the data from storage */
      deserialize?: (cachedString: string) => PersistedClient
      /** How to retry persistence on error **/
      retry?: AsyncPersistRetryer
    }
    
    interface AsyncStorage<TStorageValue = string> {
      getItem: (key: string) => MaybePromise<TStorageValue | undefined | null>
      setItem: (key: string, value: TStorageValue) => MaybePromise<unknown>
      removeItem: (key: string) => MaybePromise<void>
      entries?: () => MaybePromise<Array<[key: string, value: TStorageValue]>>
    }
    

The default options are:

    {
      key = `REACT_QUERY_OFFLINE_CACHE`,
      throttleTime = 1000,
      serialize = JSON.stringify,
      deserialize = JSON.parse,
    }
    

    {
      key = `REACT_QUERY_OFFLINE_CACHE`,
      throttleTime = 1000,
      serialize = JSON.stringify,
      deserialize = JSON.parse,
    }</content>
</page>

<page>
  <title>broadcastQueryClient (Experimental) | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/plugins/broadcastQueryClient</url>
  <content>> VERY IMPORTANT: This utility is currently in an experimental stage. This means that breaking changes will happen in minor AND patch releases. Use at your own risk. If you choose to rely on this in production in an experimental stage, please lock your version to a patch-level version to avoid unexpected breakages.

broadcastQueryClient is a utility for broadcasting and syncing the state of your queryClient between browser tabs/windows with the same origin.

[](#installation)[Installation](#installation)
----------------------------------------------

This utility comes as a separate package and is available under the '@tanstack/query-broadcast-client-experimental' import.

[](#usage)[Usage](#usage)
-------------------------

Import the broadcastQueryClient function, and pass it your QueryClient instance, and optionally, set a broadcastChannel.

    import { broadcastQueryClient } from '@tanstack/query-broadcast-client-experimental'
    
    const queryClient = new QueryClient()
    
    broadcastQueryClient({
      queryClient,
      broadcastChannel: 'my-app',
    })
    

    import { broadcastQueryClient } from '@tanstack/query-broadcast-client-experimental'
    
    const queryClient = new QueryClient()
    
    broadcastQueryClient({
      queryClient,
      broadcastChannel: 'my-app',
    })
    

[](#api)[API](#api)
-------------------

### [](#broadcastqueryclient)[broadcastQueryClient](#broadcastqueryclient)

Pass this function a QueryClient instance and optionally, a broadcastChannel.

    broadcastQueryClient({ queryClient, broadcastChannel })
    

    broadcastQueryClient({ queryClient, broadcastChannel })
    

### [](#options)[Options](#options)

An object of options:

    interface BroadcastQueryClientOptions {
      /** The QueryClient to sync */
      queryClient: QueryClient
      /** This is the unique channel name that will be used
       * to communicate between tabs and windows */
      broadcastChannel?: string
      /** Options for the BroadcastChannel API */
      options?: BroadcastChannelOptions
    }
    

    interface BroadcastQueryClientOptions {
      /** The QueryClient to sync */
      queryClient: QueryClient
      /** This is the unique channel name that will be used
       * to communicate between tabs and windows */
      broadcastChannel?: string
      /** Options for the BroadcastChannel API */
      options?: BroadcastChannelOptions
    }
    

The default options are:

    {
      broadcastChannel = 'tanstack-query',
    }
    

    {
      broadcastChannel = 'tanstack-query',
    }</content>
</page>

<page>
  <title>React TanStack Query Chat Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/examples/chat</url>
  <content>    import ReactDOM from 'react-dom/client'
    import {
      QueryClient,
      QueryClientProvider,
      useQuery,
    } from '@tanstack/react-query'
    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    
    import './style.css'
    import { useState } from 'react'
    import { chatQueryOptions } from './chat'
    import { Message } from './message'
    
    const queryClient = new QueryClient()
    
    export default function App() {
      return (
        <QueryClientProvider client={queryClient}>
          <ReactQueryDevtools />
          <Example />
        </QueryClientProvider>
      )
    }
    
    function ChatMessage({ question }: { question: string }) {
      const { error, data = [], isFetching } = useQuery(chatQueryOptions(question))
    
      if (error) return 'An error has occurred: ' + error.message
    
      return (
        <div>
          <Message message={{ content: question, isQuestion: true }} />
          <Message
            inProgress={isFetching}
            message={{ content: data.join(' '), isQuestion: false }}
          />
        </div>
      )
    }
    
    function Example() {
      const [questions, setQuestions] = useState<Array<string>>([])
      const [currentQuestion, setCurrentQuestion] = useState('')
    
      const submitMessage = () => {
        setQuestions([...questions, currentQuestion])
        setCurrentQuestion('')
      }
    
      return (
        <div className="flex flex-col h-screen max-w-3xl mx-auto p-4">
          <h1 className="text-3xl font-bold text-gray-800">
            TanStack Chat Example
          </h1>
          <div className="overflow-y-auto mb-4 space-y-4">
            {questions.map((question) => (
              <ChatMessage key={question} question={question} />
            ))}
          </div>
    
          <div className="flex items-center space-x-2">
            <input
              className="flex-1 p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-100"
              value={currentQuestion}
              onChange={(e) => setCurrentQuestion(e.target.value)}
              onKeyDown={(e) => {
                if (e.key === 'Enter') {
                  submitMessage()
                }
              }}
              placeholder="Type your message..."
            />
            <button
              onClick={submitMessage}
              disabled={!currentQuestion.trim()}
              className="flex items-center gap-2 bg-blue-600 hover:bg-blue-700 text-white font-semibold px-4 py-2 rounded-2xl shadow-md transition"
            >
              <span>Send</span>
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <path d="M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z" />
                <path d="m21.854 2.147-10.94 10.939" />
              </svg>
            </button>
          </div>
        </div>
      )
    }
    
    const rootElement = document.getElementById('root') as HTMLElement
    ReactDOM.createRoot(rootElement).render(<App />)
    

    import ReactDOM from 'react-dom/client'
    import {
      QueryClient,
      QueryClientProvider,
      useQuery,
    } from '@tanstack/react-query'
    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    
    import './style.css'
    import { useState } from 'react'
    import { chatQueryOptions } from './chat'
    import { Message } from './message'
    
    const queryClient = new QueryClient()
    
    export default function App() {
      return (
        <QueryClientProvider client={queryClient}>
          <ReactQueryDevtools />
          <Example />
        </QueryClientProvider>
      )
    }
    
    function ChatMessage({ question }: { question: string }) {
      const { error, data = [], isFetching } = useQuery(chatQueryOptions(question))
    
      if (error) return 'An error has occurred: ' + error.message
    
      return (
        <div>
          <Message message={{ content: question, isQuestion: true }} />
          <Message
            inProgress={isFetching}
            message={{ content: data.join(' '), isQuestion: false }}
          />
        </div>
      )
    }
    
    function Example() {
      const [questions, setQuestions] = useState<Array<string>>([])
      const [currentQuestion, setCurrentQuestion] = useState('')
    
      const submitMessage = () => {
        setQuestions([...questions, currentQuestion])
        setCurrentQuestion('')
      }
    
      return (
        <div className="flex flex-col h-screen max-w-3xl mx-auto p-4">
          <h1 className="text-3xl font-bold text-gray-800">
            TanStack Chat Example
          </h1>
          <div className="overflow-y-auto mb-4 space-y-4">
            {questions.map((question) => (
              <ChatMessage key={question} question={question} />
            ))}
          </div>
    
          <div className="flex items-center space-x-2">
            <input
              className="flex-1 p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-100"
              value={currentQuestion}
              onChange={(e) => setCurrentQuestion(e.target.value)}
              onKeyDown={(e) => {
                if (e.key === 'Enter') {
                  submitMessage()
                }
              }}
              placeholder="Type your message..."
            />
            <button
              onClick={submitMessage}
              disabled={!currentQuestion.trim()}
              className="flex items-center gap-2 bg-blue-600 hover:bg-blue-700 text-white font-semibold px-4 py-2 rounded-2xl shadow-md transition"
            >
              <span>Send</span>
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <path d="M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z" />
                <path d="m21.854 2.147-10.94 10.939" />
              </svg>
            </button>
          </div>
        </div>
      )
    }
    
    const rootElement = document.getElementById('root') as HTMLElement
    ReactDOM.createRoot(rootElement).render(<App />)</content>
</page>

<page>
  <title>React TanStack Query Shadow Dom Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/examples/shadow-dom</url>
  <content>    import React from 'react'
    import ReactDOM from 'react-dom/client'
    import './index.css'
    import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    import { DogList } from './DogList'
    
    const appRoot = document.getElementById('root')
    
    if (appRoot) {
      const queryClient = new QueryClient()
      const shadowRoot = appRoot.attachShadow({ mode: 'open' })
      const root = ReactDOM.createRoot(shadowRoot)
    
      root.render(
        <React.StrictMode>
          <QueryClientProvider client={queryClient}>
            <div
              style={{
                width: '100vw',
                padding: '30px',
              }}
            >
              <h2>Dog Breeds</h2>
              <DogList />
            </div>
            <ReactQueryDevtools
              initialIsOpen={false}
              buttonPosition="bottom-left"
              shadowDOMTarget={appRoot.shadowRoot!}
            />
          </QueryClientProvider>
        </React.StrictMode>,
      )
    }
    

    import React from 'react'
    import ReactDOM from 'react-dom/client'
    import './index.css'
    import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
    import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
    import { DogList } from './DogList'
    
    const appRoot = document.getElementById('root')
    
    if (appRoot) {
      const queryClient = new QueryClient()
      const shadowRoot = appRoot.attachShadow({ mode: 'open' })
      const root = ReactDOM.createRoot(shadowRoot)
    
      root.render(
        <React.StrictMode>
          <QueryClientProvider client={queryClient}>
            <div
              style={{
                width: '100vw',
                padding: '30px',
              }}
            >
              <h2>Dog Breeds</h2>
              <DogList />
            </div>
            <ReactQueryDevtools
              initialIsOpen={false}
              buttonPosition="bottom-left"
              shadowDOMTarget={appRoot.shadowRoot!}
            />
          </QueryClientProvider>
        </React.StrictMode>,
      )
    }</content>
</page>

<page>
  <title>experimental_createQueryPersister | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react/plugins/createPersister</url>
  <content>[](#installation)[Installation](#installation)
----------------------------------------------

This utility comes as a separate package and is available under the '@tanstack/query-persist-client-core' import.

    npm install @tanstack/query-persist-client-core
    

    npm install @tanstack/query-persist-client-core
    

or

    pnpm add @tanstack/query-persist-client-core
    

    pnpm add @tanstack/query-persist-client-core
    

or

    yarn add @tanstack/query-persist-client-core
    

    yarn add @tanstack/query-persist-client-core
    

or

    bun add @tanstack/query-persist-client-core
    

    bun add @tanstack/query-persist-client-core
    

> Note: This util is also included in the @tanstack/react-query-persist-client package, so you do not need to install it separately if you are using that package.

[](#usage)[Usage](#usage)
-------------------------

*   Import the experimental\_createQueryPersister function
*   Create a new experimental\_createQueryPersister
    *   you can pass any storage to it that adheres to the AsyncStorage interface - the example below uses the async-storage from React Native.
*   Pass that persister as an option to your Query. This can be done either by passing it to the defaultOptions of the QueryClient or to any useQuery hook instance.
    *   If you pass this persister as defaultOptions, all queries will be persisted to the provided storage. You can additionally narrow this down by passing filters. In contrast to the persistClient plugin, this will not persist the whole query client as a single item, but each query separately. As a key, the query hash is used.
    *   If you provide this persister to a single useQuery hook, only this Query will be persisted.
*   Note: queryClient.setQueryData() operations are not persisted, this means that if you perform an optimistic update and refresh the page before the query has been invalidated, your changes to the query data will be lost. See [https://github.com/TanStack/query/issues/6310](https://github.com/TanStack/query/issues/6310)

This way, you do not need to store whole QueryClient, but choose what is worth to be persisted in your application. Each query is lazily restored (when the Query is first used) and persisted (after each run of the queryFn), so it does not need to be throttled. staleTime is also respected after restoring the Query, so if data is considered stale, it will be refetched immediately after restoring. If data is fresh, the queryFn will not run.

Garbage collecting a Query from memory **does not** affect the persisted data. That means Queries can be kept in memory for a shorter period of time to be more **memory efficient**. If they are used the next time, they will just be restored from the persistent storage again.

    import AsyncStorage from '@react-native-async-storage/async-storage'
    import { QueryClient } from '@tanstack/react-query'
    import { experimental_createQueryPersister } from '@tanstack/query-persist-client-core'
    
    const persister = experimental_createQueryPersister({
      storage: AsyncStorage,
      maxAge: 1000 * 60 * 60 * 12, // 12 hours
    })
    
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          gcTime: 1000 * 30, // 30 seconds
          persister: persister.persisterFn,
        },
      },
    })
    

    import AsyncStorage from '@react-native-async-storage/async-storage'
    import { QueryClient } from '@tanstack/react-query'
    import { experimental_createQueryPersister } from '@tanstack/query-persist-client-core'
    
    const persister = experimental_createQueryPersister({
      storage: AsyncStorage,
      maxAge: 1000 * 60 * 60 * 12, // 12 hours
    })
    
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          gcTime: 1000 * 30, // 30 seconds
          persister: persister.persisterFn,
        },
      },
    })
    

### [](#adapted-defaults)[Adapted defaults](#adapted-defaults)

The createPersister plugin technically wraps the queryFn, so it doesn't restore if the queryFn doesn't run. In that way, it acts as a caching layer between the Query and the network. Thus, the networkMode defaults to 'offlineFirst' when a persister is used, so that restoring from the persistent storage can also happen even if there is no network connection.

[](#additional-utilities)[Additional utilities](#additional-utilities)
----------------------------------------------------------------------

Invoking experimental\_createQueryPersister returns additional utilities in addition to persisterFn for easier implementation of userland functionalities.

### [](#persistquerybykeyquerykey-querykey-queryclient-queryclient-promisevoid)[persistQueryByKey(queryKey: QueryKey, queryClient: QueryClient): Promise<void>](#persistquerybykeyquerykey-querykey-queryclient-queryclient-promisevoid)

This function will persist Query to storage and key defined when creating persister.  
This utility might be used along setQueryData to persist optimistic update to storage without waiting for invalidation.

    const persister = experimental_createQueryPersister({
      storage: AsyncStorage,
      maxAge: 1000 * 60 * 60 * 12, // 12 hours
    })
    
    const queryClient = useQueryClient()
    
    useMutation({
      mutationFn: updateTodo,
      onMutate: async (newTodo) => {
        ...
        // Optimistically update to the new value
        queryClient.setQueryData(['todos'], (old) => [...old, newTodo])
        // And persist it to storage
        persister.persistQueryByKey(['todos'], queryClient)
        ...
      },
    })
    

    const persister = experimental_createQueryPersister({
      storage: AsyncStorage,
      maxAge: 1000 * 60 * 60 * 12, // 12 hours
    })
    
    const queryClient = useQueryClient()
    
    useMutation({
      mutationFn: updateTodo,
      onMutate: async (newTodo) => {
        ...
        // Optimistically update to the new value
        queryClient.setQueryData(['todos'], (old) => [...old, newTodo])
        // And persist it to storage
        persister.persistQueryByKey(['todos'], queryClient)
        ...
      },
    })
    

### [](#retrievequerytqueryhash-string-promiset--undefined)[retrieveQuery<T>(queryHash: string): Promise<T | undefined>](#retrievequerytqueryhash-string-promiset--undefined)

This function would attempt to retrieve persisted query by queryHash.  
If query is expired, busted or malformed it would be removed from the storage instead, and undefined would be returned.

### [](#persistergc-promisevoid)[persisterGc(): Promise<void>](#persistergc-promisevoid)

This function can be used to sporadically clean up stoage from expired, busted or malformed entries.

For this function to work, your storage must expose entries method that would return a key-value tuple array.  
For example Object.entries(localStorage) for localStorage or entries from idb-keyval.

### [](#restorequeriesqueryclient-queryclient-filters-promisevoid)[restoreQueries(queryClient: QueryClient, filters): Promise<void>](#restorequeriesqueryclient-queryclient-filters-promisevoid)

This function can be used to restore queries that are currently stored by persister.  
For example when your app is starting up in offline mode, or you want all or only specific data from previous session to be immediately available without intermediate loading state.

The filter object supports the following properties:

*   queryKey?: QueryKey
    *   Set this property to define a query key to match on.
*   exact?: boolean
    *   If you don't want to search queries inclusively by query key, you can pass the exact: true option to return only the query with the exact query key you have passed.

For this function to work, your storage must expose entries method that would return a key-value tuple array.  
For example Object.entries(localStorage) for localStorage or entries from idb-keyval.

[](#api)[API](#api)
-------------------

### [](#experimental_createquerypersister)[experimental\_createQueryPersister](#experimental_createquerypersister)

    experimental_createQueryPersister(options: StoragePersisterOptions)
    

    experimental_createQueryPersister(options: StoragePersisterOptions)
    

#### [](#options)[Options](#options)

    export interface StoragePersisterOptions {
      /** The storage client used for setting and retrieving items from cache.
       * For SSR pass in `undefined`.
       */
      storage: AsyncStorage | Storage | undefined | null
      /**
       * How to serialize the data to storage.
       * @default `JSON.stringify`
       */
      serialize?: (persistedQuery: PersistedQuery) => string
      /**
       * How to deserialize the data from storage.
       * @default `JSON.parse`
       */
      deserialize?: (cachedString: string) => PersistedQuery
      /**
       * A unique string that can be used to forcefully invalidate existing caches,
       * if they do not share the same buster string
       */
      buster?: string
      /**
       * The max-allowed age of the cache in milliseconds.
       * If a persisted cache is found that is older than this
       * time, it will be discarded
       * @default 24 hours
       */
      maxAge?: number
      /**
       * Prefix to be used for storage key.
       * Storage key is a combination of prefix and query hash in a form of `prefix-queryHash`.
       */
      prefix?: string
      /**
       * If set to `true`, the query will refetch on successful query restoration if the data is stale.
       * If set to `false`, the query will not refetch on successful query restoration.
       * If set to `'always'`, the query will always refetch on successful query restoration.
       * Defaults to `true`.
       */
      refetchOnRestore?: boolean | 'always'
      /**
       * Filters to narrow down which Queries should be persisted.
       */
      filters?: QueryFilters
    }
    
    interface AsyncStorage<TStorageValue = string> {
      getItem: (key: string) => MaybePromise<TStorageValue | undefined | null>
      setItem: (key: string, value: TStorageValue) => MaybePromise<unknown>
      removeItem: (key: string) => MaybePromise<void>
      entries?: () => MaybePromise<Array<[key: string, value: TStorageValue]>>
    }
    

    export interface StoragePersisterOptions {
      /** The storage client used for setting and retrieving items from cache.
       * For SSR pass in `undefined`.
       */
      storage: AsyncStorage | Storage | undefined | null
      /**
       * How to serialize the data to storage.
       * @default `JSON.stringify`
       */
      serialize?: (persistedQuery: PersistedQuery) => string
      /**
       * How to deserialize the data from storage.
       * @default `JSON.parse`
       */
      deserialize?: (cachedString: string) => PersistedQuery
      /**
       * A unique string that can be used to forcefully invalidate existing caches,
       * if they do not share the same buster string
       */
      buster?: string
      /**
       * The max-allowed age of the cache in milliseconds.
       * If a persisted cache is found that is older than this
       * time, it will be discarded
       * @default 24 hours
       */
      maxAge?: number
      /**
       * Prefix to be used for storage key.
       * Storage key is a combination of prefix and query hash in a form of `prefix-queryHash`.
       */
      prefix?: string
      /**
       * If set to `true`, the query will refetch on successful query restoration if the data is stale.
       * If set to `false`, the query will not refetch on successful query restoration.
       * If set to `'always'`, the query will always refetch on successful query restoration.
       * Defaults to `true`.
       */
      refetchOnRestore?: boolean | 'always'
      /**
       * Filters to narrow down which Queries should be persisted.
       */
      filters?: QueryFilters
    }
    
    interface AsyncStorage<TStorageValue = string> {
      getItem: (key: string) => MaybePromise<TStorageValue | undefined | null>
      setItem: (key: string, value: TStorageValue) => MaybePromise<unknown>
      removeItem: (key: string) => MaybePromise<void>
      entries?: () => MaybePromise<Array<[key: string, value: TStorageValue]>>
    }
    

The default options are:

    {
      prefix = 'tanstack-query',
      maxAge = 1000 * 60 * 60 * 24,
      serialize = JSON.stringify,
      deserialize = JSON.parse,
      refetchOnRestore = true,
    }
    

    {
      prefix = 'tanstack-query',
      maxAge = 1000 * 60 * 60 * 24,
      serialize = JSON.stringify,
      deserialize = JSON.parse,
      refetchOnRestore = true,
    }</content>
</page>

<page>
  <title>React | TanStack Query React Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/react</url>
  <content>Guides & Concepts

*   [](https://tanstack.com/query/latest/docs/framework/react/guides/important-defaults)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/queries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-keys)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-functions)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-options)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/network-mode)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/parallel-queries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/disabling-queries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-retries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/paginated-queries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/infinite-queries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/placeholder-query-data)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/mutations)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/invalidations-from-mutations)
*   [
    
    Updates from Mutation Responses
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/updates-from-mutation-responses)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/optimistic-updates)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-cancellation)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/scroll-restoration)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/filters)
*   [
    
    Performance & Request Waterfalls
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/request-waterfalls)
*   [
    
    Prefetching & Router Integration
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/prefetching)
*   [
    
    Server Rendering & Hydration
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/ssr)
*   [
    
    Advanced Server Rendering
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/advanced-ssr)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/caching)
*   [
    
    Render Optimizations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/render-optimizations)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/suspense)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/testing)
*   [
    
    Does this replace \[Redux, MobX, etc\]?
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/does-this-replace-client-state)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-react-query-3)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-react-query-4)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-v5)

API Reference

*   [](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useQueries)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useInfiniteQuery)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useMutation)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useIsFetching)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useIsMutating)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useMutationState)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseQuery)
*   [
    
    useSuspenseInfiniteQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseInfiniteQuery)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseQueries)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/QueryClientProvider)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useQueryClient)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/queryOptions)
*   [
    
    infiniteQueryOptions
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/infiniteQueryOptions)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/mutationOptions)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/usePrefetchQuery)
*   [
    
    usePrefetchInfiniteQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/usePrefetchInfiniteQuery)
*   [
    
    QueryErrorResetBoundary
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/QueryErrorResetBoundary)
*   [
    
    useQueryErrorResetBoundary
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useQueryErrorResetBoundary)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/hydration)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Examples

*   [](https://tanstack.com/query/latest/docs/framework/react/examples/simple)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/basic)
*   [
    
    Basic w/ GraphQL-Request
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/basic-graphql-request)
*   [
    
    Auto Refetching / Polling / Realtime
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/auto-refetching)
*   [
    
    Optimistic Updates (UI)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/optimistic-updates-ui)
*   [
    
    Optimistic Updates (Cache)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/optimistic-updates-cache)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/pagination)
*   [
    
    Load-More & Infinite Scroll
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/load-more-infinite-scroll)
*   [
    
    Infinite query with Max pages
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/infinite-query-with-max-pages)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/suspense)
*   [
    
    Default Query Function
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/default-query-function)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/playground)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/prefetching)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/star-wars)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/rick-morty)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/nextjs)
*   [
    
    Next.js app with prefetching
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/nextjs-app-prefetching)
*   [
    
    Next.js app with streaming
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/nextjs-suspense-streaming)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/react-native)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/react-router)
*   [
    
    Offline Queries and Mutations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/offline)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/algolia)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/shadow-dom)
*   [
    
    Devtools Embedded Panel
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/devtools-panel)
*   [
    
    Chat example (streaming)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/chat)

Plugins

*   [](https://tanstack.com/query/latest/docs/framework/react/plugins/persistQueryClient)
*   [
    
    createSyncStoragePersister
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/createSyncStoragePersister)
*   [
    
    createAsyncStoragePersister
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/createAsyncStoragePersister)
*   [
    
    broadcastQueryClient (Experimental)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/broadcastQueryClient)
*   [
    
    createPersister (Experimental)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/createPersister)

Guides & Concepts

*   [](https://tanstack.com/query/latest/docs/framework/react/guides/important-defaults)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/queries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-keys)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-functions)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-options)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/network-mode)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/parallel-queries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/disabling-queries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-retries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/paginated-queries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/infinite-queries)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/placeholder-query-data)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/mutations)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/invalidations-from-mutations)
*   [
    
    Updates from Mutation Responses
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/updates-from-mutation-responses)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/optimistic-updates)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/query-cancellation)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/scroll-restoration)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/filters)
*   [
    
    Performance & Request Waterfalls
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/request-waterfalls)
*   [
    
    Prefetching & Router Integration
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/prefetching)
*   [
    
    Server Rendering & Hydration
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/ssr)
*   [
    
    Advanced Server Rendering
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/advanced-ssr)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/caching)
*   [
    
    Render Optimizations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/render-optimizations)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/suspense)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/testing)
*   [
    
    Does this replace \[Redux, MobX, etc\]?
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/guides/does-this-replace-client-state)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-react-query-3)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-react-query-4)
*   [](https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-v5)

API Reference

*   [](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useQuery)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useQueries)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useInfiniteQuery)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useMutation)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useIsFetching)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useIsMutating)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useMutationState)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseQuery)
*   [
    
    useSuspenseInfiniteQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseInfiniteQuery)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseQueries)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/QueryClientProvider)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/useQueryClient)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/queryOptions)
*   [
    
    infiniteQueryOptions
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/infiniteQueryOptions)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/mutationOptions)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/usePrefetchQuery)
*   [
    
    usePrefetchInfiniteQuery
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/usePrefetchInfiniteQuery)
*   [
    
    QueryErrorResetBoundary
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/QueryErrorResetBoundary)
*   [
    
    useQueryErrorResetBoundary
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/reference/useQueryErrorResetBoundary)
*   [](https://tanstack.com/query/latest/docs/framework/react/reference/hydration)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Examples

*   [](https://tanstack.com/query/latest/docs/framework/react/examples/simple)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/basic)
*   [
    
    Basic w/ GraphQL-Request
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/basic-graphql-request)
*   [
    
    Auto Refetching / Polling / Realtime
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/auto-refetching)
*   [
    
    Optimistic Updates (UI)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/optimistic-updates-ui)
*   [
    
    Optimistic Updates (Cache)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/optimistic-updates-cache)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/pagination)
*   [
    
    Load-More & Infinite Scroll
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/load-more-infinite-scroll)
*   [
    
    Infinite query with Max pages
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/infinite-query-with-max-pages)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/suspense)
*   [
    
    Default Query Function
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/default-query-function)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/playground)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/prefetching)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/star-wars)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/rick-morty)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/nextjs)
*   [
    
    Next.js app with prefetching
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/nextjs-app-prefetching)
*   [
    
    Next.js app with streaming
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/nextjs-suspense-streaming)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/react-native)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/react-router)
*   [
    
    Offline Queries and Mutations
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/offline)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/algolia)
*   [](https://tanstack.com/query/latest/docs/framework/react/examples/shadow-dom)
*   [
    
    Devtools Embedded Panel
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/devtools-panel)
*   [
    
    Chat example (streaming)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/examples/chat)

Plugins

*   [](https://tanstack.com/query/latest/docs/framework/react/plugins/persistQueryClient)
*   [
    
    createSyncStoragePersister
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/createSyncStoragePersister)
*   [
    
    createAsyncStoragePersister
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/createAsyncStoragePersister)
*   [
    
    broadcastQueryClient (Experimental)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/broadcastQueryClient)
*   [
    
    createPersister (Experimental)
    
    react
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/react/plugins/createPersister)

TanStack React Query Documentation
----------------------------------

Use the menu to select a documentation page.</content>
</page>

<page>
  <title>Vue | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue</url>
  <content>Documentation

Framework

Version

Menu

*   [
    
    Home
    
    
    
    ](https://tanstack.com/query/latest)
*   [
    
    Frameworks
    
    
    
    ](https://tanstack.com/query/latest/docs/framework)
*   [
    
    Contributors
    
    
    
    ](https://tanstack.com/query/latest/docs/contributors)
*   [
    
    Community Resources
    
    
    
    ](https://tanstack.com/query/latest/docs/community-resources)
*   [
    
    GitHub
    
    
    
    ](https://github.com/tanstack/query)
*   [
    
    Discord
    
    
    
    ](https://tlinz.com/discord)

Getting Started

*   [
    
    Overview
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/overview)
*   [
    
    Installation
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/installation)
*   [
    
    Quick Start
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/quick-start)
*   [
    
    Devtools
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/devtools)
*   [
    
    TypeScript
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/typescript)
*   [
    
    Reactivity
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/reactivity)
*   [
    
    GraphQL
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/graphql)

Guides & Concepts

*   [
    
    Important Defaults
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/important-defaults)
*   [
    
    Queries
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/queries)
*   [
    
    Query Keys
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/query-keys)
*   [
    
    Query Functions
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/query-functions)
*   [
    
    Query Options
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/query-options)
*   [
    
    Network Mode
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/network-mode)
*   [
    
    Parallel Queries
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/parallel-queries)
*   [
    
    Dependent Queries
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/disabling-queries)
*   [
    
    Query Retries
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/query-retries)
*   [
    
    Paginated Queries
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/paginated-queries)
*   [
    
    Infinite Queries
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/infinite-queries)
*   [
    
    Initial Query Data
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/placeholder-query-data)
*   [
    
    Mutations
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/mutations)
*   [
    
    Query Invalidation
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/invalidations-from-mutations)
*   [
    
    Updates from Mutation Responses
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/updates-from-mutation-responses)
*   [
    
    Optimistic Updates
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/optimistic-updates)
*   [
    
    Query Cancellation
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/query-cancellation)
*   [
    
    Scroll Restoration
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/scroll-restoration)
*   [
    
    Filters
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/filters)
*   [
    
    Prefetching
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/prefetching)
*   [
    
    SSR & Nuxt
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/ssr)
*   [
    
    Caching
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/caching)
*   [
    
    Default Query Fn
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/default-query-function)
*   [
    
    Suspense
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/suspense)
*   [
    
    Testing
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/testing)
*   [
    
    Custom Client
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/custom-client)
*   [
    
    Does this replace \[Vuex, Pinia\]?
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/does-this-replace-client-state)
*   [
    
    Migrating to v5
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/migrating-to-v5)

API Reference

*   [
    
    QueryClient
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [
    
    QueryCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [
    
    MutationCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [
    
    QueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [
    
    QueriesObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [
    
    streamedQuery
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [
    
    focusManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [
    
    onlineManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [
    
    notifyManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [
    
    timeoutManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [
    
    useQuery
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/reference/useQuery)
*   [
    
    useQueries
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/reference/useQueries)
*   [
    
    useInfiniteQuery
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/reference/useInfiniteQuery)
*   [
    
    useMutation
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/reference/useMutation)
*   [
    
    useIsFetching
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/reference/useIsFetching)
*   [
    
    useIsMutating
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/reference/useIsMutating)
*   [
    
    useMutationState
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/reference/useMutationState)
*   [
    
    useQueryClient
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/reference/useQueryClient)
*   [
    
    queryOptions
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/reference/queryOptions)
*   [
    
    infiniteQueryOptions
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/reference/infiniteQueryOptions)
*   [
    
    hydration
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/reference/hydration)

ESLint

*   [
    
    ESLint Plugin Query
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [
    
    Exhaustive Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [
    
    Stable Query Client
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [
    
    No Unstable Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Examples

*   [
    
    Basic
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/examples/basic)
*   [
    
    Vue 2.6
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/examples/2.6-basic)
*   [
    
    Nuxt 3
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/examples/nuxt3)
*   [
    
    Persister
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/examples/persister)

Plugins

*   [
    
    broadcastQueryClient (Experimental)
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/plugins/broadcastQueryClient)
*   [
    
    createPersister (Experimental)
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/plugins/createPersister)

Framework

Version

Menu

*   [
    
    Home
    
    
    
    ](https://tanstack.com/query/latest)
*   [
    
    Frameworks
    
    
    
    ](https://tanstack.com/query/latest/docs/framework)
*   [
    
    Contributors
    
    
    
    ](https://tanstack.com/query/latest/docs/contributors)
*   [
    
    Community Resources
    
    
    
    ](https://tanstack.com/query/latest/docs/community-resources)
*   [
    
    GitHub
    
    
    
    ](https://github.com/tanstack/query)
*   [
    
    Discord
    
    
    
    ](https://tlinz.com/discord)

Getting Started

*   [
    
    Overview
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/overview)
*   [
    
    Installation
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/installation)
*   [
    
    Quick Start
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/quick-start)
*   [
    
    Devtools
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/devtools)
*   [
    
    TypeScript
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/typescript)
*   [
    
    Reactivity
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/reactivity)
*   [
    
    GraphQL
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/graphql)

Guides & Concepts

*   [
    
    Important Defaults
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/important-defaults)
*   [
    
    Queries
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/queries)
*   [
    
    Query Keys
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/query-keys)
*   [
    
    Query Functions
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/query-functions)
*   [
    
    Query Options
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/query-options)
*   [
    
    Network Mode
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/network-mode)
*   [
    
    Parallel Queries
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/parallel-queries)
*   [
    
    Dependent Queries
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/disabling-queries)
*   [
    
    Query Retries
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/query-retries)
*   [
    
    Paginated Queries
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/paginated-queries)
*   [
    
    Infinite Queries
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/infinite-queries)
*   [
    
    Initial Query Data
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/placeholder-query-data)
*   [
    
    Mutations
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/mutations)
*   [
    
    Query Invalidation
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/invalidations-from-mutations)
*   [
    
    Updates from Mutation Responses
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/updates-from-mutation-responses)
*   [
    
    Optimistic Updates
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/optimistic-updates)
*   [
    
    Query Cancellation
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/query-cancellation)
*   [
    
    Scroll Restoration
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/scroll-restoration)
*   [
    
    Filters
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/filters)
*   [
    
    Prefetching
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/prefetching)
*   [
    
    SSR & Nuxt
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/ssr)
*   [
    
    Caching
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/caching)
*   [
    
    Default Query Fn
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/default-query-function)
*   [
    
    Suspense
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/suspense)
*   [
    
    Testing
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/testing)
*   [
    
    Custom Client
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/custom-client)
*   [
    
    Does this replace \[Vuex, Pinia\]?
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/does-this-replace-client-state)
*   [
    
    Migrating to v5
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/migrating-to-v5)

API Reference

*   [
    
    QueryClient
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [
    
    QueryCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [
    
    MutationCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [
    
    QueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [
    
    QueriesObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [
    
    streamedQuery
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [
    
    focusManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [
    
    onlineManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [
    
    notifyManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [
    
    timeoutManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [
    
    useQuery
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/reference/useQuery)
*   [
    
    useQueries
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/reference/useQueries)
*   [
    
    useInfiniteQuery
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/reference/useInfiniteQuery)
*   [
    
    useMutation
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/reference/useMutation)
*   [
    
    useIsFetching
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/reference/useIsFetching)
*   [
    
    useIsMutating
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/reference/useIsMutating)
*   [
    
    useMutationState
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/reference/useMutationState)
*   [
    
    useQueryClient
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/reference/useQueryClient)
*   [
    
    queryOptions
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/reference/queryOptions)
*   [
    
    infiniteQueryOptions
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/reference/infiniteQueryOptions)
*   [
    
    hydration
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/reference/hydration)

ESLint

*   [
    
    ESLint Plugin Query
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [
    
    Exhaustive Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [
    
    Stable Query Client
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [
    
    No Unstable Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Examples

*   [
    
    Basic
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/examples/basic)
*   [
    
    Vue 2.6
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/examples/2.6-basic)
*   [
    
    Nuxt 3
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/examples/nuxt3)
*   [
    
    Persister
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/examples/persister)

Plugins

*   [
    
    broadcastQueryClient (Experimental)
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/plugins/broadcastQueryClient)
*   [
    
    createPersister (Experimental)
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/plugins/createPersister)

TanStack Vue Query Documentation
--------------------------------

Use the menu to select a documentation page.

[Learn about TanStack Ads](https://tanstack.com/ads)[Hide Ads](https://tanstack.com/ads#hide-ads)

[

Home



](https://tanstack.com/query/latest)

[Partners](https://tanstack.com/partners)[Become a Partner](https://docs.google.com/document/d/1Hg2MzY2TU6U3hFEZ3MLe2oEOM3JS4-eByti3kdJU3I8)

[](https://coderabbit.link/tanstack?utm_source=tanstack&via=tanstack)[](https://www.cloudflare.com/?utm_source=tanstack)[](https://ag-grid.com/react-data-grid/?utm_source=reacttable&utm_campaign=githubreacttable)[](https://netlify.com/?utm_source=tanstack)[](https://neon.tech/?utm_source=tanstack)[](https://workos.com/?utm_source=tanstack)[](https://go.clerk.com/wOwHtuJ)[](https://convex.dev/?utm_source=tanstack)[](https://electric-sql.com/)[](https://sentry.io/?utm_source=tanstack)[](https://www.prisma.io/?utm_source=tanstack&via=tanstack)[](https://strapi.link/tanstack-start)[](https://www.unkey.com/?utm_source=tanstack)

[Learn about TanStack Ads](https://tanstack.com/ads)[Hide Ads](https://tanstack.com/ads#hide-ads)

[

###### Want to Skip the Docs?

Query.gg - The Official React Query Course

Black Friday Sale
-----------------

Get 50% off through December 6th

01

days

:

22

hours

:

51

minutes









](https://query.gg/?s=tanstack)</content>
</page>

<page>
  <title>Svelte | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte</url>
  <content>Documentation

Framework

Version

Menu

*   [
    
    Home
    
    
    
    ](https://tanstack.com/query/latest)
*   [
    
    Frameworks
    
    
    
    ](https://tanstack.com/query/latest/docs/framework)
*   [
    
    Contributors
    
    
    
    ](https://tanstack.com/query/latest/docs/contributors)
*   [
    
    Community Resources
    
    
    
    ](https://tanstack.com/query/latest/docs/community-resources)
*   [
    
    GitHub
    
    
    
    ](https://github.com/tanstack/query)
*   [
    
    Discord
    
    
    
    ](https://tlinz.com/discord)

Getting Started

*   [
    
    Overview
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/overview)
*   [
    
    Installation
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/installation)
*   [
    
    Devtools
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/devtools)
*   [
    
    SSR & SvelteKit
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/ssr)
*   [
    
    Migrate from v5 to v6
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/migrate-from-v5-to-v6)

API Reference

*   [
    
    QueryClient
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [
    
    QueryCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [
    
    MutationCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [
    
    QueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [
    
    QueriesObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [
    
    streamedQuery
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [
    
    focusManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [
    
    onlineManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [
    
    notifyManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [
    
    timeoutManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [
    
    Svelte Reference
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/index)
*   [
    
    Functions / createQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQuery)
*   [
    
    Functions / createQueries
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQueries)
*   [
    
    Functions / createInfiniteQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createInfiniteQuery)
*   [
    
    Functions / createMutation
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createMutation)
*   [
    
    Functions / useIsFetching
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsFetching)
*   [
    
    Functions / useIsMutating
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsMutating)
*   [
    
    Functions / useMutationState
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useMutationState)
*   [
    
    Functions / queryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/queryOptions)
*   [
    
    Functions / infiniteQueryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/infiniteQueryOptions)

ESLint

*   [
    
    ESLint Plugin Query
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [
    
    Exhaustive Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [
    
    Stable Query Client
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [
    
    No Unstable Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Examples

*   [
    
    Simple
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/simple)
*   [
    
    Basic
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/basic)
*   [
    
    Auto Refetching / Polling / Realtime
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/auto-refetching)
*   [
    
    SSR
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/ssr)
*   [
    
    Optimistic Updates
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/optimistic-updates)
*   [
    
    Playground
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/playground)
*   [
    
    Star Wars
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/star-wars)
*   [
    
    Infinite Queries
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/load-more-infinite-scroll)

Framework

Version

Menu

*   [
    
    Home
    
    
    
    ](https://tanstack.com/query/latest)
*   [
    
    Frameworks
    
    
    
    ](https://tanstack.com/query/latest/docs/framework)
*   [
    
    Contributors
    
    
    
    ](https://tanstack.com/query/latest/docs/contributors)
*   [
    
    Community Resources
    
    
    
    ](https://tanstack.com/query/latest/docs/community-resources)
*   [
    
    GitHub
    
    
    
    ](https://github.com/tanstack/query)
*   [
    
    Discord
    
    
    
    ](https://tlinz.com/discord)

Getting Started

*   [
    
    Overview
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/overview)
*   [
    
    Installation
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/installation)
*   [
    
    Devtools
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/devtools)
*   [
    
    SSR & SvelteKit
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/ssr)
*   [
    
    Migrate from v5 to v6
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/migrate-from-v5-to-v6)

API Reference

*   [
    
    QueryClient
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [
    
    QueryCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [
    
    MutationCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [
    
    QueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [
    
    QueriesObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [
    
    streamedQuery
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [
    
    focusManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [
    
    onlineManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [
    
    notifyManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [
    
    timeoutManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [
    
    Svelte Reference
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/index)
*   [
    
    Functions / createQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQuery)
*   [
    
    Functions / createQueries
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQueries)
*   [
    
    Functions / createInfiniteQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createInfiniteQuery)
*   [
    
    Functions / createMutation
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createMutation)
*   [
    
    Functions / useIsFetching
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsFetching)
*   [
    
    Functions / useIsMutating
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsMutating)
*   [
    
    Functions / useMutationState
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useMutationState)
*   [
    
    Functions / queryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/queryOptions)
*   [
    
    Functions / infiniteQueryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/infiniteQueryOptions)

ESLint

*   [
    
    ESLint Plugin Query
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [
    
    Exhaustive Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [
    
    Stable Query Client
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [
    
    No Unstable Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Examples

*   [
    
    Simple
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/simple)
*   [
    
    Basic
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/basic)
*   [
    
    Auto Refetching / Polling / Realtime
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/auto-refetching)
*   [
    
    SSR
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/ssr)
*   [
    
    Optimistic Updates
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/optimistic-updates)
*   [
    
    Playground
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/playground)
*   [
    
    Star Wars
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/star-wars)
*   [
    
    Infinite Queries
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/load-more-infinite-scroll)

TanStack Svelte Query Documentation
-----------------------------------

Use the menu to select a documentation page.

[Learn about TanStack Ads](https://tanstack.com/ads)[Hide Ads](https://tanstack.com/ads#hide-ads)

[

Home



](https://tanstack.com/query/latest)

[Partners](https://tanstack.com/partners)[Become a Partner](https://docs.google.com/document/d/1Hg2MzY2TU6U3hFEZ3MLe2oEOM3JS4-eByti3kdJU3I8)

[](https://coderabbit.link/tanstack?utm_source=tanstack&via=tanstack)[](https://www.cloudflare.com/?utm_source=tanstack)[](https://ag-grid.com/react-data-grid/?utm_source=reacttable&utm_campaign=githubreacttable)[](https://netlify.com/?utm_source=tanstack)[](https://neon.tech/?utm_source=tanstack)[](https://workos.com/?utm_source=tanstack)[](https://go.clerk.com/wOwHtuJ)[](https://convex.dev/?utm_source=tanstack)[](https://electric-sql.com/)[](https://sentry.io/?utm_source=tanstack)[](https://www.prisma.io/?utm_source=tanstack&via=tanstack)[](https://strapi.link/tanstack-start)[](https://www.unkey.com/?utm_source=tanstack)

[Learn about TanStack Ads](https://tanstack.com/ads)[Hide Ads](https://tanstack.com/ads#hide-ads)

[

###### Want to Skip the Docs?

Query.gg - The Official React Query Course

Black Friday Sale
-----------------

Get 50% off through December 6th

01

days

:

22

hours

:

51

minutes









](https://query.gg/?s=tanstack)</content>
</page>

<page>
  <title>Angular | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular</url>
  <content>Documentation

Framework

Version

Menu

*   [
    
    Home
    
    
    
    ](https://tanstack.com/query/latest)
*   [
    
    Frameworks
    
    
    
    ](https://tanstack.com/query/latest/docs/framework)
*   [
    
    Contributors
    
    
    
    ](https://tanstack.com/query/latest/docs/contributors)
*   [
    
    Community Resources
    
    
    
    ](https://tanstack.com/query/latest/docs/community-resources)
*   [
    
    GitHub
    
    
    
    ](https://github.com/tanstack/query)
*   [
    
    Discord
    
    
    
    ](https://tlinz.com/discord)

Getting Started

*   [
    
    Overview
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/overview)
*   [
    
    Installation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/installation)
*   [
    
    Quick Start
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/quick-start)
*   [
    
    Angular HttpClient and other data fetching clients
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/angular-httpclient-and-other-data-fetching-clients)
*   [
    
    Devtools
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/devtools)
*   [
    
    TypeScript
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/typescript)
*   [
    
    Zoneless
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/zoneless)

Guides & Concepts

*   [
    
    Important Defaults
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/important-defaults)
*   [
    
    Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/queries)
*   [
    
    Query Keys
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-keys)
*   [
    
    Query Functions
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-functions)
*   [
    
    Query Options
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-options)
*   [
    
    Network Mode
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/network-mode)
*   [
    
    Parallel Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/parallel-queries)
*   [
    
    Dependent Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/disabling-queries)
*   [
    
    Query Retries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-retries)
*   [
    
    Paginated Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/paginated-queries)
*   [
    
    Infinite Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/infinite-queries)
*   [
    
    Initial Query Data
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/placeholder-query-data)
*   [
    
    Mutations
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/mutations)
*   [
    
    Mutation Options
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/mutation-options)
*   [
    
    Query Invalidation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/invalidations-from-mutations)
*   [
    
    Optimistic Updates
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/optimistic-updates)
*   [
    
    Query Cancellation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-cancellation)
*   [
    
    Scroll Restoration
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/scroll-restoration)
*   [
    
    Filters
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/filters)
*   [
    
    Caching
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/caching)
*   [
    
    Default Query Fn
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/default-query-function)
*   [
    
    Testing
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/testing)
*   [
    
    Does this replace state managers?
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/does-this-replace-client-state)

API Reference

*   [
    
    QueryClient
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [
    
    QueryCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [
    
    MutationCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [
    
    QueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [
    
    QueriesObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [
    
    streamedQuery
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [
    
    focusManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [
    
    onlineManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [
    
    notifyManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [
    
    timeoutManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [
    
    Angular Reference
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/reference/index)
*   [
    
    Functions / injectQuery
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectQuery)
*   [
    
    Functions / injectMutation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectMutation)

ESLint

*   [
    
    ESLint Plugin Query
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [
    
    Exhaustive Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [
    
    Stable Query Client
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [
    
    No Unstable Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Examples

*   [
    
    Simple
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/simple)
*   [
    
    Basic
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/basic)
*   [
    
    Auto Refetching / Polling / Realtime
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/auto-refetching)
*   [
    
    Optimistic Updates
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/optimistic-updates)
*   [
    
    Pagination
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/pagination)
*   [
    
    Infinite query with maxPages
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/infinite-query-with-max-pages)
*   [
    
    Angular Router
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/router)
*   [
    
    RxJS autocomplete
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/rxjs)
*   [
    
    Query options from a service
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/query-options-from-a-service)
*   [
    
    Devtools embedded panel
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/devtools-panel)

Framework

Version

Menu

*   [
    
    Home
    
    
    
    ](https://tanstack.com/query/latest)
*   [
    
    Frameworks
    
    
    
    ](https://tanstack.com/query/latest/docs/framework)
*   [
    
    Contributors
    
    
    
    ](https://tanstack.com/query/latest/docs/contributors)
*   [
    
    Community Resources
    
    
    
    ](https://tanstack.com/query/latest/docs/community-resources)
*   [
    
    GitHub
    
    
    
    ](https://github.com/tanstack/query)
*   [
    
    Discord
    
    
    
    ](https://tlinz.com/discord)

Getting Started

*   [
    
    Overview
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/overview)
*   [
    
    Installation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/installation)
*   [
    
    Quick Start
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/quick-start)
*   [
    
    Angular HttpClient and other data fetching clients
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/angular-httpclient-and-other-data-fetching-clients)
*   [
    
    Devtools
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/devtools)
*   [
    
    TypeScript
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/typescript)
*   [
    
    Zoneless
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/zoneless)

Guides & Concepts

*   [
    
    Important Defaults
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/important-defaults)
*   [
    
    Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/queries)
*   [
    
    Query Keys
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-keys)
*   [
    
    Query Functions
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-functions)
*   [
    
    Query Options
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-options)
*   [
    
    Network Mode
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/network-mode)
*   [
    
    Parallel Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/parallel-queries)
*   [
    
    Dependent Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/disabling-queries)
*   [
    
    Query Retries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-retries)
*   [
    
    Paginated Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/paginated-queries)
*   [
    
    Infinite Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/infinite-queries)
*   [
    
    Initial Query Data
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/placeholder-query-data)
*   [
    
    Mutations
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/mutations)
*   [
    
    Mutation Options
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/mutation-options)
*   [
    
    Query Invalidation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/invalidations-from-mutations)
*   [
    
    Optimistic Updates
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/optimistic-updates)
*   [
    
    Query Cancellation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-cancellation)
*   [
    
    Scroll Restoration
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/scroll-restoration)
*   [
    
    Filters
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/filters)
*   [
    
    Caching
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/caching)
*   [
    
    Default Query Fn
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/default-query-function)
*   [
    
    Testing
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/testing)
*   [
    
    Does this replace state managers?
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/does-this-replace-client-state)

API Reference

*   [
    
    QueryClient
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [
    
    QueryCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [
    
    MutationCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [
    
    QueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [
    
    QueriesObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [
    
    streamedQuery
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [
    
    focusManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [
    
    onlineManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [
    
    notifyManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [
    
    timeoutManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [
    
    Angular Reference
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/reference/index)
*   [
    
    Functions / injectQuery
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectQuery)
*   [
    
    Functions / injectMutation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectMutation)

ESLint

*   [
    
    ESLint Plugin Query
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [
    
    Exhaustive Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [
    
    Stable Query Client
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [
    
    No Unstable Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Examples

*   [
    
    Simple
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/simple)
*   [
    
    Basic
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/basic)
*   [
    
    Auto Refetching / Polling / Realtime
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/auto-refetching)
*   [
    
    Optimistic Updates
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/optimistic-updates)
*   [
    
    Pagination
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/pagination)
*   [
    
    Infinite query with maxPages
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/infinite-query-with-max-pages)
*   [
    
    Angular Router
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/router)
*   [
    
    RxJS autocomplete
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/rxjs)
*   [
    
    Query options from a service
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/query-options-from-a-service)
*   [
    
    Devtools embedded panel
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/devtools-panel)

TanStack Angular Query Documentation
------------------------------------

Use the menu to select a documentation page.

[Learn about TanStack Ads](https://tanstack.com/ads)[Hide Ads](https://tanstack.com/ads#hide-ads)

[

Home



](https://tanstack.com/query/latest)

[Partners](https://tanstack.com/partners)[Become a Partner](https://docs.google.com/document/d/1Hg2MzY2TU6U3hFEZ3MLe2oEOM3JS4-eByti3kdJU3I8)

[](https://coderabbit.link/tanstack?utm_source=tanstack&via=tanstack)[](https://www.cloudflare.com/?utm_source=tanstack)[](https://ag-grid.com/react-data-grid/?utm_source=reacttable&utm_campaign=githubreacttable)[](https://netlify.com/?utm_source=tanstack)[](https://neon.tech/?utm_source=tanstack)[](https://workos.com/?utm_source=tanstack)[](https://go.clerk.com/wOwHtuJ)[](https://convex.dev/?utm_source=tanstack)[](https://electric-sql.com/)[](https://sentry.io/?utm_source=tanstack)[](https://www.prisma.io/?utm_source=tanstack&via=tanstack)[](https://strapi.link/tanstack-start)[](https://www.unkey.com/?utm_source=tanstack)

[Learn about TanStack Ads](https://tanstack.com/ads)[Hide Ads](https://tanstack.com/ads#hide-ads)

[

###### Want to Skip the Docs?

Query.gg - The Official React Query Course

Black Friday Sale
-----------------

Get 50% off through December 6th

01

days

:

22

hours

:

51

minutes









](https://query.gg/?s=tanstack)</content>
</page>

<page>
  <title>Disallow returning void from query functions | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/eslint/no-void-query-fn</url>
  <content>Query functions must return a value that will be cached by TanStack Query. Functions that don't return a value (void functions) can lead to unexpected behavior and might indicate a mistake in the implementation.

[](#rule-details)[Rule Details](#rule-details)
----------------------------------------------

Example of **incorrect** code for this rule:

    /* eslint "@tanstack/query/no-void-query-fn": "error" */
    
    useQuery({
      queryKey: ['todos'],
      queryFn: async () => {
        await api.todos.fetch() // Function doesn't return the fetched data
      },
    })
    

    /* eslint "@tanstack/query/no-void-query-fn": "error" */
    
    useQuery({
      queryKey: ['todos'],
      queryFn: async () => {
        await api.todos.fetch() // Function doesn't return the fetched data
      },
    })
    

Example of **correct** code for this rule:

    /* eslint "@tanstack/query/no-void-query-fn": "error" */
    useQuery({
      queryKey: ['todos'],
      queryFn: async () => {
        const todos = await api.todos.fetch()
        return todos
      },
    })
    

    /* eslint "@tanstack/query/no-void-query-fn": "error" */
    useQuery({
      queryKey: ['todos'],
      queryFn: async () => {
        const todos = await api.todos.fetch()
        return todos
      },
    })
    

[](#attributes)[Attributes](#attributes)
----------------------------------------

*   ‚úÖ Recommended
*   üîß Fixable</content>
</page>

<page>
  <title>Solid | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid</url>
  <content>Documentation

Framework

Version

Menu

*   [
    
    Home
    
    
    
    ](https://tanstack.com/query/latest)
*   [
    
    Frameworks
    
    
    
    ](https://tanstack.com/query/latest/docs/framework)
*   [
    
    Contributors
    
    
    
    ](https://tanstack.com/query/latest/docs/contributors)
*   [
    
    Community Resources
    
    
    
    ](https://tanstack.com/query/latest/docs/community-resources)
*   [
    
    GitHub
    
    
    
    ](https://github.com/tanstack/query)
*   [
    
    Discord
    
    
    
    ](https://tlinz.com/discord)

Getting Started

*   [
    
    Overview
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/overview)
*   [
    
    Quick Start
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/quick-start)
*   [
    
    Installation
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/installation)
*   [
    
    Devtools
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/devtools)
*   [
    
    TypeScript
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/typescript)

Guides & Concepts

*   [
    
    Important Defaults
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/important-defaults)
*   [
    
    Queries
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/queries)
*   [
    
    Query Keys
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/query-keys)
*   [
    
    Query Functions
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/query-functions)
*   [
    
    Query Options
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/query-options)
*   [
    
    Network Mode
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/network-mode)
*   [
    
    Parallel Queries
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/parallel-queries)
*   [
    
    Dependent Queries
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/disabling-queries)
*   [
    
    Query Retries
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/query-retries)
*   [
    
    Paginated Queries
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/paginated-queries)
*   [
    
    Infinite Queries
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/infinite-queries)
*   [
    
    Initial Query Data
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/placeholder-query-data)
*   [
    
    Mutations
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/mutations)
*   [
    
    Query Invalidation
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/invalidations-from-mutations)
*   [
    
    Updates from Mutation Responses
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/updates-from-mutation-responses)
*   [
    
    Optimistic Updates
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/optimistic-updates)
*   [
    
    Query Cancellation
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/query-cancellation)
*   [
    
    Scroll Restoration
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/scroll-restoration)
*   [
    
    Filters
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/filters)
*   [
    
    Request Waterfalls
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/request-waterfalls)
*   [
    
    Prefetching
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/prefetching)
*   [
    
    SSR
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/ssr)
*   [
    
    Advanced SSR
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/advanced-ssr)
*   [
    
    Caching
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/caching)
*   [
    
    Default Query Fn
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/default-query-function)
*   [
    
    Suspense
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/suspense)
*   [
    
    Testing
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/testing)
*   [
    
    Does this replace state managers?
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/does-this-replace-client-state)

API Reference

*   [
    
    QueryClient
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [
    
    QueryCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [
    
    MutationCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [
    
    QueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [
    
    QueriesObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [
    
    streamedQuery
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [
    
    focusManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [
    
    onlineManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [
    
    notifyManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [
    
    timeoutManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [
    
    useQuery
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/reference/useQuery)
*   [
    
    useQueries
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/reference/useQueries)
*   [
    
    useInfiniteQuery
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/reference/useInfiniteQuery)
*   [
    
    useMutation
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/reference/useMutation)
*   [
    
    useIsFetching
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/reference/useIsFetching)
*   [
    
    useIsMutating
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/reference/useIsMutating)
*   [
    
    useMutationState
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/reference/useMutationState)
*   [
    
    queryOptions
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/reference/queryOptions)
*   [
    
    infiniteQueryOptions
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/reference/infiniteQueryOptions)
*   [
    
    hydration
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/reference/hydration)

ESLint

*   [
    
    ESLint Plugin Query
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [
    
    Exhaustive Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [
    
    Stable Query Client
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [
    
    No Unstable Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Examples

*   [
    
    Simple
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/examples/simple)
*   [
    
    Basic
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/examples/basic)
*   [
    
    Basic w/ GraphQL-Request
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/examples/basic-graphql-request)
*   [
    
    Default Query Function
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/examples/default-query-function)
*   [
    
    Solid Start
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/examples/solid-start-streaming)
*   [
    
    Astro
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/examples/astro)

Plugins

*   [
    
    broadcastQueryClient (Experimental)
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/plugins/broadcastQueryClient)
*   [
    
    createPersister (Experimental)
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/plugins/createPersister)

Framework

Version

Menu

*   [
    
    Home
    
    
    
    ](https://tanstack.com/query/latest)
*   [
    
    Frameworks
    
    
    
    ](https://tanstack.com/query/latest/docs/framework)
*   [
    
    Contributors
    
    
    
    ](https://tanstack.com/query/latest/docs/contributors)
*   [
    
    Community Resources
    
    
    
    ](https://tanstack.com/query/latest/docs/community-resources)
*   [
    
    GitHub
    
    
    
    ](https://github.com/tanstack/query)
*   [
    
    Discord
    
    
    
    ](https://tlinz.com/discord)

Getting Started

*   [
    
    Overview
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/overview)
*   [
    
    Quick Start
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/quick-start)
*   [
    
    Installation
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/installation)
*   [
    
    Devtools
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/devtools)
*   [
    
    TypeScript
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/typescript)

Guides & Concepts

*   [
    
    Important Defaults
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/important-defaults)
*   [
    
    Queries
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/queries)
*   [
    
    Query Keys
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/query-keys)
*   [
    
    Query Functions
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/query-functions)
*   [
    
    Query Options
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/query-options)
*   [
    
    Network Mode
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/network-mode)
*   [
    
    Parallel Queries
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/parallel-queries)
*   [
    
    Dependent Queries
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/disabling-queries)
*   [
    
    Query Retries
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/query-retries)
*   [
    
    Paginated Queries
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/paginated-queries)
*   [
    
    Infinite Queries
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/infinite-queries)
*   [
    
    Initial Query Data
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/placeholder-query-data)
*   [
    
    Mutations
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/mutations)
*   [
    
    Query Invalidation
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/invalidations-from-mutations)
*   [
    
    Updates from Mutation Responses
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/updates-from-mutation-responses)
*   [
    
    Optimistic Updates
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/optimistic-updates)
*   [
    
    Query Cancellation
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/query-cancellation)
*   [
    
    Scroll Restoration
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/scroll-restoration)
*   [
    
    Filters
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/filters)
*   [
    
    Request Waterfalls
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/request-waterfalls)
*   [
    
    Prefetching
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/prefetching)
*   [
    
    SSR
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/ssr)
*   [
    
    Advanced SSR
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/advanced-ssr)
*   [
    
    Caching
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/caching)
*   [
    
    Default Query Fn
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/default-query-function)
*   [
    
    Suspense
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/suspense)
*   [
    
    Testing
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/testing)
*   [
    
    Does this replace state managers?
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/does-this-replace-client-state)

API Reference

*   [
    
    QueryClient
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [
    
    QueryCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [
    
    MutationCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [
    
    QueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [
    
    QueriesObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [
    
    streamedQuery
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [
    
    focusManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [
    
    onlineManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [
    
    notifyManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [
    
    timeoutManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [
    
    useQuery
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/reference/useQuery)
*   [
    
    useQueries
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/reference/useQueries)
*   [
    
    useInfiniteQuery
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/reference/useInfiniteQuery)
*   [
    
    useMutation
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/reference/useMutation)
*   [
    
    useIsFetching
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/reference/useIsFetching)
*   [
    
    useIsMutating
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/reference/useIsMutating)
*   [
    
    useMutationState
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/reference/useMutationState)
*   [
    
    queryOptions
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/reference/queryOptions)
*   [
    
    infiniteQueryOptions
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/reference/infiniteQueryOptions)
*   [
    
    hydration
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/reference/hydration)

ESLint

*   [
    
    ESLint Plugin Query
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [
    
    Exhaustive Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [
    
    Stable Query Client
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [
    
    No Unstable Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Examples

*   [
    
    Simple
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/examples/simple)
*   [
    
    Basic
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/examples/basic)
*   [
    
    Basic w/ GraphQL-Request
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/examples/basic-graphql-request)
*   [
    
    Default Query Function
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/examples/default-query-function)
*   [
    
    Solid Start
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/examples/solid-start-streaming)
*   [
    
    Astro
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/examples/astro)

Plugins

*   [
    
    broadcastQueryClient (Experimental)
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/plugins/broadcastQueryClient)
*   [
    
    createPersister (Experimental)
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/plugins/createPersister)

TanStack Solid Query Documentation
----------------------------------

Use the menu to select a documentation page.

[Learn about TanStack Ads](https://tanstack.com/ads)[Hide Ads](https://tanstack.com/ads#hide-ads)

[

Home



](https://tanstack.com/query/latest)

[Partners](https://tanstack.com/partners)[Become a Partner](https://docs.google.com/document/d/1Hg2MzY2TU6U3hFEZ3MLe2oEOM3JS4-eByti3kdJU3I8)

[](https://coderabbit.link/tanstack?utm_source=tanstack&via=tanstack)[](https://www.cloudflare.com/?utm_source=tanstack)[](https://ag-grid.com/react-data-grid/?utm_source=reacttable&utm_campaign=githubreacttable)[](https://netlify.com/?utm_source=tanstack)[](https://neon.tech/?utm_source=tanstack)[](https://workos.com/?utm_source=tanstack)[](https://go.clerk.com/wOwHtuJ)[](https://convex.dev/?utm_source=tanstack)[](https://electric-sql.com/)[](https://sentry.io/?utm_source=tanstack)[](https://www.prisma.io/?utm_source=tanstack&via=tanstack)[](https://strapi.link/tanstack-start)[](https://www.unkey.com/?utm_source=tanstack)

[Learn about TanStack Ads](https://tanstack.com/ads)[Hide Ads](https://tanstack.com/ads#hide-ads)

[

###### Want to Skip the Docs?

Query.gg - The Official React Query Course

Black Friday Sale
-----------------

Get 50% off through December 6th

01

days

:

22

hours

:

51

minutes









](https://query.gg/?s=tanstack)</content>
</page>

<page>
  <title>Ensure correct order of inference-sensitive properties in useMutation() | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/eslint/mutation-property-order</url>
  <content>For the following functions, the property order of the passed in object matters due to type inference:

*   useMutation()

The correct property order is as follows:

*   onMutate
*   onError
*   onSettled

All other properties are insensitive to the order as they do not depend on type inference.

[](#rule-details)[Rule Details](#rule-details)
----------------------------------------------

Examples of **incorrect** code for this rule:

    /* eslint "@tanstack/query/mutation-property-order": "warn" */
    import { useMutation } from '@tanstack/react-query'
    
    const mutation = useMutation({
      mutationFn: () => Promise.resolve('success'),
      onSettled: () => {
        results.push('onSettled-promise')
        return Promise.resolve('also-ignored') // Promise<string> (should be ignored)
      },
      onMutate: async () => {
        results.push('onMutate-async')
        await sleep(1)
        return { backup: 'async-data' }
      },
      onError: async () => {
        results.push('onError-async-start')
        await sleep(1)
        results.push('onError-async-end')
      },
    })
    

    /* eslint "@tanstack/query/mutation-property-order": "warn" */
    import { useMutation } from '@tanstack/react-query'
    
    const mutation = useMutation({
      mutationFn: () => Promise.resolve('success'),
      onSettled: () => {
        results.push('onSettled-promise')
        return Promise.resolve('also-ignored') // Promise<string> (should be ignored)
      },
      onMutate: async () => {
        results.push('onMutate-async')
        await sleep(1)
        return { backup: 'async-data' }
      },
      onError: async () => {
        results.push('onError-async-start')
        await sleep(1)
        results.push('onError-async-end')
      },
    })
    

Examples of **correct** code for this rule:

    /* eslint "@tanstack/query/mutation-property-order": "warn" */
    import { useMutation } from '@tanstack/react-query'
    
    const mutation = useMutation({
      mutationFn: () => Promise.resolve('success'),
      onMutate: async () => {
        results.push('onMutate-async')
        await sleep(1)
        return { backup: 'async-data' }
      },
      onError: async () => {
        results.push('onError-async-start')
        await sleep(1)
        results.push('onError-async-end')
      },
      onSettled: () => {
        results.push('onSettled-promise')
        return Promise.resolve('also-ignored') // Promise<string> (should be ignored)
      },
    })
    

    /* eslint "@tanstack/query/mutation-property-order": "warn" */
    import { useMutation } from '@tanstack/react-query'
    
    const mutation = useMutation({
      mutationFn: () => Promise.resolve('success'),
      onMutate: async () => {
        results.push('onMutate-async')
        await sleep(1)
        return { backup: 'async-data' }
      },
      onError: async () => {
        results.push('onError-async-start')
        await sleep(1)
        results.push('onError-async-end')
      },
      onSettled: () => {
        results.push('onSettled-promise')
        return Promise.resolve('also-ignored') // Promise<string> (should be ignored)
      },
    })
    

[](#attributes)[Attributes](#attributes)
----------------------------------------

*   ‚úÖ Recommended
*   üîß Fixable</content>
</page>

<page>
  <title>Overview | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/overview</url>
  <content>TanStack Query (formerly known as Vue Query) is often described as the missing data-fetching library for web applications, but in more technical terms, it makes **fetching, caching, synchronizing and updating server state** in your web applications a breeze.

[](#motivation)[Motivation](#motivation)
----------------------------------------

Most core web frameworks **do not** come with an opinionated way of fetching or updating data in a holistic way. Because of this developers end up building either meta-frameworks which encapsulate strict opinions about data-fetching, or they invent their own ways of fetching data. This usually means cobbling together component-based state and side-effects, or using more general purpose state management libraries to store and provide asynchronous data throughout their apps.

While most traditional state management libraries are great for working with client state, they are **not so great at working with async or server state**. This is because **server state is totally different**. For starters, server state:

*   Is persisted remotely in a location you may not control or own
*   Requires asynchronous APIs for fetching and updating
*   Implies shared ownership and can be changed by other people without your knowledge
*   Can potentially become "out of date" in your applications if you're not careful

Once you grasp the nature of server state in your application, **even more challenges will arise** as you go, for example:

*   Caching... (possibly the hardest thing to do in programming)
*   Deduping multiple requests for the same data into a single request
*   Updating "out of date" data in the background
*   Knowing when data is "out of date"
*   Reflecting updates to data as quickly as possible
*   Performance optimizations like pagination and lazy loading data
*   Managing memory and garbage collection of server state
*   Memoizing query results with structural sharing

If you're not overwhelmed by that list, then that must mean that you've probably solved all of your server state problems already and deserve an award. However, if you are like a vast majority of people, you either have yet to tackle all or most of these challenges and we're only scratching the surface!

TanStack Query is hands down one of the _best_ libraries for managing server state. It works amazingly well **out-of-the-box, with zero-config, and can be customized** to your liking as your application grows.

TanStack Query allows you to defeat and overcome the tricky challenges and hurdles of _server state_ and control your app data before it starts to control you.

On a more technical note, TanStack Query will likely:

*   Help you remove **many** lines of complicated and misunderstood code from your application and replace with just a handful of lines of TanStack Query logic
*   Make your application more maintainable and easier to build new features without worrying about wiring up new server state data sources
*   Have a direct impact on your end-users by making your application feel faster and more responsive than ever before
*   Potentially help you save on bandwidth and increase memory performance

[](#you-talked-me-into-it-so-what-now)[You talked me into it, so what now?](#you-talked-me-into-it-so-what-now)
---------------------------------------------------------------------------------------------------------------

*   Learn Vue Query at your own pace with our amazingly thorough [Walkthrough Guide](https://tanstack.com/query/latest/docs/framework/vue/installation) and [API Reference](https://tanstack.com/query/latest/docs/framework/vue/reference/useQuery)</content>
</page>

<page>
  <title>Installation | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/installation</url>
  <content>You can install Vue Query via [NPM](https://npmjs.com/).

### [](#npm)[NPM](#npm)

    npm i @tanstack/vue-query
    

    npm i @tanstack/vue-query
    

or

    pnpm add @tanstack/vue-query
    

    pnpm add @tanstack/vue-query
    

or

    yarn add @tanstack/vue-query
    

    yarn add @tanstack/vue-query
    

or

    bun add @tanstack/vue-query
    

    bun add @tanstack/vue-query
    

> Wanna give it a spin before you download? Try out the [basic](https://tanstack.com/query/latest/docs/framework/vue/examples/basic) example!

Vue Query is compatible with Vue 2.x and 3.x

> If you are using Vue 2.6, make sure to also setup [@vue/composition-api](https://github.com/vuejs/composition-api)

### [](#vue-query-initialization)[Vue Query Initialization](#vue-query-initialization)

Before using Vue Query, you need to initialize it using VueQueryPlugin

    import { VueQueryPlugin } from '@tanstack/vue-query'
    
    app.use(VueQueryPlugin)
    

    import { VueQueryPlugin } from '@tanstack/vue-query'
    
    app.use(VueQueryPlugin)
    

### [](#use-of-composition-api-with-script-setup)[Use of Composition API with <script setup>](#use-of-composition-api-with-script-setup)

All examples in our documentation use [<script setup>](https://staging.vuejs.org/api/sfc-script-setup.html) syntax.

Vue 2 users can also use that syntax using [this plugin](https://github.com/antfu/unplugin-vue2-script-setup). Please check the plugin documentation for installation details.

If you are not a fan of <script setup> syntax, you can easily translate all the examples into normal Composition API syntax by moving the code under setup() function and returning the values used in the template.

    <script setup>
    import { useQuery } from '@tanstack/vue-query'
    
    const { isPending, isFetching, isError, data, error } = useQuery({
      queryKey: ['todos'],
      queryFn: getTodos,
    })
    </script>
    
    <template>...</template>
    

    <script setup>
    import { useQuery } from '@tanstack/vue-query'
    
    const { isPending, isFetching, isError, data, error } = useQuery({
      queryKey: ['todos'],
      queryFn: getTodos,
    })
    </script>
    
    <template>...</template></content>
</page>

<page>
  <title>Quick Start | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/quick-start</url>
  <content>This code snippet very briefly illustrates the 3 core concepts of Vue Query:

*   [Queries](https://tanstack.com/query/latest/docs/framework/vue/guides/queries)
*   [Mutations](https://tanstack.com/query/latest/docs/framework/vue/guides/mutations)
*   [Query Invalidation](https://tanstack.com/query/latest/docs/framework/vue/guides/query-invalidation)

If you're looking for a fully functioning example, please have a look at our [basic codesandbox example](https://tanstack.com/query/latest/docs/framework/vue/examples/basic)

    <script setup>
    import { useQueryClient, useQuery, useMutation } from '@tanstack/vue-query'
    
    // Access QueryClient instance
    const queryClient = useQueryClient()
    
    // Query
    const { isPending, isError, data, error } = useQuery({
      queryKey: ['todos'],
      queryFn: getTodos,
    })
    
    // Mutation
    const mutation = useMutation({
      mutationFn: postTodo,
      onSuccess: () => {
        // Invalidate and refetch
        queryClient.invalidateQueries({ queryKey: ['todos'] })
      },
    })
    
    function onButtonClick() {
      mutation.mutate({
        id: Date.now(),
        title: 'Do Laundry',
      })
    }
    </script>
    
    <template>
      <span v-if="isPending">Loading...</span>
      <span v-else-if="isError">Error: {{ error.message }}</span>
      <!-- We can assume by this point that `isSuccess === true` -->
      <ul v-else>
        <li v-for="todo in data" :key="todo.id">{{ todo.title }}</li>
      </ul>
      <button @click="onButtonClick">Add Todo</button>
    </template>
    

    <script setup>
    import { useQueryClient, useQuery, useMutation } from '@tanstack/vue-query'
    
    // Access QueryClient instance
    const queryClient = useQueryClient()
    
    // Query
    const { isPending, isError, data, error } = useQuery({
      queryKey: ['todos'],
      queryFn: getTodos,
    })
    
    // Mutation
    const mutation = useMutation({
      mutationFn: postTodo,
      onSuccess: () => {
        // Invalidate and refetch
        queryClient.invalidateQueries({ queryKey: ['todos'] })
      },
    })
    
    function onButtonClick() {
      mutation.mutate({
        id: Date.now(),
        title: 'Do Laundry',
      })
    }
    </script>
    
    <template>
      <span v-if="isPending">Loading...</span>
      <span v-else-if="isError">Error: {{ error.message }}</span>
      <!-- We can assume by this point that `isSuccess === true` -->
      <ul v-else>
        <li v-for="todo in data" :key="todo.id">{{ todo.title }}</li>
      </ul>
      <button @click="onButtonClick">Add Todo</button>
    </template>
    

These three concepts make up most of the core functionality of Vue Query. The next sections of the documentation will go over each of these core concepts in great detail.</content>
</page>

<page>
  <title>GraphQL | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/graphql</url>
  <content>Because Vue Query's fetching mechanisms are agnostically built on Promises, you can use Vue Query with literally any asynchronous data fetching client, including GraphQL!

> Keep in mind that Vue Query does not support normalized caching. While a vast majority of users do not actually need a normalized cache or even benefit from it as much as they believe they do, there may be very rare circumstances that may warrant it so be sure to check with us first to make sure it's truly something you need!</content>
</page>

<page>
  <title>TypeScript | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/typescript</url>
  <content>Vue Query is now written in **TypeScript** to make sure the library and your projects are type-safe!

Things to keep in mind:

*   Types currently require using TypeScript **v4.7** or greater
*   Changes to types in this repository are considered **non-breaking** and are usually released as **patch** semver changes (otherwise every type enhancement would be a major version!).
*   It is **highly recommended that you lock your vue-query package version to a specific patch release and upgrade with the expectation that types may be fixed or upgraded between any release**
*   The non-type-related public API of Vue Query still follows semver very strictly.

[](#type-inference)[Type Inference](#type-inference)
----------------------------------------------------

Types in Vue Query generally flow through very well so that you don't have to provide type annotations for yourself

    const { data } = useQuery({
      //    ^? const data: Ref<number> | Ref<undefined>
      queryKey: ['test'],
      queryFn: () => Promise.resolve(5),
    })
    

    const { data } = useQuery({
      //    ^? const data: Ref<number> | Ref<undefined>
      queryKey: ['test'],
      queryFn: () => Promise.resolve(5),
    })
    

[typescript playground](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgVwM4FMCKz1QJ5wC+cAZlBCHAOQACMAhgHaoMDGA1gPQBuOAtAEcc+KgFgAUBNYRm8JABN6DInAC8KDNlx4AFAglw4nTocMA9APwG4Q7QGl0eAFxwA2lRjoWVALoAaa1t8ADFGFx0ASjUAPjgABXIQYAwAOigvCAAbbnQdAFYIgPFCCKA)

    const { data } = useQuery({
      //      ^? const data: Ref<string> | Ref<undefined>
      queryKey: ['test'],
      queryFn: () => Promise.resolve(5),
      select: (data) => data.toString(),
    })
    

    const { data } = useQuery({
      //      ^? const data: Ref<string> | Ref<undefined>
      queryKey: ['test'],
      queryFn: () => Promise.resolve(5),
      select: (data) => data.toString(),
    })
    

[typescript playground](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgVwM4FMCKz1QJ5wC+cAZlBCHAOQACMAhgHaoMDGA1gPQBuOAtAEcc+KgFgAUBNYRm8JABN6DInAC8KDNlx4AFAglw4nTodNwAegH4DcIdoDS6PAC44AbSox0LKgF0ANDZ2+ABijK46AJRqAHxwAArkIMAYAHRQ3hAANtzoOgCskYHihhhZ6KwwEYoM0apxNfSpMBAAyjBQwIwA5lHFhJFAA)

This works best if your queryFn has a well-defined returned type. Keep in mind that most data fetching libraries return any per default, so make sure to extract it to a properly typed function:

    const fetchGroups = (): Promise<Group[]> =>
      axios.get('/groups').then((response) => response.data)
    
    const { data } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })
    //      ^? const data: Ref<Group[]> | Ref<undefined>
    

    const fetchGroups = (): Promise<Group[]> =>
      axios.get('/groups').then((response) => response.data)
    
    const { data } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })
    //      ^? const data: Ref<Group[]> | Ref<undefined>
    

[typescript playground](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgVwM4FMCKz1QJ5wC+cAZlBCHAOQACMAhgHaoMDGA1gPQBuOAtAEcc+KgFgAUKEiw49AB7AIqUuUpV5i1GPESYeMOjgBxcsjBwAvIjjAAJgC44jZCABGuIhImsIzeCXQYVgALEwgzZSsACgBKRwAFVWAMAB4wswBtAF0APksciThZBSUAOgBzQKiqTnLTMC0Y0phg9EYoqKh0VEhmdBj8uC6e3wxS23oGGK9xHz9rCYYiSxQMbFw8KKQhDYBpdDxHDKo68IaqLIAaOB38ADFGRwCg0PrlQmnxTk4i37gAPQA-EA)

[](#type-narrowing)[Type Narrowing](#type-narrowing)
----------------------------------------------------

Vue Query uses a [discriminated union type](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#discriminated-unions) for the query result, discriminated by the status field and the derived status boolean flags. This will allow you to check for e.g. success status to make data defined:

    const { data, isSuccess } = reactive(
      useQuery({
        queryKey: ['test'],
        queryFn: () => Promise.resolve(5),
      }),
    )
    
    if (isSuccess) {
      data
      // ^? const data: number
    }
    

    const { data, isSuccess } = reactive(
      useQuery({
        queryKey: ['test'],
        queryFn: () => Promise.resolve(5),
      }),
    )
    
    if (isSuccess) {
      data
      // ^? const data: number
    }
    

[typescript playground](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgVwM4FMCKz1QJ5wC+cAZlBCHAOQACMAhgHaoMDGA1gPQBuOAtAEcc+KgFgAUKEixEcKOnqsYwbuiKlylKr3RUA3BImsIzeEgAm9BgBo4wVAGVkrVulSp1AXjkKlK9AAUaFjCeAEA2lQwbjBUALq2AQCUcJ4AfHAACpr26AB08qgQADaqAQCsSVWGkiRwAfZOLm6oKQgScJ1wlgwSnJydAHoA-BKEEkA)

[](#typing-the-error-field)[Typing the error field](#typing-the-error-field)
----------------------------------------------------------------------------

The type for error defaults to Error, because that is what most users expect.

    const { error } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })
    //      ^? const error: Ref<unknown>
    
    if (error.value instanceof Error) {
      error.value
      //     ^? const error: Error
    }
    

    const { error } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })
    //      ^? const error: Ref<unknown>
    
    if (error.value instanceof Error) {
      error.value
      //     ^? const error: Error
    }
    

[typescript playground](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgVwM4FMCKz1QJ5wC+cAZlBCHAOQACMAhgHaoMDGA1gPRTr2swBaAI458VALAAoUJFhx6AD2ARUpcpSqLlqCZKkw8YdHADi5ZGDgBeRHGAATAFxxGyEACNcRKVNYRm8CToMKwAFmYQFqo2ABQAlM4ACurAGAA8ERYA2gC6AHzWBVoqAHQA5sExVJxl5mA6cSUwoeiMMTyokMzGVgUdXRgl9vQMcT6SfgG2uORQRNYoGNi4eDFIIisA0uh4zllUtZH1VDkANHAb+ABijM5BIeF1qoRjkpyccJ9fAHoA-OPAEhwGLFVAlVIAQSUKgAolBZjEZtA4nFEFJPkioOi4O84H8pIQgA)

If you want to throw a custom error, or something that isn't an Error at all, you can specify the type of the error field:

However, this has the drawback that type inference for all other generics of useQuery will not work anymore. It is generally not considered a good practice to throw something that isn't an Error, so if you have a subclass like AxiosError you can use _type narrowing_ to make the error field more specific:

### [](#registering-a-global-error)[Registering a global Error](#registering-a-global-error)

TanStack Query v5 allows for a way to set a global Error type for everything, without having to specify generics on call-sides, by amending the Register interface. This will make sure inference still works, but the error field will be of the specified type. If you want to enforce that call-sides must do explicit type-narrowing, set defaultError to unknown:

    import '@tanstack/vue-query'
    
    declare module '@tanstack/vue-query' {
      interface Register {
        // Use unknown so call sites must narrow explicitly.
        defaultError: unknown
      }
    }
    
    const { error } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })
    //      ^? const error: unknown | null
    

    import '@tanstack/vue-query'
    
    declare module '@tanstack/vue-query' {
      interface Register {
        // Use unknown so call sites must narrow explicitly.
        defaultError: unknown
      }
    }
    
    const { error } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })
    //      ^? const error: unknown | null
    

[](#typing-query-and-mutation-keys)[Typing query and mutation keys](#typing-query-and-mutation-keys)
----------------------------------------------------------------------------------------------------

### [](#registering-the-query-and-mutation-key-types)[Registering the query and mutation key types](#registering-the-query-and-mutation-key-types)

Also similarly to registering a [global error type](#registering-a-global-error), you can also register a global QueryKey and MutationKey type. This allows you to provide more structure to your keys, that matches your application's hierarchy, and have them be typed across all of the library's surface area. Note that the registered type must extend the Array type, so that your keys remain an array.

    import '@tanstack/vue-query'
    
    type QueryKey = ['dashboard' | 'marketing', ...ReadonlyArray<unknown>]
    
    declare module '@tanstack/vue-query' {
      interface Register {
        queryKey: QueryKey
        mutationKey: QueryKey
      }
    }
    

    import '@tanstack/vue-query'
    
    type QueryKey = ['dashboard' | 'marketing', ...ReadonlyArray<unknown>]
    
    declare module '@tanstack/vue-query' {
      interface Register {
        queryKey: QueryKey
        mutationKey: QueryKey
      }
    }
    

[](#typesafe-disabling-of-queries-using-skiptoken)[Typesafe disabling of queries using skipToken](#typesafe-disabling-of-queries-using-skiptoken)
-------------------------------------------------------------------------------------------------------------------------------------------------

If you are using TypeScript, you can use the skipToken to disable a query. This is useful when you want to disable a query based on a condition, but you still want to keep the query to be type safe. Read more about it in the [Disabling Queries](https://tanstack.com/query/latest/docs/framework/vue/guides/disabling-queries) guide.</content>
</page>

<page>
  <title>Reactivity | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/reactivity</url>
  <content>Vue uses the [the signals paradigm](https://vuejs.org/guide/extras/reactivity-in-depth.html#connection-to-signals) to handle and track reactivity. A key feature of this system is the reactive system only triggers updates on specifically watched reactive properties. A consequence of this is you also need to ensure that the queries are updated when values they consume are updated.

[](#keeping-queries-reactive)[Keeping Queries Reactive](#keeping-queries-reactive)
----------------------------------------------------------------------------------

When creating a composable for a query your first choice may be to write it like so:

    export function useUserProjects(userId: string) {
      return useQuery(
        queryKey: ['userProjects', userId],
        queryFn: () => api.fetchUserProjects(userId),
      );
    }
    

    export function useUserProjects(userId: string) {
      return useQuery(
        queryKey: ['userProjects', userId],
        queryFn: () => api.fetchUserProjects(userId),
      );
    }
    

We might consume this composable like so:

    // Reactive user ID ref.
    const userId = ref('1')
    // Fetches the user 1's projects.
    const { data: projects } = useUserProjects(userId.value)
    
    const onChangeUser = (newUserId: string) => {
      // Edits the userId, but the query will not re-fetch.
      userId.value = newUserId
    }
    

    // Reactive user ID ref.
    const userId = ref('1')
    // Fetches the user 1's projects.
    const { data: projects } = useUserProjects(userId.value)
    
    const onChangeUser = (newUserId: string) => {
      // Edits the userId, but the query will not re-fetch.
      userId.value = newUserId
    }
    

This code will not work as intended. This is because we are extracting the value from the userId ref directly. Vue-query is not tracking the userId ref so it has no way of knowing when the value changes.

Luckily, the fix for this is trivial. The value must be made trackable in the query key. We can Just accept the ref directly in the composable and place it in the query key:

    export function useUserProjects(userId: Ref<string>) {
      return useQuery(
        queryKey: ['userProjects', userId],
        queryFn: () => api.fetchUserProjects(userId.value),
      );
    }
    

    export function useUserProjects(userId: Ref<string>) {
      return useQuery(
        queryKey: ['userProjects', userId],
        queryFn: () => api.fetchUserProjects(userId.value),
      );
    }
    

Now the query will re-fetch when the userId changes.

    const onChangeUser = (newUserId: string) => {
      // Query refetches data with new user ID!
      userId.value = newUserId
    }
    

    const onChangeUser = (newUserId: string) => {
      // Query refetches data with new user ID!
      userId.value = newUserId
    }
    

In vue query any reactive properties within a query key are tracked for changes automatically. This allows vue-query to refetch data whenever the parameters for a given request change.

[](#accounting-for-non-reactive-queries)[Accounting for Non-Reactive Queries](#accounting-for-non-reactive-queries)
-------------------------------------------------------------------------------------------------------------------

While far less likely, sometimes passing non-reactive variables is intentional. For example, some entities only need to be fetched once and don't need tracking or we invalidate a mutation a query options object after a mutation. If we use our custom composable defined above the usage in this case feels a bit off:

    const { data: projects } = useUserProjects(ref('1'))
    

    const { data: projects } = useUserProjects(ref('1'))
    

We have to create an intermediate ref just to make the parameter type-compatible. We can do better here. Let's instead update our composable to accept both plain values and reactive values:

    export function useUserProjects(userId: MaybeRef<string>) {
      return useQuery(
        queryKey: ['userProjects', userId],
        queryFn: () => api.fetchUserProjects(toValue(userId)),
      );
    }
    

    export function useUserProjects(userId: MaybeRef<string>) {
      return useQuery(
        queryKey: ['userProjects', userId],
        queryFn: () => api.fetchUserProjects(toValue(userId)),
      );
    }
    

Now we can use the composable with both plain values and refs:

    // Fetches the user 1's projects, userId is not expected to change.
    const { data: projects } = useUserProjects('1')
    
    // Fetches the user 1's projects, queries will react to changes on userId.
    const userId = ref('1')
    
    // Make some changes to userId...
    
    // Query re-fetches based on any changes to userId.
    const { data: projects } = useUserProjects(userId)
    

    // Fetches the user 1's projects, userId is not expected to change.
    const { data: projects } = useUserProjects('1')
    
    // Fetches the user 1's projects, queries will react to changes on userId.
    const userId = ref('1')
    
    // Make some changes to userId...
    
    // Query re-fetches based on any changes to userId.
    const { data: projects } = useUserProjects(userId)
    

[](#using-derived-state-inside-queries)[Using Derived State inside Queries](#using-derived-state-inside-queries)
----------------------------------------------------------------------------------------------------------------

It's quite common to derive some new reactive state from another source of reactive state. Commonly, this problem manifests in situations where you deal with component props. Let's assume our userId is a prop passed to a component:

    <script setup lang="ts">
    const props = defineProps<{
      userId: string
    }>()
    </script>
    

    <script setup lang="ts">
    const props = defineProps<{
      userId: string
    }>()
    </script>
    

You may be tempted to use the prop directly in the query like so:

    // Won't react to changes in props.userId.
    const { data: projects } = useUserProjects(props.userId)
    

    // Won't react to changes in props.userId.
    const { data: projects } = useUserProjects(props.userId)
    

However, similar to the first example, this is not reactive. Property access on reactive variables causes reactivity to be lost. We can fix this by making this derived state reactive via a computed:

    const userId = computed(() => props.userId)
    
    // Reacts to changes in props.userId.
    const { data: projects } = useUserProjects(userId)
    

    const userId = computed(() => props.userId)
    
    // Reacts to changes in props.userId.
    const { data: projects } = useUserProjects(userId)
    

This works as expected, however, this solution isn't always the most optimal. Aside from the introduction of an intermediate variable, we also create a memoized value that is somewhat unnecessary. For trivial cases of simple property access computed is an optimization with no real benefit. In these cases a more appropriate solution is to use [reactive getters](https://blog.vuejs.org/posts/vue-3-3#better-getter-support-with-toref-and-tovalue). Reactive getters are simply functions that return a value based on some reactive state, similar to how computed works. Unlike computed, reactive getters do not memoize their values so it makes it a good candidate for simple property access.

Let's once again refactor our composable, but this time we'll have it accept a ref, plain value, or a reactive getter:

    export function useUserProjects(userId: MaybeRefOrGetter<string>) {
      ...
    }
    

    export function useUserProjects(userId: MaybeRefOrGetter<string>) {
      ...
    }
    

Let's adjust our usage and now use a reactive getter:

    // Reacts to changes in props.userId. No `computed` needed!
    const { data: projects } = useUserProjects(() => props.userId)
    

    // Reacts to changes in props.userId. No `computed` needed!
    const { data: projects } = useUserProjects(() => props.userId)
    

This gives us a terse syntax and the reactivity we need without any unneeded memoization overhead.

[](#other-tracked-query-options)[Other tracked Query Options](#other-tracked-query-options)
-------------------------------------------------------------------------------------------

Above, we only touched one query option that tracks reactive dependencies. However, in addition to queryKey, enabled also allows the use of reactive values. This comes in handy in situations where you want to control the fetching of a query based on some derived state:

    export function useUserProjects(userId: MaybeRef<string>) {
      return useQuery(
        queryKey: ['userProjects', userId],
        queryFn: () => api.fetchUserProjects(toValue(userId)),
        enabled: () => userId.value === activeUserId.value,
      );
    }
    

    export function useUserProjects(userId: MaybeRef<string>) {
      return useQuery(
        queryKey: ['userProjects', userId],
        queryFn: () => api.fetchUserProjects(toValue(userId)),
        enabled: () => userId.value === activeUserId.value,
      );
    }
    

More details on this option can be found on the [useQuery reference](https://tanstack.com/query/latest/docs/framework/vue/reference/useQuery) page.

[](#immutability)[Immutability](#immutability)
----------------------------------------------

Results from useQuery are always immutable. This is necessary for performance and caching purposes. If you need to mutate a value returned from useQuery, you must create a copy of the data.

One implication of this design is that passing values from useQuery to a two-way binding such as v-model will not work. You must create a mutable copy of the data before attempting to update it in place.

[](#key-takeaways)[Key Takeaways](#key-takeaways)
-------------------------------------------------

*   enabled and queryKey are the two query options that can accept reactive values.
*   Pass query option that accept all three types of values in Vue: refs, plain values, and reactive getters.
*   If you expect a query to react to changes based on the values it consumes, ensure that the values are reactive. (i.e. pass in refs directly to the query, or use reactive getters)
*   If you don't need a query to be reactive pass in a plain value.
*   For trivial derived state such as property access consider using a reactive getter in place of a computed.
*   Results from useQuery are always immutable.</content>
</page>

<page>
  <title>Devtools | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/devtools</url>
  <content>Wave your hands in the air and shout hooray because Vue Query comes with dedicated devtools! ü•≥

When you begin your Vue Query journey, you'll want these devtools by your side. They help visualize all of the inner workings of Vue Query and will likely save you hours of debugging if you find yourself in a pinch!

> For Chrome, Firefox, and Edge users: Third-party browser extensions are available for debugging TanStack Query directly in browser DevTools. These provide the same functionality as the framework-specific devtools packages:
> 
> *   [Devtools for Chrome](https://chromewebstore.google.com/detail/tanstack-query-devtools/annajfchloimdhceglpgglpeepfghfai)
> *   [Devtools for Firefox](https://addons.mozilla.org/en-US/firefox/addon/tanstack-query-devtools/)
> *   [Devtools for Edge](https://microsoftedge.microsoft.com/addons/detail/tanstack-query-devtools/edmdpkgkacmjopodhfolmphdenmddobj)

You can directly integrate the devtools component into your page using a dedicated package. Component-based devtools use a framework-agnostic implementation and are always up-to-date.

The devtools component is a separate package that you need to install:

    npm i @tanstack/vue-query-devtools
    

    npm i @tanstack/vue-query-devtools
    

or

    pnpm add @tanstack/vue-query-devtools
    

    pnpm add @tanstack/vue-query-devtools
    

or

    yarn add @tanstack/vue-query-devtools
    

    yarn add @tanstack/vue-query-devtools
    

or

    bun add @tanstack/vue-query-devtools
    

    bun add @tanstack/vue-query-devtools
    

By default, Vue Query Devtools are only included in bundles when process.env.NODE\_ENV === 'development', so you don't need to worry about excluding them during a production build.

[](#floating-mode)[Floating Mode](#floating-mode)
-------------------------------------------------

Devtools will be mounted as a fixed, floating element in your app and provide a toggle in the corner of the screen to show and hide the devtools. This toggle state will be stored and remembered in localStorage across reloads.

Place the following code as high in your Vue app as you can. The closer it is to the root of the page, the better it will work!

    <script setup>
    import { VueQueryDevtools } from '@tanstack/vue-query-devtools'
    </script>
    
    <template>
      <h1>The app!</h1>
      <VueQueryDevtools />
    </template>
    

    <script setup>
    import { VueQueryDevtools } from '@tanstack/vue-query-devtools'
    </script>
    
    <template>
      <h1>The app!</h1>
      <VueQueryDevtools />
    </template>
    

### [](#options)[Options](#options)

*   initialIsOpen: boolean
    *   Set this true if you want the dev tools to default to being open.
*   buttonPosition?: "top-left" | "top-right" | "bottom-left" | "bottom-right"
    *   Defaults to bottom-right.
    *   The position of the React Query logo to open and close the devtools panel.
*   position?: "top" | "bottom" | "left" | "right"
    *   Defaults to bottom.
    *   The position of the React Query devtools panel.
*   client?: QueryClient
    *   Use this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.
*   errorTypes?: { name: string; initializer: (query: Query) => TError}
    *   Use this to predefine some errors that can be triggered on your queries. The initializer will be called (with the specific query) when that error is toggled on from the UI. It must return an Error.
*   styleNonce?: string
    *   Use this to pass a nonce to the style tag that is added to the document head. This is useful if you are using a Content Security Policy (CSP) nonce to allow inline styles.
*   shadowDOMTarget?: ShadowRoot
    *   Default behavior will apply the devtool's styles to the head tag within the DOM.
    *   Use this to pass a shadow DOM target to the devtools so that the styles will be applied within the shadow DOM instead of within the head tag in the light DOM.

[](#embedded-mode)[Embedded Mode](#embedded-mode)
-------------------------------------------------

Embedded mode will show the development tools as a fixed element in your application, so you can use our panel in your own development tools.

Place the following code as high in your React app as you can. The closer it is to the root of the page, the better it will work!

    <script setup>
    import { VueQueryDevtoolsPanel } from '@tanstack/vue-query-devtools'
    const isDevtoolsOpen = ref(false)
    function toggleDevtools() {
      isDevtoolsOpen.value = !isDevtoolsOpen.value
    }
    </script>
    
    <template>
      <h1>The app!</h1>
      <button @click="toggleDevtools">Open Devtools</button>
      <VueQueryDevtoolsPanel v-if="isDevtoolsOpen" :onClose="toggleDevtools" />
    </template>
    

    <script setup>
    import { VueQueryDevtoolsPanel } from '@tanstack/vue-query-devtools'
    const isDevtoolsOpen = ref(false)
    function toggleDevtools() {
      isDevtoolsOpen.value = !isDevtoolsOpen.value
    }
    </script>
    
    <template>
      <h1>The app!</h1>
      <button @click="toggleDevtools">Open Devtools</button>
      <VueQueryDevtoolsPanel v-if="isDevtoolsOpen" :onClose="toggleDevtools" />
    </template>
    

### [](#options-1)[Options](#options-1)

*   style?: React.CSSProperties
    *   Custom styles for the devtools panel
    *   Default: { height: '500px' }
    *   Example: { height: '100%' }
    *   Example: { height: '100%', width: '100%' }
*   onClose?: () => unknown
    *   Callback function that is called when the devtools panel is closed
*   client?: QueryClient,
    *   Use this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.
*   errorTypes?: { name: string; initializer: (query: Query) => TError}\[\]
    *   Use this to predefine some errors that can be triggered on your queries. Initializer will be called (with the specific query) when that error is toggled on from the UI. It must return an Error.
*   styleNonce?: string
    *   Use this to pass a nonce to the style tag that is added to the document head. This is useful if you are using a Content Security Policy (CSP) nonce to allow inline styles.
*   shadowDOMTarget?: ShadowRoot
    *   Default behavior will apply the devtool's styles to the head tag within the DOM.
    *   Use this to pass a shadow DOM target to the devtools so that the styles will be applied within the shadow DOM instead of within the head tag in the light DOM.

Vue Query will seamlessly integrate with the [Official Vue devtools](https://github.com/vuejs/devtools-next), adding custom inspector and timeline events. Devtool code will be treeshaken from production bundles by default.

To make it work, you only need to enable it in the plugin options:

    app.use(VueQueryPlugin, {
      enableDevtoolsV6Plugin: true,
    })
    

    app.use(VueQueryPlugin, {
      enableDevtoolsV6Plugin: true,
    })
    

Both v6 and v7 versions of devtools are supported.</content>
</page>

<page>
  <title>Queries | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/guides/queries</url>
  <content>[](#query-basics)[Query Basics](#query-basics)
----------------------------------------------

A query is a declarative dependency on an asynchronous source of data that is tied to a **unique key**. A query can be used with any Promise based method (including GET and POST methods) to fetch data from a server. If your method modifies data on the server, we recommend using [Mutations](https://tanstack.com/query/latest/docs/framework/vue/guides/mutations) instead.

To subscribe to a query in your components or custom hooks, call the useQuery hook with at least:

*   A **unique key for the query**
*   A function that returns a promise that:
    *   Resolves the data, or
    *   Throws an error

    import { useQuery } from '@tanstack/vue-query'
    
    const result = useQuery({ queryKey: ['todos'], queryFn: fetchTodoList })
    

    import { useQuery } from '@tanstack/vue-query'
    
    const result = useQuery({ queryKey: ['todos'], queryFn: fetchTodoList })
    

The **unique key** you provide is used internally for refetching, caching, and sharing your queries throughout your application.

The query result returned by useQuery contains all of the information about the query that you'll need for templating and any other usage of the data:

    const result = useQuery({ queryKey: ['todos'], queryFn: fetchTodoList })
    

    const result = useQuery({ queryKey: ['todos'], queryFn: fetchTodoList })
    

The result object contains a few very important states you'll need to be aware of to be productive. A query can only be in one of the following states at any given moment:

*   isPending or status === 'pending' - The query has no data yet
*   isError or status === 'error' - The query encountered an error
*   isSuccess or status === 'success' - The query was successful and data is available

Beyond those primary states, more information is available depending on the state of the query:

*   error - If the query is in an isError state, the error is available via the error property.
*   data - If the query is in an isSuccess state, the data is available via the data property.
*   isFetching - In any state, if the query is fetching at any time (including background refetching) isFetching will be true.

For **most** queries, it's usually sufficient to check for the isPending state, then the isError state, then finally, assume that the data is available and render the successful state:

    <script setup>
    import { useQuery } from '@tanstack/vue-query'
    
    const { isPending, isError, data, error } = useQuery({
      queryKey: ['todos'],
      queryFn: fetchTodoList,
    })
    </script>
    
    <template>
      <span v-if="isPending">Loading...</span>
      <span v-else-if="isError">Error: {{ error.message }}</span>
      <!-- We can assume by this point that `isSuccess === true` -->
      <ul v-else-if="data">
        <li v-for="todo in data" :key="todo.id">{{ todo.title }}</li>
      </ul>
    </template>
    

    <script setup>
    import { useQuery } from '@tanstack/vue-query'
    
    const { isPending, isError, data, error } = useQuery({
      queryKey: ['todos'],
      queryFn: fetchTodoList,
    })
    </script>
    
    <template>
      <span v-if="isPending">Loading...</span>
      <span v-else-if="isError">Error: {{ error.message }}</span>
      <!-- We can assume by this point that `isSuccess === true` -->
      <ul v-else-if="data">
        <li v-for="todo in data" :key="todo.id">{{ todo.title }}</li>
      </ul>
    </template>
    

If booleans aren't your thing, you can always use the status state as well:

    <script setup>
    import { useQuery } from '@tanstack/vue-query'
    
    const { status, data, error } = useQuery({
      queryKey: ['todos'],
      queryFn: fetchTodoList,
    })
    </script>
    
    <template>
      <span v-if="status === 'pending'">Loading...</span>
      <span v-else-if="status === 'error'">Error: {{ error.message }}</span>
      <!-- also status === 'success', but "else" logic works, too -->
      <ul v-else-if="data">
        <li v-for="todo in data" :key="todo.id">{{ todo.title }}</li>
      </ul>
    </template>
    

    <script setup>
    import { useQuery } from '@tanstack/vue-query'
    
    const { status, data, error } = useQuery({
      queryKey: ['todos'],
      queryFn: fetchTodoList,
    })
    </script>
    
    <template>
      <span v-if="status === 'pending'">Loading...</span>
      <span v-else-if="status === 'error'">Error: {{ error.message }}</span>
      <!-- also status === 'success', but "else" logic works, too -->
      <ul v-else-if="data">
        <li v-for="todo in data" :key="todo.id">{{ todo.title }}</li>
      </ul>
    </template>
    

TypeScript will also narrow the type of data correctly if you've checked for pending and error before accessing it.

### [](#fetchstatus)[FetchStatus](#fetchstatus)

In addition to the status field, you will also get an additional fetchStatus property with the following options:

*   fetchStatus === 'fetching' - The query is currently fetching.
*   fetchStatus === 'paused' - The query wanted to fetch, but it is paused. Read more about this in the [Network Mode](https://tanstack.com/query/latest/docs/framework/vue/guides/network-mode) guide.
*   fetchStatus === 'idle' - The query is not doing anything at the moment.

### [](#why-two-different-states)[Why two different states?](#why-two-different-states)

Background refetches and stale-while-revalidate logic make all combinations for status and fetchStatus possible. For example:

*   a query in success status will usually be in idle fetchStatus, but it could also be in fetching if a background refetch is happening.
*   a query that mounts and has no data will usually be in pending status and fetching fetchStatus, but it could also be paused if there is no network connection.

So keep in mind that a query can be in pending state without actually fetching data. As a rule of thumb:

*   The status gives information about the data: Do we have any or not?
*   The fetchStatus gives information about the queryFn: Is it running or not?</content>
</page>

<page>
  <title>Query Keys | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/guides/query-keys</url>
  <content>At its core, TanStack Query manages query caching for you based on query keys. Query keys have to be an Array at the top level, and can be as simple as an Array with a single string, or as complex as an array of many strings and nested objects. As long as the query key is serializable using JSON.stringify, and **unique to the query's data**, you can use it!

[](#simple-query-keys)[Simple Query Keys](#simple-query-keys)
-------------------------------------------------------------

The simplest form of a key is an array with constants values. This format is useful for:

*   Generic List/Index resources
*   Non-hierarchical resources

    // A list of todos
    useQuery({ queryKey: ['todos'], ... })
    
    // Something else, whatever!
    useQuery({ queryKey: ['something', 'special'], ... })
    

    // A list of todos
    useQuery({ queryKey: ['todos'], ... })
    
    // Something else, whatever!
    useQuery({ queryKey: ['something', 'special'], ... })
    

[](#array-keys-with-variables)[Array Keys with variables](#array-keys-with-variables)
-------------------------------------------------------------------------------------

When a query needs more information to uniquely describe its data, you can use an array with a string and any number of serializable objects to describe it. This is useful for:

*   Hierarchical or nested resources
    *   It's common to pass an ID, index, or other primitive to uniquely identify the item
*   Queries with additional parameters
    *   It's common to pass an object of additional options

    // An individual todo
    useQuery({ queryKey: ['todo', 5], ... })
    
    // An individual todo in a "preview" format
    useQuery({ queryKey: ['todo', 5, { preview: true }], ...})
    
    // A list of todos that are "done"
    useQuery({ queryKey: ['todos', { type: 'done' }], ... })
    

    // An individual todo
    useQuery({ queryKey: ['todo', 5], ... })
    
    // An individual todo in a "preview" format
    useQuery({ queryKey: ['todo', 5, { preview: true }], ...})
    
    // A list of todos that are "done"
    useQuery({ queryKey: ['todos', { type: 'done' }], ... })
    

[](#query-keys-are-hashed-deterministically)[Query Keys are hashed deterministically!](#query-keys-are-hashed-deterministically)
--------------------------------------------------------------------------------------------------------------------------------

This means that no matter the order of keys in objects, all of the following queries are considered equal:

    useQuery({ queryKey: ['todos', { status, page }], ... })
    useQuery({ queryKey: ['todos', { page, status }], ...})
    useQuery({ queryKey: ['todos', { page, status, other: undefined }], ... })
    

    useQuery({ queryKey: ['todos', { status, page }], ... })
    useQuery({ queryKey: ['todos', { page, status }], ...})
    useQuery({ queryKey: ['todos', { page, status, other: undefined }], ... })
    

The following query keys, however, are not equal. Array item order matters!

    useQuery({ queryKey: ['todos', status, page], ... })
    useQuery({ queryKey: ['todos', page, status], ...})
    useQuery({ queryKey: ['todos', undefined, page, status], ...})
    

    useQuery({ queryKey: ['todos', status, page], ... })
    useQuery({ queryKey: ['todos', page, status], ...})
    useQuery({ queryKey: ['todos', undefined, page, status], ...})
    

[](#if-your-query-function-depends-on-a-variable-include-it-in-your-query-key)[If your query function depends on a variable, include it in your query key](#if-your-query-function-depends-on-a-variable-include-it-in-your-query-key)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Since query keys uniquely describe the data they are fetching, they should include any variables you use in your query function that **change**. For example:

    import type { Ref } from 'vue'
    
    function useTodos(todoId: Ref<string>) {
      const queryKey = ['todos', todoId]
      return useQuery({
        queryKey,
        queryFn: () => fetchTodoById(todoId.value),
      })
    }
    

    import type { Ref } from 'vue'
    
    function useTodos(todoId: Ref<string>) {
      const queryKey = ['todos', todoId]
      return useQuery({
        queryKey,
        queryFn: () => fetchTodoById(todoId.value),
      })
    }
    

Note that query keys act as dependencies for your query functions. Adding dependent variables to your query key will ensure that queries are cached independently, and that any time a variable changes, _queries will be refetched automatically_ (depending on your staleTime settings). See the [exhaustive-deps](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps) section for more information and examples.

[](#further-reading)[Further reading](#further-reading)
-------------------------------------------------------

For tips on organizing Query Keys in larger applications, have a look at [Effective React Query Keys](https://tkdodo.eu/blog/effective-react-query-keys) and check the [Query Key Factory Package](https://github.com/lukemorales/query-key-factory) from the [Community Resources](https://tanstack.com/query/latest/docs/community-resources).</content>
</page>

<page>
  <title>Important Defaults | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/guides/important-defaults</url>
  <content>Out of the box, TanStack Query is configured with **aggressive but sane** defaults. **Sometimes these defaults can catch new users off guard or make learning/debugging difficult if they are unknown by the user.** Keep them in mind as you continue to learn and use TanStack Query:

*   Query instances via useQuery or useInfiniteQuery by default **consider cached data as stale**.

> To change this behavior, you can configure your queries both globally and per-query using the staleTime option. Specifying a longer staleTime means queries will not refetch their data as often

*   A Query that has a staleTime set is considered **fresh** until that staleTime has elapsed.
    
    *   set staleTime to e.g. 2 \* 60 \* 1000 to make sure data is read from the cache, without triggering any kinds of refetches, for 2 minutes, or until the Query is [invalidated manually](https://tanstack.com/query/latest/docs/framework/vue/guides/query-invalidation).
    *   set staleTime to Infinity to never trigger a refetch until the Query is [invalidated manually](https://tanstack.com/query/latest/docs/framework/vue/guides/query-invalidation).
    *   set staleTime to 'static' to **never** trigger a refetch, even if the Query is [invalidated manually](https://tanstack.com/query/latest/docs/framework/vue/guides/query-invalidation).
*   Stale queries are refetched automatically in the background when:
    
    *   New instances of the query mount
    *   The window is refocused
    *   The network is reconnected

> Setting staleTime is the recommended way to avoid excessive refetches, but you can also customize the points in time for refetches by setting options like refetchOnMount, refetchOnWindowFocus and refetchOnReconnect.

*   Queries can optionally be configured with a refetchInterval to trigger refetches periodically, which is independent of the staleTime setting.
    
*   Query results that have no more active instances of useQuery, useInfiniteQuery or query observers are labeled as "inactive" and remain in the cache in case they are used again at a later time.
    
*   By default, "inactive" queries are garbage collected after **5 minutes**.
    
    > To change this, you can alter the default gcTime for queries to something other than 1000 \* 60 \* 5 milliseconds.
    
*   Queries that fail are **silently retried 3 times, with exponential backoff delay** before capturing and displaying an error to the UI.
    
    > To change this, you can alter the default retry and retryDelay options for queries to something other than 3 and the default exponential backoff function.
    
*   Query results by default are **structurally shared to detect if data has actually changed** and if not, **the data reference remains unchanged** to better help with value stabilization with regards to useMemo and useCallback. If this concept sounds foreign, then don't worry about it! 99.9% of the time you will not need to disable this and it makes your app more performant at zero cost to you.
    
    > Structural sharing only works with JSON-compatible values, any other value types will always be considered as changed. If you are seeing performance issues because of large responses for example, you can disable this feature with the config.structuralSharing flag. If you are dealing with non-JSON compatible values in your query responses and still want to detect if data has changed or not, you can provide your own custom function as config.structuralSharing to compute a value from the old and new responses, retaining references as required.</content>
</page>

<page>
  <title>Query Options | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/guides/query-options</url>
  <content>One of the best ways to share queryKey and queryFn between multiple places, yet keep them co-located to one another, is to use the queryOptions helper. At runtime, this helper just returns whatever you pass into it, but it has a lot of advantages when using it [with TypeScript](https://tanstack.com/query/latest/docs/framework/vue/typescript#typing-query-options). You can define all possible options for a query in one place, and you'll also get type inference and type safety for all of them.

    import { queryOptions } from '@tanstack/vue-query'
    
    function groupOptions(id: number) {
      return queryOptions({
        queryKey: ['groups', id],
        queryFn: () => fetchGroups(id),
        staleTime: 5 * 1000,
      })
    }
    
    // usage:
    
    useQuery(groupOptions(1))
    useSuspenseQuery(groupOptions(5))
    useQueries({
      queries: [groupOptions(1), groupOptions(2)],
    })
    queryClient.prefetchQuery(groupOptions(23))
    queryClient.setQueryData(groupOptions(42).queryKey, newGroups)
    

    import { queryOptions } from '@tanstack/vue-query'
    
    function groupOptions(id: number) {
      return queryOptions({
        queryKey: ['groups', id],
        queryFn: () => fetchGroups(id),
        staleTime: 5 * 1000,
      })
    }
    
    // usage:
    
    useQuery(groupOptions(1))
    useSuspenseQuery(groupOptions(5))
    useQueries({
      queries: [groupOptions(1), groupOptions(2)],
    })
    queryClient.prefetchQuery(groupOptions(23))
    queryClient.setQueryData(groupOptions(42).queryKey, newGroups)
    

For Infinite Queries, a separate [infiniteQueryOptions](https://tanstack.com/query/latest/docs/framework/vue/reference/infiniteQueryOptions) helper is available.

You can still override some options at the component level. A very common and useful pattern is to create per-component [select](https://tanstack.com/query/latest/docs/framework/vue/guides/render-optimizations#select) functions:

    // Type inference still works, so query.data will be the return type of select instead of queryFn
    
    const query = useQuery({
      ...groupOptions(1),
      select: (data) => data.groupName,
    })
    

    // Type inference still works, so query.data will be the return type of select instead of queryFn
    
    const query = useQuery({
      ...groupOptions(1),
      select: (data) => data.groupName,
    })</content>
</page>

<page>
  <title>Query Functions | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/guides/query-functions</url>
  <content>A query function can be literally any function that **returns a promise**. The promise that is returned should either **resolve the data** or **throw an error**.

All of the following are valid query function configurations:

    useQuery({ queryKey: ['todos'], queryFn: fetchAllTodos })
    useQuery({ queryKey: ['todos', todoId], queryFn: () => fetchTodoById(todoId) })
    useQuery({
      queryKey: ['todos', todoId],
      queryFn: async () => {
        const data = await fetchTodoById(todoId)
        return data
      },
    })
    useQuery({
      queryKey: ['todos', todoId],
      queryFn: ({ queryKey }) => fetchTodoById(queryKey[1]),
    })
    

    useQuery({ queryKey: ['todos'], queryFn: fetchAllTodos })
    useQuery({ queryKey: ['todos', todoId], queryFn: () => fetchTodoById(todoId) })
    useQuery({
      queryKey: ['todos', todoId],
      queryFn: async () => {
        const data = await fetchTodoById(todoId)
        return data
      },
    })
    useQuery({
      queryKey: ['todos', todoId],
      queryFn: ({ queryKey }) => fetchTodoById(queryKey[1]),
    })
    

[](#handling-and-throwing-errors)[Handling and Throwing Errors](#handling-and-throwing-errors)
----------------------------------------------------------------------------------------------

For TanStack Query to determine a query has errored, the query function **must throw** or return a **rejected Promise**. Any error that is thrown in the query function will be persisted on the error state of the query.

    const { error } = useQuery({
      queryKey: ['todos', todoId],
      queryFn: async () => {
        if (somethingGoesWrong) {
          throw new Error('Oh no!')
        }
        if (somethingElseGoesWrong) {
          return Promise.reject(new Error('Oh no!'))
        }
    
        return data
      },
    })
    

    const { error } = useQuery({
      queryKey: ['todos', todoId],
      queryFn: async () => {
        if (somethingGoesWrong) {
          throw new Error('Oh no!')
        }
        if (somethingElseGoesWrong) {
          return Promise.reject(new Error('Oh no!'))
        }
    
        return data
      },
    })
    

[](#usage-with-fetch-and-other-clients-that-do-not-throw-by-default)[Usage with fetch and other clients that do not throw by default](#usage-with-fetch-and-other-clients-that-do-not-throw-by-default)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

While most utilities like axios or graphql-request automatically throw errors for unsuccessful HTTP calls, some utilities like fetch do not throw errors by default. If that's the case, you'll need to throw them on your own. Here is a simple way to do that with the popular fetch API:

    useQuery({
      queryKey: ['todos', todoId],
      queryFn: async () => {
        const response = await fetch('/todos/' + todoId)
        if (!response.ok) {
          throw new Error('Network response was not ok')
        }
        return response.json()
      },
    })
    

    useQuery({
      queryKey: ['todos', todoId],
      queryFn: async () => {
        const response = await fetch('/todos/' + todoId)
        if (!response.ok) {
          throw new Error('Network response was not ok')
        }
        return response.json()
      },
    })
    

[](#query-function-variables)[Query Function Variables](#query-function-variables)
----------------------------------------------------------------------------------

Query keys are not just for uniquely identifying the data you are fetching, but are also conveniently passed into your query function as part of the QueryFunctionContext. While not always necessary, this makes it possible to extract your query functions if needed:

    const result = useQuery({
      queryKey: ['todos', { status, page }],
      queryFn: fetchTodoList,
    })
    
    // Access the key, status and page variables in your query function!
    function fetchTodoList({ queryKey }) {
      const [_key, { status, page }] = queryKey
      return new Promise()
    }
    

    const result = useQuery({
      queryKey: ['todos', { status, page }],
      queryFn: fetchTodoList,
    })
    
    // Access the key, status and page variables in your query function!
    function fetchTodoList({ queryKey }) {
      const [_key, { status, page }] = queryKey
      return new Promise()
    }
    

### [](#queryfunctioncontext)[QueryFunctionContext](#queryfunctioncontext)

The QueryFunctionContext is the object passed to each query function. It consists of:

*   queryKey: QueryKey: [Query Keys](https://tanstack.com/query/latest/docs/framework/vue/guides/query-keys)
*   client: QueryClient: [QueryClient](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   signal?: AbortSignal
    *   [AbortSignal](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) instance provided by TanStack Query
    *   Can be used for [Query Cancellation](https://tanstack.com/query/latest/docs/framework/vue/guides/query-cancellation)
*   meta: Record<string, unknown> | undefined
    *   an optional field you can fill with additional information about your query

Additionally, [Infinite Queries](https://tanstack.com/query/latest/docs/framework/vue/guides/infinite-queries) get the following options passed:

*   pageParam: TPageParam
    *   the page parameter used to fetch the current page
*   direction: 'forward' | 'backward'
    *   **deprecated**
    *   the direction of the current page fetch
    *   To get access to the direction of the current page fetch, please add a direction to pageParam from getNextPageParam and getPreviousPageParam.</content>
</page>

<page>
  <title>Parallel Queries | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/guides/parallel-queries</url>
  <content>"Parallel" queries are queries that are executed in parallel, or at the same time so as to maximize fetching concurrency.

[](#manual-parallel-queries)[Manual Parallel Queries](#manual-parallel-queries)
-------------------------------------------------------------------------------

When the number of parallel queries does not change, there is **no extra effort** to use parallel queries. Just use any number of TanStack Query's useQuery and useInfiniteQuery hooks side-by-side!

    <script setup lang="ts">
    // The following queries will execute in parallel
    const usersQuery = useQuery({ queryKey: ['users'], queryFn: fetchUsers })
    const teamsQuery = useQuery({ queryKey: ['teams'], queryFn: fetchTeams })
    const projectsQuery = useQuery({
      queryKey: ['projects'],
      queryFn: fetchProjects,
    })
    </script>
    

    <script setup lang="ts">
    // The following queries will execute in parallel
    const usersQuery = useQuery({ queryKey: ['users'], queryFn: fetchUsers })
    const teamsQuery = useQuery({ queryKey: ['teams'], queryFn: fetchTeams })
    const projectsQuery = useQuery({
      queryKey: ['projects'],
      queryFn: fetchProjects,
    })
    </script>
    

[](#dynamic-parallel-queries-with-usequeries)[Dynamic Parallel Queries with useQueries](#dynamic-parallel-queries-with-usequeries)
----------------------------------------------------------------------------------------------------------------------------------

If the number of queries you need to execute is changing from render to render, you cannot use manual querying since that would violate the rules of hooks. Instead, TanStack Query provides a useQueries hook, which you can use to dynamically execute as many queries in parallel as you'd like.

useQueries accepts an **options object** with a **queries key** whose value is an **array of query objects**. It returns an **array of query results**:

    const users = computed(...)
    const queries = computed(() => users.value.map(user => {
        return {
          queryKey: ['user', user.id],
          queryFn: () => fetchUserById(user.id),
        }
      })
    );
    const userQueries = useQueries({queries: queries})
    

    const users = computed(...)
    const queries = computed(() => users.value.map(user => {
        return {
          queryKey: ['user', user.id],
          queryFn: () => fetchUserById(user.id),
        }
      })
    );
    const userQueries = useQueries({queries: queries})</content>
</page>

<page>
  <title>Network Mode | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/guides/network-mode</url>
  <content>TanStack Query provides three different network modes to distinguish how [Queries](https://tanstack.com/query/latest/docs/framework/vue/guides/queries) and [Mutations](https://tanstack.com/query/latest/docs/framework/vue/guides/mutations) should behave if you have no network connection. This mode can be set for each Query / Mutation individually, or globally via the query / mutation defaults.

Since TanStack Query is most often used for data fetching in combination with data fetching libraries, the default network mode is [online](#network-mode-online).

[](#network-mode-online)[Network Mode: online](#network-mode-online)
--------------------------------------------------------------------

In this mode, Queries and Mutations will not fire unless you have network connection. This is the default mode. If a fetch is initiated for a query, it will always stay in the state (pending, error, success) it is in if the fetch cannot be made because there is no network connection. However, a [fetchStatus](https://tanstack.com/query/latest/docs/framework/vue/guides/queries#fetchstatus) is exposed additionally. This can be either:

*   fetching: The queryFn is really executing - a request is in-flight.
*   paused: The query is not executing - it is paused until you have connection again
*   idle: The query is not fetching and not paused

The flags isFetching and isPaused are derived from this state and exposed for convenience.

> Keep in mind that it might not be enough to check for pending state to show a loading spinner. Queries can be in state: 'pending', but fetchStatus: 'paused' if they are mounting for the first time, and you have no network connection.

If a query runs because you are online, but you go offline while the fetch is still happening, TanStack Query will also pause the retry mechanism. Paused queries will then continue to run once you re-gain network connection. This is independent of refetchOnReconnect (which also defaults to true in this mode), because it is not a refetch, but rather a continue. If the query has been [cancelled](https://tanstack.com/query/latest/docs/framework/vue/guides/query-cancellation) in the meantime, it will not continue.

[](#network-mode-always)[Network Mode: always](#network-mode-always)
--------------------------------------------------------------------

In this mode, TanStack Query will always fetch and ignore the online / offline state. This is likely the mode you want to choose if you use TanStack Query in an environment where you don't need an active network connection for your Queries to work - e.g. if you just read from AsyncStorage, or if you just want to return Promise.resolve(5) from your queryFn.

*   Queries will never be paused because you have no network connection.
*   Retries will also not pause - your Query will go to error state if it fails.
*   refetchOnReconnect defaults to false in this mode, because reconnecting to the network is not a good indicator anymore that stale queries should be refetched. You can still turn it on if you want.

[](#network-mode-offlinefirst)[Network Mode: offlineFirst](#network-mode-offlinefirst)
--------------------------------------------------------------------------------------

This mode is the middle ground between the first two options, where TanStack Query will run the queryFn once, but then pause retries. This is very handy if you have a serviceWorker that intercepts a request for caching like in an [offline-first PWA](https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Offline_Service_workers), or if you use HTTP caching via the [Cache-Control header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#the_cache-control_header).

In those situations, the first fetch might succeed because it comes from an offline storage / cache. However, if there is a cache miss, the network request will go out and fail, in which case this mode behaves like an online query - pausing retries.

The [TanStack Query Devtools](https://tanstack.com/query/latest/docs/framework/vue/devtools) will show Queries in a paused state if they would be fetching, but there is no network connection. There is also a toggle button to _Mock offline behavior_. Please note that this button will _not_ actually mess with your network connection (you can do that in the browser devtools), but it will set the [OnlineManager](https://tanstack.com/query/latest/docs/reference/onlineManager) in an offline state.

[](#signature)[Signature](#signature)
-------------------------------------

*   networkMode: 'online' | 'always' | 'offlineFirst'
    *   optional
    *   defaults to 'online'</content>
</page>

<page>
  <title>Dependent Queries | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/guides/dependent-queries</url>
  <content>[](#usequery-dependent-query)[useQuery dependent Query](#usequery-dependent-query)
----------------------------------------------------------------------------------

Dependent (or serial) queries depend on previous ones to finish before they can execute. To achieve this, it's as easy as using the enabled option to tell a query when it is ready to run:

    // Get the user
    const { data: user } = useQuery({
      queryKey: ['user', email],
      queryFn: () => getUserByEmail(email.value),
    })
    
    const userId = computed(() => user.value?.id)
    const enabled = computed(() => !!user.value?.id)
    
    // Then get the user's projects
    const { isIdle, data: projects } = useQuery({
      queryKey: ['projects', userId],
      queryFn: () => getProjectsByUser(userId.value),
      enabled, // The query will not execute until `enabled == true`
    })
    

    // Get the user
    const { data: user } = useQuery({
      queryKey: ['user', email],
      queryFn: () => getUserByEmail(email.value),
    })
    
    const userId = computed(() => user.value?.id)
    const enabled = computed(() => !!user.value?.id)
    
    // Then get the user's projects
    const { isIdle, data: projects } = useQuery({
      queryKey: ['projects', userId],
      queryFn: () => getProjectsByUser(userId.value),
      enabled, // The query will not execute until `enabled == true`
    })
    

The projects query will start in:

    status: 'pending'
    isPending: true
    fetchStatus: 'idle'
    

    status: 'pending'
    isPending: true
    fetchStatus: 'idle'
    

As soon as the user is available, the projects query will be enabled and will then transition to:

    status: 'pending'
    isPending: true
    fetchStatus: 'fetching'
    

    status: 'pending'
    isPending: true
    fetchStatus: 'fetching'
    

Once we have the projects, it will go to:

    status: 'success'
    isPending: false
    fetchStatus: 'idle'
    

    status: 'success'
    isPending: false
    fetchStatus: 'idle'
    

[](#usequeries-dependent-query)[useQueries dependent Query](#usequeries-dependent-query)
----------------------------------------------------------------------------------------

Dynamic parallel query - useQueries can depend on a previous query also, here's how to achieve this:

    // Get the users ids
    const { data: userIds } = useQuery({
      queryKey: ['users'],
      queryFn: getUsersData,
      select: (users) => users.map((user) => user.id),
    })
    
    const queries = computed(() => {
      return userIds.value.length
        ? userIds.value.map((id) => {
            return {
              queryKey: ['messages', id],
              queryFn: () => getMessagesByUsers(id),
            }
          })
        : []
    })
    
    // Then get the users messages
    const usersMessages = useQueries({
      queries, // if userIds.value is undefined or has no items, an empty array will be returned
    })
    

    // Get the users ids
    const { data: userIds } = useQuery({
      queryKey: ['users'],
      queryFn: getUsersData,
      select: (users) => users.map((user) => user.id),
    })
    
    const queries = computed(() => {
      return userIds.value.length
        ? userIds.value.map((id) => {
            return {
              queryKey: ['messages', id],
              queryFn: () => getMessagesByUsers(id),
            }
          })
        : []
    })
    
    // Then get the users messages
    const usersMessages = useQueries({
      queries, // if userIds.value is undefined or has no items, an empty array will be returned
    })
    

**Note** that useQueries return an **array of query results**

[](#a-note-about-performance)[A note about performance](#a-note-about-performance)
----------------------------------------------------------------------------------

Dependent queries by definition constitutes a form of [request waterfall](https://tanstack.com/query/latest/docs/framework/vue/guides/request-waterfalls), which hurts performance. If we pretend both queries take the same amount of time, doing them serially instead of in parallel always takes twice as much time, which is especially hurtful when it happens on a client that has high latency. If you can, it's always better to restructure the backend APIs so that both queries can be fetched in parallel, though that might not always be practically feasible.

In the example above, instead of first fetching getUserByEmail to be able to getProjectsByUser, introducing a new getProjectsByUserEmail query would flatten the waterfall.</content>
</page>

<page>
  <title>Background Fetching Indicators | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/guides/background-fetching-indicators</url>
  <content>A query's status === 'pending' state is sufficient enough to show the initial hard-loading state for a query, but sometimes you may want to display an additional indicator that a query is refetching in the background. To do this, queries also supply you with an isFetching boolean that you can use to show that it's in a fetching state, regardless of the state of the status variable:

    <script setup>
    import { useQuery } from '@tanstack/vue-query'
    
    const { isPending, isFetching, isError, data, error } = useQuery({
      queryKey: ['todos'],
      queryFn: getTodos,
    })
    </script>
    
    <template>
      <div v-if="isFetching">Refreshing...</div>
      <span v-if="isPending">Loading...</span>
      <span v-else-if="isError">Error: {{ error.message }}</span>
      <!-- We can assume by this point that `isSuccess === true` -->
      <ul v-else-if="data">
        <li v-for="todo in data" :key="todo.id">{{ todo.title }}</li>
      </ul>
    </template>
    

    <script setup>
    import { useQuery } from '@tanstack/vue-query'
    
    const { isPending, isFetching, isError, data, error } = useQuery({
      queryKey: ['todos'],
      queryFn: getTodos,
    })
    </script>
    
    <template>
      <div v-if="isFetching">Refreshing...</div>
      <span v-if="isPending">Loading...</span>
      <span v-else-if="isError">Error: {{ error.message }}</span>
      <!-- We can assume by this point that `isSuccess === true` -->
      <ul v-else-if="data">
        <li v-for="todo in data" :key="todo.id">{{ todo.title }}</li>
      </ul>
    </template>
    

[](#displaying-global-background-fetching-loading-state)[Displaying Global Background Fetching Loading State](#displaying-global-background-fetching-loading-state)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------

In addition to individual query loading states, if you would like to show a global loading indicator when **any** queries are fetching (including in the background), you can use the useIsFetching hook:

    <script setup>
    import { useIsFetching } from '@tanstack/vue-query'
    
    const isFetching = useIsFetching()
    </script>
    
    <template>
      <div v-if="isFetching">Queries are fetching in the background...</div>
    </template>
    

    <script setup>
    import { useIsFetching } from '@tanstack/vue-query'
    
    const isFetching = useIsFetching()
    </script>
    
    <template>
      <div v-if="isFetching">Queries are fetching in the background...</div>
    </template></content>
</page>

<page>
  <title>Window Focus Refetching | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/guides/window-focus-refetching</url>
  <content>If a user leaves your application and returns and the query data is stale, **TanStack Query automatically requests fresh data for you in the background**. You can disable this globally or per-query using the refetchOnWindowFocus option:

#### [](#disabling-globally)[Disabling Globally](#disabling-globally)

    const vueQueryPluginOptions: VueQueryPluginOptions = {
      queryClientConfig: {
        defaultOptions: {
          queries: {
            refetchOnWindowFocus: false,
          },
        },
      },
    }
    app.use(VueQueryPlugin, vueQueryPluginOptions)
    

    const vueQueryPluginOptions: VueQueryPluginOptions = {
      queryClientConfig: {
        defaultOptions: {
          queries: {
            refetchOnWindowFocus: false,
          },
        },
      },
    }
    app.use(VueQueryPlugin, vueQueryPluginOptions)
    

#### [](#disabling-per-query)[Disabling Per-Query](#disabling-per-query)

    useQuery({
      queryKey: ['todos'],
      queryFn: fetchTodos,
      refetchOnWindowFocus: false,
    })
    

    useQuery({
      queryKey: ['todos'],
      queryFn: fetchTodos,
      refetchOnWindowFocus: false,
    })
    

[](#custom-window-focus-event)[Custom Window Focus Event](#custom-window-focus-event)
-------------------------------------------------------------------------------------

In rare circumstances, you may want to manage your own window focus events that trigger TanStack Query to revalidate. To do this, TanStack Query provides a focusManager.setEventListener function that supplies you the callback that should be fired when the window is focused and allows you to set up your own events. When calling focusManager.setEventListener, the previously set handler is removed (which in most cases will be the default handler) and your new handler is used instead. For example, this is the default handler:

    focusManager.setEventListener((handleFocus) => {
      // Listen to visibilitychange
      if (typeof window !== 'undefined' && window.addEventListener) {
        const visibilitychangeHandler = () => {
          handleFocus(document.visibilityState === 'visible')
        }
        window.addEventListener('visibilitychange', visibilitychangeHandler, false)
        return () => {
          // Be sure to unsubscribe if a new handler is set
          window.removeEventListener('visibilitychange', visibilitychangeHandler)
        }
      }
    })
    

    focusManager.setEventListener((handleFocus) => {
      // Listen to visibilitychange
      if (typeof window !== 'undefined' && window.addEventListener) {
        const visibilitychangeHandler = () => {
          handleFocus(document.visibilityState === 'visible')
        }
        window.addEventListener('visibilitychange', visibilitychangeHandler, false)
        return () => {
          // Be sure to unsubscribe if a new handler is set
          window.removeEventListener('visibilitychange', visibilitychangeHandler)
        }
      }
    })
    

[](#managing-focus-state)[Managing focus state](#managing-focus-state)
----------------------------------------------------------------------

    import { focusManager } from '@tanstack/vue-query'
    
    // Override the default focus state
    focusManager.setFocused(true)
    
    // Fallback to the default focus check
    focusManager.setFocused(undefined)
    

    import { focusManager } from '@tanstack/vue-query'
    
    // Override the default focus state
    focusManager.setFocused(true)
    
    // Fallback to the default focus check
    focusManager.setFocused(undefined)</content>
</page>

<page>
  <title>Disabling/Pausing Queries | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/guides/disabling-queries</url>
  <content>If you ever want to disable a query from automatically running, you can use the enabled = false option. The enabled option also accepts a callback that returns a boolean.

When enabled is false:

*   If the query has cached data, then the query will be initialized in the status === 'success' or isSuccess state.
*   If the query does not have cached data, then the query will start in the status === 'pending' and fetchStatus === 'idle' state.
*   The query will not automatically fetch on mount.
*   The query will not automatically refetch in the background.
*   The query will ignore query client invalidateQueries and refetchQueries calls that would normally result in the query refetching.
*   refetch returned from useQuery can be used to manually trigger the query to fetch. However, it will not work with skipToken.

> TypeScript users may prefer to use [skipToken](#typesafe-disabling-of-queries-using-skiptoken) as an alternative to enabled = false.

    <script setup>
    import { useQuery } from '@tanstack/vue-query'
    
    const { isLoading, isError, data, error, refetch, isFetching } = useQuery({
      queryKey: ['todos'],
      queryFn: fetchTodoList,
      enabled: false,
    })
    </script>
    
    <template>
      <button @click="refetch()">Fetch Todos</button>
      <span v-if="isLoading">Loading...</span>
      <span v-else-if="isError">Error: {{ error?.message }}</span>
      <div v-else-if="data">
        <span v-if="isFetching">Fetching...</span>
        <ul>
          <li v-for="todo in data" :key="todo.id">{{ todo.title }}</li>
        </ul>
      </div>
      <span v-else>Not ready...</span>
    </template>
    

    <script setup>
    import { useQuery } from '@tanstack/vue-query'
    
    const { isLoading, isError, data, error, refetch, isFetching } = useQuery({
      queryKey: ['todos'],
      queryFn: fetchTodoList,
      enabled: false,
    })
    </script>
    
    <template>
      <button @click="refetch()">Fetch Todos</button>
      <span v-if="isLoading">Loading...</span>
      <span v-else-if="isError">Error: {{ error?.message }}</span>
      <div v-else-if="data">
        <span v-if="isFetching">Fetching...</span>
        <ul>
          <li v-for="todo in data" :key="todo.id">{{ todo.title }}</li>
        </ul>
      </div>
      <span v-else>Not ready...</span>
    </template>
    

Permanently disabling a query opts out of many great features that TanStack Query has to offer (like background refetches), and it's also not the idiomatic way. It takes you from the declarative approach (defining dependencies when your query should run) into an imperative mode (fetch whenever I click here). It is also not possible to pass parameters to refetch. Oftentimes, all you want is a lazy query that defers the initial fetch:

[](#lazy-queries)[Lazy Queries](#lazy-queries)
----------------------------------------------

The enabled option can not only be used to permanently disable a query, but also to enable / disable it at a later time. A good example would be a filter form where you only want to fire off the first request once the user has entered a filter value:

    <script setup>
    import { useQuery } from '@tanstack/vue-query'
    
    const filter = ref('')
    const isEnabled = computed(() => !!filter.value)
    const { data } = useQuery({
      queryKey: ['todos', filter],
      queryFn: () => fetchTodos(filter),
      // ‚¨áÔ∏è disabled as long as the filter is empty
      enabled: isEnabled,
    })
    </script>
    
    <template>
      <span v-if="data">Filter was set and data is here!</span>
    </template>
    

    <script setup>
    import { useQuery } from '@tanstack/vue-query'
    
    const filter = ref('')
    const isEnabled = computed(() => !!filter.value)
    const { data } = useQuery({
      queryKey: ['todos', filter],
      queryFn: () => fetchTodos(filter),
      // ‚¨áÔ∏è disabled as long as the filter is empty
      enabled: isEnabled,
    })
    </script>
    
    <template>
      <span v-if="data">Filter was set and data is here!</span>
    </template>
    

### [](#isloading-previously-isinitialloading)[isLoading (Previously: isInitialLoading)](#isloading-previously-isinitialloading)

Lazy queries will be in status: 'pending' right from the start because pending means that there is no data yet. This is technically true, however, since we are not currently fetching any data (as the query is not _enabled_), it also means you likely cannot use this flag to show a loading spinner.

If you are using disabled or lazy queries, you can use the isLoading flag instead. It's a derived flag that is computed from:

isPending && isFetching

so it will only be true if the query is currently fetching for the first time.

[](#typesafe-disabling-of-queries-using-skiptoken)[Typesafe disabling of queries using skipToken](#typesafe-disabling-of-queries-using-skiptoken)
-------------------------------------------------------------------------------------------------------------------------------------------------

If you are using TypeScript, you can use the skipToken to disable a query. This is useful when you want to disable a query based on a condition, but you still want to keep the query to be type safe.

> **IMPORTANT**: refetch from useQuery will not work with skipToken. Calling refetch() on a query that uses skipToken will result in a Missing queryFn error because there is no valid query function to execute. If you need to manually trigger queries, consider using enabled: false instead, which allows refetch() to work properly. Other than this limitation, skipToken works the same as enabled: false.

    <script setup>
    import { useQuery, skipToken } from '@tanstack/vue-query'
    
    const filter = ref('')
    const queryFn = computed(() =>
      !!filter.value ? () => fetchTodos(filter) : skipToken,
    )
    const { data } = useQuery({
      queryKey: ['todos', filter],
      // ‚¨áÔ∏è disabled as long as the filter is undefined or empty
      queryFn: queryFn,
    })
    </script>
    
    <template>
      <span v-if="data">Filter was set and data is here!</span>
    </template>
    

    <script setup>
    import { useQuery, skipToken } from '@tanstack/vue-query'
    
    const filter = ref('')
    const queryFn = computed(() =>
      !!filter.value ? () => fetchTodos(filter) : skipToken,
    )
    const { data } = useQuery({
      queryKey: ['todos', filter],
      // ‚¨áÔ∏è disabled as long as the filter is undefined or empty
      queryFn: queryFn,
    })
    </script>
    
    <template>
      <span v-if="data">Filter was set and data is here!</span>
    </template></content>
</page>

<page>
  <title>Query Retries | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/guides/query-retries</url>
  <content>When a useQuery query fails (the query function throws an error), TanStack Query will automatically retry the query if that query's request has not reached the max number of consecutive retries (defaults to 3) or a function is provided to determine if a retry is allowed.

You can configure retries both on a global level and an individual query level.

*   Setting retry = false will disable retries.
*   Setting retry = 6 will retry failing requests 6 times before showing the final error thrown by the function.
*   Setting retry = true will infinitely retry failing requests.
*   Setting retry = (failureCount, error) => ... allows for custom logic based on why the request failed.

> On the server, retries default to 0 to make server rendering as fast as possible.

    import { useQuery } from '@tanstack/vue-query'
    
    // Make a specific query retry a certain number of times
    const result = useQuery({
      queryKey: ['todos', 1],
      queryFn: fetchTodoListPage,
      retry: 10, // Will retry failed requests 10 times before displaying an error
    })
    

    import { useQuery } from '@tanstack/vue-query'
    
    // Make a specific query retry a certain number of times
    const result = useQuery({
      queryKey: ['todos', 1],
      queryFn: fetchTodoListPage,
      retry: 10, // Will retry failed requests 10 times before displaying an error
    })
    

> Info: Contents of the error property will be part of failureReason response property of useQuery until the last retry attempt. So in above example any error contents will be part of failureReason property for first 9 retry attempts (Overall 10 attempts) and finally they will be part of error after last attempt if error persists after all retry attempts.

[](#retry-delay)[Retry Delay](#retry-delay)
-------------------------------------------

By default, retries in TanStack Query do not happen immediately after a request fails. As is standard, a back-off delay is gradually applied to each retry attempt.

The default retryDelay is set to double (starting at 1000ms) with each attempt, but not exceed 30 seconds:

    import { VueQueryPlugin } from '@tanstack/vue-query'
    
    const vueQueryPluginOptions = {
      queryClientConfig: {
        defaultOptions: {
          queries: {
            retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
          },
        },
      },
    }
    app.use(VueQueryPlugin, vueQueryPluginOptions)
    

    import { VueQueryPlugin } from '@tanstack/vue-query'
    
    const vueQueryPluginOptions = {
      queryClientConfig: {
        defaultOptions: {
          queries: {
            retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
          },
        },
      },
    }
    app.use(VueQueryPlugin, vueQueryPluginOptions)
    

Though it is not recommended, you can obviously override the retryDelay function/integer in both the Plugin and individual query options. If set to an integer instead of a function the delay will always be the same amount of time:

    const result = useQuery({
      queryKey: ['todos'],
      queryFn: fetchTodoList,
      retryDelay: 1000, // Will always wait 1000ms to retry, regardless of how many retries
    })
    

    const result = useQuery({
      queryKey: ['todos'],
      queryFn: fetchTodoList,
      retryDelay: 1000, // Will always wait 1000ms to retry, regardless of how many retries
    })
    

[](#background-retry-behavior)[Background Retry Behavior](#background-retry-behavior)
-------------------------------------------------------------------------------------

When using refetchInterval with refetchIntervalInBackground: true, retries will pause when the browser tab is inactive. This happens because retries respect the same focus behavior as regular refetches.

If you need continuous retries in the background, consider disabling retries and implementing a custom refetch strategy:

    const result = useQuery({
      queryKey: ['todos'],
      queryFn: fetchTodos,
      refetchInterval: (query) => {
        // Refetch more frequently when in error state
        return query.state.status === 'error' ? 5000 : 30000
      },
      refetchIntervalInBackground: true,
      retry: false, // Disable built-in retries
    })
    

    const result = useQuery({
      queryKey: ['todos'],
      queryFn: fetchTodos,
      refetchInterval: (query) => {
        // Refetch more frequently when in error state
        return query.state.status === 'error' ? 5000 : 30000
      },
      refetchIntervalInBackground: true,
      retry: false, // Disable built-in retries
    })
    

This approach lets you control retry timing manually while keeping refetches active in the background.</content>
</page>

<page>
  <title>Paginated / Lagged Queries | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/guides/paginated-queries</url>
  <content>Rendering paginated data is a very common UI pattern and in TanStack Query, it "just works" by including the page information in the query key:

    const result = useQuery({
      queryKey: ['projects', page],
      queryFn: () => fetchProjects(page),
    })
    

    const result = useQuery({
      queryKey: ['projects', page],
      queryFn: () => fetchProjects(page),
    })
    

However, if you run this simple example, you might notice something strange:

**The UI jumps in and out of the success and pending states because each new page is treated like a brand new query.**

This experience is not optimal and unfortunately is how many tools today insist on working. But not TanStack Query! As you may have guessed, TanStack Query comes with an awesome feature called placeholderData that allows us to get around this.

[](#better-paginated-queries-with-placeholderdata)[Better Paginated Queries with placeholderData](#better-paginated-queries-with-placeholderdata)
-------------------------------------------------------------------------------------------------------------------------------------------------

Consider the following example where we would ideally want to increment a pageIndex (or cursor) for a query. If we were to use useQuery, **it would still technically work fine**, but the UI would jump in and out of the success and pending states as different queries are created and destroyed for each page or cursor. By setting placeholderData to (previousData) => previousData or keepPreviousData function exported from TanStack Query, we get a few new things:

*   **The data from the last successful fetch is available while new data is being requested, even though the query key has changed**.
*   When the new data arrives, the previous data is seamlessly swapped to show the new data.
*   isPlaceholderData is made available to know what data the query is currently providing you

    <script setup lang="ts">
    import { ref, Ref } from 'vue'
    import { useQuery, keepPreviousData } from '@tanstack/vue-query'
    
    const fetcher = (page: Ref<number>) =>
      fetch(
        `https://jsonplaceholder.typicode.com/posts?_page=${page.value}&_limit=10`,
      ).then((response) => response.json())
    
    const page = ref(1)
    const { isPending, isError, data, error, isFetching, isPlaceholderData } =
      useQuery({
        queryKey: ['projects', page],
        queryFn: () => fetcher(page),
        placeholderData: keepPreviousData,
      })
    const prevPage = () => {
      page.value = Math.max(page.value - 1, 1)
    }
    const nextPage = () => {
      if (!isPlaceholderData.value) {
        page.value = page.value + 1
      }
    }
    </script>
    
    <template>
      <h1>Posts</h1>
      <p>Current Page: {{ page }} | Previous data: {{ isPlaceholderData }}</p>
      <button @click="prevPage">Prev Page</button>
      <button @click="nextPage">Next Page</button>
      <div v-if="isPending">Loading...</div>
      <div v-else-if="isError">An error has occurred: {{ error }}</div>
      <div v-else-if="data">
        <ul>
          <li v-for="item in data" :key="item.id">
            {{ item.title }}
          </li>
        </ul>
      </div>
    </template>
    

    <script setup lang="ts">
    import { ref, Ref } from 'vue'
    import { useQuery, keepPreviousData } from '@tanstack/vue-query'
    
    const fetcher = (page: Ref<number>) =>
      fetch(
        `https://jsonplaceholder.typicode.com/posts?_page=${page.value}&_limit=10`,
      ).then((response) => response.json())
    
    const page = ref(1)
    const { isPending, isError, data, error, isFetching, isPlaceholderData } =
      useQuery({
        queryKey: ['projects', page],
        queryFn: () => fetcher(page),
        placeholderData: keepPreviousData,
      })
    const prevPage = () => {
      page.value = Math.max(page.value - 1, 1)
    }
    const nextPage = () => {
      if (!isPlaceholderData.value) {
        page.value = page.value + 1
      }
    }
    </script>
    
    <template>
      <h1>Posts</h1>
      <p>Current Page: {{ page }} | Previous data: {{ isPlaceholderData }}</p>
      <button @click="prevPage">Prev Page</button>
      <button @click="nextPage">Next Page</button>
      <div v-if="isPending">Loading...</div>
      <div v-else-if="isError">An error has occurred: {{ error }}</div>
      <div v-else-if="data">
        <ul>
          <li v-for="item in data" :key="item.id">
            {{ item.title }}
          </li>
        </ul>
      </div>
    </template>
    

[](#lagging-infinite-query-results-with-placeholderdata)[Lagging Infinite Query results with placeholderData](#lagging-infinite-query-results-with-placeholderdata)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------

While not as common, the placeholderData option also works flawlessly with the useInfiniteQuery hook, so you can seamlessly allow your users to continue to see cached data while infinite query keys change over time.</content>
</page>

<page>
  <title>Initial Query Data | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/guides/initial-query-data</url>
  <content>There are many ways to supply initial data for a query to the cache before you need it:

*   Declaratively:
    *   Provide initialData to a query to prepopulate its cache if empty
*   Imperatively:
    *   [Prefetch the data using queryClient.prefetchQuery](https://tanstack.com/query/latest/docs/framework/vue/guides/prefetching)
    *   [Manually place the data into the cache using queryClient.setQueryData](https://tanstack.com/query/latest/docs/framework/vue/guides/prefetching)

[](#using-initialdata-to-prepopulate-a-query)[Using initialData to prepopulate a query](#using-initialdata-to-prepopulate-a-query)
----------------------------------------------------------------------------------------------------------------------------------

There may be times when you already have the initial data for a query available in your app and can simply provide it directly to your query. If and when this is the case, you can use the config.initialData option to set the initial data for a query and skip the initial loading state!

> IMPORTANT: initialData is persisted to the cache, so it is not recommended to provide placeholder, partial or incomplete data to this option and instead use placeholderData

    const result = useQuery({
      queryKey: ['todos'],
      queryFn: () => fetch('/todos'),
      initialData: initialTodos,
    })
    

    const result = useQuery({
      queryKey: ['todos'],
      queryFn: () => fetch('/todos'),
      initialData: initialTodos,
    })
    

### [](#staletime-and-initialdataupdatedat)[staleTime and initialDataUpdatedAt](#staletime-and-initialdataupdatedat)

By default, initialData is treated as totally fresh, as if it were just fetched. This also means that it will affect how it is interpreted by the staleTime option.

*   If you configure your query observer with initialData, and no staleTime (the default staleTime: 0), the query will immediately refetch when it mounts:
    
        // Will show initialTodos immediately, but also immediately refetch todos after mount
        const result = useQuery({
          queryKey: ['todos'],
          queryFn: () => fetch('/todos'),
          initialData: initialTodos,
        })
        
    
        // Will show initialTodos immediately, but also immediately refetch todos after mount
        const result = useQuery({
          queryKey: ['todos'],
          queryFn: () => fetch('/todos'),
          initialData: initialTodos,
        })
        
    
*   If you configure your query observer with initialData and a staleTime of 1000 ms, the data will be considered fresh for that same amount of time, as if it was just fetched from your query function.
    
        // Show initialTodos immediately, but won't refetch until another interaction event is encountered after 1000 ms
        const result = useQuery({
          queryKey: ['todos'],
          queryFn: () => fetch('/todos'),
          initialData: initialTodos,
          staleTime: 1000,
        })
        
    
        // Show initialTodos immediately, but won't refetch until another interaction event is encountered after 1000 ms
        const result = useQuery({
          queryKey: ['todos'],
          queryFn: () => fetch('/todos'),
          initialData: initialTodos,
          staleTime: 1000,
        })
        
    
*   So what if your initialData isn't totally fresh? That leaves us with the last configuration that is actually the most accurate and uses an option called initialDataUpdatedAt. This option allows you to pass a numeric JS timestamp in milliseconds of when the initialData itself was last updated, e.g. what Date.now() provides. Take note that if you have a unix timestamp, you'll need to convert it to a JS timestamp by multiplying it by 1000.
    
        // Show initialTodos immediately, but won't refetch until another interaction event is encountered after 1000 ms
        const result = useQuery({
          queryKey: ['todos'],
          queryFn: () => fetch('/todos'),
          initialData: initialTodos,
          staleTime: 60 * 1000, // 1 minute
          // This could be 10 seconds ago or 10 minutes ago
          initialDataUpdatedAt: initialTodosUpdatedTimestamp, // eg. 1608412420052
        })
        
    
        // Show initialTodos immediately, but won't refetch until another interaction event is encountered after 1000 ms
        const result = useQuery({
          queryKey: ['todos'],
          queryFn: () => fetch('/todos'),
          initialData: initialTodos,
          staleTime: 60 * 1000, // 1 minute
          // This could be 10 seconds ago or 10 minutes ago
          initialDataUpdatedAt: initialTodosUpdatedTimestamp, // eg. 1608412420052
        })
        
    
    This option allows the staleTime to be used for its original purpose, determining how fresh the data needs to be, while also allowing the data to be refetched on mount if the initialData is older than the staleTime. In the example above, our data needs to be fresh within 1 minute, and we can hint to the query when the initialData was last updated so the query can decide for itself whether the data needs to be refetched again or not.
    
    > If you would rather treat your data as **prefetched data**, we recommend that you use the prefetchQuery or fetchQuery APIs to populate the cache beforehand, thus letting you configure your staleTime independently from your initialData
    

### [](#initial-data-function)[Initial Data Function](#initial-data-function)

If the process for accessing a query's initial data is intensive or just not something you want to perform on every render, you can pass a function as the initialData value. This function will be executed only once when the query is initialized, saving you precious memory and/or CPU:

    const result = useQuery({
      queryKey: ['todos'],
      queryFn: () => fetch('/todos'),
      initialData: () => getExpensiveTodos(),
    })
    

    const result = useQuery({
      queryKey: ['todos'],
      queryFn: () => fetch('/todos'),
      initialData: () => getExpensiveTodos(),
    })
    

### [](#initial-data-from-cache)[Initial Data from Cache](#initial-data-from-cache)

In some circumstances, you may be able to provide the initial data for a query from the cached result of another. A good example of this would be searching the cached data from a todos list query for an individual todo item, then using that as the initial data for your individual todo query:

    const result = useQuery({
      queryKey: ['todo', todoId],
      queryFn: () => fetch('/todos'),
      initialData: () => {
        // Use a todo from the 'todos' query as the initial data for this todo query
        return queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId)
      },
    })
    

    const result = useQuery({
      queryKey: ['todo', todoId],
      queryFn: () => fetch('/todos'),
      initialData: () => {
        // Use a todo from the 'todos' query as the initial data for this todo query
        return queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId)
      },
    })
    

### [](#initial-data-from-the-cache-with-initialdataupdatedat)[Initial Data from the cache with initialDataUpdatedAt](#initial-data-from-the-cache-with-initialdataupdatedat)

Getting initial data from the cache means the source query you're using to look up the initial data from is likely old. Instead of using an artificial staleTime to keep your query from refetching immediately, it's suggested that you pass the source query's dataUpdatedAt to initialDataUpdatedAt. This provides the query instance with all the information it needs to determine if and when the query needs to be refetched, regardless of initial data being provided.

    const result = useQuery({
      queryKey: ['todos', todoId],
      queryFn: () => fetch(`/todos/${todoId}`),
      initialData: () =>
        queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId),
      initialDataUpdatedAt: () =>
        queryClient.getQueryState(['todos'])?.dataUpdatedAt,
    })
    

    const result = useQuery({
      queryKey: ['todos', todoId],
      queryFn: () => fetch(`/todos/${todoId}`),
      initialData: () =>
        queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId),
      initialDataUpdatedAt: () =>
        queryClient.getQueryState(['todos'])?.dataUpdatedAt,
    })
    

### [](#conditional-initial-data-from-cache)[Conditional Initial Data from Cache](#conditional-initial-data-from-cache)

If the source query you're using to look up the initial data from is old, you may not want to use the cached data at all and just fetch from the server. To make this decision easier, you can use the queryClient.getQueryState method instead to get more information about the source query, including a state.dataUpdatedAt timestamp you can use to decide if the query is "fresh" enough for your needs:

    const result = useQuery({
      queryKey: ['todo', todoId],
      queryFn: () => fetch(`/todos/${todoId}`),
      initialData: () => {
        // Get the query state
        const state = queryClient.getQueryState(['todos'])
    
        // If the query exists and has data that is no older than 10 seconds...
        if (state && Date.now() - state.dataUpdatedAt <= 10 * 1000) {
          // return the individual todo
          return state.data.find((d) => d.id === todoId)
        }
    
        // Otherwise, return undefined and let it fetch from a hard loading state!
      },
    })
    

    const result = useQuery({
      queryKey: ['todo', todoId],
      queryFn: () => fetch(`/todos/${todoId}`),
      initialData: () => {
        // Get the query state
        const state = queryClient.getQueryState(['todos'])
    
        // If the query exists and has data that is no older than 10 seconds...
        if (state && Date.now() - state.dataUpdatedAt <= 10 * 1000) {
          // return the individual todo
          return state.data.find((d) => d.id === todoId)
        }
    
        // Otherwise, return undefined and let it fetch from a hard loading state!
      },
    })</content>
</page>

<page>
  <title>Infinite Queries | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/guides/infinite-queries</url>
  <content>Rendering lists that can additively "load more" data onto an existing set of data or "infinite scroll" is also a very common UI pattern. TanStack Query supports a useful version of useQuery called useInfiniteQuery for querying these types of lists.

When using useInfiniteQuery, you'll notice a few things are different:

*   data is now an object containing infinite query data:
*   data.pages array containing the fetched pages
*   data.pageParams array containing the page params used to fetch the pages
*   The fetchNextPage and fetchPreviousPage functions are now available (fetchNextPage is required)
*   The initialPageParam option is now available (and required) to specify the initial page param
*   The getNextPageParam and getPreviousPageParam options are available for both determining if there is more data to load and the information to fetch it. This information is supplied as an additional parameter in the query function
*   A hasNextPage boolean is now available and is true if getNextPageParam returns a value other than null or undefined
*   A hasPreviousPage boolean is now available and is true if getPreviousPageParam returns a value other than null or undefined
*   The isFetchingNextPage and isFetchingPreviousPage booleans are now available to distinguish between a background refresh state and a loading more state

> Note: Options initialData or placeholderData need to conform to the same structure of an object with data.pages and data.pageParams properties.

[](#example)[Example](#example)
-------------------------------

Let's assume we have an API that returns pages of projects 3 at a time based on a cursor index along with a cursor that can be used to fetch the next group of projects:

    fetch('/api/projects?cursor=0')
    // { data: [...], nextCursor: 3}
    fetch('/api/projects?cursor=3')
    // { data: [...], nextCursor: 6}
    fetch('/api/projects?cursor=6')
    // { data: [...], nextCursor: 9}
    fetch('/api/projects?cursor=9')
    // { data: [...] }
    

    fetch('/api/projects?cursor=0')
    // { data: [...], nextCursor: 3}
    fetch('/api/projects?cursor=3')
    // { data: [...], nextCursor: 6}
    fetch('/api/projects?cursor=6')
    // { data: [...], nextCursor: 9}
    fetch('/api/projects?cursor=9')
    // { data: [...] }
    

With this information, we can create a "Load More" UI by:

*   Waiting for useInfiniteQuery to request the first group of data by default
*   Returning the information for the next query in getNextPageParam
*   Calling fetchNextPage function

    <script setup>
    import { useInfiniteQuery } from '@tanstack/vue-query'
    
    const fetchProjects = async ({ pageParam = 0 }) => {
      const res = await fetch('/api/projects?cursor=' + pageParam)
      return res.json()
    }
    
    const {
      data,
      error,
      fetchNextPage,
      hasNextPage,
      isFetching,
      isFetchingNextPage,
      isPending,
      isError,
    } = useInfiniteQuery({
      queryKey: ['projects'],
      queryFn: fetchProjects,
      getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
    })
    </script>
    
    <template>
      <span v-if="isPending">Loading...</span>
      <span v-else-if="isError">Error: {{ error.message }}</span>
      <div v-else-if="data">
        <span v-if="isFetching && !isFetchingNextPage">Fetching...</span>
        <ul v-for="(group, index) in data.pages" :key="index">
          <li v-for="project in group.projects" :key="project.id">
            {{ project.name }}
          </li>
        </ul>
        <button
          @click="() => fetchNextPage()"
          :disabled="!hasNextPage || isFetchingNextPage"
        >
          <span v-if="isFetchingNextPage">Loading more...</span>
          <span v-else-if="hasNextPage">Load More</span>
          <span v-else>Nothing more to load</span>
        </button>
      </div>
    </template>
    

    <script setup>
    import { useInfiniteQuery } from '@tanstack/vue-query'
    
    const fetchProjects = async ({ pageParam = 0 }) => {
      const res = await fetch('/api/projects?cursor=' + pageParam)
      return res.json()
    }
    
    const {
      data,
      error,
      fetchNextPage,
      hasNextPage,
      isFetching,
      isFetchingNextPage,
      isPending,
      isError,
    } = useInfiniteQuery({
      queryKey: ['projects'],
      queryFn: fetchProjects,
      getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
    })
    </script>
    
    <template>
      <span v-if="isPending">Loading...</span>
      <span v-else-if="isError">Error: {{ error.message }}</span>
      <div v-else-if="data">
        <span v-if="isFetching && !isFetchingNextPage">Fetching...</span>
        <ul v-for="(group, index) in data.pages" :key="index">
          <li v-for="project in group.projects" :key="project.id">
            {{ project.name }}
          </li>
        </ul>
        <button
          @click="() => fetchNextPage()"
          :disabled="!hasNextPage || isFetchingNextPage"
        >
          <span v-if="isFetchingNextPage">Loading more...</span>
          <span v-else-if="hasNextPage">Load More</span>
          <span v-else>Nothing more to load</span>
        </button>
      </div>
    </template>
    

It's essential to understand that calling fetchNextPage while an ongoing fetch is in progress runs the risk of overwriting data refreshes happening in the background. This situation becomes particularly critical when rendering a list and triggering fetchNextPage simultaneously.

Remember, there can only be a single ongoing fetch for an InfiniteQuery. A single cache entry is shared for all pages, attempting to fetch twice simultaneously might lead to data overwrites.

If you intend to enable simultaneous fetching, you can utilize the { cancelRefetch: false } option (default: true) within fetchNextPage.

To ensure a seamless querying process without conflicts, it's highly recommended to verify that the query is not in an isFetching state, especially if the user won't directly control that call.

    <List onEndReached={() => hasNextPage && !isFetching && fetchNextPage()} />
    

    <List onEndReached={() => hasNextPage && !isFetching && fetchNextPage()} />
    

[](#what-happens-when-an-infinite-query-needs-to-be-refetched)[What happens when an infinite query needs to be refetched?](#what-happens-when-an-infinite-query-needs-to-be-refetched)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

When an infinite query becomes stale and needs to be refetched, each group is fetched sequentially, starting from the first one. This ensures that even if the underlying data is mutated, we're not using stale cursors and potentially getting duplicates or skipping records. If an infinite query's results are ever removed from the queryCache, the pagination restarts at the initial state with only the initial group being requested.

[](#what-if-i-want-to-implement-a-bi-directional-infinite-list)[What if I want to implement a bi-directional infinite list?](#what-if-i-want-to-implement-a-bi-directional-infinite-list)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Bi-directional lists can be implemented by using the getPreviousPageParam, fetchPreviousPage, hasPreviousPage and isFetchingPreviousPage properties and functions.

    useInfiniteQuery({
      queryKey: ['projects'],
      queryFn: fetchProjects,
      initialPageParam: 0,
      getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
      getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,
    })
    

    useInfiniteQuery({
      queryKey: ['projects'],
      queryFn: fetchProjects,
      initialPageParam: 0,
      getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
      getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,
    })
    

[](#what-if-i-want-to-show-the-pages-in-reversed-order)[What if I want to show the pages in reversed order?](#what-if-i-want-to-show-the-pages-in-reversed-order)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------

Sometimes you may want to show the pages in reversed order. If this is case, you can use the select option:

    useInfiniteQuery({
      queryKey: ['projects'],
      queryFn: fetchProjects,
      select: (data) => ({
        pages: [...data.pages].reverse(),
        pageParams: [...data.pageParams].reverse(),
      }),
    })
    

    useInfiniteQuery({
      queryKey: ['projects'],
      queryFn: fetchProjects,
      select: (data) => ({
        pages: [...data.pages].reverse(),
        pageParams: [...data.pageParams].reverse(),
      }),
    })
    

[](#what-if-i-want-to-manually-update-the-infinite-query)[What if I want to manually update the infinite query?](#what-if-i-want-to-manually-update-the-infinite-query)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

### [](#manually-removing-first-page)[Manually removing first page:](#manually-removing-first-page)

    queryClient.setQueryData(['projects'], (data) => ({
      pages: data.pages.slice(1),
      pageParams: data.pageParams.slice(1),
    }))
    

    queryClient.setQueryData(['projects'], (data) => ({
      pages: data.pages.slice(1),
      pageParams: data.pageParams.slice(1),
    }))
    

### [](#manually-removing-a-single-value-from-an-individual-page)[Manually removing a single value from an individual page:](#manually-removing-a-single-value-from-an-individual-page)

    const newPagesArray =
      oldPagesArray?.pages.map((page) =>
        page.filter((val) => val.id !== updatedId),
      ) ?? []
    
    queryClient.setQueryData(['projects'], (data) => ({
      pages: newPagesArray,
      pageParams: data.pageParams,
    }))
    

    const newPagesArray =
      oldPagesArray?.pages.map((page) =>
        page.filter((val) => val.id !== updatedId),
      ) ?? []
    
    queryClient.setQueryData(['projects'], (data) => ({
      pages: newPagesArray,
      pageParams: data.pageParams,
    }))
    

### [](#keep-only-the-first-page)[Keep only the first page:](#keep-only-the-first-page)

    queryClient.setQueryData(['projects'], (data) => ({
      pages: data.pages.slice(0, 1),
      pageParams: data.pageParams.slice(0, 1),
    }))
    

    queryClient.setQueryData(['projects'], (data) => ({
      pages: data.pages.slice(0, 1),
      pageParams: data.pageParams.slice(0, 1),
    }))
    

Make sure to always keep the same data structure of pages and pageParams!

[](#what-if-i-want-to-limit-the-number-of-pages)[What if I want to limit the number of pages?](#what-if-i-want-to-limit-the-number-of-pages)
--------------------------------------------------------------------------------------------------------------------------------------------

In some use cases you may want to limit the number of pages stored in the query data to improve the performance and UX:

*   when the user can load a large number of pages (memory usage)
*   when you have to refetch an infinite query that contains dozens of pages (network usage: all the pages are sequentially fetched)

The solution is to use a "Limited Infinite Query". This is made possible by using the maxPages option in conjunction with getNextPageParam and getPreviousPageParam to allow fetching pages when needed in both directions.

In the following example only 3 pages are kept in the query data pages array. If a refetch is needed, only 3 pages will be refetched sequentially.

    useInfiniteQuery({
      queryKey: ['projects'],
      queryFn: fetchProjects,
      initialPageParam: 0,
      getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
      getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,
      maxPages: 3,
    })
    

    useInfiniteQuery({
      queryKey: ['projects'],
      queryFn: fetchProjects,
      initialPageParam: 0,
      getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
      getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,
      maxPages: 3,
    })
    

[](#what-if-my-api-doesnt-return-a-cursor)[What if my API doesn't return a cursor?](#what-if-my-api-doesnt-return-a-cursor)
---------------------------------------------------------------------------------------------------------------------------

If your API doesn't return a cursor, you can use the pageParam as a cursor. Because getNextPageParam and getPreviousPageParam also get the pageParamof the current page, you can use it to calculate the next / previous page param.

    return useInfiniteQuery({
      queryKey: ['projects'],
      queryFn: fetchProjects,
      initialPageParam: 0,
      getNextPageParam: (lastPage, allPages, lastPageParam) => {
        if (lastPage.length === 0) {
          return undefined
        }
        return lastPageParam + 1
      },
      getPreviousPageParam: (firstPage, allPages, firstPageParam) => {
        if (firstPageParam <= 1) {
          return undefined
        }
        return firstPageParam - 1
      },
    })
    

    return useInfiniteQuery({
      queryKey: ['projects'],
      queryFn: fetchProjects,
      initialPageParam: 0,
      getNextPageParam: (lastPage, allPages, lastPageParam) => {
        if (lastPage.length === 0) {
          return undefined
        }
        return lastPageParam + 1
      },
      getPreviousPageParam: (firstPage, allPages, firstPageParam) => {
        if (firstPageParam <= 1) {
          return undefined
        }
        return firstPageParam - 1
      },
    })
    

[](#further-reading)[Further reading](#further-reading)
-------------------------------------------------------

To get a better understanding of how Infinite Queries work under the hood, see the article [How Infinite Queries work](https://tkdodo.eu/blog/how-infinite-queries-work).</content>
</page>

<page>
  <title>Placeholder Query Data | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/guides/placeholder-query-data</url>
  <content>[](#what-is-placeholder-data)[What is placeholder data?](#what-is-placeholder-data)
-----------------------------------------------------------------------------------

Placeholder data allows a query to behave as if it already has data, similar to the initialData option, but **the data is not persisted to the cache**. This comes in handy for situations where you have enough partial (or fake) data to render the query successfully while the actual data is fetched in the background.

> Example: An individual blog post query could pull "preview" data from a parent list of blog posts that only include title and a small snippet of the post body. You would not want to persist this partial data to the query result of the individual query, but it is useful for showing the content layout as quickly as possible while the actual query finishes to fetch the entire object.

There are a few ways to supply placeholder data for a query to the cache before you need it:

*   Declaratively:
    *   Provide placeholderData to a query to prepopulate its cache if empty
*   Imperatively:
    *   [Prefetch or fetch the data using queryClient and the placeholderData option](https://tanstack.com/query/latest/docs/framework/vue/guides/prefetching)

When we use placeholderData, our Query will not be in a pending state - it will start out as being in success state, because we have data to display - even if that data is just "placeholder" data. To distinguish it from "real" data, we will also have the isPlaceholderData flag set to true on the Query result.

[](#placeholder-data-as-a-value)[Placeholder Data as a Value](#placeholder-data-as-a-value)
-------------------------------------------------------------------------------------------

    const result = useQuery({
      queryKey: ['todos'],
      queryFn: () => fetch('/todos'),
      placeholderData: placeholderTodos,
    })
    

    const result = useQuery({
      queryKey: ['todos'],
      queryFn: () => fetch('/todos'),
      placeholderData: placeholderTodos,
    })
    

[](#placeholder-data-as-a-function)[Placeholder Data as a Function](#placeholder-data-as-a-function)
----------------------------------------------------------------------------------------------------

placeholderData can also be a function, where you can get access to the data and Query meta information of a "previous" successful Query. This is useful for situations where you want to use the data from one query as the placeholder data for another query. When the QueryKey changes, e.g. from \['todos', 1\] to \['todos', 2\], we can keep displaying "old" data instead of having to show a loading spinner while data is _transitioning_ from one Query to the next. For more information, see [Paginated Queries](https://tanstack.com/query/latest/docs/framework/vue/guides/paginated-queries).

    const result = useQuery({
      queryKey: ['todos', id],
      queryFn: () => fetch(`/todos/${id}`),
      placeholderData: (previousData, previousQuery) => previousData,
    })
    

    const result = useQuery({
      queryKey: ['todos', id],
      queryFn: () => fetch(`/todos/${id}`),
      placeholderData: (previousData, previousQuery) => previousData,
    })
    

### [](#placeholder-data-from-cache)[Placeholder Data from Cache](#placeholder-data-from-cache)

In some circumstances, you may be able to provide the placeholder data for a query from the cached result of another. A good example of this would be searching the cached data from a blog post list query for a preview version of the post, then using that as the placeholder data for your individual post query:

    const result = useQuery({
      queryKey: ['blogPost', blogPostId],
      queryFn: () => fetch(`/blogPosts/${blogPostId}`),
      placeholderData: () => {
        // Use the smaller/preview version of the blogPost from the 'blogPosts'
        // query as the placeholder data for this blogPost query
        return queryClient
          .getQueryData(['blogPosts'])
          ?.find((d) => d.id === blogPostId)
      },
    })
    

    const result = useQuery({
      queryKey: ['blogPost', blogPostId],
      queryFn: () => fetch(`/blogPosts/${blogPostId}`),
      placeholderData: () => {
        // Use the smaller/preview version of the blogPost from the 'blogPosts'
        // query as the placeholder data for this blogPost query
        return queryClient
          .getQueryData(['blogPosts'])
          ?.find((d) => d.id === blogPostId)
      },
    })</content>
</page>

<page>
  <title>Query Invalidation | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/guides/query-invalidation</url>
  <content>Waiting for queries to become stale before they are fetched again doesn't always work, especially when you know for a fact that a query's data is out of date because of something the user has done. For that purpose, the QueryClient has an invalidateQueries method that lets you intelligently mark queries as stale and potentially refetch them too!

    // Invalidate every query in the cache
    queryClient.invalidateQueries()
    // Invalidate every query with a key that starts with `todos`
    queryClient.invalidateQueries({ queryKey: ['todos'] })
    

    // Invalidate every query in the cache
    queryClient.invalidateQueries()
    // Invalidate every query with a key that starts with `todos`
    queryClient.invalidateQueries({ queryKey: ['todos'] })
    

> Note: Where other libraries that use normalized caches would attempt to update local queries with the new data either imperatively or via schema inference, TanStack Query gives you the tools to avoid the manual labor that comes with maintaining normalized caches and instead prescribes **targeted invalidation, background-refetching and ultimately atomic updates**.

When a query is invalidated with invalidateQueries, two things happen:

*   It is marked as stale. This stale state overrides any staleTime configurations being used in useQuery or related hooks
*   If the query is currently being rendered via useQuery or related hooks, it will also be refetched in the background

[](#query-matching-with-invalidatequeries)[Query Matching with invalidateQueries](#query-matching-with-invalidatequeries)
-------------------------------------------------------------------------------------------------------------------------

When using APIs like invalidateQueries and removeQueries (and others that support partial query matching), you can match multiple queries by their prefix, or get really specific and match an exact query. For information on the types of filters you can use, please see [Query Filters](https://tanstack.com/query/latest/docs/framework/vue/guides/filters#query-filters).

In this example, we can use the todos prefix to invalidate any queries that start with todos in their query key:

    import { useQuery, useQueryClient } from '@tanstack/vue-query'
    
    // Get QueryClient from the context
    const queryClient = useQueryClient()
    
    queryClient.invalidateQueries({ queryKey: ['todos'] })
    
    // Both queries below will be invalidated
    const todoListQuery = useQuery({
      queryKey: ['todos'],
      queryFn: fetchTodoList,
    })
    const todoListQuery = useQuery({
      queryKey: ['todos', { page: 1 }],
      queryFn: fetchTodoList,
    })
    

    import { useQuery, useQueryClient } from '@tanstack/vue-query'
    
    // Get QueryClient from the context
    const queryClient = useQueryClient()
    
    queryClient.invalidateQueries({ queryKey: ['todos'] })
    
    // Both queries below will be invalidated
    const todoListQuery = useQuery({
      queryKey: ['todos'],
      queryFn: fetchTodoList,
    })
    const todoListQuery = useQuery({
      queryKey: ['todos', { page: 1 }],
      queryFn: fetchTodoList,
    })
    

You can even invalidate queries with specific variables by passing a more specific query key to the invalidateQueries method:

    queryClient.invalidateQueries({
      queryKey: ['todos', { type: 'done' }],
    })
    
    // The query below will be invalidated
    const todoListQuery = useQuery({
      queryKey: ['todos', { type: 'done' }],
      queryFn: fetchTodoList,
    })
    
    // However, the following query below will NOT be invalidated
    const todoListQuery = useQuery({
      queryKey: ['todos'],
      queryFn: fetchTodoList,
    })
    

    queryClient.invalidateQueries({
      queryKey: ['todos', { type: 'done' }],
    })
    
    // The query below will be invalidated
    const todoListQuery = useQuery({
      queryKey: ['todos', { type: 'done' }],
      queryFn: fetchTodoList,
    })
    
    // However, the following query below will NOT be invalidated
    const todoListQuery = useQuery({
      queryKey: ['todos'],
      queryFn: fetchTodoList,
    })
    

The invalidateQueries API is very flexible, so even if you want to **only** invalidate todos queries that don't have any more variables or subkeys, you can pass an exact: true option to the invalidateQueries method:

    queryClient.invalidateQueries({
      queryKey: ['todos'],
      exact: true,
    })
    
    // The query below will be invalidated
    const todoListQuery = useQuery({
      queryKey: ['todos'],
      queryFn: fetchTodoList,
    })
    
    // However, the following query below will NOT be invalidated
    const todoListQuery = useQuery({
      queryKey: ['todos', { type: 'done' }],
      queryFn: fetchTodoList,
    })
    

    queryClient.invalidateQueries({
      queryKey: ['todos'],
      exact: true,
    })
    
    // The query below will be invalidated
    const todoListQuery = useQuery({
      queryKey: ['todos'],
      queryFn: fetchTodoList,
    })
    
    // However, the following query below will NOT be invalidated
    const todoListQuery = useQuery({
      queryKey: ['todos', { type: 'done' }],
      queryFn: fetchTodoList,
    })
    

If you find yourself wanting **even more** granularity, you can pass a predicate function to the invalidateQueries method. This function will receive each Query instance from the query cache and allow you to return true or false for whether you want to invalidate that query:

    queryClient.invalidateQueries({
      predicate: (query) =>
        query.queryKey[0] === 'todos' && query.queryKey[1]?.version >= 10,
    })
    
    // The query below will be invalidated
    const todoListQuery = useQuery({
      queryKey: ['todos', { version: 20 }],
      queryFn: fetchTodoList,
    })
    
    // The query below will be invalidated
    const todoListQuery = useQuery({
      queryKey: ['todos', { version: 10 }],
      queryFn: fetchTodoList,
    })
    
    // However, the following query below will NOT be invalidated
    const todoListQuery = useQuery({
      queryKey: ['todos', { version: 5 }],
      queryFn: fetchTodoList,
    })
    

    queryClient.invalidateQueries({
      predicate: (query) =>
        query.queryKey[0] === 'todos' && query.queryKey[1]?.version >= 10,
    })
    
    // The query below will be invalidated
    const todoListQuery = useQuery({
      queryKey: ['todos', { version: 20 }],
      queryFn: fetchTodoList,
    })
    
    // The query below will be invalidated
    const todoListQuery = useQuery({
      queryKey: ['todos', { version: 10 }],
      queryFn: fetchTodoList,
    })
    
    // However, the following query below will NOT be invalidated
    const todoListQuery = useQuery({
      queryKey: ['todos', { version: 5 }],
      queryFn: fetchTodoList,
    })</content>
</page>

<page>
  <title>Mutations | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/guides/mutations</url>
  <content>Unlike queries, mutations are typically used to create/update/delete data or perform server side-effects. For this purpose, TanStack Query exports a useMutation hook.

Here's an example of a mutation that adds a new todo to the server:

    <script setup>
    import { useMutation } from '@tanstack/vue-query'
    
    const { isPending, isError, error, isSuccess, mutate } = useMutation({
      mutationFn: (newTodo) => axios.post('/todos', newTodo),
    })
    
    function addTodo() {
      mutate({ id: new Date(), title: 'Do Laundry' })
    }
    </script>
    
    <template>
      <span v-if="isPending">Adding todo...</span>
      <span v-else-if="isError">An error occurred: {{ error.message }}</span>
      <span v-else-if="isSuccess">Todo added!</span>
      <button @click="addTodo">Create Todo</button>
    </template>
    

    <script setup>
    import { useMutation } from '@tanstack/vue-query'
    
    const { isPending, isError, error, isSuccess, mutate } = useMutation({
      mutationFn: (newTodo) => axios.post('/todos', newTodo),
    })
    
    function addTodo() {
      mutate({ id: new Date(), title: 'Do Laundry' })
    }
    </script>
    
    <template>
      <span v-if="isPending">Adding todo...</span>
      <span v-else-if="isError">An error occurred: {{ error.message }}</span>
      <span v-else-if="isSuccess">Todo added!</span>
      <button @click="addTodo">Create Todo</button>
    </template>
    

A mutation can only be in one of the following states at any given moment:

*   isIdle or status === 'idle' - The mutation is currently idle or in a fresh/reset state
*   isPending or status === 'pending' - The mutation is currently running
*   isError or status === 'error' - The mutation encountered an error
*   isSuccess or status === 'success' - The mutation was successful and mutation data is available

Beyond those primary states, more information is available depending on the state of the mutation:

*   error - If the mutation is in an error state, the error is available via the error property.
*   data - If the mutation is in a success state, the data is available via the data property.

In the example above, you also saw that you can pass variables to your mutations function by calling the mutate function with a **single variable or object**.

Even with just variables, mutations aren't all that special, but when used with the onSuccess option, the [Query Client's invalidateQueries method](https://tanstack.com/query/latest/docs/reference/QueryClient#queryclientinvalidatequeries) and the [Query Client's setQueryData method](https://tanstack.com/query/latest/docs/reference/QueryClient#queryclientsetquerydata), mutations become a very powerful tool.

[](#resetting-mutation-state)[Resetting Mutation State](#resetting-mutation-state)
----------------------------------------------------------------------------------

It's sometimes the case that you need to clear the error or data of a mutation request. To do this, you can use the reset function to handle this:

    <script>
    import { useMutation } from '@tanstack/vue-query'
    
    const { error, mutate, reset } = useMutation({
      mutationFn: (newTodo) => axios.post('/todos', newTodo),
    })
    
    function addTodo() {
      mutate({ id: new Date(), title: 'Do Laundry' })
    }
    </script>
    
    <template>
      <span v-else-if="error">
        <span>An error occurred: {{ error.message }}</span>
        <button @click="reset">Reset error</button>
      </span>
      <button @click="addTodo">Create Todo</button>
    </template>
    

    <script>
    import { useMutation } from '@tanstack/vue-query'
    
    const { error, mutate, reset } = useMutation({
      mutationFn: (newTodo) => axios.post('/todos', newTodo),
    })
    
    function addTodo() {
      mutate({ id: new Date(), title: 'Do Laundry' })
    }
    </script>
    
    <template>
      <span v-else-if="error">
        <span>An error occurred: {{ error.message }}</span>
        <button @click="reset">Reset error</button>
      </span>
      <button @click="addTodo">Create Todo</button>
    </template>
    

[](#mutation-side-effects)[Mutation Side Effects](#mutation-side-effects)
-------------------------------------------------------------------------

useMutation comes with some helper options that allow quick and easy side-effects at any stage during the mutation lifecycle. These come in handy for both [invalidating and refetching queries after mutations](https://tanstack.com/query/latest/docs/framework/vue/guides/invalidations-from-mutations) and even [optimistic updates](https://tanstack.com/query/latest/docs/framework/vue/guides/optimistic-updates)

    useMutation({
      mutationFn: addTodo,
      onMutate: (variables, context) => {
        // A mutation is about to happen!
    
        // Optionally return a result containing data to use when for example rolling back
        return { id: 1 }
      },
      onError: (error, variables, onMutateResult, context) => {
        // An error happened!
        console.log(`rolling back optimistic update with id ${onMutateResult.id}`)
      },
      onSuccess: (data, variables, onMutateResult, context) => {
        // Boom baby!
      },
      onSettled: (data, error, variables, onMutateResult, context) => {
        // Error or success... doesn't matter!
      },
    })
    

    useMutation({
      mutationFn: addTodo,
      onMutate: (variables, context) => {
        // A mutation is about to happen!
    
        // Optionally return a result containing data to use when for example rolling back
        return { id: 1 }
      },
      onError: (error, variables, onMutateResult, context) => {
        // An error happened!
        console.log(`rolling back optimistic update with id ${onMutateResult.id}`)
      },
      onSuccess: (data, variables, onMutateResult, context) => {
        // Boom baby!
      },
      onSettled: (data, error, variables, onMutateResult, context) => {
        // Error or success... doesn't matter!
      },
    })
    

When returning a promise in any of the callback functions it will first be awaited before the next callback is called:

    useMutation({
      mutationFn: addTodo,
      onSuccess: async () => {
        console.log("I'm first!")
      },
      onSettled: async () => {
        console.log("I'm second!")
      },
    })
    

    useMutation({
      mutationFn: addTodo,
      onSuccess: async () => {
        console.log("I'm first!")
      },
      onSettled: async () => {
        console.log("I'm second!")
      },
    })
    

You might find that you want to **trigger additional callbacks** beyond the ones defined on useMutation when calling mutate. This can be used to trigger component-specific side effects. To do that, you can provide any of the same callback options to the mutate function after your mutation variable. Supported options include: onSuccess, onError and onSettled. Please keep in mind that those additional callbacks won't run if your component unmounts _before_ the mutation finishes.

    useMutation({
      mutationFn: addTodo,
      onSuccess: (data, variables, onMutateResult, context) => {
        // I will fire first
      },
      onError: (error, variables, onMutateResult, context) => {
        // I will fire first
      },
      onSettled: (data, error, variables, onMutateResult, context) => {
        // I will fire first
      },
    })
    
    mutate(todo, {
      onSuccess: (data, variables, onMutateResult, context) => {
        // I will fire second!
      },
      onError: (error, variables, onMutateResult, context) => {
        // I will fire second!
      },
      onSettled: (data, error, variables, onMutateResult, context) => {
        // I will fire second!
      },
    })
    

    useMutation({
      mutationFn: addTodo,
      onSuccess: (data, variables, onMutateResult, context) => {
        // I will fire first
      },
      onError: (error, variables, onMutateResult, context) => {
        // I will fire first
      },
      onSettled: (data, error, variables, onMutateResult, context) => {
        // I will fire first
      },
    })
    
    mutate(todo, {
      onSuccess: (data, variables, onMutateResult, context) => {
        // I will fire second!
      },
      onError: (error, variables, onMutateResult, context) => {
        // I will fire second!
      },
      onSettled: (data, error, variables, onMutateResult, context) => {
        // I will fire second!
      },
    })
    

### [](#consecutive-mutations)[Consecutive mutations](#consecutive-mutations)

There is a slight difference in handling onSuccess, onError and onSettled callbacks when it comes to consecutive mutations. When passed to the mutate function, they will be fired up only _once_ and only if the component is still mounted. This is due to the fact that mutation observer is removed and resubscribed every time when the mutate function is called. On the contrary, useMutation handlers execute for each mutate call.

> Be aware that most likely, mutationFn passed to useMutation is asynchronous. In that case, the order in which mutations are fulfilled may differ from the order of mutate function calls.

    useMutation({
      mutationFn: addTodo,
      onSuccess: (data, variables, onMutateResult, context) => {
        // Will be called 3 times
      },
    })
    
    const todos = ['Todo 1', 'Todo 2', 'Todo 3']
    todos.forEach((todo) => {
      mutate(todo, {
        onSuccess: (data, variables, onMutateResult, context) => {
          // Will execute only once, for the last mutation (Todo 3),
          // regardless which mutation resolves first
        },
      })
    })
    

    useMutation({
      mutationFn: addTodo,
      onSuccess: (data, variables, onMutateResult, context) => {
        // Will be called 3 times
      },
    })
    
    const todos = ['Todo 1', 'Todo 2', 'Todo 3']
    todos.forEach((todo) => {
      mutate(todo, {
        onSuccess: (data, variables, onMutateResult, context) => {
          // Will execute only once, for the last mutation (Todo 3),
          // regardless which mutation resolves first
        },
      })
    })
    

[](#promises)[Promises](#promises)
----------------------------------

Use mutateAsync instead of mutate to get a promise which will resolve on success or throw on an error. This can for example be used to compose side effects.

    const mutation = useMutation({ mutationFn: addTodo })
    
    try {
      const todo = await mutation.mutateAsync(todo)
      console.log(todo)
    } catch (error) {
      console.error(error)
    } finally {
      console.log('done')
    }
    

    const mutation = useMutation({ mutationFn: addTodo })
    
    try {
      const todo = await mutation.mutateAsync(todo)
      console.log(todo)
    } catch (error) {
      console.error(error)
    } finally {
      console.log('done')
    }
    

[](#retry)[Retry](#retry)
-------------------------

By default, TanStack Query will not retry a mutation on error, but it is possible with the retry option:

    const mutation = useMutation({
      mutationFn: addTodo,
      retry: 3,
    })
    

    const mutation = useMutation({
      mutationFn: addTodo,
      retry: 3,
    })
    

If mutations fail because the device is offline, they will be retried in the same order when the device reconnects.

[](#persist-mutations)[Persist mutations](#persist-mutations)
-------------------------------------------------------------

Mutations can be persisted to storage if needed and resumed at a later point. This can be done with the hydration functions:

    const queryClient = new QueryClient()
    
    // Define the "addTodo" mutation
    queryClient.setMutationDefaults(['addTodo'], {
      mutationFn: addTodo,
      onMutate: async (variables, context) => {
        // Cancel current queries for the todos list
        await context.client.cancelQueries({ queryKey: ['todos'] })
    
        // Create optimistic todo
        const optimisticTodo = { id: uuid(), title: variables.title }
    
        // Add optimistic todo to todos list
        context.client.setQueryData(['todos'], (old) => [...old, optimisticTodo])
    
        // Return a result with the optimistic todo
        return { optimisticTodo }
      },
      onSuccess: (result, variables, onMutateResult, context) => {
        // Replace optimistic todo in the todos list with the result
        context.client.setQueryData(['todos'], (old) =>
          old.map((todo) =>
            todo.id === onMutateResult.optimisticTodo.id ? result : todo,
          ),
        )
      },
      onError: (error, variables, onMutateResult, context) => {
        // Remove optimistic todo from the todos list
        context.client.setQueryData(['todos'], (old) =>
          old.filter((todo) => todo.id !== onMutateResult.optimisticTodo.id),
        )
      },
      retry: 3,
    })
    
    // Start mutation in some component:
    const mutation = useMutation({ mutationKey: ['addTodo'] })
    mutation.mutate({ title: 'title' })
    
    // If the mutation has been paused because the device is for example offline,
    // Then the paused mutation can be dehydrated when the application quits:
    const state = dehydrate(queryClient)
    
    // The mutation can then be hydrated again when the application is started:
    hydrate(queryClient, state)
    
    // Resume the paused mutations:
    queryClient.resumePausedMutations()
    

    const queryClient = new QueryClient()
    
    // Define the "addTodo" mutation
    queryClient.setMutationDefaults(['addTodo'], {
      mutationFn: addTodo,
      onMutate: async (variables, context) => {
        // Cancel current queries for the todos list
        await context.client.cancelQueries({ queryKey: ['todos'] })
    
        // Create optimistic todo
        const optimisticTodo = { id: uuid(), title: variables.title }
    
        // Add optimistic todo to todos list
        context.client.setQueryData(['todos'], (old) => [...old, optimisticTodo])
    
        // Return a result with the optimistic todo
        return { optimisticTodo }
      },
      onSuccess: (result, variables, onMutateResult, context) => {
        // Replace optimistic todo in the todos list with the result
        context.client.setQueryData(['todos'], (old) =>
          old.map((todo) =>
            todo.id === onMutateResult.optimisticTodo.id ? result : todo,
          ),
        )
      },
      onError: (error, variables, onMutateResult, context) => {
        // Remove optimistic todo from the todos list
        context.client.setQueryData(['todos'], (old) =>
          old.filter((todo) => todo.id !== onMutateResult.optimisticTodo.id),
        )
      },
      retry: 3,
    })
    
    // Start mutation in some component:
    const mutation = useMutation({ mutationKey: ['addTodo'] })
    mutation.mutate({ title: 'title' })
    
    // If the mutation has been paused because the device is for example offline,
    // Then the paused mutation can be dehydrated when the application quits:
    const state = dehydrate(queryClient)
    
    // The mutation can then be hydrated again when the application is started:
    hydrate(queryClient, state)
    
    // Resume the paused mutations:
    queryClient.resumePausedMutations()
    

### [](#persisting-offline-mutations)[Persisting Offline mutations](#persisting-offline-mutations)

If you persist offline mutations with the [persistQueryClient plugin](https://tanstack.com/query/latest/docs/framework/vue/plugins/persistQueryClient), mutations cannot be resumed when the page is reloaded unless you provide a default mutation function.

This is a technical limitation. When persisting to an external storage, only the state of mutations is persisted, as functions cannot be serialized. After hydration, the component that triggers the mutation might not be mounted, so calling resumePausedMutations might yield an error: No mutationFn found.

    const client = new QueryClient({
      defaultOptions: {
        queries: {
          gcTime: 1000 * 60 * 60 * 24, // 24 hours
        },
      },
    })
    
    // we need a default mutation function so that paused mutations can resume after a page reload
    queryClient.setMutationDefaults({
      mutationKey: ['todos'],
      mutationFn: ({ id, data }) => {
        return api.updateTodo(id, data)
      },
    })
    
    const vueQueryOptions: VueQueryPluginOptions = {
      queryClient: client,
      clientPersister: (queryClient) => {
        return persistQueryClient({
          queryClient,
          persister: createAsyncStoragePersister({ storage: localStorage }),
        })
      },
      clientPersisterOnSuccess: (queryClient) => {
        queryClient.resumePausedMutations()
      },
    }
    
    createApp(App).use(VueQueryPlugin, vueQueryOptions).mount('#app')
    

    const client = new QueryClient({
      defaultOptions: {
        queries: {
          gcTime: 1000 * 60 * 60 * 24, // 24 hours
        },
      },
    })
    
    // we need a default mutation function so that paused mutations can resume after a page reload
    queryClient.setMutationDefaults({
      mutationKey: ['todos'],
      mutationFn: ({ id, data }) => {
        return api.updateTodo(id, data)
      },
    })
    
    const vueQueryOptions: VueQueryPluginOptions = {
      queryClient: client,
      clientPersister: (queryClient) => {
        return persistQueryClient({
          queryClient,
          persister: createAsyncStoragePersister({ storage: localStorage }),
        })
      },
      clientPersisterOnSuccess: (queryClient) => {
        queryClient.resumePausedMutations()
      },
    }
    
    createApp(App).use(VueQueryPlugin, vueQueryOptions).mount('#app')
    

We also have an extensive [offline example](https://tanstack.com/query/latest/docs/framework/vue/examples/offline) that covers both queries and mutations.

[](#mutation-scopes)[Mutation Scopes](#mutation-scopes)
-------------------------------------------------------

Per default, all mutations run in parallel - even if you invoke .mutate() of the same mutation multiple times. Mutations can be given a scope with an id to avoid that. All mutations with the same scope.id will run in serial, which means when they are triggered, they will start in isPaused: true state if there is already a mutation for that scope in progress. They will be put into a queue and will automatically resume once their time in the queue has come.

    const mutation = useMutation({
      mutationFn: addTodo,
      scope: {
        id: 'todo',
      },
    })
    

    const mutation = useMutation({
      mutationFn: addTodo,
      scope: {
        id: 'todo',
      },
    })</content>
</page>

<page>
  <title>Invalidations from Mutations | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/guides/invalidations-from-mutations</url>
  <content>Invalidating queries is only half the battle. Knowing **when** to invalidate them is the other half. Usually when a mutation in your app succeeds, it's VERY likely that there are related queries in your application that need to be invalidated and possibly refetched to account for the new changes from your mutation.

For example, assume we have a mutation to post a new todo:

    const mutation = useMutation({ mutationFn: postTodo })
    

    const mutation = useMutation({ mutationFn: postTodo })
    

When a successful postTodo mutation happens, we likely want all todos queries to get invalidated and possibly refetched to show the new todo item. To do this, you can use useMutation's onSuccess options and the client's invalidateQueries function:

    import { useMutation, useQueryClient } from '@tanstack/react-query'
    
    const queryClient = useQueryClient()
    
    // When this mutation succeeds, invalidate any queries with the `todos` or `reminders` query key
    const mutation = useMutation({
      mutationFn: addTodo,
      onSuccess: async () => {
        // If you're invalidating a single query
        await queryClient.invalidateQueries({ queryKey: ['todos'] })
    
        // If you're invalidating multiple queries
        await Promise.all([
          queryClient.invalidateQueries({ queryKey: ['todos'] }),
          queryClient.invalidateQueries({ queryKey: ['reminders'] }),
        ])
      },
    })
    

    import { useMutation, useQueryClient } from '@tanstack/react-query'
    
    const queryClient = useQueryClient()
    
    // When this mutation succeeds, invalidate any queries with the `todos` or `reminders` query key
    const mutation = useMutation({
      mutationFn: addTodo,
      onSuccess: async () => {
        // If you're invalidating a single query
        await queryClient.invalidateQueries({ queryKey: ['todos'] })
    
        // If you're invalidating multiple queries
        await Promise.all([
          queryClient.invalidateQueries({ queryKey: ['todos'] }),
          queryClient.invalidateQueries({ queryKey: ['reminders'] }),
        ])
      },
    })
    

Returning a Promise on onSuccess makes sure the data is updated before the mutation is entirely complete (i.e., isPending is true until onSuccess is fulfilled)

    import { useMutation, useQueryClient } from '@tanstack/vue-query'
    
    const queryClient = useQueryClient()
    
    // When this mutation succeeds, invalidate any queries with the `todos` or `reminders` query key
    const mutation = useMutation({
      mutationFn: addTodo,
      onSuccess: () => {
        queryClient.invalidateQueries({ queryKey: ['todos'] })
        queryClient.invalidateQueries({ queryKey: ['reminders'] })
      },
    })
    

    import { useMutation, useQueryClient } from '@tanstack/vue-query'
    
    const queryClient = useQueryClient()
    
    // When this mutation succeeds, invalidate any queries with the `todos` or `reminders` query key
    const mutation = useMutation({
      mutationFn: addTodo,
      onSuccess: () => {
        queryClient.invalidateQueries({ queryKey: ['todos'] })
        queryClient.invalidateQueries({ queryKey: ['reminders'] })
      },
    })
    

[](#further-reading)[Further reading](#further-reading)
-------------------------------------------------------

For a technique to automatically invalidate Queries after Mutations, have a look at [TkDodo's article on Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/automatic-query-invalidation-after-mutations).</content>
</page>

<page>
  <title>Updates from Mutation Responses | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/guides/updates-from-mutation-responses</url>
  <content>When dealing with mutations that **update** objects on the server, it's common for the new object to be automatically returned in the response of the mutation. Instead of refetching any queries for that item and wasting a network call for data we already have, we can take advantage of the object returned by the mutation function and update the existing query with the new data immediately using the [Query Client's setQueryData](https://tanstack.com/query/latest/docs/reference/QueryClient#queryclientsetquerydata) method:

    const queryClient = useQueryClient()
    
    const mutation = useMutation({
      mutationFn: editTodo,
      onSuccess: (data) => {
        queryClient.setQueryData(['todo', { id: 5 }], data)
      },
    })
    
    mutation.mutate({
      id: 5,
      name: 'Do the laundry',
    })
    
    // The query below will be updated with the response from the
    // successful mutation
    const { status, data, error } = useQuery({
      queryKey: ['todo', { id: 5 }],
      queryFn: fetchTodoById,
    })
    

    const queryClient = useQueryClient()
    
    const mutation = useMutation({
      mutationFn: editTodo,
      onSuccess: (data) => {
        queryClient.setQueryData(['todo', { id: 5 }], data)
      },
    })
    
    mutation.mutate({
      id: 5,
      name: 'Do the laundry',
    })
    
    // The query below will be updated with the response from the
    // successful mutation
    const { status, data, error } = useQuery({
      queryKey: ['todo', { id: 5 }],
      queryFn: fetchTodoById,
    })
    

You might want to tie the onSuccess logic into a reusable mutation, for that you can create a custom hook like this:

    const useMutateTodo = () => {
      const queryClient = useQueryClient()
    
      return useMutation({
        mutationFn: editTodo,
        // Notice the second argument is the variables object that the `mutate` function receives
        onSuccess: (data, variables) => {
          queryClient.setQueryData(['todo', { id: variables.id }], data)
        },
      })
    }
    

    const useMutateTodo = () => {
      const queryClient = useQueryClient()
    
      return useMutation({
        mutationFn: editTodo,
        // Notice the second argument is the variables object that the `mutate` function receives
        onSuccess: (data, variables) => {
          queryClient.setQueryData(['todo', { id: variables.id }], data)
        },
      })
    }
    

[](#immutability)[Immutability](#immutability)
----------------------------------------------

Updates via setQueryData must be performed in an _immutable_ way. **DO NOT** attempt to write directly to the cache by mutating data (that you retrieved from the cache) in place. It might work at first but can lead to subtle bugs along the way.

    queryClient.setQueryData(['posts', { id }], (oldData) => {
      if (oldData) {
        // ‚ùå do not try this
        oldData.title = 'my new post title'
      }
      return oldData
    })
    
    queryClient.setQueryData(
      ['posts', { id }],
      // ‚úÖ this is the way
      (oldData) =>
        oldData
          ? {
              ...oldData,
              title: 'my new post title',
            }
          : oldData,
    )
    

    queryClient.setQueryData(['posts', { id }], (oldData) => {
      if (oldData) {
        // ‚ùå do not try this
        oldData.title = 'my new post title'
      }
      return oldData
    })
    
    queryClient.setQueryData(
      ['posts', { id }],
      // ‚úÖ this is the way
      (oldData) =>
        oldData
          ? {
              ...oldData,
              title: 'my new post title',
            }
          : oldData,
    )</content>
</page>

<page>
  <title>Optimistic Updates | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/guides/optimistic-updates</url>
  <content>Vue Query provides two ways to optimistically update your UI before a mutation has completed. You can either use the onMutate option to update your cache directly, or leverage the returned variables to update your UI from the useMutation result.

[](#via-the-ui)[Via the UI](#via-the-ui)
----------------------------------------

This is the simpler variant, as it doesn't interact with the cache directly.

    const addTodoMutation = useMutation({
      mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
      // make sure to _return_ the Promise from the query invalidation
      // so that the mutation stays in `pending` state until the refetch is finished
      onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
    })
    
    const { isPending, submittedAt, variables, mutate, isError } = addTodoMutation
    

    const addTodoMutation = useMutation({
      mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
      // make sure to _return_ the Promise from the query invalidation
      // so that the mutation stays in `pending` state until the refetch is finished
      onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
    })
    
    const { isPending, submittedAt, variables, mutate, isError } = addTodoMutation
    

you will then have access to addTodoMutation.variables, which contain the added todo. In your UI list, where the query is rendered, you can append another item to the list while the mutation isPending:

    <ul>
      {todoQuery.items.map((todo) => (
        <li key={todo.id}>{todo.text}</li>
      ))}
      {isPending && <li style={{ opacity: 0.5 }}>{variables}</li>}
    </ul>
    

    <ul>
      {todoQuery.items.map((todo) => (
        <li key={todo.id}>{todo.text}</li>
      ))}
      {isPending && <li style={{ opacity: 0.5 }}>{variables}</li>}
    </ul>
    

We're rendering a temporary item with a different opacity as long as the mutation is pending. Once it completes, the item will automatically no longer be rendered. Given that the refetch succeeded, we should see the item as a "normal item" in our list.

If the mutation errors, the item will also disappear. But we could continue to show it, if we want, by checking for the isError state of the mutation. variables are _not_ cleared when the mutation errors, so we can still access them, maybe even show a retry button:

    {
      isError && (
        <li style={{ color: 'red' }}>
          {variables}
          <button onClick={() => mutate(variables)}>Retry</button>
        </li>
      )
    }
    

    {
      isError && (
        <li style={{ color: 'red' }}>
          {variables}
          <button onClick={() => mutate(variables)}>Retry</button>
        </li>
      )
    }
    

### [](#if-the-mutation-and-the-query-dont-live-in-the-same-component)[If the mutation and the query don't live in the same component](#if-the-mutation-and-the-query-dont-live-in-the-same-component)

This approach works very well if the mutation and the query live in the same component. However, you also get access to all mutations in other components via the dedicated useMutationState hook. It is best combined with a mutationKey:

    // somewhere in your app
    const { mutate } = useMutation({
      mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
      onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
      mutationKey: ['addTodo'],
    })
    
    // access variables somewhere else
    const variables = useMutationState<string>({
      filters: { mutationKey: ['addTodo'], status: 'pending' },
      select: (mutation) => mutation.state.variables,
    })
    

    // somewhere in your app
    const { mutate } = useMutation({
      mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
      onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
      mutationKey: ['addTodo'],
    })
    
    // access variables somewhere else
    const variables = useMutationState<string>({
      filters: { mutationKey: ['addTodo'], status: 'pending' },
      select: (mutation) => mutation.state.variables,
    })
    

variables will be an Array, because there might be multiple mutations running at the same time. If we need a unique key for the items, we can also select mutation.state.submittedAt. This will even make displaying concurrent optimistic updates a breeze.

[](#via-the-cache)[Via the cache](#via-the-cache)
-------------------------------------------------

When you optimistically update your state before performing a mutation, there is a chance that the mutation will fail. In most of these failure cases, you can just trigger a refetch for your optimistic queries to revert them to their true server state. In some circumstances though, refetching may not work correctly and the mutation error could represent some type of server issue that won't make it possible to refetch. In this event, you can instead choose to roll back your update.

To do this, useMutation's onMutate handler option allows you to return a value that will later be passed to both onError and onSettled handlers as the last argument. In most cases, it is most useful to pass a rollback function.

### [](#updating-a-list-of-todos-when-adding-a-new-todo)[Updating a list of todos when adding a new todo](#updating-a-list-of-todos-when-adding-a-new-todo)

    const queryClient = useQueryClient()
    
    useMutation({
      mutationFn: updateTodo,
      // When mutate is called:
      onMutate: async (newTodo, context) => {
        // Cancel any outgoing refetches
        // (so they don't overwrite our optimistic update)
        await context.client.cancelQueries({ queryKey: ['todos'] })
    
        // Snapshot the previous value
        const previousTodos = context.client.getQueryData(['todos'])
    
        // Optimistically update to the new value
        context.client.setQueryData(['todos'], (old) => [...old, newTodo])
    
        // Return a result with the snapshotted value
        return { previousTodos }
      },
      // If the mutation fails,
      // use the result returned from onMutate to roll back
      onError: (err, newTodo, onMutateResult, context) => {
        context.client.setQueryData(['todos'], onMutateResult.previousTodos)
      },
      // Always refetch after error or success:
      onSettled: (data, error, variables, onMutateResult, context) =>
        context.client.invalidateQueries({ queryKey: ['todos'] }),
    })
    

    const queryClient = useQueryClient()
    
    useMutation({
      mutationFn: updateTodo,
      // When mutate is called:
      onMutate: async (newTodo, context) => {
        // Cancel any outgoing refetches
        // (so they don't overwrite our optimistic update)
        await context.client.cancelQueries({ queryKey: ['todos'] })
    
        // Snapshot the previous value
        const previousTodos = context.client.getQueryData(['todos'])
    
        // Optimistically update to the new value
        context.client.setQueryData(['todos'], (old) => [...old, newTodo])
    
        // Return a result with the snapshotted value
        return { previousTodos }
      },
      // If the mutation fails,
      // use the result returned from onMutate to roll back
      onError: (err, newTodo, onMutateResult, context) => {
        context.client.setQueryData(['todos'], onMutateResult.previousTodos)
      },
      // Always refetch after error or success:
      onSettled: (data, error, variables, onMutateResult, context) =>
        context.client.invalidateQueries({ queryKey: ['todos'] }),
    })
    

### [](#updating-a-single-todo)[Updating a single todo](#updating-a-single-todo)

    useMutation({
      mutationFn: updateTodo,
      // When mutate is called:
      onMutate: async (newTodo, context) => {
        // Cancel any outgoing refetches
        // (so they don't overwrite our optimistic update)
        await context.client.cancelQueries({ queryKey: ['todos', newTodo.id] })
    
        // Snapshot the previous value
        const previousTodo = context.client.getQueryData(['todos', newTodo.id])
    
        // Optimistically update to the new value
        context.client.setQueryData(['todos', newTodo.id], newTodo)
    
        // Return a result with the previous and new todo
        return { previousTodo, newTodo }
      },
      // If the mutation fails, use the result we returned above
      onError: (err, newTodo, onMutateResult, context) => {
        context.client.setQueryData(
          ['todos', onMutateResult.newTodo.id],
          onMutateResult.previousTodo,
        )
      },
      // Always refetch after error or success:
      onSettled: (newTodo, error, variables, onMutateResult, context) =>
        context.client.invalidateQueries({ queryKey: ['todos', newTodo.id] }),
    })
    

    useMutation({
      mutationFn: updateTodo,
      // When mutate is called:
      onMutate: async (newTodo, context) => {
        // Cancel any outgoing refetches
        // (so they don't overwrite our optimistic update)
        await context.client.cancelQueries({ queryKey: ['todos', newTodo.id] })
    
        // Snapshot the previous value
        const previousTodo = context.client.getQueryData(['todos', newTodo.id])
    
        // Optimistically update to the new value
        context.client.setQueryData(['todos', newTodo.id], newTodo)
    
        // Return a result with the previous and new todo
        return { previousTodo, newTodo }
      },
      // If the mutation fails, use the result we returned above
      onError: (err, newTodo, onMutateResult, context) => {
        context.client.setQueryData(
          ['todos', onMutateResult.newTodo.id],
          onMutateResult.previousTodo,
        )
      },
      // Always refetch after error or success:
      onSettled: (newTodo, error, variables, onMutateResult, context) =>
        context.client.invalidateQueries({ queryKey: ['todos', newTodo.id] }),
    })
    

You can also use the onSettled function in place of the separate onError and onSuccess handlers if you wish:

    useMutation({
      mutationFn: updateTodo,
      // ...
      onSettled: async (newTodo, error, variables, onMutateResult, context) => {
        if (error) {
          // do something
        }
      },
    })
    

    useMutation({
      mutationFn: updateTodo,
      // ...
      onSettled: async (newTodo, error, variables, onMutateResult, context) => {
        if (error) {
          // do something
        }
      },
    })
    

[](#when-to-use-what)[When to use what](#when-to-use-what)
----------------------------------------------------------

If you only have one place where the optimistic result should be shown, using variables and updating the UI directly is the approach that requires less code and is generally easier to reason about. For example, you don't need to handle rollbacks at all.

However, if you have multiple places on the screen that would require to know about the update, manipulating the cache directly will take care of this for you automatically.

[](#further-reading)[Further reading](#further-reading)
-------------------------------------------------------

Have a look at the guide by TkDodo on [Concurrent Optimistic Updates](https://tkdodo.eu/blog/concurrent-optimistic-updates-in-react-query).</content>
</page>

<page>
  <title>Query Cancellation | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/guides/query-cancellation</url>
  <content>TanStack Query provides each query function with an [AbortSignal instance](https://developer.mozilla.org/docs/Web/API/AbortSignal). When a query becomes out-of-date or inactive, this signal will become aborted. This means that all queries are cancellable, and you can respond to the cancellation inside your query function if desired. The best part about this is that it allows you to continue to use normal async/await syntax while getting all the benefits of automatic cancellation.

The AbortController API is available in [most runtime environments](https://developer.mozilla.org/docs/Web/API/AbortController#browser_compatibility), but if your runtime environment does not support it, you will need to provide a polyfill. There are [several available](https://www.npmjs.com/search?q=abortcontroller%20polyfill).

[](#default-behavior)[Default behavior](#default-behavior)
----------------------------------------------------------

By default, queries that unmount or become unused before their promises are resolved are _not_ cancelled. This means that after the promise has resolved, the resulting data will be available in the cache. This is helpful if you've started receiving a query, but then unmount the component before it finishes. If you mount the component again and the query has not been garbage collected yet, data will be available.

However, if you consume the AbortSignal, the Promise will be cancelled (e.g. aborting the fetch) and therefore, also the Query must be cancelled. Cancelling the query will result in its state being _reverted_ to its previous state.

[](#using-fetch)[Using fetch](#using-fetch)
-------------------------------------------

    const query = useQuery({
      queryKey: ['todos'],
      queryFn: async ({ signal }) => {
        const todosResponse = await fetch('/todos', {
          // Pass the signal to one fetch
          signal,
        })
        const todos = await todosResponse.json()
    
        const todoDetails = todos.map(async ({ details }) => {
          const response = await fetch(details, {
            // Or pass it to several
            signal,
          })
          return response.json()
        })
    
        return Promise.all(todoDetails)
      },
    })
    

    const query = useQuery({
      queryKey: ['todos'],
      queryFn: async ({ signal }) => {
        const todosResponse = await fetch('/todos', {
          // Pass the signal to one fetch
          signal,
        })
        const todos = await todosResponse.json()
    
        const todoDetails = todos.map(async ({ details }) => {
          const response = await fetch(details, {
            // Or pass it to several
            signal,
          })
          return response.json()
        })
    
        return Promise.all(todoDetails)
      },
    })
    

[](#using-axios-v0220)[Using axios](#using-axios-v0220) [v0.22.0+](https://github.com/axios/axios/releases/tag/v0.22.0)
-----------------------------------------------------------------------------------------------------------------------

    import axios from 'axios'
    
    const query = useQuery({
      queryKey: ['todos'],
      queryFn: ({ signal }) =>
        axios.get('/todos', {
          // Pass the signal to `axios`
          signal,
        }),
    })
    

    import axios from 'axios'
    
    const query = useQuery({
      queryKey: ['todos'],
      queryFn: ({ signal }) =>
        axios.get('/todos', {
          // Pass the signal to `axios`
          signal,
        }),
    })
    

### [](#using-axios-with-version-lower-than-v0220)[Using axios with version lower than v0.22.0](#using-axios-with-version-lower-than-v0220)

    import axios from 'axios'
    
    const query = useQuery({
      queryKey: ['todos'],
      queryFn: ({ signal }) => {
        // Create a new CancelToken source for this request
        const CancelToken = axios.CancelToken
        const source = CancelToken.source()
    
        const promise = axios.get('/todos', {
          // Pass the source token to your request
          cancelToken: source.token,
        })
    
        // Cancel the request if TanStack Query signals to abort
        signal?.addEventListener('abort', () => {
          source.cancel('Query was cancelled by TanStack Query')
        })
    
        return promise
      },
    })
    

    import axios from 'axios'
    
    const query = useQuery({
      queryKey: ['todos'],
      queryFn: ({ signal }) => {
        // Create a new CancelToken source for this request
        const CancelToken = axios.CancelToken
        const source = CancelToken.source()
    
        const promise = axios.get('/todos', {
          // Pass the source token to your request
          cancelToken: source.token,
        })
    
        // Cancel the request if TanStack Query signals to abort
        signal?.addEventListener('abort', () => {
          source.cancel('Query was cancelled by TanStack Query')
        })
    
        return promise
      },
    })
    

[](#using-xmlhttprequest)[Using XMLHttpRequest](#using-xmlhttprequest)
----------------------------------------------------------------------

    const query = useQuery({
      queryKey: ['todos'],
      queryFn: ({ signal }) => {
        return new Promise((resolve, reject) => {
          var oReq = new XMLHttpRequest()
          oReq.addEventListener('load', () => {
            resolve(JSON.parse(oReq.responseText))
          })
          signal?.addEventListener('abort', () => {
            oReq.abort()
            reject()
          })
          oReq.open('GET', '/todos')
          oReq.send()
        })
      },
    })
    

    const query = useQuery({
      queryKey: ['todos'],
      queryFn: ({ signal }) => {
        return new Promise((resolve, reject) => {
          var oReq = new XMLHttpRequest()
          oReq.addEventListener('load', () => {
            resolve(JSON.parse(oReq.responseText))
          })
          signal?.addEventListener('abort', () => {
            oReq.abort()
            reject()
          })
          oReq.open('GET', '/todos')
          oReq.send()
        })
      },
    })
    

[](#using-graphql-request)[Using graphql-request](#using-graphql-request)
-------------------------------------------------------------------------

An AbortSignal can be set in the client request method.

    const client = new GraphQLClient(endpoint)
    
    const query = useQuery({
      queryKey: ['todos'],
      queryFn: ({ signal }) => {
        client.request({ document: query, signal })
      },
    })
    

    const client = new GraphQLClient(endpoint)
    
    const query = useQuery({
      queryKey: ['todos'],
      queryFn: ({ signal }) => {
        client.request({ document: query, signal })
      },
    })
    

[](#using-graphql-request-with-version-lower-than-v400)[Using graphql-request with version lower than v4.0.0](#using-graphql-request-with-version-lower-than-v400)
------------------------------------------------------------------------------------------------------------------------------------------------------------------

An AbortSignal can be set in the GraphQLClient constructor.

    const query = useQuery({
      queryKey: ['todos'],
      queryFn: ({ signal }) => {
        const client = new GraphQLClient(endpoint, {
          signal,
        })
        return client.request(query, variables)
      },
    })
    

    const query = useQuery({
      queryKey: ['todos'],
      queryFn: ({ signal }) => {
        const client = new GraphQLClient(endpoint, {
          signal,
        })
        return client.request(query, variables)
      },
    })
    

[](#manual-cancellation)[Manual Cancellation](#manual-cancellation)
-------------------------------------------------------------------

You might want to cancel a query manually. For example, if the request takes a long time to finish, you can allow the user to click a cancel button to stop the request. To do this, you just need to call queryClient.cancelQueries({ queryKey }), which will cancel the query and revert it back to its previous state. If you have consumed the signal passed to the query function, TanStack Query will additionally also cancel the Promise.

    const query = useQuery({
      queryKey: ['todos'],
      queryFn: async ({ signal }) => {
        const resp = await fetch('/todos', { signal })
        return resp.json()
      },
    })
    
    const queryClient = useQueryClient()
    
    function onButtonClick() {
      queryClient.cancelQueries({ queryKey: ['todos'] })
    }
    

    const query = useQuery({
      queryKey: ['todos'],
      queryFn: async ({ signal }) => {
        const resp = await fetch('/todos', { signal })
        return resp.json()
      },
    })
    
    const queryClient = useQueryClient()
    
    function onButtonClick() {
      queryClient.cancelQueries({ queryKey: ['todos'] })
    }
    

[](#cancel-options)[Cancel Options](#cancel-options)
----------------------------------------------------

Cancel options are used to control the behavior of query cancellation operations.

    // Cancel specific queries silently
    await queryClient.cancelQueries({ queryKey: ['posts'] }, { silent: true })
    

    // Cancel specific queries silently
    await queryClient.cancelQueries({ queryKey: ['posts'] }, { silent: true })
    

A cancel options object supports the following properties:

*   silent?: boolean
    *   When set to true, suppresses propagation of CancelledError to observers (e.g., onError callbacks) and related notifications, and returns the retry promise instead of rejecting.
    *   Defaults to false
*   revert?: boolean
    *   When set to true, restores the query‚Äôs state (data and status) from immediately before the in-flight fetch, sets fetchStatus back to idle, and only throws if there was no prior data.
    *   Defaults to true

[](#limitations)[Limitations](#limitations)
-------------------------------------------

Cancellation does not work when working with Suspense hooks: useSuspenseQuery, useSuspenseQueries and useSuspenseInfiniteQuery.</content>
</page>

<page>
  <title>Scroll Restoration | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/guides/scroll-restoration</url>
  <content>Traditionally, when you navigate to a previously visited page on a web browser, you would find that the page would be scrolled to the exact position where you were before you navigated away from that page. This is called **scroll restoration** and has been in a bit of a regression since web applications have started moving towards client side data fetching. With TanStack Query however, that's no longer the case.

Out of the box, "scroll restoration" for all queries (including paginated and infinite queries) Just Works‚Ñ¢Ô∏è in TanStack Query. The reason for this is that query results are cached and able to be retrieved synchronously when a query is rendered. As long as your queries are being cached long enough (the default time is 5 minutes) and have not been garbage collected, scroll restoration will work out of the box all the time.</content>
</page>

<page>
  <title>Filters | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/guides/filters</url>
  <content>Some methods within TanStack Query accept a QueryFilters or MutationFilters object.

[](#query-filters)[Query Filters](#query-filters)
-------------------------------------------------

A query filter is an object with certain conditions to match a query with:

    // Cancel all queries
    await queryClient.cancelQueries()
    
    // Remove all inactive queries that begin with `posts` in the key
    queryClient.removeQueries({ queryKey: ['posts'], type: 'inactive' })
    
    // Refetch all active queries
    await queryClient.refetchQueries({ type: 'active' })
    
    // Refetch all active queries that begin with `posts` in the key
    await queryClient.refetchQueries({ queryKey: ['posts'], type: 'active' })
    

    // Cancel all queries
    await queryClient.cancelQueries()
    
    // Remove all inactive queries that begin with `posts` in the key
    queryClient.removeQueries({ queryKey: ['posts'], type: 'inactive' })
    
    // Refetch all active queries
    await queryClient.refetchQueries({ type: 'active' })
    
    // Refetch all active queries that begin with `posts` in the key
    await queryClient.refetchQueries({ queryKey: ['posts'], type: 'active' })
    

A query filter object supports the following properties:

*   queryKey?: QueryKey
    *   Set this property to define a query key to match on.
*   exact?: boolean
    *   If you don't want to search queries inclusively by query key, you can pass the exact: true option to return only the query with the exact query key you have passed.
*   type?: 'active' | 'inactive' | 'all'
    *   Defaults to all
    *   When set to active it will match active queries.
    *   When set to inactive it will match inactive queries.
*   stale?: boolean
    *   When set to true it will match stale queries.
    *   When set to false it will match fresh queries.
*   fetchStatus?: FetchStatus
    *   When set to fetching it will match queries that are currently fetching.
    *   When set to paused it will match queries that wanted to fetch, but have been paused.
    *   When set to idle it will match queries that are not fetching.
*   predicate?: (query: Query) => boolean
    *   This predicate function will be used as a final filter on all matching queries. If no other filters are specified, this function will be evaluated against every query in the cache.

[](#mutation-filters)[Mutation Filters](#mutation-filters)
----------------------------------------------------------

A mutation filter is an object with certain conditions to match a mutation with:

    // Get the number of all fetching mutations
    await queryClient.isMutating()
    
    // Filter mutations by mutationKey
    await queryClient.isMutating({ mutationKey: ['post'] })
    
    // Filter mutations using a predicate function
    await queryClient.isMutating({
      predicate: (mutation) => mutation.state.variables?.id === 1,
    })
    

    // Get the number of all fetching mutations
    await queryClient.isMutating()
    
    // Filter mutations by mutationKey
    await queryClient.isMutating({ mutationKey: ['post'] })
    
    // Filter mutations using a predicate function
    await queryClient.isMutating({
      predicate: (mutation) => mutation.state.variables?.id === 1,
    })
    

A mutation filter object supports the following properties:

*   mutationKey?: MutationKey
    *   Set this property to define a mutation key to match on.
*   exact?: boolean
    *   If you don't want to search mutations inclusively by mutation key, you can pass the exact: true option to return only the mutation with the exact mutation key you have passed.
*   status?: MutationStatus
    *   Allows for filtering mutations according to their status.
*   predicate?: (mutation: Mutation) => boolean
    *   This predicate function will be used as a final filter on all matching mutations. If no other filters are specified, this function will be evaluated against every mutation in the cache.

[](#utils)[Utils](#utils)
-------------------------

### [](#matchquery)[matchQuery](#matchquery)

    const isMatching = matchQuery(filters, query)
    

    const isMatching = matchQuery(filters, query)
    

Returns a boolean that indicates whether a query matches the provided set of query filters.

### [](#matchmutation)[matchMutation](#matchmutation)

    const isMatching = matchMutation(filters, mutation)
    

    const isMatching = matchMutation(filters, mutation)
    

Returns a boolean that indicates whether a mutation matches the provided set of mutation filters.</content>
</page>

<page>
  <title>Prefetching | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/guides/prefetching</url>
  <content>If you're lucky enough, you may know enough about what your users will do to be able to prefetch the data they need before it's needed! If this is the case, you can use the prefetchQuery method to prefetch the results of a query to be placed into the cache:

    const prefetchTodos = async () => {
      // The results of this query will be cached like a normal query
      await queryClient.prefetchQuery({
        queryKey: ['todos'],
        queryFn: fetchTodos,
      })
    }
    

    const prefetchTodos = async () => {
      // The results of this query will be cached like a normal query
      await queryClient.prefetchQuery({
        queryKey: ['todos'],
        queryFn: fetchTodos,
      })
    }
    

*   If **fresh** data for this query is already in the cache, the data will not be fetched
*   If a staleTime is passed eg. prefetchQuery({ queryKey: \['todos'\], queryFn: fn, staleTime: 5000 }) and the data is older than the specified staleTime, the query will be fetched
*   If no instances of useQuery appear for a prefetched query, it will be deleted and garbage collected after the time specified in gcTime.

[](#prefetching-infinite-queries)[Prefetching Infinite Queries](#prefetching-infinite-queries)
----------------------------------------------------------------------------------------------

Infinite Queries can be prefetched like regular Queries. Per default, only the first page of the Query will be prefetched and will be stored under the given QueryKey. If you want to prefetch more than one page, you can use the pages option, in which case you also have to provide a getNextPageParam function:

    const prefetchProjects = async () => {
      // The results of this query will be cached like a normal query
      await queryClient.prefetchInfiniteQuery({
        queryKey: ['projects'],
        queryFn: fetchProjects,
        initialPageParam: 0,
        getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
        pages: 3, // prefetch the first 3 pages
      })
    }
    

    const prefetchProjects = async () => {
      // The results of this query will be cached like a normal query
      await queryClient.prefetchInfiniteQuery({
        queryKey: ['projects'],
        queryFn: fetchProjects,
        initialPageParam: 0,
        getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
        pages: 3, // prefetch the first 3 pages
      })
    }
    

The above code will try to prefetch 3 pages in order, and getNextPageParam will be executed for each page to determine the next page to prefetch. If getNextPageParam returns undefined, the prefetching will stop.</content>
</page>

<page>
  <title>Caching Examples | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/guides/caching</url>
  <content>> Please thoroughly read the [Important Defaults](https://tanstack.com/query/latest/docs/framework/vue/guides/important-defaults) before reading this guide

[](#basic-example)[Basic Example](#basic-example)
-------------------------------------------------

This caching example illustrates the story and lifecycle of:

*   Query Instances with and without cache data
*   Background Refetching
*   Inactive Queries
*   Garbage Collection

Let's assume we are using the default gcTime of **5 minutes** and the default staleTime of 0.

*   A new instance of useQuery({ queryKey: \['todos'\], queryFn: fetchTodos }) mounts.
    *   Since no other queries have been made with the \['todos'\] query key, this query will show a hard loading state and make a network request to fetch the data.
    *   When the network request has completed, the returned data will be cached under the \['todos'\] key.
    *   The hook will mark the data as stale after the configured staleTime (defaults to 0, or immediately).
*   A second instance of useQuery({ queryKey: \['todos'\], queryFn: fetchTodos }) mounts elsewhere.
    *   Since the cache already has data for the \['todos'\] key from the first query, that data is immediately returned from the cache.
    *   The new instance triggers a new network request using its query function.
        *   Note that regardless of whether both fetchTodos query functions are identical or not, both queries' [status](https://tanstack.com/query/latest/docs/framework/vue/reference/useQuery) are updated (including isFetching, isPending, and other related values) because they have the same query key.
    *   When the request completes successfully, the cache's data under the \['todos'\] key is updated with the new data, and both instances are updated with the new data.
*   Both instances of the useQuery({ queryKey: \['todos'\], queryFn: fetchTodos }) query are unmounted and no longer in use.
    *   Since there are no more active instances of this query, a garbage collection timeout is set using gcTime to delete and garbage collect the query (defaults to **5 minutes**).
*   Before the cache timeout has completed, another instance of useQuery({ queryKey: \['todos'\], queryFn: fetchTodos }) mounts. The query immediately returns the available cached data while the fetchTodos function is being run in the background. When it completes successfully, it will populate the cache with fresh data.
*   The final instance of useQuery({ queryKey: \['todos'\], queryFn: fetchTodos }) unmounts.
*   No more instances of useQuery({ queryKey: \['todos'\], queryFn: fetchTodos }) appear within **5 minutes**.
    *   The cached data under the \['todos'\] key is deleted and garbage collected.</content>
</page>

<page>
  <title>SSR | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/guides/ssr</url>
  <content>Vue Query supports prefetching multiple queries on the server and then _dehydrating_ those queries to the queryClient. This means the server can prerender markup that is immediately available on page load and as soon as JS is available, Vue Query can upgrade or _hydrate_ those queries with the full functionality of the library. This includes refetching those queries on the client if they have become stale since the time they were rendered on the server.

[](#using-nuxtjs)[Using Nuxt.js](#using-nuxtjs)
-----------------------------------------------

### [](#nuxt-3)[Nuxt 3](#nuxt-3)

First create vue-query.ts file in your plugins directory with the following content:

    import type {
      DehydratedState,
      VueQueryPluginOptions,
    } from '@tanstack/vue-query'
    import {
      VueQueryPlugin,
      QueryClient,
      hydrate,
      dehydrate,
    } from '@tanstack/vue-query'
    // Nuxt 3 app aliases
    import { defineNuxtPlugin, useState } from '#imports'
    
    export default defineNuxtPlugin((nuxt) => {
      const vueQueryState = useState<DehydratedState | null>('vue-query')
    
      // Modify your Vue Query global settings here
      const queryClient = new QueryClient({
        defaultOptions: { queries: { staleTime: 5000 } },
      })
      const options: VueQueryPluginOptions = { queryClient }
    
      nuxt.vueApp.use(VueQueryPlugin, options)
    
      if (import.meta.server) {
        nuxt.hooks.hook('app:rendered', () => {
          vueQueryState.value = dehydrate(queryClient)
        })
      }
    
      if (import.meta.client) {
        hydrate(queryClient, vueQueryState.value)
      }
    })
    

    import type {
      DehydratedState,
      VueQueryPluginOptions,
    } from '@tanstack/vue-query'
    import {
      VueQueryPlugin,
      QueryClient,
      hydrate,
      dehydrate,
    } from '@tanstack/vue-query'
    // Nuxt 3 app aliases
    import { defineNuxtPlugin, useState } from '#imports'
    
    export default defineNuxtPlugin((nuxt) => {
      const vueQueryState = useState<DehydratedState | null>('vue-query')
    
      // Modify your Vue Query global settings here
      const queryClient = new QueryClient({
        defaultOptions: { queries: { staleTime: 5000 } },
      })
      const options: VueQueryPluginOptions = { queryClient }
    
      nuxt.vueApp.use(VueQueryPlugin, options)
    
      if (import.meta.server) {
        nuxt.hooks.hook('app:rendered', () => {
          vueQueryState.value = dehydrate(queryClient)
        })
      }
    
      if (import.meta.client) {
        hydrate(queryClient, vueQueryState.value)
      }
    })
    

Now you are ready to prefetch some data in your pages with onServerPrefetch.

*   Prefetch all the queries that you need with queryClient.prefetchQuery or suspense

    export default defineComponent({
      setup() {
        const { data, suspense } = useQuery({
          queryKey: ['test'],
          queryFn: fetcher,
        })
    
        onServerPrefetch(async () => {
          await suspense()
        })
    
        return { data }
      },
    })
    

    export default defineComponent({
      setup() {
        const { data, suspense } = useQuery({
          queryKey: ['test'],
          queryFn: fetcher,
        })
    
        onServerPrefetch(async () => {
          await suspense()
        })
    
        return { data }
      },
    })
    

### [](#nuxt-2)[Nuxt 2](#nuxt-2)

First create vue-query.js file in your plugins directory with the following content:

    import Vue from 'vue'
    import { VueQueryPlugin, QueryClient, hydrate } from '@tanstack/vue-query'
    
    export default (context) => {
      // Modify your Vue Query global settings here
      const queryClient = new QueryClient({
        defaultOptions: { queries: { staleTime: 5000 } },
      })
    
      if (process.server) {
        context.ssrContext.VueQuery = queryClient
      }
    
      if (process.client) {
        Vue.use(VueQueryPlugin, { queryClient })
    
        if (context.nuxtState && context.nuxtState.vueQueryState) {
          hydrate(queryClient, context.nuxtState.vueQueryState)
        }
      }
    }
    

    import Vue from 'vue'
    import { VueQueryPlugin, QueryClient, hydrate } from '@tanstack/vue-query'
    
    export default (context) => {
      // Modify your Vue Query global settings here
      const queryClient = new QueryClient({
        defaultOptions: { queries: { staleTime: 5000 } },
      })
    
      if (process.server) {
        context.ssrContext.VueQuery = queryClient
      }
    
      if (process.client) {
        Vue.use(VueQueryPlugin, { queryClient })
    
        if (context.nuxtState && context.nuxtState.vueQueryState) {
          hydrate(queryClient, context.nuxtState.vueQueryState)
        }
      }
    }
    

Add this plugin to your nuxt.config.js

    module.exports = {
      ...
      plugins: ['~/plugins/vue-query.js'],
    }
    

    module.exports = {
      ...
      plugins: ['~/plugins/vue-query.js'],
    }
    

Now you are ready to prefetch some data in your pages with onServerPrefetch.

*   Use useContext to get nuxt context
*   Use useQueryClient to get server-side instance of queryClient
*   Prefetch all the queries that you need with queryClient.prefetchQuery or suspense
*   Dehydrate queryClient to the nuxtContext

    // pages/todos.vue
    <template>
      <div>
        <button @click="refetch">Refetch</button>
        <p>{{ data }}</p>
      </div>
    </template>
    
    <script lang="ts">
    import {
      defineComponent,
      onServerPrefetch,
      useContext,
    } from '@nuxtjs/composition-api'
    import { useQuery, useQueryClient, dehydrate } from '@tanstack/vue-query'
    
    export default defineComponent({
      setup() {
        // Get QueryClient either from SSR context, or Vue context
        const { ssrContext } = useContext()
        // Make sure to provide `queryClient` as a second parameter to `useQuery` calls
        const queryClient =
          (ssrContext != null && ssrContext.VueQuery) || useQueryClient()
    
        // This will be prefetched and sent from the server
        const { data, refetch, suspense } = useQuery(
          {
            queryKey: ['todos'],
            queryFn: getTodos,
          },
          queryClient,
        )
        // This won't be prefetched, it will start fetching on client side
        const { data2 } = useQuery(
          {
            queryKey: 'todos2',
            queryFn: getTodos,
          },
          queryClient,
        )
    
        onServerPrefetch(async () => {
          await suspense()
          ssrContext.nuxt.vueQueryState = dehydrate(queryClient)
        })
    
        return {
          refetch,
          data,
        }
      },
    })
    </script>
    

    // pages/todos.vue
    <template>
      <div>
        <button @click="refetch">Refetch</button>
        <p>{{ data }}</p>
      </div>
    </template>
    
    <script lang="ts">
    import {
      defineComponent,
      onServerPrefetch,
      useContext,
    } from '@nuxtjs/composition-api'
    import { useQuery, useQueryClient, dehydrate } from '@tanstack/vue-query'
    
    export default defineComponent({
      setup() {
        // Get QueryClient either from SSR context, or Vue context
        const { ssrContext } = useContext()
        // Make sure to provide `queryClient` as a second parameter to `useQuery` calls
        const queryClient =
          (ssrContext != null && ssrContext.VueQuery) || useQueryClient()
    
        // This will be prefetched and sent from the server
        const { data, refetch, suspense } = useQuery(
          {
            queryKey: ['todos'],
            queryFn: getTodos,
          },
          queryClient,
        )
        // This won't be prefetched, it will start fetching on client side
        const { data2 } = useQuery(
          {
            queryKey: 'todos2',
            queryFn: getTodos,
          },
          queryClient,
        )
    
        onServerPrefetch(async () => {
          await suspense()
          ssrContext.nuxt.vueQueryState = dehydrate(queryClient)
        })
    
        return {
          refetch,
          data,
        }
      },
    })
    </script>
    

As demonstrated, it's fine to prefetch some queries and let others fetch on the queryClient. This means you can control what content server renders or not by adding or removing prefetchQuery or suspense for a specific query.

[](#using-vite-ssr)[Using Vite SSR](#using-vite-ssr)
----------------------------------------------------

Sync VueQuery client state with [vite-ssr](https://github.com/frandiox/vite-ssr) in order to serialize it in the DOM:

    // main.js (entry point)
    import App from './App.vue'
    import viteSSR from 'vite-ssr/vue'
    import {
      QueryClient,
      VueQueryPlugin,
      hydrate,
      dehydrate,
    } from '@tanstack/vue-query'
    
    export default viteSSR(App, { routes: [] }, ({ app, initialState }) => {
      // -- This is Vite SSR main hook, which is called once per request
    
      // Create a fresh VueQuery client
      const queryClient = new QueryClient()
    
      // Sync initialState with the client state
      if (import.meta.env.SSR) {
        // Indicate how to access and serialize VueQuery state during SSR
        initialState.vueQueryState = { toJSON: () => dehydrate(queryClient) }
      } else {
        // Reuse the existing state in the browser
        hydrate(queryClient, initialState.vueQueryState)
      }
    
      // Mount and provide the client to the app components
      app.use(VueQueryPlugin, { queryClient })
    })
    

    // main.js (entry point)
    import App from './App.vue'
    import viteSSR from 'vite-ssr/vue'
    import {
      QueryClient,
      VueQueryPlugin,
      hydrate,
      dehydrate,
    } from '@tanstack/vue-query'
    
    export default viteSSR(App, { routes: [] }, ({ app, initialState }) => {
      // -- This is Vite SSR main hook, which is called once per request
    
      // Create a fresh VueQuery client
      const queryClient = new QueryClient()
    
      // Sync initialState with the client state
      if (import.meta.env.SSR) {
        // Indicate how to access and serialize VueQuery state during SSR
        initialState.vueQueryState = { toJSON: () => dehydrate(queryClient) }
      } else {
        // Reuse the existing state in the browser
        hydrate(queryClient, initialState.vueQueryState)
      }
    
      // Mount and provide the client to the app components
      app.use(VueQueryPlugin, { queryClient })
    })
    

Then, call VueQuery from any component using Vue's onServerPrefetch:

    <!-- MyComponent.vue -->
    <template>
      <div>
        <button @click="refetch">Refetch</button>
        <p>{{ data }}</p>
      </div>
    </template>
    
    <script setup>
      import { useQuery } from '@tanstack/vue-query'
      import { onServerPrefetch } from 'vue'
    
      // This will be prefetched and sent from the server
      const { refetch, data, suspense } = useQuery({
        queryKey: ['todos'],
        queryFn: getTodos,
      })
    
      onServerPrefetch(suspense)
    </script>
    

    <!-- MyComponent.vue -->
    <template>
      <div>
        <button @click="refetch">Refetch</button>
        <p>{{ data }}</p>
      </div>
    </template>
    
    <script setup>
      import { useQuery } from '@tanstack/vue-query'
      import { onServerPrefetch } from 'vue'
    
      // This will be prefetched and sent from the server
      const { refetch, data, suspense } = useQuery({
        queryKey: ['todos'],
        queryFn: getTodos,
      })
    
      onServerPrefetch(suspense)
    </script>
    

[](#tips-tricks-and-caveats)[Tips, Tricks and Caveats](#tips-tricks-and-caveats)
--------------------------------------------------------------------------------

### [](#only-successful-queries-are-included-in-dehydration)[Only successful queries are included in dehydration](#only-successful-queries-are-included-in-dehydration)

Any query with an error is automatically excluded from dehydration. This means that the default behavior is to pretend these queries were never loaded on the server, usually showing a loading state instead, and retrying the queries on the queryClient. This happens regardless of error.

Sometimes this behavior is not desirable, maybe you want to render an error page with a correct status code instead on certain errors or queries. In those cases, use fetchQuery and catch any errors to handle those manually.

### [](#staleness-is-measured-from-when-the-query-was-fetched-on-the-server)[Staleness is measured from when the query was fetched on the server](#staleness-is-measured-from-when-the-query-was-fetched-on-the-server)

A query is considered stale depending on when it was dataUpdatedAt. A caveat here is that the server needs to have the correct time for this to work properly, but UTC time is used, so timezones do not factor into this.

Because staleTime defaults to 0, queries will be refetched in the background on page load by default. You might want to use a higher staleTime to avoid this double fetching, especially if you don't cache your markup.

This refetching of stale queries is a perfect match when caching markup in a CDN! You can set the cache time of the page itself decently high to avoid having to re-render pages on the server, but configure the staleTime of the queries lower to make sure data is refetched in the background as soon as a user visits the page. Maybe you want to cache the pages for a week, but refetch the data automatically on page load if it's older than a day?

### [](#high-memory-consumption-on-server)[High memory consumption on server](#high-memory-consumption-on-server)

In case you are creating the QueryClient for every request, Vue Query creates the isolated cache for this client, which is preserved in memory for the gcTime period. That may lead to high memory consumption on server in case of high number of requests during that period.

On the server, gcTime defaults to Infinity which disables manual garbage collection and will automatically clear memory once a request has finished. If you are explicitly setting a non-Infinity gcTime then you will be responsible for clearing the cache early.

To clear the cache after it is not needed and to lower memory consumption, you can add a call to [queryClient.clear()](https://tanstack.com/query/latest/docs/reference/QueryClient#queryclientclear) after the request is handled and dehydrated state has been sent to the client.

Alternatively, you can set a smaller gcTime.</content>
</page>

<page>
  <title>Default Query Function | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/guides/default-query-function</url>
  <content>If you find yourself wishing for whatever reason that you could just share the same query function for your entire app and just use query keys to identify what it should fetch, you can do that by providing a **default query function** to TanStack Query:

    // Define a default query function that will receive the query key
    const defaultQueryFn = async ({ queryKey }) => {
      const { data } = await axios.get(
        `https://jsonplaceholder.typicode.com${queryKey[0]}`,
      )
      return data
    }
    
    // provide the default query function to your app with defaultOptions
    const vueQueryPluginOptions: VueQueryPluginOptions = {
      queryClientConfig: {
        defaultOptions: { queries: { queryFn: defaultQueryFn } },
      },
    }
    app.use(VueQueryPlugin, vueQueryPluginOptions)
    
    // All you have to do now is pass a key!
    const { status, data, error, isFetching } = useQuery({
      queryKey: [`/posts/${postId}`],
    })
    

    // Define a default query function that will receive the query key
    const defaultQueryFn = async ({ queryKey }) => {
      const { data } = await axios.get(
        `https://jsonplaceholder.typicode.com${queryKey[0]}`,
      )
      return data
    }
    
    // provide the default query function to your app with defaultOptions
    const vueQueryPluginOptions: VueQueryPluginOptions = {
      queryClientConfig: {
        defaultOptions: { queries: { queryFn: defaultQueryFn } },
      },
    }
    app.use(VueQueryPlugin, vueQueryPluginOptions)
    
    // All you have to do now is pass a key!
    const { status, data, error, isFetching } = useQuery({
      queryKey: [`/posts/${postId}`],
    })
    

If you ever want to override the default queryFn, you can just provide your own like you normally would.</content>
</page>

<page>
  <title>Suspense (experimental) | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/guides/suspense</url>
  <content>> NOTE: Suspense mode for Vue Query is experimental, same as Vue's Suspense itself. These APIs WILL change and should not be used in production unless you lock both your Vue and Vue Query versions to patch-level versions that are compatible with each other.

Vue Query can also be used with Vue's new [Suspense](https://vuejs.org/guide/built-ins/suspense.html) API's.

To do that you need to wrap your suspendable component with Suspense component provided by Vue

    <script setup>
    import SuspendableComponent from './SuspendableComponent.vue'
    </script>
    
    <template>
      <Suspense>
        <template #default>
          <SuspendableComponent />
        </template>
        <template #fallback>
          <div>Loading...</div>
        </template>
      </Suspense>
    </template>
    

    <script setup>
    import SuspendableComponent from './SuspendableComponent.vue'
    </script>
    
    <template>
      <Suspense>
        <template #default>
          <SuspendableComponent />
        </template>
        <template #fallback>
          <div>Loading...</div>
        </template>
      </Suspense>
    </template>
    

And change your setup function in suspendable component to be async. Then you can use async suspense function that is provided by vue-query.

    <script>
    import { defineComponent } from 'vue'
    import { useQuery } from '@tanstack/vue-query'
    
    const todoFetcher = async () =>
      await fetch('https://jsonplaceholder.cypress.io/todos').then((response) =>
        response.json(),
      )
    export default defineComponent({
      name: 'SuspendableComponent',
      async setup() {
        const { data, suspense } = useQuery(['todos'], todoFetcher)
        await suspense()
    
        return { data }
      },
    })
    </script>
    

    <script>
    import { defineComponent } from 'vue'
    import { useQuery } from '@tanstack/vue-query'
    
    const todoFetcher = async () =>
      await fetch('https://jsonplaceholder.cypress.io/todos').then((response) =>
        response.json(),
      )
    export default defineComponent({
      name: 'SuspendableComponent',
      async setup() {
        const { data, suspense } = useQuery(['todos'], todoFetcher)
        await suspense()
    
        return { data }
      },
    })
    </script>
    

[](#fetch-on-render-vs-render-as-you-fetch)[Fetch-on-render vs Render-as-you-fetch](#fetch-on-render-vs-render-as-you-fetch)
----------------------------------------------------------------------------------------------------------------------------

Out of the box, Vue Query in suspense mode works really well as a **Fetch-on-render** solution with no additional configuration. This means that when your components attempt to mount, they will trigger query fetching and suspend, but only once you have imported them and mounted them. If you want to take it to the next level and implement a **Render-as-you-fetch** model, we recommend implementing [Prefetching](https://tanstack.com/query/latest/docs/framework/vue/guides/prefetching) on routing callbacks and/or user interactions events to start loading queries before they are mounted and hopefully even before you start importing or mounting their parent components.</content>
</page>

<page>
  <title>Testing | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/guides/testing</url>
  <content>Guides & Concepts

*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/important-defaults)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/queries)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/query-keys)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/query-functions)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/query-options)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/network-mode)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/parallel-queries)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/disabling-queries)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/query-retries)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/paginated-queries)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/infinite-queries)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/placeholder-query-data)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/mutations)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/invalidations-from-mutations)
*   [
    
    Updates from Mutation Responses
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/updates-from-mutation-responses)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/optimistic-updates)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/query-cancellation)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/scroll-restoration)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/filters)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/prefetching)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/ssr)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/caching)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/default-query-function)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/suspense)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/testing)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/custom-client)
*   [
    
    Does this replace \[Vuex, Pinia\]?
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/does-this-replace-client-state)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/migrating-to-v5)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Plugins

*   [
    
    broadcastQueryClient (Experimental)
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/plugins/broadcastQueryClient)
*   [
    
    createPersister (Experimental)
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/plugins/createPersister)

Guides & Concepts

*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/important-defaults)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/queries)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/query-keys)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/query-functions)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/query-options)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/network-mode)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/parallel-queries)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/disabling-queries)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/query-retries)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/paginated-queries)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/infinite-queries)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/placeholder-query-data)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/mutations)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/invalidations-from-mutations)
*   [
    
    Updates from Mutation Responses
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/updates-from-mutation-responses)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/optimistic-updates)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/query-cancellation)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/scroll-restoration)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/filters)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/prefetching)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/ssr)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/caching)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/default-query-function)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/suspense)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/testing)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/custom-client)
*   [
    
    Does this replace \[Vuex, Pinia\]?
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/guides/does-this-replace-client-state)
*   [](https://tanstack.com/query/latest/docs/framework/vue/guides/migrating-to-v5)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Plugins

*   [
    
    broadcastQueryClient (Experimental)
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/plugins/broadcastQueryClient)
*   [
    
    createPersister (Experimental)
    
    vue
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/vue/plugins/createPersister)</content>
</page>

<page>
  <title>Custom Client | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/guides/custom-client</url>
  <content>### [](#custom-client)[Custom client](#custom-client)

Vue Query allows providing custom QueryClient for Vue context.

It might be handy when you need to create QueryClient beforehand to integrate it with other libraries that do not have access to the Vue context.

For this reason, VueQueryPlugin accepts either QueryClientConfig or QueryClient as a plugin options.

If You provide QueryClientConfig, QueryClient instance will be created internally and provided to Vue context.

    const vueQueryPluginOptions: VueQueryPluginOptions = {
      queryClientConfig: {
        defaultOptions: { queries: { staleTime: 3600 } },
      },
    }
    app.use(VueQueryPlugin, vueQueryPluginOptions)
    

    const vueQueryPluginOptions: VueQueryPluginOptions = {
      queryClientConfig: {
        defaultOptions: { queries: { staleTime: 3600 } },
      },
    }
    app.use(VueQueryPlugin, vueQueryPluginOptions)
    

    const myClient = new QueryClient(queryClientConfig)
    const vueQueryPluginOptions: VueQueryPluginOptions = {
      queryClient: myClient,
    }
    app.use(VueQueryPlugin, vueQueryPluginOptions)
    

    const myClient = new QueryClient(queryClientConfig)
    const vueQueryPluginOptions: VueQueryPluginOptions = {
      queryClient: myClient,
    }
    app.use(VueQueryPlugin, vueQueryPluginOptions)
    

### [](#custom-context-key)[Custom context key](#custom-context-key)

You can also customize the key under which QueryClient will be accessible in Vue context. This can be useful is you want to avoid name clashing between multiple apps on the same page with Vue2.

It works both with default, and custom QueryClient

    const vueQueryPluginOptions: VueQueryPluginOptions = {
      queryClientKey: 'Foo',
    }
    app.use(VueQueryPlugin, vueQueryPluginOptions)
    

    const vueQueryPluginOptions: VueQueryPluginOptions = {
      queryClientKey: 'Foo',
    }
    app.use(VueQueryPlugin, vueQueryPluginOptions)
    

    const myClient = new QueryClient(queryClientConfig)
    const vueQueryPluginOptions: VueQueryPluginOptions = {
      queryClient: myClient,
      queryClientKey: 'Foo',
    }
    app.use(VueQueryPlugin, vueQueryPluginOptions)
    

    const myClient = new QueryClient(queryClientConfig)
    const vueQueryPluginOptions: VueQueryPluginOptions = {
      queryClient: myClient,
      queryClientKey: 'Foo',
    }
    app.use(VueQueryPlugin, vueQueryPluginOptions)
    

To use the custom client key, You have to provide it as a query options

    useQuery({
      queryKey: ['query1'],
      queryFn: fetcher,
      queryClientKey: 'foo',
    })
    

    useQuery({
      queryKey: ['query1'],
      queryFn: fetcher,
      queryClientKey: 'foo',
    })
    

Internally custom key will be combined with default query key as a suffix. But user do not have to worry about it.

    const vueQueryPluginOptions: VueQueryPluginOptions = {
      queryClientKey: 'Foo',
    }
    app.use(VueQueryPlugin, vueQueryPluginOptions) // -> VUE_QUERY_CLIENT:Foo
    

    const vueQueryPluginOptions: VueQueryPluginOptions = {
      queryClientKey: 'Foo',
    }
    app.use(VueQueryPlugin, vueQueryPluginOptions) // -> VUE_QUERY_CLIENT:Foo</content>
</page>

<page>
  <title>Does TanStack Query replace Vuex, Pinia or other global state managers? | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/guides/does-this-replace-client-state</url>
  <content>Well, let's start with a few important items:

*   TanStack Query is a **server-state** library, responsible for managing asynchronous operations between your server and client
*   Vuex, Pinia, Zustand, etc. are **client-state** libraries that _can be used to store asynchronous data, albeit inefficiently when compared to a tool like TanStack Query_

With those points in mind, the short answer is that TanStack Query **replaces the boilerplate code and related wiring used to manage cache data in your client-state and replaces it with just a few lines of code.**

For a vast majority of applications, the truly **globally accessible client state** that is left over after migrating all of your async code to TanStack Query is usually very tiny.

> There are still some circumstances where an application might indeed have a massive amount of synchronous client-only state (like a visual designer or music production application), in which case, you will probably still want a client state manager. In this situation it's important to note that **TanStack Query is not a replacement for local/client state management**. However, you can use TanStack Query alongside most client state managers with zero issues.

[](#a-contrived-example)[A Contrived Example](#a-contrived-example)
-------------------------------------------------------------------

Here we have some "global" state being managed by a global state library:

    const globalState = {
      projects,
      teams,
      tasks,
      users,
      themeMode,
      sidebarStatus,
    }
    

    const globalState = {
      projects,
      teams,
      tasks,
      users,
      themeMode,
      sidebarStatus,
    }
    

Currently, the global state manager is caching 4 types of server-state: projects, teams, tasks, and users. If we were to move these server-state assets to TanStack Query, our remaining global state would look more like this:

    const globalState = {
      themeMode,
      sidebarStatus,
    }
    

    const globalState = {
      themeMode,
      sidebarStatus,
    }
    

This also means that with a few hook calls to useQuery and useMutation, we also get to remove any boilerplate code that was used to manage our server state e.g.

*   Connectors
*   Action Creators
*   Middlewares
*   Reducers
*   Loading/Error/Result states
*   Contexts

With all of those things removed, you may ask yourself, **"Is it worth it to keep using our client state manager for this tiny global state?"**

**And that's up to you!**

But TanStack Query's role is clear. It removes asynchronous wiring and boilerplate from your application and replaces it with just a few lines of code.

What are you waiting for, give it a go already!</content>
</page>

<page>
  <title>useQueries | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/reference/useQueries</url>
  <content>The useQueries hook can be used to fetch a variable number of queries:

    const ids = [1, 2, 3]
    const results = useQueries({
      queries: ids.map((id) => ({
        queryKey: ['post', id],
        queryFn: () => fetchPost(id),
        staleTime: Infinity,
      })),
    })
    

    const ids = [1, 2, 3]
    const results = useQueries({
      queries: ids.map((id) => ({
        queryKey: ['post', id],
        queryFn: () => fetchPost(id),
        staleTime: Infinity,
      })),
    })
    

**Options**

The useQueries hook accepts an options object with a **queries** key whose value is an array with query option objects identical to the [useQuery hook](https://tanstack.com/query/latest/docs/framework/vue/reference/useQuery) (excluding the queryClient option - because the QueryClient can be passed in on the top level).

*   queryClient?: QueryClient
    *   Use this to provide a custom QueryClient. Otherwise, the one from the nearest context will be used.
*   combine?: (result: UseQueriesResults) => TCombinedResult
    *   Use this to combine the results of the queries into a single value.

> Having the same query key more than once in the array of query objects may cause some data to be shared between queries. To avoid this, consider de-duplicating the queries and map the results back to the desired structure.

**placeholderData**

The placeholderData option exists for useQueries as well, but it doesn't get information passed from previously rendered Queries like useQuery does, because the input to useQueries can be a different number of Queries on each render.

**Returns**

The useQueries hook returns an array with all the query results. The order returned is the same as the input order.

[](#combine)[Combine](#combine)
-------------------------------

If you want to combine data (or other Query information) from the results into a single value, you can use the combine option. The result will be structurally shared to be as referentially stable as possible.

    const ids = [1, 2, 3]
    const combinedQueries = useQueries({
      queries: ids.map((id) => ({
        queryKey: ['post', id],
        queryFn: () => fetchPost(id),
      })),
      combine: (results) => {
        return {
          data: results.map((result) => result.data),
          pending: results.some((result) => result.isPending),
        }
      },
    })
    

    const ids = [1, 2, 3]
    const combinedQueries = useQueries({
      queries: ids.map((id) => ({
        queryKey: ['post', id],
        queryFn: () => fetchPost(id),
      })),
      combine: (results) => {
        return {
          data: results.map((result) => result.data),
          pending: results.some((result) => result.isPending),
        }
      },
    })
    

In the above example, combinedQueries will be an object with a data and a pending property. Note that all other properties of the Query results will be lost.

### [](#memoization)[Memoization](#memoization)

The combine function will only re-run if:

*   the combine function itself changed referentially
*   any of the query results changed

This means that an inlined combine function, as shown above, will run on every render. To avoid this, you can wrap the combine function in useCallback, or extract it to a stable function reference if it doesn't have any dependencies.</content>
</page>

<page>
  <title>useQuery | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/reference/useQuery</url>
  <content>    const {
      data,
      dataUpdatedAt,
      error,
      errorUpdatedAt,
      failureCount,
      failureReason,
      fetchStatus,
      isError,
      isFetched,
      isFetchedAfterMount,
      isFetching,
      isInitialLoading,
      isLoading,
      isLoadingError,
      isPaused,
      isPending,
      isPlaceholderData,
      isRefetchError,
      isRefetching,
      isStale,
      isSuccess,
      isEnabled,
      promise,
      refetch,
      status,
    } = useQuery(
      {
        queryKey,
        queryFn,
        gcTime,
        enabled,
        networkMode,
        initialData,
        initialDataUpdatedAt,
        meta,
        notifyOnChangeProps,
        placeholderData,
        queryKeyHashFn,
        refetchInterval,
        refetchIntervalInBackground,
        refetchOnMount,
        refetchOnReconnect,
        refetchOnWindowFocus,
        retry,
        retryOnMount,
        retryDelay,
        select,
        staleTime,
        structuralSharing,
        subscribed,
        throwOnError,
      },
      queryClient,
    )
    

    const {
      data,
      dataUpdatedAt,
      error,
      errorUpdatedAt,
      failureCount,
      failureReason,
      fetchStatus,
      isError,
      isFetched,
      isFetchedAfterMount,
      isFetching,
      isInitialLoading,
      isLoading,
      isLoadingError,
      isPaused,
      isPending,
      isPlaceholderData,
      isRefetchError,
      isRefetching,
      isStale,
      isSuccess,
      isEnabled,
      promise,
      refetch,
      status,
    } = useQuery(
      {
        queryKey,
        queryFn,
        gcTime,
        enabled,
        networkMode,
        initialData,
        initialDataUpdatedAt,
        meta,
        notifyOnChangeProps,
        placeholderData,
        queryKeyHashFn,
        refetchInterval,
        refetchIntervalInBackground,
        refetchOnMount,
        refetchOnReconnect,
        refetchOnWindowFocus,
        retry,
        retryOnMount,
        retryDelay,
        select,
        staleTime,
        structuralSharing,
        subscribed,
        throwOnError,
      },
      queryClient,
    )</content>
</page>

<page>
  <title>Migrating to TanStack Query v5 | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/guides/migrating-to-v5</url>
  <content>[](#breaking-changes)[Breaking Changes](#breaking-changes)
----------------------------------------------------------

v5 is a major version, so there are some breaking changes to be aware of:

### [](#supports-a-single-signature-one-object)[Supports a single signature, one object](#supports-a-single-signature-one-object)

useQuery and friends used to have many overloads in TypeScript: different ways how the function could be invoked. Not only was this tough to maintain, type wise, it also required a runtime check to see which types the first and the second parameter were, to correctly create options.

now we only support the object format.

    useQuery(key, fn, options) // [!code --]
    useQuery({ queryKey, queryFn, ...options }) // [!code ++]
    useInfiniteQuery(key, fn, options) // [!code --]
    useInfiniteQuery({ queryKey, queryFn, ...options }) // [!code ++]
    useMutation(fn, options) // [!code --]
    useMutation({ mutationFn, ...options }) // [!code ++]
    useIsFetching(key, filters) // [!code --]
    useIsFetching({ queryKey, ...filters }) // [!code ++]
    useIsMutating(key, filters) // [!code --]
    useIsMutating({ mutationKey, ...filters }) // [!code ++]
    

    useQuery(key, fn, options) // [!code --]
    useQuery({ queryKey, queryFn, ...options }) // [!code ++]
    useInfiniteQuery(key, fn, options) // [!code --]
    useInfiniteQuery({ queryKey, queryFn, ...options }) // [!code ++]
    useMutation(fn, options) // [!code --]
    useMutation({ mutationFn, ...options }) // [!code ++]
    useIsFetching(key, filters) // [!code --]
    useIsFetching({ queryKey, ...filters }) // [!code ++]
    useIsMutating(key, filters) // [!code --]
    useIsMutating({ mutationKey, ...filters }) // [!code ++]
    

    queryClient.isFetching(key, filters) // [!code --]
    queryClient.isFetching({ queryKey, ...filters }) // [!code ++]
    queryClient.ensureQueryData(key, filters) // [!code --]
    queryClient.ensureQueryData({ queryKey, ...filters }) // [!code ++]
    queryClient.getQueriesData(key, filters) // [!code --]
    queryClient.getQueriesData({ queryKey, ...filters }) // [!code ++]
    queryClient.setQueriesData(key, updater, filters, options) // [!code --]
    queryClient.setQueriesData({ queryKey, ...filters }, updater, options) // [!code ++]
    queryClient.removeQueries(key, filters) // [!code --]
    queryClient.removeQueries({ queryKey, ...filters }) // [!code ++]
    queryClient.resetQueries(key, filters, options) // [!code --]
    queryClient.resetQueries({ queryKey, ...filters }, options) // [!code ++]
    queryClient.cancelQueries(key, filters, options) // [!code --]
    queryClient.cancelQueries({ queryKey, ...filters }, options) // [!code ++]
    queryClient.invalidateQueries(key, filters, options) // [!code --]
    queryClient.invalidateQueries({ queryKey, ...filters }, options) // [!code ++]
    queryClient.refetchQueries(key, filters, options) // [!code --]
    queryClient.refetchQueries({ queryKey, ...filters }, options) // [!code ++]
    queryClient.fetchQuery(key, fn, options) // [!code --]
    queryClient.fetchQuery({ queryKey, queryFn, ...options }) // [!code ++]
    queryClient.prefetchQuery(key, fn, options) // [!code --]
    queryClient.prefetchQuery({ queryKey, queryFn, ...options }) // [!code ++]
    queryClient.fetchInfiniteQuery(key, fn, options) // [!code --]
    queryClient.fetchInfiniteQuery({ queryKey, queryFn, ...options }) // [!code ++]
    queryClient.prefetchInfiniteQuery(key, fn, options) // [!code --]
    queryClient.prefetchInfiniteQuery({ queryKey, queryFn, ...options }) // [!code ++]
    

    queryClient.isFetching(key, filters) // [!code --]
    queryClient.isFetching({ queryKey, ...filters }) // [!code ++]
    queryClient.ensureQueryData(key, filters) // [!code --]
    queryClient.ensureQueryData({ queryKey, ...filters }) // [!code ++]
    queryClient.getQueriesData(key, filters) // [!code --]
    queryClient.getQueriesData({ queryKey, ...filters }) // [!code ++]
    queryClient.setQueriesData(key, updater, filters, options) // [!code --]
    queryClient.setQueriesData({ queryKey, ...filters }, updater, options) // [!code ++]
    queryClient.removeQueries(key, filters) // [!code --]
    queryClient.removeQueries({ queryKey, ...filters }) // [!code ++]
    queryClient.resetQueries(key, filters, options) // [!code --]
    queryClient.resetQueries({ queryKey, ...filters }, options) // [!code ++]
    queryClient.cancelQueries(key, filters, options) // [!code --]
    queryClient.cancelQueries({ queryKey, ...filters }, options) // [!code ++]
    queryClient.invalidateQueries(key, filters, options) // [!code --]
    queryClient.invalidateQueries({ queryKey, ...filters }, options) // [!code ++]
    queryClient.refetchQueries(key, filters, options) // [!code --]
    queryClient.refetchQueries({ queryKey, ...filters }, options) // [!code ++]
    queryClient.fetchQuery(key, fn, options) // [!code --]
    queryClient.fetchQuery({ queryKey, queryFn, ...options }) // [!code ++]
    queryClient.prefetchQuery(key, fn, options) // [!code --]
    queryClient.prefetchQuery({ queryKey, queryFn, ...options }) // [!code ++]
    queryClient.fetchInfiniteQuery(key, fn, options) // [!code --]
    queryClient.fetchInfiniteQuery({ queryKey, queryFn, ...options }) // [!code ++]
    queryClient.prefetchInfiniteQuery(key, fn, options) // [!code --]
    queryClient.prefetchInfiniteQuery({ queryKey, queryFn, ...options }) // [!code ++]
    

    queryCache.find(key, filters) // [!code --]
    queryCache.find({ queryKey, ...filters }) // [!code ++]
    queryCache.findAll(key, filters) // [!code --]
    queryCache.findAll({ queryKey, ...filters }) // [!code ++]
    

    queryCache.find(key, filters) // [!code --]
    queryCache.find({ queryKey, ...filters }) // [!code ++]
    queryCache.findAll(key, filters) // [!code --]
    queryCache.findAll({ queryKey, ...filters }) // [!code ++]
    

### [](#queryclientgetquerydata-now-accepts-querykey-only-as-an-argument)[queryClient.getQueryData now accepts queryKey only as an Argument](#queryclientgetquerydata-now-accepts-querykey-only-as-an-argument)

queryClient.getQueryData argument is changed to accept only a queryKey

    queryClient.getQueryData(queryKey, filters) // [!code --]
    queryClient.getQueryData(queryKey) // [!code ++]
    

    queryClient.getQueryData(queryKey, filters) // [!code --]
    queryClient.getQueryData(queryKey) // [!code ++]
    

### [](#queryclientgetquerystate-now-accepts-querykey-only-as-an-argument)[queryClient.getQueryState now accepts queryKey only as an Argument](#queryclientgetquerystate-now-accepts-querykey-only-as-an-argument)

queryClient.getQueryState argument is changed to accept only a queryKey

    queryClient.getQueryState(queryKey, filters) // [!code --]
    queryClient.getQueryState(queryKey) // [!code ++]
    

    queryClient.getQueryState(queryKey, filters) // [!code --]
    queryClient.getQueryState(queryKey) // [!code ++]
    

#### [](#codemod)[Codemod](#codemod)

To make the remove overloads migration easier, v5 comes with a codemod.

> The codemod is a best efforts attempt to help you migrate the breaking change. Please review the generated code thoroughly! Also, there are edge cases that cannot be found by the code mod, so please keep an eye on the log output.

If you want to run it against .js or .jsx files, please use the command below:

    npx jscodeshift@latest ./path/to/src/ \
      --extensions=js,jsx \
      --transform=./node_modules/@tanstack/react-query/build/codemods/src/v5/remove-overloads/remove-overloads.cjs
    

    npx jscodeshift@latest ./path/to/src/ \
      --extensions=js,jsx \
      --transform=./node_modules/@tanstack/react-query/build/codemods/src/v5/remove-overloads/remove-overloads.cjs
    

If you want to run it against .ts or .tsx files, please use the command below:

    npx jscodeshift@latest ./path/to/src/ \
      --extensions=ts,tsx \
      --parser=tsx \
      --transform=./node_modules/@tanstack/react-query/build/codemods/src/v5/remove-overloads/remove-overloads.cjs
    

    npx jscodeshift@latest ./path/to/src/ \
      --extensions=ts,tsx \
      --parser=tsx \
      --transform=./node_modules/@tanstack/react-query/build/codemods/src/v5/remove-overloads/remove-overloads.cjs
    

Please note in the case of TypeScript you need to use tsx as the parser; otherwise, the codemod won't be applied properly!

**Note:** Applying the codemod might break your code formatting, so please don't forget to run prettier and/or eslint after you've applied the codemod!

A few notes about how codemod works:

*   Generally, we're looking for the lucky case, when the first parameter is an object expression and contains the "queryKey" or "mutationKey" property (depending on which hook/method call is being transformed). If this is the case, your code already matches the new signature, so the codemod won't touch it. üéâ
*   If the condition above is not fulfilled, then the codemod will check whether the first parameter is an array expression or an identifier that references an array expression. If this is the case, the codemod will put it into an object expression, then it will be the first parameter.
*   If object parameters can be inferred, the codemod will attempt to copy the already existing properties to the newly created one.
*   If the codemod cannot infer the usage, then it will leave a message on the console. The message contains the file name and the line number of the usage. In this case, you need to do the migration manually.
*   If the transformation results in an error, you will also see a message on the console. This message will notify you something unexpected happened, please do the migration manually.

### [](#callbacks-on-usequery-and-queryobserver-have-been-removed)[Callbacks on useQuery (and QueryObserver) have been removed](#callbacks-on-usequery-and-queryobserver-have-been-removed)

onSuccess, onError and onSettled have been removed from Queries. They haven't been touched for Mutations. Please see [this RFC](https://github.com/TanStack/query/discussions/5279) for motivations behind this change and what to do instead.

### [](#the-refetchinterval-callback-function-only-gets-query-passed)[The refetchInterval callback function only gets query passed](#the-refetchinterval-callback-function-only-gets-query-passed)

This streamlines how callbacks are invoked (the refetchOnWindowFocus, refetchOnMount and refetchOnReconnect callbacks all only get the query passed as well), and it fixes some typing issues when callbacks get data transformed by select.

    - refetchInterval: number | false | ((data: TData | undefined, query: Query) => number | false | undefined) // [!code --]
    + refetchInterval: number | false | ((query: Query) => number | false | undefined) // [!code ++]
    

    - refetchInterval: number | false | ((data: TData | undefined, query: Query) => number | false | undefined) // [!code --]
    + refetchInterval: number | false | ((query: Query) => number | false | undefined) // [!code ++]
    

You can still access data with query.state.data, however, it will not be data that has been transformed by select. If you need to access the transformed data, you can call the transformation again on query.state.data.

### [](#the-remove-method-has-been-removed-from-usequery)[The remove method has been removed from useQuery](#the-remove-method-has-been-removed-from-usequery)

Previously, remove method used to remove the query from the queryCache without informing observers about it. It was best used to remove data imperatively that is no longer needed, e.g. when logging a user out.

But It doesn't make much sense to do this while a query is still active, because it will just trigger a hard loading state with the next re-render.

if you still need to remove a query, you can use queryClient.removeQueries({queryKey: key})

    const queryClient = useQueryClient()
    const query = useQuery({ queryKey, queryFn })
    
    query.remove() // [!code --]
    queryClient.removeQueries({ queryKey }) // [!code ++]
    

    const queryClient = useQueryClient()
    const query = useQuery({ queryKey, queryFn })
    
    query.remove() // [!code --]
    queryClient.removeQueries({ queryKey }) // [!code ++]
    

### [](#the-minimum-required-typescript-version-is-now-47)[The minimum required TypeScript version is now 4.7](#the-minimum-required-typescript-version-is-now-47)

Mainly because an important fix was shipped around type inference. Please see this [TypeScript issue](https://github.com/microsoft/TypeScript/issues/43371) for more information.

### [](#the-isdataequal-option-has-been-removed-from-usequery)[The isDataEqual option has been removed from useQuery](#the-isdataequal-option-has-been-removed-from-usequery)

Previously, This function was used to indicate whether to use previous data (true) or new data (false) as a resolved data for the query.

You can achieve the same functionality by passing a function to structuralSharing instead:

    import { replaceEqualDeep } from '@tanstack/react-query'
    
    - isDataEqual: (oldData, newData) => customCheck(oldData, newData) // [!code --]
    + structuralSharing: (oldData, newData) => customCheck(oldData, newData) ? oldData : replaceEqualDeep(oldData, newData) // [!code ++]
    

    import { replaceEqualDeep } from '@tanstack/react-query'
    
    - isDataEqual: (oldData, newData) => customCheck(oldData, newData) // [!code --]
    + structuralSharing: (oldData, newData) => customCheck(oldData, newData) ? oldData : replaceEqualDeep(oldData, newData) // [!code ++]
    

### [](#the-deprecated-custom-logger-has-been-removed)[The deprecated custom logger has been removed](#the-deprecated-custom-logger-has-been-removed)

Custom loggers were already deprecated in 4 and have been removed in this version. Logging only had an effect in development mode, where passing a custom logger is not necessary.

### [](#supported-browsers)[Supported Browsers](#supported-browsers)

We have updated our browserslist to produce a more modern, performant and smaller bundle. You can read about the requirements [here](https://tanstack.com/query/latest/docs/framework/vue/installation#requirements).

### [](#private-class-fields-and-methods)[Private class fields and methods](#private-class-fields-and-methods)

TanStack Query has always had private fields and methods on classes, but they weren't really private - they were just private in TypeScript. We now use [ECMAScript Private class features](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields), which means those fields are now truly private and can't be accessed from the outside at runtime.

### [](#rename-cachetime-to-gctime)[Rename cacheTime to gcTime](#rename-cachetime-to-gctime)

Almost everyone gets cacheTime wrong. It sounds like "the amount of time that data is cached for", but that is not correct.

cacheTime does nothing as long as a query is still in use. It only kicks in as soon as the query becomes unused. After the time has passed, data will be "garbage collected" to avoid the cache from growing.

gc is referring to "garbage collect" time. It's a bit more technical, but also a quite [well known abbreviation](https://en.wikipedia.org/wiki/Garbage_collection_\(computer_science\)) in computer science.

    const MINUTE = 1000 * 60;
    
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
    -      cacheTime: 10 * MINUTE, // [!code --]
    +      gcTime: 10 * MINUTE, // [!code ++]
        },
      },
    })
    

    const MINUTE = 1000 * 60;
    
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
    -      cacheTime: 10 * MINUTE, // [!code --]
    +      gcTime: 10 * MINUTE, // [!code ++]
        },
      },
    })
    

### [](#the-useerrorboundary-option-has-been-renamed-to-throwonerror)[The useErrorBoundary option has been renamed to throwOnError](#the-useerrorboundary-option-has-been-renamed-to-throwonerror)

To make the useErrorBoundary option more framework-agnostic and avoid confusion with the established React function prefix "use" for hooks and the "ErrorBoundary" component name, it has been renamed to throwOnError to more accurately reflect its functionality.

### [](#typescript-error-is-now-the-default-type-for-errors-instead-of-unknown)[TypeScript: Error is now the default type for errors instead of unknown](#typescript-error-is-now-the-default-type-for-errors-instead-of-unknown)

Even though in JavaScript, you can throw anything (which makes unknown the most correct type), almost always, Errors (or subclasses of Error) are thrown. This change makes it easier to work with the error field in TypeScript for most cases.

If you want to throw something that isn't an Error, you'll now have to set the generic for yourself:

    useQuery<number, string>({
      queryKey: ['some-query'],
      queryFn: async () => {
        if (Math.random() > 0.5) {
          throw 'some error'
        }
        return 42
      },
    })
    

    useQuery<number, string>({
      queryKey: ['some-query'],
      queryFn: async () => {
        if (Math.random() > 0.5) {
          throw 'some error'
        }
        return 42
      },
    })
    

For a way to set a different kind of Error globally, see [the TypeScript Guide](https://tanstack.com/query/latest/docs/framework/vue/typescript#registering-a-global-error).

### [](#eslint-prefer-query-object-syntax-rule-is-removed)[eslint prefer-query-object-syntax rule is removed](#eslint-prefer-query-object-syntax-rule-is-removed)

Since the only supported syntax now is the object syntax, this rule is no longer needed

### [](#removed-keeppreviousdata-in-favor-of-placeholderdata-identity-function)[Removed keepPreviousData in favor of placeholderData identity function](#removed-keeppreviousdata-in-favor-of-placeholderdata-identity-function)

We have removed the keepPreviousData option and isPreviousData flag as they were doing mostly the same thing as placeholderData and isPlaceholderData flag.

To achieve the same functionality as keepPreviousData, we have added previous query data as an argument to placeholderData which accepts an identity function. Therefore you just need to provide an identity function to placeholderData or use the included keepPreviousData function from Tanstack Query.

> A note here is that useQueries would not receive previousData in the placeholderData function as argument. This is due to a dynamic nature of queries passed in the array, which may lead to a different shape of result from placeholder and queryFn.

    import {
       useQuery,
    +  keepPreviousData // [!code ++]
    } from "@tanstack/react-query";
    
    const {
       data,
    -  isPreviousData, // [!code --]
    +  isPlaceholderData, // [!code ++]
    } = useQuery({
      queryKey,
      queryFn,
    - keepPreviousData: true, // [!code --]
    + placeholderData: keepPreviousData // [!code ++]
    });
    

    import {
       useQuery,
    +  keepPreviousData // [!code ++]
    } from "@tanstack/react-query";
    
    const {
       data,
    -  isPreviousData, // [!code --]
    +  isPlaceholderData, // [!code ++]
    } = useQuery({
      queryKey,
      queryFn,
    - keepPreviousData: true, // [!code --]
    + placeholderData: keepPreviousData // [!code ++]
    });
    

An identity function, in the context of Tanstack Query, refers to a function that always returns its provided argument (i.e. data) unchanged.

    useQuery({
      queryKey,
      queryFn,
      placeholderData: (previousData, previousQuery) => previousData, // identity function with the same behaviour as `keepPreviousData`
    })
    

    useQuery({
      queryKey,
      queryFn,
      placeholderData: (previousData, previousQuery) => previousData, // identity function with the same behaviour as `keepPreviousData`
    })
    

There are some caveats to this change however, which you must be aware of:

*   placeholderData will always put you into success state, while keepPreviousData gave you the status of the previous query. That status could be error if we have data fetched successfully and then got a background refetch error. However, the error itself was not shared, so we decided to stick with behavior of placeholderData.
    
*   keepPreviousData gave you the dataUpdatedAt timestamp of the previous data, while with placeholderData, dataUpdatedAt will stay at 0. This might be annoying if you want to show that timestamp continuously on screen. However you might get around it with useEffect.
    
        const [updatedAt, setUpdatedAt] = useState(0)
        
        const { data, dataUpdatedAt } = useQuery({
          queryKey: ['projects', page],
          queryFn: () => fetchProjects(page),
        })
        
        useEffect(() => {
          if (dataUpdatedAt > updatedAt) {
            setUpdatedAt(dataUpdatedAt)
          }
        }, [dataUpdatedAt])
        
    
        const [updatedAt, setUpdatedAt] = useState(0)
        
        const { data, dataUpdatedAt } = useQuery({
          queryKey: ['projects', page],
          queryFn: () => fetchProjects(page),
        })
        
        useEffect(() => {
          if (dataUpdatedAt > updatedAt) {
            setUpdatedAt(dataUpdatedAt)
          }
        }, [dataUpdatedAt])
        
    

### [](#window-focus-refetching-no-longer-listens-to-the-focus-event)[Window focus refetching no longer listens to the focus event](#window-focus-refetching-no-longer-listens-to-the-focus-event)

The visibilitychange event is used exclusively now. This is possible because we only support browsers that support the visibilitychange event. This fixes a bunch of issues [as listed here](https://github.com/TanStack/query/pull/4805).

### [](#network-status-no-longer-relies-on-the-navigatoronline-property)[Network status no longer relies on the navigator.onLine property](#network-status-no-longer-relies-on-the-navigatoronline-property)

navigator.onLine doesn't work well in Chromium based browsers. There are [a lot of issues](https://bugs.chromium.org/p/chromium/issues/list?q=navigator.online) around false negatives, which lead to Queries being wrongfully marked as offline.

To circumvent this, we now always start with online: true and only listen to online and offline events to update the status.

This should reduce the likelihood of false negatives, however, it might mean false positives for offline apps that load via serviceWorkers, which can work even without an internet connection.

### [](#removed-custom-context-prop-in-favor-of-custom-queryclient-instance)[Removed custom context prop in favor of custom queryClient instance](#removed-custom-context-prop-in-favor-of-custom-queryclient-instance)

In v4, we introduced the possibility to pass a custom context to all react-query hooks. This allowed for proper isolation when using MicroFrontends.

However, context is a react-only feature. All that context does is give us access to the queryClient. We could achieve the same isolation by allowing to pass in a custom queryClient directly. This in turn will enable other frameworks to have the same functionality in a framework-agnostic way.

    import { queryClient } from './my-client'
    
    const { data } = useQuery(
      {
        queryKey: ['users', id],
        queryFn: () => fetch(...),
    -   context: customContext // [!code --]
      },
    +  queryClient, // [!code ++]
    )
    

    import { queryClient } from './my-client'
    
    const { data } = useQuery(
      {
        queryKey: ['users', id],
        queryFn: () => fetch(...),
    -   context: customContext // [!code --]
      },
    +  queryClient, // [!code ++]
    )
    

### [](#removed-refetchpage-in-favor-of-maxpages)[Removed refetchPage in favor of maxPages](#removed-refetchpage-in-favor-of-maxpages)

In v4, we introduced the possibility to define the pages to refetch for infinite queries with the refetchPage function.

However, refetching all pages might lead to UI inconsistencies. Also, this option is available on e.g. queryClient.refetchQueries, but it only does something for infinite queries, not "normal" queries.

The v5 includes a new maxPages option for infinite queries to limit the number of pages to store in the query data and to refetch. This new feature handles the use cases initially identified for the refetchPage page feature without the related issues.

### [](#new-dehydrate-api)[New dehydrate API](#new-dehydrate-api)

The options you can pass to dehydrate have been simplified. Queries and Mutations are always dehydrated (according to the default function implementation). To change this behaviour, instead of using the removed boolean options dehydrateMutations and dehydrateQueries you can implement the function equivalents shouldDehydrateQuery or shouldDehydrateMutation instead. To get the old behaviour of not hydrating queries/mutations at all, pass in () => false.

    - dehydrateMutations?: boolean // [!code --]
    - dehydrateQueries?: boolean // [!code --]
    

    - dehydrateMutations?: boolean // [!code --]
    - dehydrateQueries?: boolean // [!code --]
    

### [](#infinite-queries-now-need-a-initialpageparam)[Infinite queries now need a initialPageParam](#infinite-queries-now-need-a-initialpageparam)

Previously, we've passed undefined to the queryFn as pageParam, and you could assign a default value to the pageParam parameter in the queryFn function signature. This had the drawback of storing undefined in the queryCache, which is not serializable.

Instead, you now have to pass an explicit initialPageParam to the infinite query options. This will be used as the pageParam for the first page:

    useInfiniteQuery({
       queryKey,
    -  queryFn: ({ pageParam = 0 }) => fetchSomething(pageParam), // [!code --]
    +  queryFn: ({ pageParam }) => fetchSomething(pageParam), // [!code ++]
    +  initialPageParam: 0, // [!code ++]
       getNextPageParam: (lastPage) => lastPage.next,
    })
    

    useInfiniteQuery({
       queryKey,
    -  queryFn: ({ pageParam = 0 }) => fetchSomething(pageParam), // [!code --]
    +  queryFn: ({ pageParam }) => fetchSomething(pageParam), // [!code ++]
    +  initialPageParam: 0, // [!code ++]
       getNextPageParam: (lastPage) => lastPage.next,
    })
    

### [](#manual-mode-for-infinite-queries-has-been-removed)[Manual mode for infinite queries has been removed](#manual-mode-for-infinite-queries-has-been-removed)

Previously, we've allowed to overwrite the pageParams that would be returned from getNextPageParam or getPreviousPageParam by passing a pageParam value directly to fetchNextPage or fetchPreviousPage. This feature didn't work at all with refetches and wasn't widely known or used. This also means that getNextPageParam is now required for infinite queries.

### [](#returning-null-from-getnextpageparam-or-getpreviouspageparam-now-indicates-that-there-is-no-further-page-available)[Returning null from getNextPageParam or getPreviousPageParam now indicates that there is no further page available](#returning-null-from-getnextpageparam-or-getpreviouspageparam-now-indicates-that-there-is-no-further-page-available)

In v4, you needed to explicitly return undefined to indicate that there is no further page available. We've widened this check to include null.

### [](#no-retries-on-the-server)[No retries on the server](#no-retries-on-the-server)

On the server, retry now defaults to 0 instead of 3. For prefetching, we have always defaulted to 0 retries, but since queries that have suspense enabled can now execute directly on the server as well (since React18), we have to make sure that we don't retry on the server at all.

### [](#status-loading-has-been-changed-to-status-pending-and-isloading-has-been-changed-to-ispending-and-isinitialloading-has-now-been-renamed-to-isloading)[status: loading has been changed to status: pending and isLoading has been changed to isPending and isInitialLoading has now been renamed to isLoading](#status-loading-has-been-changed-to-status-pending-and-isloading-has-been-changed-to-ispending-and-isinitialloading-has-now-been-renamed-to-isloading)

The loading status has been renamed to pending, and similarly the derived isLoading flag has been renamed to isPending.

For mutations as well the status has been changed from loading to pending and the isLoading flag has been changed to isPending.

Lastly, a new derived isLoading flag has been added to the queries that is implemented as isPending && isFetching. This means that isLoading and isInitialLoading have the same thing, but isInitialLoading is deprecated now and will be removed in the next major version.

To understand the reasoning behind this change checkout the [v5 roadmap discussion](https://github.com/TanStack/query/discussions/4252).

### [](#hashquerykey-has-been-renamed-to-hashkey)[hashQueryKey has been renamed to hashKey](#hashquerykey-has-been-renamed-to-hashkey)

because it also hashes mutation keys and can be used inside the predicate functions of useIsMutating and useMutationState, which gets mutations passed.

[](#vue-query-breaking-changes)[Vue Query Breaking Changes](#vue-query-breaking-changes)
----------------------------------------------------------------------------------------

### [](#usequeries-composable-returns-ref-instead-of-reactive)[useQueries composable returns ref instead of reactive](#usequeries-composable-returns-ref-instead-of-reactive)

To fix compatibility with Vue 2, useQueries composable now returns queries array wrapped in ref. Previously reactive was returned which led to multiple problems:

*   User could spread return value loosing reactivity.
*   readonly wrapper used for return value was breaking Vue 2 reactivity detection mechanism. This was a silent issue in Vue 2.6, but appeared as error in Vue 2.7.
*   Vue 2 does not support arrays as a root value of reactive.

With this change all of those issues are fixed.

Also this aligns useQueries with other composables which return all of the values as refs.

### [](#vue-v33-is-now-required)[Vue v3.3 is now required](#vue-v33-is-now-required)

To be able to provide new features following Vue releases, we now require Vue 3 to be at least in v3.3 version. Requirements for Vue 2.x remain unchanged.

[](#new-features-)[New Features üöÄ](#new-features-)
---------------------------------------------------

v5 also comes with new features:

### [](#simplified-optimistic-updates)[Simplified optimistic updates](#simplified-optimistic-updates)

We have a new, simplified way to perform optimistic updates by leveraging the returned variables from useMutation:

    const queryInfo = useTodos()
    const addTodoMutation = useMutation({
      mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
      onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
    })
    
    if (queryInfo.data) {
      return (
        <ul>
          {queryInfo.data.items.map((todo) => (
            <li key={todo.id}>{todo.text}</li>
          ))}
          {addTodoMutation.isPending && (
            <li key={String(addTodoMutation.submittedAt)} style={{ opacity: 0.5 }}>
              {addTodoMutation.variables}
            </li>
          )}
        </ul>
      )
    }
    

    const queryInfo = useTodos()
    const addTodoMutation = useMutation({
      mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
      onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
    })
    
    if (queryInfo.data) {
      return (
        <ul>
          {queryInfo.data.items.map((todo) => (
            <li key={todo.id}>{todo.text}</li>
          ))}
          {addTodoMutation.isPending && (
            <li key={String(addTodoMutation.submittedAt)} style={{ opacity: 0.5 }}>
              {addTodoMutation.variables}
            </li>
          )}
        </ul>
      )
    }
    

Here, we are only changing how the UI looks when the mutation is running instead of writing data directly to the cache. This works best if we only have one place where we need to show the optimistic update. For more details, have a look at the [optimistic updates documentation](https://tanstack.com/query/latest/docs/framework/vue/guides/optimistic-updates).

### [](#limited-infinite-queries-with-new-maxpages-option)[Limited, Infinite Queries with new maxPages option](#limited-infinite-queries-with-new-maxpages-option)

Infinite queries are great when infinite scroll or pagination are needed. However, the more pages you fetch, the more memory you consume, and this also slows down the query refetching process as all the pages are sequentially refetched.

Version 5 has a new maxPages option for infinite queries, which allows developers to limit the number of pages that are stored in the query data and subsequently refetched. You can adjust the maxPages value according to the UX and refetching performance you want to deliver.

Note that the infinite list must be bi-directional, which requires both getNextPageParam and getPreviousPageParam to be defined.

### [](#infinite-queries-can-prefetch-multiple-pages)[Infinite Queries can prefetch multiple pages](#infinite-queries-can-prefetch-multiple-pages)

Infinite Queries can be prefetched like regular Queries. Per default, only the first page of the Query will be prefetched and will be stored under the given QueryKey. If you want to prefetch more than one page, you can use the pages option. Read the [prefetching guide](https://tanstack.com/query/latest/docs/framework/vue/guides/prefetching) for more information.

### [](#new-combine-option-for-usequeries)[New combine option for useQueries](#new-combine-option-for-usequeries)

See the [useQueries docs](https://tanstack.com/query/latest/docs/framework/vue/reference/useQueries#combine) for more details.

### [](#experimental-fine-grained-storage-persister)[Experimental fine grained storage persister](#experimental-fine-grained-storage-persister)

See the [experimental\_createPersister docs](https://tanstack.com/query/latest/docs/framework/vue/plugins/createPersister) for more details.

### [](#ability-to-run-vue-query-composables-in-injectioncontext)[Ability to run vue-query composables in injectionContext](#ability-to-run-vue-query-composables-in-injectioncontext)

Previously vue-query composables could be run only within setup function of the component.  
We had an escape hatch in place to allow those hooks to be run anywhere if user would provide queryClient as a composable option.

Now you can use vue-query composables in any function that supports injectionContext. Ex. router navigation guards. When using this new feature, make sure that vue-query composable is running within effectScope. Otherwise it might lead to memory leaks. We have added dev-only warnings to inform users about potential misusage.</content>
</page>

<page>
  <title>useInfiniteQuery | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/reference/useInfiniteQuery</url>
  <content>    const {
      fetchNextPage,
      fetchPreviousPage,
      hasNextPage,
      hasPreviousPage,
      isFetchingNextPage,
      isFetchingPreviousPage,
      promise,
      ...result
    } = useInfiniteQuery({
      queryKey,
      queryFn: ({ pageParam }) => fetchPage(pageParam),
      initialPageParam: 1,
      ...options,
      getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) =>
        lastPage.nextCursor,
      getPreviousPageParam: (firstPage, allPages, firstPageParam, allPageParams) =>
        firstPage.prevCursor,
    })
    

    const {
      fetchNextPage,
      fetchPreviousPage,
      hasNextPage,
      hasPreviousPage,
      isFetchingNextPage,
      isFetchingPreviousPage,
      promise,
      ...result
    } = useInfiniteQuery({
      queryKey,
      queryFn: ({ pageParam }) => fetchPage(pageParam),
      initialPageParam: 1,
      ...options,
      getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) =>
        lastPage.nextCursor,
      getPreviousPageParam: (firstPage, allPages, firstPageParam, allPageParams) =>
        firstPage.prevCursor,
    })
    

**Options**

The options for useInfiniteQuery are identical to the [useQuery hook](https://tanstack.com/query/latest/docs/framework/vue/reference/useQuery) with the addition of the following:

*   queryFn: (context: QueryFunctionContext) => Promise<TData>
    *   **Required, but only if no default query function has been defined** [defaultQueryFn](https://tanstack.com/query/latest/docs/framework/vue/guides/default-query-function)
    *   The function that the query will use to request data.
    *   Receives a [QueryFunctionContext](https://tanstack.com/query/latest/docs/framework/vue/guides/query-functions#queryfunctioncontext)
    *   Must return a promise that will either resolve data or throw an error.
*   initialPageParam: TPageParam
    *   **Required**
    *   The default page param to use when fetching the first page.
*   getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => TPageParam | undefined | null
    *   **Required**
    *   When new data is received for this query, this function receives both the last page of the infinite list of data and the full array of all pages, as well as pageParam information.
    *   It should return a **single variable** that will be passed as the last optional parameter to your query function.
    *   Return undefined or null to indicate there is no next page available.
*   getPreviousPageParam: (firstPage, allPages, firstPageParam, allPageParams) => TPageParam | undefined | null
    *   When new data is received for this query, this function receives both the first page of the infinite list of data and the full array of all pages, as well as pageParam information.
    *   It should return a **single variable** that will be passed as the last optional parameter to your query function.
    *   Return undefined or nullto indicate there is no previous page available.
*   maxPages: number | undefined
    *   The maximum number of pages to store in the infinite query data.
    *   When the maximum number of pages is reached, fetching a new page will result in the removal of either the first or last page from the pages array, depending on the specified direction.
    *   If undefined or equals 0, the number of pages is unlimited
    *   Default value is undefined
    *   getNextPageParam and getPreviousPageParam must be properly defined if maxPages value is greater than 0 to allow fetching a page in both directions when needed.

**Returns**

The returned properties for useInfiniteQuery are identical to the [useQuery hook](https://tanstack.com/query/latest/docs/framework/vue/reference/useQuery), with the addition of the following properties and a small difference in isRefetching and isRefetchError:

*   data.pages: TData\[\]
    *   Array containing all pages.
*   data.pageParams: unknown\[\]
    *   Array containing all page params.
*   isFetchingNextPage: boolean
    *   Will be true while fetching the next page with fetchNextPage.
*   isFetchingPreviousPage: boolean
    *   Will be true while fetching the previous page with fetchPreviousPage.
*   fetchNextPage: (options?: FetchNextPageOptions) => Promise<UseInfiniteQueryResult>
    *   This function allows you to fetch the next "page" of results.
    *   options.cancelRefetch: boolean if set to true, calling fetchNextPage repeatedly will invoke queryFn every time, whether the previous invocation has resolved or not. Also, the result from previous invocations will be ignored. If set to false, calling fetchNextPage repeatedly won't have any effect until the first invocation has resolved. Default is true.
*   fetchPreviousPage: (options?: FetchPreviousPageOptions) => Promise<UseInfiniteQueryResult>
    *   This function allows you to fetch the previous "page" of results.
    *   options.cancelRefetch: boolean same as for fetchNextPage.
*   hasNextPage: boolean
    *   Will be true if there is a next page to be fetched (known via the getNextPageParam option).
*   hasPreviousPage: boolean
    *   Will be true if there is a previous page to be fetched (known via the getPreviousPageParam option).
*   isFetchNextPageError: boolean
    *   Will be true if the query failed while fetching the next page.
*   isFetchPreviousPageError: boolean
    *   Will be true if the query failed while fetching the previous page.
*   isRefetching: boolean
    *   Will be true whenever a background refetch is in-flight, which _does not_ include initial pending or fetching of next or previous page
    *   Is the same as isFetching && !isPending && !isFetchingNextPage && !isFetchingPreviousPage
*   isRefetchError: boolean
    *   Will be true if the query failed while refetching a page.
*   promise: Promise<TData>
    *   A stable promise that resolves to the query result.
    *   This can be used with React.use() to fetch data
    *   Requires the experimental\_prefetchInRender feature flag to be enabled on the QueryClient.

Keep in mind that imperative fetch calls, such as fetchNextPage, may interfere with the default refetch behaviour, resulting in outdated data. Make sure to call these functions only in response to user actions, or add conditions like hasNextPage && !isFetching.</content>
</page>

<page>
  <title>useMutation | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/reference/useMutation</url>
  <content>    const {
      data,
      error,
      isError,
      isIdle,
      isPending,
      isPaused,
      isSuccess,
      failureCount,
      failureReason,
      mutate,
      mutateAsync,
      reset,
      status,
      submittedAt,
      variables,
    } = useMutation(
      {
        mutationFn,
        gcTime,
        meta,
        mutationKey,
        networkMode,
        onError,
        onMutate,
        onSettled,
        onSuccess,
        retry,
        retryDelay,
        scope,
        throwOnError,
      },
      queryClient,
    )
    
    mutate(variables, {
      onError,
      onSettled,
      onSuccess,
    })
    

    const {
      data,
      error,
      isError,
      isIdle,
      isPending,
      isPaused,
      isSuccess,
      failureCount,
      failureReason,
      mutate,
      mutateAsync,
      reset,
      status,
      submittedAt,
      variables,
    } = useMutation(
      {
        mutationFn,
        gcTime,
        meta,
        mutationKey,
        networkMode,
        onError,
        onMutate,
        onSettled,
        onSuccess,
        retry,
        retryDelay,
        scope,
        throwOnError,
      },
      queryClient,
    )
    
    mutate(variables, {
      onError,
      onSettled,
      onSuccess,
    })</content>
</page>

<page>
  <title>useIsFetching | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/reference/useIsFetching</url>
  <content>useIsFetching is an optional hook that returns the number of the queries that your application is loading or fetching in the background (useful for app-wide loading indicators).

    import { useIsFetching } from '@tanstack/vue-query'
    // How many queries are fetching?
    const isFetching = useIsFetching()
    // How many queries matching the posts prefix are fetching?
    const isFetchingPosts = useIsFetching({ queryKey: ['posts'] })
    

    import { useIsFetching } from '@tanstack/vue-query'
    // How many queries are fetching?
    const isFetching = useIsFetching()
    // How many queries matching the posts prefix are fetching?
    const isFetchingPosts = useIsFetching({ queryKey: ['posts'] })
    

**Options**

*   filters?: QueryFilters: [Query Filters](https://tanstack.com/query/latest/docs/framework/vue/guides/filters#query-filters)
*   queryClient?: QueryClient
    *   Use this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.

**Returns**

*   isFetching: number
    *   Will be the number of the queries that your application is currently loading or fetching in the background.</content>
</page>

<page>
  <title>useIsMutating | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/reference/useIsMutating</url>
  <content>useIsMutating is an optional hook that returns the number of mutations that your application is fetching (useful for app-wide loading indicators).

    import { useIsMutating } from '@tanstack/vue-query'
    // How many mutations are fetching?
    const isMutating = useIsMutating()
    // How many mutations matching the posts prefix are fetching?
    const isMutatingPosts = useIsMutating({ mutationKey: ['posts'] })
    

    import { useIsMutating } from '@tanstack/vue-query'
    // How many mutations are fetching?
    const isMutating = useIsMutating()
    // How many mutations matching the posts prefix are fetching?
    const isMutatingPosts = useIsMutating({ mutationKey: ['posts'] })
    

**Options**

*   filters?: MutationFilters: [Mutation Filters](https://tanstack.com/query/latest/docs/framework/vue/guides/filters#mutation-filters)
*   queryClient?: QueryClient
    *   Use this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.

**Returns**

*   isMutating: number
    *   Will be the number of the mutations that your application is currently fetching.</content>
</page>

<page>
  <title>useMutationState | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/reference/useMutationState</url>
  <content>useMutationState is a hook that gives you access to all mutations in the MutationCache. You can pass filters to it to narrow down your mutations, and select to transform the mutation state.

**Example 1: Get all variables of all running mutations**

    import { useMutationState } from '@tanstack/vue-query'
    
    const variables = useMutationState({
      filters: { status: 'pending' },
      select: (mutation) => mutation.state.variables,
    })
    

    import { useMutationState } from '@tanstack/vue-query'
    
    const variables = useMutationState({
      filters: { status: 'pending' },
      select: (mutation) => mutation.state.variables,
    })
    

**Example 2: Get all data for specific mutations via the mutationKey**

    import { useMutation, useMutationState } from '@tanstack/vue-query'
    
    const mutationKey = ['posts']
    
    // Some mutation that we want to get the state for
    const mutation = useMutation({
      mutationKey,
      mutationFn: (newPost) => {
        return axios.post('/posts', newPost)
      },
    })
    
    const data = useMutationState({
      // this mutation key needs to match the mutation key of the given mutation (see above)
      filters: { mutationKey },
      select: (mutation) => mutation.state.data,
    })
    

    import { useMutation, useMutationState } from '@tanstack/vue-query'
    
    const mutationKey = ['posts']
    
    // Some mutation that we want to get the state for
    const mutation = useMutation({
      mutationKey,
      mutationFn: (newPost) => {
        return axios.post('/posts', newPost)
      },
    })
    
    const data = useMutationState({
      // this mutation key needs to match the mutation key of the given mutation (see above)
      filters: { mutationKey },
      select: (mutation) => mutation.state.data,
    })
    

**Example 3: Access the latest mutation data via the mutationKey**. Each invocation of mutate adds a new entry to the mutation cache for gcTime milliseconds.

To access the latest invocation, you can check for the last item that useMutationState returns.

    import { useMutation, useMutationState } from '@tanstack/vue-query'
    
    const mutationKey = ['posts']
    
    // Some mutation that we want to get the state for
    const mutation = useMutation({
      mutationKey,
      mutationFn: (newPost) => {
        return axios.post('/posts', newPost)
      },
    })
    
    const data = useMutationState({
      // this mutation key needs to match the mutation key of the given mutation (see above)
      filters: { mutationKey },
      select: (mutation) => mutation.state.data,
    })
    
    // Latest mutation data
    const latest = data[data.length - 1]
    

    import { useMutation, useMutationState } from '@tanstack/vue-query'
    
    const mutationKey = ['posts']
    
    // Some mutation that we want to get the state for
    const mutation = useMutation({
      mutationKey,
      mutationFn: (newPost) => {
        return axios.post('/posts', newPost)
      },
    })
    
    const data = useMutationState({
      // this mutation key needs to match the mutation key of the given mutation (see above)
      filters: { mutationKey },
      select: (mutation) => mutation.state.data,
    })
    
    // Latest mutation data
    const latest = data[data.length - 1]
    

**Options**

*   options
    *   filters?: MutationFilters: [Mutation Filters](https://tanstack.com/query/latest/docs/framework/vue/guides/filters#mutation-filters)
    *   select?: (mutation: Mutation) => TResult
        *   Use this to transform the mutation state.
*   queryClient?: QueryClient
    *   Use this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.

**Returns**

*   Array<TResult>
    *   Will be an Array of whatever select returns for each matching mutation.</content>
</page>

<page>
  <title>useQueryClient | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/reference/useQueryClient</url>
  <content>The useQueryClient hook returns the current QueryClient instance.

    import { useQueryClient } from '@tanstack/vue-query'
    
    const queryClient = useQueryClient(queryClient?: QueryClient)
    

    import { useQueryClient } from '@tanstack/vue-query'
    
    const queryClient = useQueryClient(queryClient?: QueryClient)
    

**Options**

*   queryClient?: QueryClient
    *   Use this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.</content>
</page>

<page>
  <title>queryOptions | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/reference/queryOptions</url>
  <content>    queryOptions({
      queryKey,
      ...options,
    })
    

    queryOptions({
      queryKey,
      ...options,
    })
    

**Options**

You can generally pass everything to queryOptions that you can also pass to [useQuery](https://tanstack.com/query/latest/docs/framework/vue/reference/useQuery). Some options will have no effect when then forwarded to a function like queryClient.prefetchQuery, but TypeScript will still be fine with those excess properties.

*   queryKey: QueryKey
    *   **Required**
    *   The query key to generate options for.
*   experimental\_prefetchInRender?: boolean
    *   Optional
    *   Defaults to false
    *   When set to true, queries will be prefetched during render, which can be useful for certain optimization scenarios
    *   Needs to be turned on for the experimental useQuery().promise functionality

[](#further-reading)[Further reading](#further-reading)
-------------------------------------------------------

To learn more about QueryOptions, have a look at [this article by TkDodo The Query Options API](https://tkdodo.eu/blog/the-query-options-api).</content>
</page>

<page>
  <title>infiniteQueryOptions | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/reference/infiniteQueryOptions</url>
  <content>tsx

    infiniteQueryOptions({
      queryKey,
      ...options,
    })
    

    infiniteQueryOptions({
      queryKey,
      ...options,
    })
    

**Options**

You can generally pass everything to infiniteQueryOptions that you can also pass to [useInfiniteQuery](https://tanstack.com/query/latest/docs/framework/vue/reference/useInfiniteQuery). Some options will have no effect when then forwarded to a function like queryClient.prefetchInfiniteQuery, but TypeScript will still be fine with those excess properties.

*   queryKey: QueryKey
    *   **Required**
    *   The query key to generate options for.

See [useInfiniteQuery](https://tanstack.com/query/latest/docs/framework/vue/reference/useInfiniteQuery) for more information.</content>
</page>

<page>
  <title>hydration | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/reference/hydration</url>
  <content>[](#dehydrate)[dehydrate](#dehydrate)
-------------------------------------

dehydrate creates a frozen representation of a cache that can later be hydrated with HydrationBoundary or hydrate. This is useful for passing prefetched queries from server to client or persisting queries to localStorage or other persistent locations. It only includes currently successful queries by default.

    import { dehydrate } from '@tanstack/vue-query'
    
    const dehydratedState = dehydrate(queryClient, {
      shouldDehydrateQuery,
      shouldDehydrateMutation,
    })
    

    import { dehydrate } from '@tanstack/vue-query'
    
    const dehydratedState = dehydrate(queryClient, {
      shouldDehydrateQuery,
      shouldDehydrateMutation,
    })
    

**Options**

*   client: QueryClient
    *   **Required**
    *   The queryClient that should be dehydrated
*   options: DehydrateOptions
    *   Optional
    *   shouldDehydrateMutation: (mutation: Mutation) => boolean
        *   Optional
        *   Whether to dehydrate mutations.
        *   The function is called for each mutation in the cache
            *   Return true to include this mutation in dehydration, or false otherwise
        *   Defaults to only including paused mutations
        *   If you would like to extend the function while retaining the default behavior, import and execute defaultShouldDehydrateMutation as part of the return statement
    *   shouldDehydrateQuery: (query: Query) => boolean
        *   Optional
        *   Whether to dehydrate queries.
        *   The function is called for each query in the cache
            *   Return true to include this query in dehydration, or false otherwise
        *   Defaults to only including successful queries
        *   If you would like to extend the function while retaining the default behavior, import and execute defaultShouldDehydrateQuery as part of the return statement
    *   serializeData?: (data: any) => any A function to transform (serialize) data during dehydration.
    *   shouldRedactErrors?: (error: unknown) => boolean
        *   Optional
        *   Whether to redact errors from the server during dehydration.
        *   The function is called for each error in the cache
            *   Return true to redact this error, or false otherwise
        *   Defaults to redacting all errors

**Returns**

*   dehydratedState: DehydratedState
    *   This includes everything that is needed to hydrate the queryClient at a later point
    *   You **should not** rely on the exact format of this response, it is not part of the public API and can change at any time
    *   This result is not in serialized form, you need to do that yourself if desired

### [](#limitations)[Limitations](#limitations)

Some storage systems (such as browser [Web Storage API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API)) require values to be JSON serializable. If you need to dehydrate values that are not automatically serializable to JSON (like Error or undefined), you have to serialize them for yourself. Since only successful queries are included per default, to also include Errors, you have to provide shouldDehydrateQuery, e.g.:

    // server
    const state = dehydrate(client, { shouldDehydrateQuery: () => true }) // to also include Errors
    const serializedState = mySerialize(state) // transform Error instances to objects
    
    // client
    const state = myDeserialize(serializedState) // transform objects back to Error instances
    hydrate(client, state)
    

    // server
    const state = dehydrate(client, { shouldDehydrateQuery: () => true }) // to also include Errors
    const serializedState = mySerialize(state) // transform Error instances to objects
    
    // client
    const state = myDeserialize(serializedState) // transform objects back to Error instances
    hydrate(client, state)
    

[](#hydrate)[hydrate](#hydrate)
-------------------------------

hydrate adds a previously dehydrated state into a cache.

    import { hydrate } from '@tanstack/vue-query'
    
    hydrate(queryClient, dehydratedState, options)
    

    import { hydrate } from '@tanstack/vue-query'
    
    hydrate(queryClient, dehydratedState, options)
    

**Options**

*   client: QueryClient
    *   **Required**
    *   The queryClient to hydrate the state into
*   dehydratedState: DehydratedState
    *   **Required**
    *   The state to hydrate into the client
*   options: HydrateOptions
    *   Optional
    *   defaultOptions: DefaultOptions
        *   Optional
        *   mutations: MutationOptions The default mutation options to use for the hydrated mutations.
        *   queries: QueryOptions The default query options to use for the hydrated queries.
        *   deserializeData?: (data: any) => any A function to transform (deserialize) data before it is put into the cache.
    *   queryClient?: QueryClient
        *   Use this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.

### [](#limitations-1)[Limitations](#limitations-1)

If the queries you're trying to hydrate already exist in the queryCache, hydrate will only overwrite them if the data is newer than the data present in the cache. Otherwise, it will **not** get applied.</content>
</page>

<page>
  <title>broadcastQueryClient (Experimental) | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/plugins/broadcastQueryClient</url>
  <content>> VERY IMPORTANT: This utility is currently in an experimental stage. This means that breaking changes will happen in minor AND patch releases. Use at your own risk. If you choose to rely on this in production in an experimental stage, please lock your version to a patch-level version to avoid unexpected breakages.

broadcastQueryClient is a utility for broadcasting and syncing the state of your queryClient between browser tabs/windows with the same origin.

[](#installation)[Installation](#installation)
----------------------------------------------

This utility comes as a separate package and is available under the '@tanstack/query-broadcast-client-experimental' import.

[](#usage)[Usage](#usage)
-------------------------

Import the broadcastQueryClient function, and pass it your QueryClient instance, and optionally, set a broadcastChannel.

    import { broadcastQueryClient } from '@tanstack/query-broadcast-client-experimental'
    
    const queryClient = new QueryClient()
    
    broadcastQueryClient({
      queryClient,
      broadcastChannel: 'my-app',
    })
    

    import { broadcastQueryClient } from '@tanstack/query-broadcast-client-experimental'
    
    const queryClient = new QueryClient()
    
    broadcastQueryClient({
      queryClient,
      broadcastChannel: 'my-app',
    })
    

[](#api)[API](#api)
-------------------

### [](#broadcastqueryclient)[broadcastQueryClient](#broadcastqueryclient)

Pass this function a QueryClient instance and optionally, a broadcastChannel.

    broadcastQueryClient({ queryClient, broadcastChannel })
    

    broadcastQueryClient({ queryClient, broadcastChannel })
    

### [](#options)[Options](#options)

An object of options:

    interface BroadcastQueryClientOptions {
      /** The QueryClient to sync */
      queryClient: QueryClient
      /** This is the unique channel name that will be used
       * to communicate between tabs and windows */
      broadcastChannel?: string
      /** Options for the BroadcastChannel API */
      options?: BroadcastChannelOptions
    }
    

    interface BroadcastQueryClientOptions {
      /** The QueryClient to sync */
      queryClient: QueryClient
      /** This is the unique channel name that will be used
       * to communicate between tabs and windows */
      broadcastChannel?: string
      /** Options for the BroadcastChannel API */
      options?: BroadcastChannelOptions
    }
    

The default options are:

    {
      broadcastChannel = 'tanstack-query',
    }
    

    {
      broadcastChannel = 'tanstack-query',
    }</content>
</page>

<page>
  <title>experimental_createQueryPersister | TanStack Query Vue Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/plugins/createPersister</url>
  <content>[](#installation)[Installation](#installation)
----------------------------------------------

This utility comes as a separate package and is available under the '@tanstack/query-persist-client-core' import.

    npm install @tanstack/query-persist-client-core
    

    npm install @tanstack/query-persist-client-core
    

or

    pnpm add @tanstack/query-persist-client-core
    

    pnpm add @tanstack/query-persist-client-core
    

or

    yarn add @tanstack/query-persist-client-core
    

    yarn add @tanstack/query-persist-client-core
    

or

    bun add @tanstack/query-persist-client-core
    

    bun add @tanstack/query-persist-client-core
    

[](#usage)[Usage](#usage)
-------------------------

*   Import the experimental\_createQueryPersister function
*   Create a new experimental\_createQueryPersister
    *   you can pass any storage to it that adheres to the AsyncStorage interface
*   Pass that persister as an option to your Query. This can be done either by passing it to the defaultOptions of the QueryClient or to any useQuery hook instance.
    *   If you pass this persister as defaultOptions, all queries will be persisted to the provided storage. You can additionally narrow this down by passing filters. In contrast to the persistClient plugin, this will not persist the whole query client as a single item, but each query separately. As a key, the query hash is used.
    *   If you provide this persister to a single useQuery hook, only this Query will be persisted.
*   Note: queryClient.setQueryData() operations are not persisted, this means that if you perform an optimistic update and refresh the page before the query has been invalidated, your changes to the query data will be lost. See [https://github.com/TanStack/query/issues/6310](https://github.com/TanStack/query/issues/6310)

This way, you do not need to store whole QueryClient, but choose what is worth to be persisted in your application. Each query is lazily restored (when the Query is first used) and persisted (after each run of the queryFn), so it does not need to be throttled. staleTime is also respected after restoring the Query, so if data is considered stale, it will be refetched immediately after restoring. If data is fresh, the queryFn will not run.

Garbage collecting a Query from memory **does not** affect the persisted data. That means Queries can be kept in memory for a shorter period of time to be more **memory efficient**. If they are used the next time, they will just be restored from the persistent storage again.

    import { QueryClient } from '@tanstack/vue-query'
    import { experimental_createQueryPersister } from '@tanstack/query-persist-client-core'
    
    const persister = experimental_createQueryPersister({
      storage: AsyncStorage,
      maxAge: 1000 * 60 * 60 * 12, // 12 hours
    })
    
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          gcTime: 1000 * 30, // 30 seconds
          persister: persister.persisterFn,
        },
      },
    })
    

    import { QueryClient } from '@tanstack/vue-query'
    import { experimental_createQueryPersister } from '@tanstack/query-persist-client-core'
    
    const persister = experimental_createQueryPersister({
      storage: AsyncStorage,
      maxAge: 1000 * 60 * 60 * 12, // 12 hours
    })
    
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          gcTime: 1000 * 30, // 30 seconds
          persister: persister.persisterFn,
        },
      },
    })
    

### [](#adapted-defaults)[Adapted defaults](#adapted-defaults)

The createPersister plugin technically wraps the queryFn, so it doesn't restore if the queryFn doesn't run. In that way, it acts as a caching layer between the Query and the network. Thus, the networkMode defaults to 'offlineFirst' when a persister is used, so that restoring from the persistent storage can also happen even if there is no network connection.

[](#additional-utilities)[Additional utilities](#additional-utilities)
----------------------------------------------------------------------

Invoking experimental\_createQueryPersister returns additional utilities in addition to persisterFn for easier implementation of userland functionalities.

### [](#persistquerybykeyquerykey-querykey-queryclient-queryclient-promisevoid)[persistQueryByKey(queryKey: QueryKey, queryClient: QueryClient): Promise<void>](#persistquerybykeyquerykey-querykey-queryclient-queryclient-promisevoid)

This function will persist Query to storage and key defined when creating persister.  
This utility might be used along setQueryData to persist optimistic update to storage without waiting for invalidation.

    const persister = experimental_createQueryPersister({
      storage: AsyncStorage,
      maxAge: 1000 * 60 * 60 * 12, // 12 hours
    })
    
    const queryClient = useQueryClient()
    
    useMutation({
      mutationFn: updateTodo,
      onMutate: async (newTodo) => {
        ...
        // Optimistically update to the new value
        queryClient.setQueryData(['todos'], (old) => [...old, newTodo])
        // And persist it to storage
        persister.persistQueryByKey(['todos'], queryClient)
        ...
      },
    })
    

    const persister = experimental_createQueryPersister({
      storage: AsyncStorage,
      maxAge: 1000 * 60 * 60 * 12, // 12 hours
    })
    
    const queryClient = useQueryClient()
    
    useMutation({
      mutationFn: updateTodo,
      onMutate: async (newTodo) => {
        ...
        // Optimistically update to the new value
        queryClient.setQueryData(['todos'], (old) => [...old, newTodo])
        // And persist it to storage
        persister.persistQueryByKey(['todos'], queryClient)
        ...
      },
    })
    

### [](#retrievequerytqueryhash-string-promiset--undefined)[retrieveQuery<T>(queryHash: string): Promise<T | undefined>](#retrievequerytqueryhash-string-promiset--undefined)

This function would attempt to retrieve persisted query by queryHash.  
If query is expired, busted or malformed it would be removed from the storage instead, and undefined would be returned.

### [](#persistergc-promisevoid)[persisterGc(): Promise<void>](#persistergc-promisevoid)

This function can be used to sporadically clean up stoage from expired, busted or malformed entries.

For this function to work, your storage must expose entries method that would return a key-value tuple array.  
For example Object.entries(localStorage) for localStorage or entries from idb-keyval.

### [](#restorequeriesqueryclient-queryclient-filters-promisevoid)[restoreQueries(queryClient: QueryClient, filters): Promise<void>](#restorequeriesqueryclient-queryclient-filters-promisevoid)

This function can be used to restore queries that are currently stored by persister.  
For example when your app is starting up in offline mode, or you want all or only specific data from previous session to be immediately available without intermediate loading state.

The filter object supports the following properties:

*   queryKey?: QueryKey
    *   Set this property to define a query key to match on.
*   exact?: boolean
    *   If you don't want to search queries inclusively by query key, you can pass the exact: true option to return only the query with the exact query key you have passed.

For this function to work, your storage must expose entries method that would return a key-value tuple array.  
For example Object.entries(localStorage) for localStorage or entries from idb-keyval.

[](#api)[API](#api)
-------------------

### [](#experimental_createquerypersister)[experimental\_createQueryPersister](#experimental_createquerypersister)

    experimental_createQueryPersister(options: StoragePersisterOptions)
    

    experimental_createQueryPersister(options: StoragePersisterOptions)
    

#### [](#options)[Options](#options)

    export interface StoragePersisterOptions {
      /** The storage client used for setting and retrieving items from cache.
       * For SSR pass in `undefined`.
       */
      storage: AsyncStorage | Storage | undefined | null
      /**
       * How to serialize the data to storage.
       * @default `JSON.stringify`
       */
      serialize?: (persistedQuery: PersistedQuery) => string
      /**
       * How to deserialize the data from storage.
       * @default `JSON.parse`
       */
      deserialize?: (cachedString: string) => PersistedQuery
      /**
       * A unique string that can be used to forcefully invalidate existing caches,
       * if they do not share the same buster string
       */
      buster?: string
      /**
       * The max-allowed age of the cache in milliseconds.
       * If a persisted cache is found that is older than this
       * time, it will be discarded
       * @default 24 hours
       */
      maxAge?: number
      /**
       * Prefix to be used for storage key.
       * Storage key is a combination of prefix and query hash in a form of `prefix-queryHash`.
       */
      prefix?: string
      /**
       * If set to `true`, the query will refetch on successful query restoration if the data is stale.
       * If set to `false`, the query will not refetch on successful query restoration.
       * If set to `'always'`, the query will always refetch on successful query restoration.
       * Defaults to `true`.
       */
      refetchOnRestore?: boolean | 'always'
      /**
       * Filters to narrow down which Queries should be persisted.
       */
      filters?: QueryFilters
    }
    
    interface AsyncStorage<TStorageValue = string> {
      getItem: (key: string) => MaybePromise<TStorageValue | undefined | null>
      setItem: (key: string, value: TStorageValue) => MaybePromise<unknown>
      removeItem: (key: string) => MaybePromise<void>
      entries?: () => MaybePromise<Array<[key: string, value: TStorageValue]>>
    }
    

    export interface StoragePersisterOptions {
      /** The storage client used for setting and retrieving items from cache.
       * For SSR pass in `undefined`.
       */
      storage: AsyncStorage | Storage | undefined | null
      /**
       * How to serialize the data to storage.
       * @default `JSON.stringify`
       */
      serialize?: (persistedQuery: PersistedQuery) => string
      /**
       * How to deserialize the data from storage.
       * @default `JSON.parse`
       */
      deserialize?: (cachedString: string) => PersistedQuery
      /**
       * A unique string that can be used to forcefully invalidate existing caches,
       * if they do not share the same buster string
       */
      buster?: string
      /**
       * The max-allowed age of the cache in milliseconds.
       * If a persisted cache is found that is older than this
       * time, it will be discarded
       * @default 24 hours
       */
      maxAge?: number
      /**
       * Prefix to be used for storage key.
       * Storage key is a combination of prefix and query hash in a form of `prefix-queryHash`.
       */
      prefix?: string
      /**
       * If set to `true`, the query will refetch on successful query restoration if the data is stale.
       * If set to `false`, the query will not refetch on successful query restoration.
       * If set to `'always'`, the query will always refetch on successful query restoration.
       * Defaults to `true`.
       */
      refetchOnRestore?: boolean | 'always'
      /**
       * Filters to narrow down which Queries should be persisted.
       */
      filters?: QueryFilters
    }
    
    interface AsyncStorage<TStorageValue = string> {
      getItem: (key: string) => MaybePromise<TStorageValue | undefined | null>
      setItem: (key: string, value: TStorageValue) => MaybePromise<unknown>
      removeItem: (key: string) => MaybePromise<void>
      entries?: () => MaybePromise<Array<[key: string, value: TStorageValue]>>
    }
    

The default options are:

    {
      prefix = 'tanstack-query',
      maxAge = 1000 * 60 * 60 * 24,
      serialize = JSON.stringify,
      deserialize = JSON.parse,
      refetchOnRestore = true,
    }
    

    {
      prefix = 'tanstack-query',
      maxAge = 1000 * 60 * 60 * 24,
      serialize = JSON.stringify,
      deserialize = JSON.parse,
      refetchOnRestore = true,
    }</content>
</page>

<page>
  <title>Overview | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/overview</url>
  <content>The @tanstack/svelte-query package offers a 1st-class API for using TanStack Query via Svelte.

> Migrating from stores to the runes syntax? See the [migration guide](https://tanstack.com/query/latest/docs/framework/svelte/migrate-from-v5-to-v6).

[](#example)[Example](#example)
-------------------------------

Include the QueryClientProvider near the root of your project:

    <script lang="ts">
      import { QueryClient, QueryClientProvider } from '@tanstack/svelte-query'
      import Example from './lib/Example.svelte'
    
      const queryClient = new QueryClient()
    </script>
    
    <QueryClientProvider client={queryClient}>
      <Example />
    </QueryClientProvider>
    

    <script lang="ts">
      import { QueryClient, QueryClientProvider } from '@tanstack/svelte-query'
      import Example from './lib/Example.svelte'
    
      const queryClient = new QueryClient()
    </script>
    
    <QueryClientProvider client={queryClient}>
      <Example />
    </QueryClientProvider>
    

Then call any function (e.g. createQuery) from any component:

    <script lang="ts">
      import { createQuery } from '@tanstack/svelte-query'
    
      const query = createQuery(() => ({
        queryKey: ['todos'],
        queryFn: () => fetchTodos(),
      }))
    </script>
    
    <div>
      {#if query.isLoading}
        <p>Loading...</p>
      {:else if query.isError}
        <p>Error: {query.error.message}</p>
      {:else if query.isSuccess}
        {#each query.data as todo}
          <p>{todo.title}</p>
        {/each}
      {/if}
    </div>
    

    <script lang="ts">
      import { createQuery } from '@tanstack/svelte-query'
    
      const query = createQuery(() => ({
        queryKey: ['todos'],
        queryFn: () => fetchTodos(),
      }))
    </script>
    
    <div>
      {#if query.isLoading}
        <p>Loading...</p>
      {:else if query.isError}
        <p>Error: {query.error.message}</p>
      {:else if query.isSuccess}
        {#each query.data as todo}
          <p>{todo.title}</p>
        {/each}
      {/if}
    </div>
    

[](#sveltekit)[SvelteKit](#sveltekit)
-------------------------------------

If you are using SvelteKit, please have a look at [SSR & SvelteKit](https://tanstack.com/query/latest/docs/framework/svelte/ssr).

[](#available-functions)[Available Functions](#available-functions)
-------------------------------------------------------------------

Svelte Query offers useful functions and components that will make managing server state in Svelte apps easier.

*   createQuery
*   createQueries
*   createInfiniteQuery
*   createMutation
*   useQueryClient
*   useIsFetching
*   useIsMutating
*   useMutationState
*   useIsRestoring
*   useHydrate
*   <QueryClientProvider>
*   <HydrationBoundary>

[](#important-differences-between-svelte-query--react-query)[Important Differences between Svelte Query & React Query](#important-differences-between-svelte-query--react-query)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Svelte Query offers an API similar to React Query, but there are some key differences to be mindful of.

*   The arguments to the create\* functions must be wrapped in a function to preserve reactivity.</content>
</page>

<page>
  <title>Installation | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/installation</url>
  <content>You can install Svelte Query via [NPM](https://npmjs.com/).

### [](#npm)[NPM](#npm)

bash

    npm i @tanstack/svelte-query
    

    npm i @tanstack/svelte-query
    

or

bash

    pnpm add @tanstack/svelte-query
    

    pnpm add @tanstack/svelte-query
    

or

bash

    yarn add @tanstack/svelte-query
    

    yarn add @tanstack/svelte-query
    

or

bash

    bun add @tanstack/svelte-query
    

    bun add @tanstack/svelte-query
    

> Wanna give it a spin before you download? Try out the [basic](https://tanstack.com/query/latest/docs/framework/svelte/examples/basic) example!</content>
</page>

<page>
  <title>Vue TanStack Query Basic Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/examples/basic</url>
  <content>    <script lang="ts">
    import { defineComponent, ref } from 'vue'
    import { VueQueryDevtools } from '@tanstack/vue-query-devtools'
    
    import Posts from './Posts.vue'
    import Post from './Post.vue'
    
    export default defineComponent({
      name: 'App',
      components: { Posts, Post, VueQueryDevtools },
      setup() {
        const visitedPosts = ref(new Set())
        const isVisited = (id: number) => visitedPosts.value.has(id)
    
        const postId = ref(-1)
        const setPostId = (id: number) => {
          visitedPosts.value.add(id)
          postId.value = id
        }
    
        return {
          isVisited,
          postId,
          setPostId,
        }
      },
    })
    </script>
    
    <template>
      <h1>Vue Query - Basic</h1>
      <p>
        As you visit the posts below, you will notice them in a loading state the
        first time you load them. However, after you return to this list and click
        on any posts you have already visited again, you will see them load
        instantly and background refresh right before your eyes!
        <strong>
          (You may need to throttle your network speed to simulate longer loading
          sequences)
        </strong>
      </p>
      <Post v-if="postId > -1" :postId="postId" @setPostId="setPostId" />
      <Posts v-else :isVisited="isVisited" @setPostId="setPostId" />
      <VueQueryDevtools />
    </template>
    

    <script lang="ts">
    import { defineComponent, ref } from 'vue'
    import { VueQueryDevtools } from '@tanstack/vue-query-devtools'
    
    import Posts from './Posts.vue'
    import Post from './Post.vue'
    
    export default defineComponent({
      name: 'App',
      components: { Posts, Post, VueQueryDevtools },
      setup() {
        const visitedPosts = ref(new Set())
        const isVisited = (id: number) => visitedPosts.value.has(id)
    
        const postId = ref(-1)
        const setPostId = (id: number) => {
          visitedPosts.value.add(id)
          postId.value = id
        }
    
        return {
          isVisited,
          postId,
          setPostId,
        }
      },
    })
    </script>
    
    <template>
      <h1>Vue Query - Basic</h1>
      <p>
        As you visit the posts below, you will notice them in a loading state the
        first time you load them. However, after you return to this list and click
        on any posts you have already visited again, you will see them load
        instantly and background refresh right before your eyes!
        <strong>
          (You may need to throttle your network speed to simulate longer loading
          sequences)
        </strong>
      </p>
      <Post v-if="postId > -1" :postId="postId" @setPostId="setPostId" />
      <Posts v-else :isVisited="isVisited" @setPostId="setPostId" />
      <VueQueryDevtools />
    </template></content>
</page>

<page>
  <title>Vue TanStack Query Persister Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/examples/persister</url>
  <content>    <script lang="ts">
    import { defineComponent, ref } from 'vue'
    
    import Posts from './Posts.vue'
    import Post from './Post.vue'
    
    export default defineComponent({
      name: 'App',
      components: { Posts, Post },
      setup() {
        const visitedPosts = ref(new Set())
        const isVisited = (id: number) => visitedPosts.value.has(id)
    
        const postId = ref(-1)
        const setPostId = (id: number) => {
          visitedPosts.value.add(id)
          postId.value = id
        }
    
        return {
          isVisited,
          postId,
          setPostId,
        }
      },
    })
    </script>
    
    <template>
      <h1>Vue Query - Basic</h1>
      <p>
        As you visit the posts below, you will notice them in a loading state the
        first time you load them. However, after you return to this list and click
        on any posts you have already visited again, you will see them load
        instantly and background refresh right before your eyes!
        <strong>
          (You may need to throttle your network speed to simulate longer loading
          sequences)
        </strong>
      </p>
      <Post v-if="postId > -1" :postId="postId" @setPostId="setPostId" />
      <Posts v-else :isVisited="isVisited" @setPostId="setPostId" />
    </template>
    

    <script lang="ts">
    import { defineComponent, ref } from 'vue'
    
    import Posts from './Posts.vue'
    import Post from './Post.vue'
    
    export default defineComponent({
      name: 'App',
      components: { Posts, Post },
      setup() {
        const visitedPosts = ref(new Set())
        const isVisited = (id: number) => visitedPosts.value.has(id)
    
        const postId = ref(-1)
        const setPostId = (id: number) => {
          visitedPosts.value.add(id)
          postId.value = id
        }
    
        return {
          isVisited,
          postId,
          setPostId,
        }
      },
    })
    </script>
    
    <template>
      <h1>Vue Query - Basic</h1>
      <p>
        As you visit the posts below, you will notice them in a loading state the
        first time you load them. However, after you return to this list and click
        on any posts you have already visited again, you will see them load
        instantly and background refresh right before your eyes!
        <strong>
          (You may need to throttle your network speed to simulate longer loading
          sequences)
        </strong>
      </p>
      <Post v-if="postId > -1" :postId="postId" @setPostId="setPostId" />
      <Posts v-else :isVisited="isVisited" @setPostId="setPostId" />
    </template></content>
</page>

<page>
  <title>Devtools | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/devtools</url>
  <content>> For Chrome, Firefox, and Edge users: Third-party browser extensions are available for debugging TanStack Query directly in browser DevTools. These provide the same functionality as the framework-specific devtools packages:
> 
> *   [Devtools for Chrome](https://chromewebstore.google.com/detail/tanstack-query-devtools/annajfchloimdhceglpgglpeepfghfai)
> *   [Devtools for Firefox](https://addons.mozilla.org/en-US/firefox/addon/tanstack-query-devtools/)
> *   [Devtools for Edge](https://microsoftedge.microsoft.com/addons/detail/tanstack-query-devtools/edmdpkgkacmjopodhfolmphdenmddobj)

The devtools are a separate package that you need to install:

    npm i @tanstack/svelte-query-devtools
    

    npm i @tanstack/svelte-query-devtools
    

or

    pnpm add @tanstack/svelte-query-devtools
    

    pnpm add @tanstack/svelte-query-devtools
    

or

    yarn add @tanstack/svelte-query-devtools
    

    yarn add @tanstack/svelte-query-devtools
    

or

    bun add @tanstack/svelte-query-devtools
    

    bun add @tanstack/svelte-query-devtools
    

You can import the devtools like this:

    import { SvelteQueryDevtools } from '@tanstack/svelte-query-devtools'
    

    import { SvelteQueryDevtools } from '@tanstack/svelte-query-devtools'
    

[](#floating-mode)[Floating Mode](#floating-mode)
-------------------------------------------------

Floating Mode will mount the devtools as a fixed, floating element in your app and provide a toggle in the corner of the screen to show and hide the devtools. This toggle state will be stored and remembered in localStorage across reloads.

Place the following code as high in your Svelte app as you can. The closer it is to the root of the page, the better it will work!

    <script>
      import { QueryClientProvider } from '@tanstack/svelte-query'
      import { SvelteQueryDevtools } from '@tanstack/svelte-query-devtools'
    </script>
    
    <QueryClientProvider client={queryClient}>
      {/* The rest of your application */}
      <SvelteQueryDevtools />
    </QueryClientProvider>
    

    <script>
      import { QueryClientProvider } from '@tanstack/svelte-query'
      import { SvelteQueryDevtools } from '@tanstack/svelte-query-devtools'
    </script>
    
    <QueryClientProvider client={queryClient}>
      {/* The rest of your application */}
      <SvelteQueryDevtools />
    </QueryClientProvider>
    

### [](#options)[Options](#options)

*   initialIsOpen: boolean
    *   Set this true if you want the dev tools to default to being open
*   buttonPosition?: "top-left" | "top-right" | "bottom-left" | "bottom-right" | "relative"
    *   Defaults to bottom-right
    *   The position of the TanStack logo to open and close the devtools panel
    *   If relative, the button is placed in the location that you render the devtools.
*   position?: "top" | "bottom" | "left" | "right"
    *   Defaults to bottom
    *   The position of the Svelte Query devtools panel
*   client?: QueryClient,
    *   Use this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.
*   errorTypes?: { name: string; initializer: (query: Query) => TError}
    *   Use this to predefine some errors that can be triggered on your queries. Initializer will be called (with the specific query) when that error is toggled on from the UI. It must return an Error.
*   styleNonce?: string
    *   Use this to pass a nonce to the style tag that is added to the document head. This is useful if you are using a Content Security Policy (CSP) nonce to allow inline styles.
*   shadowDOMTarget?: ShadowRoot
    *   Default behavior will apply the devtool's styles to the head tag within the DOM.
    *   Use this to pass a shadow DOM target to the devtools so that the styles will be applied within the shadow DOM instead of within the head tag in the light DOM.</content>
</page>

<page>
  <title>SSR and SvelteKit | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/ssr</url>
  <content>[](#setup)[Setup](#setup)
-------------------------

SvelteKit defaults to rendering routes with SSR. Because of this, you need to disable the query on the server. Otherwise, your query will continue executing on the server asynchronously, even after the HTML has been sent to the client.

The recommended way to achieve this is to use the browser module from SvelteKit in your QueryClient object. This will not disable queryClient.prefetchQuery(), which is used in one of the solutions below.

**src/routes/+layout.svelte**

    <script lang="ts">
      import { browser } from '$app/environment'
      import { QueryClient, QueryClientProvider } from '@tanstack/svelte-query'
    
      const queryClient = new QueryClient({
        defaultOptions: {
          queries: {
            enabled: browser,
          },
        },
      })
    </script>
    
    <QueryClientProvider client={queryClient}>
      <slot />
    </QueryClientProvider>
    

    <script lang="ts">
      import { browser } from '$app/environment'
      import { QueryClient, QueryClientProvider } from '@tanstack/svelte-query'
    
      const queryClient = new QueryClient({
        defaultOptions: {
          queries: {
            enabled: browser,
          },
        },
      })
    </script>
    
    <QueryClientProvider client={queryClient}>
      <slot />
    </QueryClientProvider>
    

[](#prefetching-data)[Prefetching data](#prefetching-data)
----------------------------------------------------------

Svelte Query supports two ways of prefetching data on the server and passing that to the client with SvelteKit.

If you wish to view the ideal SSR setup, please have a look at the [SSR example](https://tanstack.com/query/latest/docs/framework/svelte/examples/ssr).

### [](#using-initialdata)[Using initialData](#using-initialdata)

Together with SvelteKit's [load](https://kit.svelte.dev/docs/load), you can pass the data loaded server-side into createQuery's' initialData option:

**src/routes/+page.ts**

    export async function load() {
      const posts = await getPosts()
      return { posts }
    }
    

    export async function load() {
      const posts = await getPosts()
      return { posts }
    }
    

**src/routes/+page.svelte**

    <script>
      import { createQuery } from '@tanstack/svelte-query'
      import type { PageData } from './$types'
    
      export let data: PageData
    
      const query = createQuery(() => ({
        queryKey: ['posts'],
        queryFn: getPosts,
        initialData: data.posts,
      }))
    </script>
    

    <script>
      import { createQuery } from '@tanstack/svelte-query'
      import type { PageData } from './$types'
    
      export let data: PageData
    
      const query = createQuery(() => ({
        queryKey: ['posts'],
        queryFn: getPosts,
        initialData: data.posts,
      }))
    </script>
    

Pros:

*   This setup is minimal and this can be a quick solution for some cases
*   Works with both +page.ts/+layout.ts and +page.server.ts/+layout.server.ts load functions

Cons:

*   If you are calling createQuery in a component deeper down in the tree you need to pass the initialData down to that point
*   If you are calling createQuery with the same query in multiple locations, you need to pass initialData to all of them
*   There is no way to know at what time the query was fetched on the server, so dataUpdatedAt and determining if the query needs refetching is based on when the page loaded instead

### [](#using-prefetchquery)[Using prefetchQuery](#using-prefetchquery)

Svelte Query supports prefetching queries on the server. Using this setup below, you can fetch data and pass it into QueryClientProvider before it is sent to the user's browser. Therefore, this data is already available in the cache, and no initial fetch occurs client-side.

**src/routes/+layout.ts**

    import { browser } from '$app/environment'
    import { QueryClient } from '@tanstack/svelte-query'
    
    export async function load() {
      const queryClient = new QueryClient({
        defaultOptions: {
          queries: {
            enabled: browser,
          },
        },
      })
    
      return { queryClient }
    }
    

    import { browser } from '$app/environment'
    import { QueryClient } from '@tanstack/svelte-query'
    
    export async function load() {
      const queryClient = new QueryClient({
        defaultOptions: {
          queries: {
            enabled: browser,
          },
        },
      })
    
      return { queryClient }
    }
    

**src/routes/+layout.svelte**

    <script lang="ts">
      import { QueryClientProvider } from '@tanstack/svelte-query'
      import type { LayoutData } from './$types'
    
      export let data: LayoutData
    </script>
    
    <QueryClientProvider client={data.queryClient}>
      <slot />
    </QueryClientProvider>
    

    <script lang="ts">
      import { QueryClientProvider } from '@tanstack/svelte-query'
      import type { LayoutData } from './$types'
    
      export let data: LayoutData
    </script>
    
    <QueryClientProvider client={data.queryClient}>
      <slot />
    </QueryClientProvider>
    

**src/routes/+page.ts**

    export async function load({ parent, fetch }) {
      const { queryClient } = await parent()
    
      // You need to use the SvelteKit fetch function here
      await queryClient.prefetchQuery({
        queryKey: ['posts'],
        queryFn: async () => (await fetch('/api/posts')).json(),
      })
    }
    

    export async function load({ parent, fetch }) {
      const { queryClient } = await parent()
    
      // You need to use the SvelteKit fetch function here
      await queryClient.prefetchQuery({
        queryKey: ['posts'],
        queryFn: async () => (await fetch('/api/posts')).json(),
      })
    }
    

**src/routes/+page.svelte**

    <script lang="ts">
      import { createQuery } from '@tanstack/svelte-query'
    
      // This data is cached by prefetchQuery in +page.ts so no fetch actually happens here
      const query = createQuery(() => ({
        queryKey: ['posts'],
        queryFn: async () => (await fetch('/api/posts')).json(),
      }))
    </script>
    

    <script lang="ts">
      import { createQuery } from '@tanstack/svelte-query'
    
      // This data is cached by prefetchQuery in +page.ts so no fetch actually happens here
      const query = createQuery(() => ({
        queryKey: ['posts'],
        queryFn: async () => (await fetch('/api/posts')).json(),
      }))
    </script>
    

Pros:

*   Server-loaded data can be accessed anywhere without prop-drilling
*   No initial fetch occurs client-side once the page is rendered, as the query cache retains all information about the query was made including dataUpdatedAt

Cons:

*   Requires more files for initial setup
*   Will not work with +page.server.ts/+layout.server.ts load functions (however, APIs which are used with TanStack Query need to be fully exposed to the browser anyway)</content>
</page>

<page>
  <title>TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/migrate-from-v5-to-v6</url>
  <content>While Svelte v5 has legacy compatibility with the stores syntax from Svelte v3/v4, it has been somewhat buggy and unreliable for this adapter. The @tanstack/svelte-query v6 adapter fully migrates to the runes syntax, which relies on signals. This rewrite should also simplify the code required to ensure your query inputs remain reactive.

[](#installation)[Installation](#installation)
----------------------------------------------

Please ensure your project has [Svelte v5.25.0](https://github.com/sveltejs/svelte/releases/tag/svelte%405.25.0) or newer.

Run pnpm add @tanstack/svelte-query@latest (or your package manager's equivalent).

> Note that @tanstack/svelte-query v6 depends on @tanstack/query-core v5.

[](#function-inputs)[Function Inputs](#function-inputs)
-------------------------------------------------------

Like the Angular and Solid adapters, most functions for the Svelte adapter now require options to be provided as a "thunk" (() => options) to provide reactivity. TypeScript will be your friend here and warn you if you're missing this notation.

    - const query = createQuery({  // [!code --]
    + const query = createQuery(() => ({ // [!code ++]
        queryKey: ['todos'],
        queryFn: () => fetchTodos(),
    - }) // [!code --]
    + })) // [!code ++]
    

    - const query = createQuery({  // [!code --]
    + const query = createQuery(() => ({ // [!code ++]
        queryKey: ['todos'],
        queryFn: () => fetchTodos(),
    - }) // [!code --]
    + })) // [!code ++]
    

[](#accessing-properties)[Accessing Properties](#accessing-properties)
----------------------------------------------------------------------

Given the adapter no longer uses stores, it is no longer necessary to prefix with $.

    - {#if $todos.isSuccess} // [!code --]
    + {#if todos.isSuccess} // [!code ++]
        <ul>
    -     {#each $todos.data.items as item} // [!code --]
    +     {#each todos.data.items as item} // [!code ++]
            <li>{item}</li>
          {/each}
        </ul>
      {/if}
    

    - {#if $todos.isSuccess} // [!code --]
    + {#if todos.isSuccess} // [!code ++]
        <ul>
    -     {#each $todos.data.items as item} // [!code --]
    +     {#each todos.data.items as item} // [!code ++]
            <li>{item}</li>
          {/each}
        </ul>
      {/if}
    

[](#reactivity)[Reactivity](#reactivity)
----------------------------------------

You previously needed to do some funky things with stores to achieve reactivity for inputs. This is no longer the case! You don't even need to wrap your query in a $derived.

    - const intervalMs = writable(1000) // [!code --]
    + let intervalMs = $state(1000) // [!code ++]
    
    - const query = createQuery(derived(intervalMs, ($intervalMs) => ({ // [!code --]
    + const query = createQuery(() => ({ // [!code ++]
        queryKey: ['refetch'],
        queryFn: async () => await fetch('/api/data').then((r) => r.json()),
    -   refetchInterval: $intervalMs, // [!code --]
    +   refetchInterval: intervalMs, // [!code ++]
    - }))) // [!code --]
    + })) // [!code ++]
    

    - const intervalMs = writable(1000) // [!code --]
    + let intervalMs = $state(1000) // [!code ++]
    
    - const query = createQuery(derived(intervalMs, ($intervalMs) => ({ // [!code --]
    + const query = createQuery(() => ({ // [!code ++]
        queryKey: ['refetch'],
        queryFn: async () => await fetch('/api/data').then((r) => r.json()),
    -   refetchInterval: $intervalMs, // [!code --]
    +   refetchInterval: intervalMs, // [!code ++]
    - }))) // [!code --]
    + })) // [!code ++]
    

[](#disabling-legacy-mode)[Disabling Legacy Mode](#disabling-legacy-mode)
-------------------------------------------------------------------------

If your component has any stores, it might not properly switch to runes mode. You can ensure your application is using runes in two ways:

### [](#on-a-per-file-basis)[On a per-file basis](#on-a-per-file-basis)

In each .svelte file, once you have migrated to runes, add <svelte:options runes={true} />. This is better for large applications requiring gradual migration.

### [](#on-an-project-wide-basis)[On an project-wide basis](#on-an-project-wide-basis)

In your svelte.config.js, add the following to config:

      compilerOptions: {
        runes: true,
      },
    

      compilerOptions: {
        runes: true,
      },
    

This can be added once you've 100% eradicated stores syntax from your app.</content>
</page>

<page>
  <title>@tanstack/svelte-query | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/index</url>
  <content>API Reference

*   [](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [](https://tanstack.com/query/latest/docs/framework/svelte/reference/index)
*   [
    
    Functions / createQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQuery)
*   [
    
    Functions / createQueries
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQueries)
*   [
    
    Functions / createInfiniteQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createInfiniteQuery)
*   [
    
    Functions / createMutation
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createMutation)
*   [
    
    Functions / useIsFetching
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsFetching)
*   [
    
    Functions / useIsMutating
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsMutating)
*   [
    
    Functions / useMutationState
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useMutationState)
*   [
    
    Functions / queryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/queryOptions)
*   [
    
    Functions / infiniteQueryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/infiniteQueryOptions)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

API Reference

*   [](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [](https://tanstack.com/query/latest/docs/framework/svelte/reference/index)
*   [
    
    Functions / createQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQuery)
*   [
    
    Functions / createQueries
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQueries)
*   [
    
    Functions / createInfiniteQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createInfiniteQuery)
*   [
    
    Functions / createMutation
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createMutation)
*   [
    
    Functions / useIsFetching
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsFetching)
*   [
    
    Functions / useIsMutating
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsMutating)
*   [
    
    Functions / useMutationState
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useMutationState)
*   [
    
    Functions / queryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/queryOptions)
*   [
    
    Functions / infiniteQueryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/infiniteQueryOptions)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)</content>
</page>

<page>
  <title>Vue TanStack Query 2.6 Basic Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/examples/2.6-basic</url>
  <content>    <script lang="ts">
    import { defineComponent, ref } from '@vue/composition-api'
    
    import Posts from './Posts.vue'
    import Post from './Post.vue'
    
    export default defineComponent({
      name: 'App',
      components: { Posts, Post },
      setup() {
        const visitedPosts = ref(new Set())
        const isVisited = (id: number) => visitedPosts.value.has(id)
    
        const postId = ref(-1)
        const setPostId = (id: number) => {
          visitedPosts.value.add(id)
          postId.value = id
        }
    
        return {
          isVisited,
          postId,
          setPostId,
        }
      },
    })
    </script>
    
    <template>
      <div>
        <h1>Vue Query - Basic</h1>
        <p>
          As you visit the posts below, you will notice them in a loading state the
          first time you load them. However, after you return to this list and click
          on any posts you have already visited again, you will see them load
          instantly and background refresh right before your eyes!
          <strong>
            (You may need to throttle your network speed to simulate longer loading
            sequences)
          </strong>
        </p>
        <Post v-if="postId > -1" :postId="postId" @setPostId="setPostId" />
        <Posts v-else :isVisited="isVisited" @setPostId="setPostId" />
      </div>
    </template>
    

    <script lang="ts">
    import { defineComponent, ref } from '@vue/composition-api'
    
    import Posts from './Posts.vue'
    import Post from './Post.vue'
    
    export default defineComponent({
      name: 'App',
      components: { Posts, Post },
      setup() {
        const visitedPosts = ref(new Set())
        const isVisited = (id: number) => visitedPosts.value.has(id)
    
        const postId = ref(-1)
        const setPostId = (id: number) => {
          visitedPosts.value.add(id)
          postId.value = id
        }
    
        return {
          isVisited,
          postId,
          setPostId,
        }
      },
    })
    </script>
    
    <template>
      <div>
        <h1>Vue Query - Basic</h1>
        <p>
          As you visit the posts below, you will notice them in a loading state the
          first time you load them. However, after you return to this list and click
          on any posts you have already visited again, you will see them load
          instantly and background refresh right before your eyes!
          <strong>
            (You may need to throttle your network speed to simulate longer loading
            sequences)
          </strong>
        </p>
        <Post v-if="postId > -1" :postId="postId" @setPostId="setPostId" />
        <Posts v-else :isVisited="isVisited" @setPostId="setPostId" />
      </div>
    </template></content>
</page>

<page>
  <title>createQuery | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQuery</url>
  <content>[](#function-createquery)[Function: createQuery()](#function-createquery)
-------------------------------------------------------------------------

[](#call-signature)[Call Signature](#call-signature)
----------------------------------------------------

    function createQuery<TQueryFnData, TError, TData, TQueryKey>(options, queryClient?): CreateQueryResult<TData, TError>;
    

    function createQuery<TQueryFnData, TError, TData, TQueryKey>(options, queryClient?): CreateQueryResult<TData, TError>;
    

Defined in: [packages/svelte-query/src/createQuery.ts:15](https://github.com/TanStack/query/blob/main/packages/svelte-query/src/createQuery.ts#L15)

### [](#type-parameters)[Type Parameters](#type-parameters)

#### [](#tqueryfndata)[TQueryFnData](#tqueryfndata)

TQueryFnData = unknown

#### [](#terror)[TError](#terror)

TError = Error

#### [](#tdata)[TData](#tdata)

TData = TQueryFnData

#### [](#tquerykey)[TQueryKey](#tquerykey)

TQueryKey _extends_ readonly unknown\[\] = readonly unknown\[\]

### [](#parameters)[Parameters](#parameters)

#### [](#options)[options](#options)

[Accessor](https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/Accessor)<[UndefinedInitialDataOptions](https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/UndefinedInitialDataOptions)<TQueryFnData, TError, TData, TQueryKey\>>

#### [](#queryclient)[queryClient?](#queryclient)

[Accessor](https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/Accessor)<QueryClient\>

### [](#returns)[Returns](#returns)

[CreateQueryResult](https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/CreateQueryResult)<TData, TError\>

[](#call-signature-1)[Call Signature](#call-signature-1)
--------------------------------------------------------

    function createQuery<TQueryFnData, TError, TData, TQueryKey>(options, queryClient?): DefinedCreateQueryResult<TData, TError>;
    

    function createQuery<TQueryFnData, TError, TData, TQueryKey>(options, queryClient?): DefinedCreateQueryResult<TData, TError>;
    

Defined in: [packages/svelte-query/src/createQuery.ts:27](https://github.com/TanStack/query/blob/main/packages/svelte-query/src/createQuery.ts#L27)

### [](#type-parameters-1)[Type Parameters](#type-parameters-1)

#### [](#tqueryfndata-1)[TQueryFnData](#tqueryfndata-1)

TQueryFnData = unknown

#### [](#terror-1)[TError](#terror-1)

TError = Error

#### [](#tdata-1)[TData](#tdata-1)

TData = TQueryFnData

#### [](#tquerykey-1)[TQueryKey](#tquerykey-1)

TQueryKey _extends_ readonly unknown\[\] = readonly unknown\[\]

### [](#parameters-1)[Parameters](#parameters-1)

#### [](#options-1)[options](#options-1)

[Accessor](https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/Accessor)<[DefinedInitialDataOptions](https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/DefinedInitialDataOptions)<TQueryFnData, TError, TData, TQueryKey\>>

#### [](#queryclient-1)[queryClient?](#queryclient-1)

[Accessor](https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/Accessor)<QueryClient\>

### [](#returns-1)[Returns](#returns-1)

[DefinedCreateQueryResult](https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/DefinedCreateQueryResult)<TData, TError\>

[](#call-signature-2)[Call Signature](#call-signature-2)
--------------------------------------------------------

    function createQuery<TQueryFnData, TError, TData, TQueryKey>(options, queryClient?): CreateQueryResult<TData, TError>;
    

    function createQuery<TQueryFnData, TError, TData, TQueryKey>(options, queryClient?): CreateQueryResult<TData, TError>;
    

Defined in: [packages/svelte-query/src/createQuery.ts:39](https://github.com/TanStack/query/blob/main/packages/svelte-query/src/createQuery.ts#L39)

### [](#type-parameters-2)[Type Parameters](#type-parameters-2)

#### [](#tqueryfndata-2)[TQueryFnData](#tqueryfndata-2)

TQueryFnData

#### [](#terror-2)[TError](#terror-2)

TError = Error

#### [](#tdata-2)[TData](#tdata-2)

TData = TQueryFnData

#### [](#tquerykey-2)[TQueryKey](#tquerykey-2)

TQueryKey _extends_ readonly unknown\[\] = readonly unknown\[\]

### [](#parameters-2)[Parameters](#parameters-2)

#### [](#options-2)[options](#options-2)

[Accessor](https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/Accessor)<[CreateQueryOptions](https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/CreateQueryOptions)<TQueryFnData, TError, TData, TQueryKey\>>

#### [](#queryclient-2)[queryClient?](#queryclient-2)

[Accessor](https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/Accessor)<QueryClient\>

### [](#returns-2)[Returns](#returns-2)

[CreateQueryResult](https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/CreateQueryResult)<TData, TError\></content>
</page>

<page>
  <title>createQueries | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQueries</url>
  <content>[](#function-createqueries)[Function: createQueries()](#function-createqueries)
-------------------------------------------------------------------------------

    function createQueries<T, TCombinedResult>(createQueriesOptions, queryClient?): TCombinedResult;
    

    function createQueries<T, TCombinedResult>(createQueriesOptions, queryClient?): TCombinedResult;
    

Defined in: [packages/svelte-query/src/createQueries.svelte.ts:189](https://github.com/TanStack/query/blob/main/packages/svelte-query/src/createQueries.svelte.ts#L189)

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#t)[T](#t)

T _extends_ any\[\]

### [](#tcombinedresult)[TCombinedResult](#tcombinedresult)

TCombinedResult = T _extends_ \[\] ? \[\] : T _extends_ \[Head\] ? \[GetCreateQueryResult<Head\>\] : T _extends_ \[Head, ...Tails\[\]\] ? \[...Tails\[\]\] _extends_ \[\] ? \[\] : \[...Tails\[\]\] _extends_ \[Head\] ? \[GetCreateQueryResult<Head\>, GetCreateQueryResult<Head\>\] : \[...Tails\[\]\] _extends_ \[Head, ...Tails\[\]\] ? \[...Tails\[\]\] _extends_ \[\] ? \[\] : \[...Tails\[\]\] _extends_ \[Head\] ? \[GetCreateQueryResult<Head\>, GetCreateQueryResult<Head\>, GetCreateQueryResult<Head\>\] : \[...Tails\[\]\] _extends_ \[Head, ...Tails\[\]\] ? \[...(...)\[\]\] _extends_ \[\] ? \[\] : ... _extends_ ... ? ... : ... : \[...{ \[K in (...)\]: (...) }\[\]\] : \[...{ \[K in string | number | symbol\]: GetCreateQueryResult<Tails\[K<(...)>\]> }\[\]\] : { \[K in string | number | symbol\]: GetCreateQueryResult<T\[K<K>\]> }

[](#parameters)[Parameters](#parameters)
----------------------------------------

### [](#createqueriesoptions)[createQueriesOptions](#createqueriesoptions)

[Accessor](https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/Accessor)<{ combine?: (result) => TCombinedResult; queries: | readonly \[T _extends_ \[\] ? \[\] : T _extends_ \[Head\] ? \[GetCreateQueryOptionsForCreateQueries<Head\>\] : T _extends_ \[Head, ...Tails\[\]\] ? \[...Tails\[\]\] _extends_ \[\] ? \[\] : \[...Tails\[\]\] _extends_ \[Head\] ? \[GetCreateQueryOptionsForCreateQueries<...>, GetCreateQueryOptionsForCreateQueries<...>\] : \[...(...)\[\]\] _extends_ \[..., ...(...)\[\]\] ? ... _extends_ ... ? ... : ... : ... _extends_ ... ? ... : ... : readonly unknown\[\] _extends_ T ? T : T _extends_ CreateQueryOptionsForCreateQueries<..., ..., ..., ...>\[\] ? CreateQueryOptionsForCreateQueries<..., ..., ..., ...>\[\] : CreateQueryOptionsForCreateQueries<..., ..., ..., ...>\[\]\] | readonly \[{ \[K in string | number | symbol\]: GetCreateQueryOptionsForCreateQueries<T\[K<K>\]> }\]; }>

### [](#queryclient)[queryClient?](#queryclient)

[Accessor](https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/Accessor)<QueryClient\>

[](#returns)[Returns](#returns)
-------------------------------

TCombinedResult</content>
</page>

<page>
  <title>createInfiniteQuery | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createInfiniteQuery</url>
  <content>[](#function-createinfinitequery)[Function: createInfiniteQuery()](#function-createinfinitequery)
-------------------------------------------------------------------------------------------------

    function createInfiniteQuery<TQueryFnData, TError, TData, TQueryKey, TPageParam>(options, queryClient?): CreateInfiniteQueryResult<TData, TError>;
    

    function createInfiniteQuery<TQueryFnData, TError, TData, TQueryKey, TPageParam>(options, queryClient?): CreateInfiniteQueryResult<TData, TError>;
    

Defined in: [packages/svelte-query/src/createInfiniteQuery.ts:16](https://github.com/TanStack/query/blob/main/packages/svelte-query/src/createInfiniteQuery.ts#L16)

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tqueryfndata)[TQueryFnData](#tqueryfndata)

TQueryFnData

### [](#terror)[TError](#terror)

TError = Error

### [](#tdata)[TData](#tdata)

TData = InfiniteData<TQueryFnData, unknown\>

### [](#tquerykey)[TQueryKey](#tquerykey)

TQueryKey _extends_ readonly unknown\[\] = readonly unknown\[\]

### [](#tpageparam)[TPageParam](#tpageparam)

TPageParam = unknown

[](#parameters)[Parameters](#parameters)
----------------------------------------

### [](#options)[options](#options)

[Accessor](https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/Accessor)<[CreateInfiniteQueryOptions](https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/CreateInfiniteQueryOptions)<TQueryFnData, TError, TData, TQueryKey, TPageParam\>>

### [](#queryclient)[queryClient?](#queryclient)

[Accessor](https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/Accessor)<QueryClient\>

[](#returns)[Returns](#returns)
-------------------------------

[CreateInfiniteQueryResult](https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/CreateInfiniteQueryResult)<TData, TError\></content>
</page>

<page>
  <title>createMutation | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createMutation</url>
  <content>[](#function-createmutation)[Function: createMutation()](#function-createmutation)
----------------------------------------------------------------------------------

    function createMutation<TData, TError, TVariables, TContext>(options, queryClient?): CreateMutationResult<TData, TError, TVariables, TContext>;
    

    function createMutation<TData, TError, TVariables, TContext>(options, queryClient?): CreateMutationResult<TData, TError, TVariables, TContext>;
    

Defined in: [packages/svelte-query/src/createMutation.svelte.ts:17](https://github.com/TanStack/query/blob/main/packages/svelte-query/src/createMutation.svelte.ts#L17)

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tdata)[TData](#tdata)

TData = unknown

### [](#terror)[TError](#terror)

TError = Error

### [](#tvariables)[TVariables](#tvariables)

TVariables = void

### [](#tcontext)[TContext](#tcontext)

TContext = unknown

[](#parameters)[Parameters](#parameters)
----------------------------------------

### [](#options)[options](#options)

[Accessor](https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/Accessor)<[CreateMutationOptions](https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/CreateMutationOptions)<TData, TError, TVariables, TContext\>>

A function that returns mutation options

### [](#queryclient)[queryClient?](#queryclient)

[Accessor](https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/Accessor)<QueryClient\>

Custom query client which overrides provider

[](#returns)[Returns](#returns)
-------------------------------

[CreateMutationResult](https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/CreateMutationResult)<TData, TError, TVariables, TContext\></content>
</page>

<page>
  <title>useIsFetching | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsFetching</url>
  <content>ts

    function useIsFetching(filters?, queryClient?): ReactiveValue<number>;
    

    function useIsFetching(filters?, queryClient?): ReactiveValue<number>;</content>
</page>

<page>
  <title>Vue TanStack Query Nuxt3 Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/vue/examples/nuxt3</url>
  <content>    # Nuxt 3 Minimal Starter
    
    We recommend to look at the [documentation](https://v3.nuxtjs.org).
    
    ## Setup
    
    Make sure to install the dependencies
    
    ```bash
    yarn install
    ```
    
    ## Development
    
    Start the development server on http://localhost:3000
    
    ```bash
    yarn dev
    ```
    
    ## Production
    
    Build the application for production:
    
    ```bash
    yarn build
    ```
    
    Checkout the [deployment documentation](https://v3.nuxtjs.org/docs/deployment).
    

    # Nuxt 3 Minimal Starter
    
    We recommend to look at the [documentation](https://v3.nuxtjs.org).
    
    ## Setup
    
    Make sure to install the dependencies
    
    ```bash
    yarn install
    ```
    
    ## Development
    
    Start the development server on http://localhost:3000
    
    ```bash
    yarn dev
    ```
    
    ## Production
    
    Build the application for production:
    
    ```bash
    yarn build
    ```
    
    Checkout the [deployment documentation](https://v3.nuxtjs.org/docs/deployment).</content>
</page>

<page>
  <title>useIsMutating | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsMutating</url>
  <content>[](#function-useismutating)[Function: useIsMutating()](#function-useismutating)
-------------------------------------------------------------------------------

ts

    function useIsMutating(filters?, queryClient?): ReactiveValue<number>;
    

    function useIsMutating(filters?, queryClient?): ReactiveValue<number>;
    

Defined in: [packages/svelte-query/src/useIsMutating.svelte.ts:5](https://github.com/TanStack/query/blob/main/packages/svelte-query/src/useIsMutating.svelte.ts#L5)

[](#parameters)[Parameters](#parameters)
----------------------------------------

### [](#filters)[filters?](#filters)

MutationFilters<unknown, Error, unknown, unknown\>

### [](#queryclient)[queryClient?](#queryclient)

QueryClient

[](#returns)[Returns](#returns)
-------------------------------

ReactiveValue<number\></content>
</page>

<page>
  <title>useMutationState | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useMutationState</url>
  <content>[](#function-usemutationstate)[Function: useMutationState()](#function-usemutationstate)
----------------------------------------------------------------------------------------

ts

    function useMutationState<TResult>(options, queryClient?): TResult[];
    

    function useMutationState<TResult>(options, queryClient?): TResult[];
    

Defined in: [packages/svelte-query/src/useMutationState.svelte.ts:22](https://github.com/TanStack/query/blob/main/packages/svelte-query/src/useMutationState.svelte.ts#L22)

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tresult)[TResult](#tresult)

TResult = MutationState<unknown, Error, unknown, unknown\>

[](#parameters)[Parameters](#parameters)
----------------------------------------

### [](#options)[options](#options)

[MutationStateOptions](https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/MutationStateOptions)<TResult\> = {}

### [](#queryclient)[queryClient?](#queryclient)

QueryClient

[](#returns)[Returns](#returns)
-------------------------------

TResult\[\]</content>
</page>

<page>
  <title>queryOptions | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/queryOptions</url>
  <content>[](#function-queryoptions)[Function: queryOptions()](#function-queryoptions)
----------------------------------------------------------------------------

[](#call-signature)[Call Signature](#call-signature)
----------------------------------------------------

    function queryOptions<TQueryFnData, TError, TData, TQueryKey>(options): CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey> & object & object;
    

    function queryOptions<TQueryFnData, TError, TData, TQueryKey>(options): CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey> & object & object;
    

Defined in: [packages/svelte-query/src/queryOptions.ts:30](https://github.com/TanStack/query/blob/main/packages/svelte-query/src/queryOptions.ts#L30)

### [](#type-parameters)[Type Parameters](#type-parameters)

#### [](#tqueryfndata)[TQueryFnData](#tqueryfndata)

TQueryFnData = unknown

#### [](#terror)[TError](#terror)

TError = Error

#### [](#tdata)[TData](#tdata)

TData = TQueryFnData

#### [](#tquerykey)[TQueryKey](#tquerykey)

TQueryKey _extends_ readonly unknown\[\] = readonly unknown\[\]

### [](#parameters)[Parameters](#parameters)

#### [](#options)[options](#options)

[DefinedInitialDataOptions](https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/DefinedInitialDataOptions)<TQueryFnData, TError, TData, TQueryKey\>

### [](#returns)[Returns](#returns)

[CreateQueryOptions](https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/CreateQueryOptions)<TQueryFnData, TError, TData, TQueryKey\> & object & object

[](#call-signature-1)[Call Signature](#call-signature-1)
--------------------------------------------------------

    function queryOptions<TQueryFnData, TError, TData, TQueryKey>(options): CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey> & object & object;
    

    function queryOptions<TQueryFnData, TError, TData, TQueryKey>(options): CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey> & object & object;
    

Defined in: [packages/svelte-query/src/queryOptions.ts:41](https://github.com/TanStack/query/blob/main/packages/svelte-query/src/queryOptions.ts#L41)

### [](#type-parameters-1)[Type Parameters](#type-parameters-1)

#### [](#tqueryfndata-1)[TQueryFnData](#tqueryfndata-1)

TQueryFnData = unknown

#### [](#terror-1)[TError](#terror-1)

TError = Error

#### [](#tdata-1)[TData](#tdata-1)

TData = TQueryFnData

#### [](#tquerykey-1)[TQueryKey](#tquerykey-1)

TQueryKey _extends_ readonly unknown\[\] = readonly unknown\[\]

### [](#parameters-1)[Parameters](#parameters-1)

#### [](#options-1)[options](#options-1)

[UndefinedInitialDataOptions](https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/UndefinedInitialDataOptions)<TQueryFnData, TError, TData, TQueryKey\>

### [](#returns-1)[Returns](#returns-1)

[CreateQueryOptions](https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/CreateQueryOptions)<TQueryFnData, TError, TData, TQueryKey\> & object & object</content>
</page>

<page>
  <title>infiniteQueryOptions | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/infiniteQueryOptions</url>
  <content>[](#function-infinitequeryoptions)[Function: infiniteQueryOptions()](#function-infinitequeryoptions)
----------------------------------------------------------------------------------------------------

    function infiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>(options): CreateInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>;
    

    function infiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>(options): CreateInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>;
    

Defined in: [packages/svelte-query/src/infiniteQueryOptions.ts:4](https://github.com/TanStack/query/blob/main/packages/svelte-query/src/infiniteQueryOptions.ts#L4)

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tqueryfndata)[TQueryFnData](#tqueryfndata)

TQueryFnData

### [](#terror)[TError](#terror)

TError = Error

### [](#tdata)[TData](#tdata)

TData = InfiniteData<TQueryFnData, unknown\>

### [](#tquerykey)[TQueryKey](#tquerykey)

TQueryKey _extends_ readonly unknown\[\] = readonly unknown\[\]

### [](#tpageparam)[TPageParam](#tpageparam)

TPageParam = unknown

[](#parameters)[Parameters](#parameters)
----------------------------------------

### [](#options)[options](#options)

[CreateInfiniteQueryOptions](https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/CreateInfiniteQueryOptions)<TQueryFnData, TError, TData, TQueryKey, TPageParam\>

[](#returns)[Returns](#returns)
-------------------------------

[CreateInfiniteQueryOptions](https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/CreateInfiniteQueryOptions)<TQueryFnData, TError, TData, TQueryKey, TPageParam\></content>
</page>

<page>
  <title>Svelte TanStack Query Simple Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/examples/simple</url>
  <content>    <script lang="ts">
      import { QueryClientProvider, QueryClient } from '@tanstack/svelte-query'
      import { SvelteQueryDevtools } from '@tanstack/svelte-query-devtools'
      import Simple from './lib/Simple.svelte'
    
      const queryClient = new QueryClient()
    </script>
    
    <QueryClientProvider client={queryClient}>
      <main>
        <Simple />
      </main>
      <SvelteQueryDevtools />
    </QueryClientProvider>
    

    <script lang="ts">
      import { QueryClientProvider, QueryClient } from '@tanstack/svelte-query'
      import { SvelteQueryDevtools } from '@tanstack/svelte-query-devtools'
      import Simple from './lib/Simple.svelte'
    
      const queryClient = new QueryClient()
    </script>
    
    <QueryClientProvider client={queryClient}>
      <main>
        <Simple />
      </main>
      <SvelteQueryDevtools />
    </QueryClientProvider></content>
</page>

<page>
  <title>Svelte TanStack Query Ssr Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/examples/ssr</url>
  <content>    # create-svelte
    
    Everything you need to build a Svelte project, powered by [`create-svelte`](https://github.com/sveltejs/kit/tree/master/packages/create-svelte).
    
    ## Creating a project
    
    If you're seeing this, you've probably already done this step. Congrats!
    
    ```bash
    # create a new project in the current directory
    npm create svelte@latest
    
    # create a new project in my-app
    npm create svelte@latest my-app
    ```
    
    ## Developing
    
    Once you've created a project and installed dependencies with `npm install` (or `pnpm install` or `yarn` or `bun install`), start a development server:
    
    ```bash
    npm run dev
    
    # or start the server and open the app in a new browser tab
    npm run dev -- --open
    ```
    
    ## Building
    
    To create a production version of your app:
    
    ```bash
    npm run build
    ```
    
    You can preview the production build with `npm run preview`.
    
    > To deploy your app, you may need to install an [adapter](https://kit.svelte.dev/docs/adapters) for your target environment.
    

    # create-svelte
    
    Everything you need to build a Svelte project, powered by [`create-svelte`](https://github.com/sveltejs/kit/tree/master/packages/create-svelte).
    
    ## Creating a project
    
    If you're seeing this, you've probably already done this step. Congrats!
    
    ```bash
    # create a new project in the current directory
    npm create svelte@latest
    
    # create a new project in my-app
    npm create svelte@latest my-app
    ```
    
    ## Developing
    
    Once you've created a project and installed dependencies with `npm install` (or `pnpm install` or `yarn` or `bun install`), start a development server:
    
    ```bash
    npm run dev
    
    # or start the server and open the app in a new browser tab
    npm run dev -- --open
    ```
    
    ## Building
    
    To create a production version of your app:
    
    ```bash
    npm run build
    ```
    
    You can preview the production build with `npm run preview`.
    
    > To deploy your app, you may need to install an [adapter](https://kit.svelte.dev/docs/adapters) for your target environment.</content>
</page>

<page>
  <title>Svelte TanStack Query Basic Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/examples/basic</url>
  <content>    # create-svelte
    
    Everything you need to build a Svelte project, powered by [`create-svelte`](https://github.com/sveltejs/kit/tree/master/packages/create-svelte).
    
    ## Creating a project
    
    If you're seeing this, you've probably already done this step. Congrats!
    
    ```bash
    # create a new project in the current directory
    npm create svelte@latest
    
    # create a new project in my-app
    npm create svelte@latest my-app
    ```
    
    ## Developing
    
    Once you've created a project and installed dependencies with `npm install` (or `pnpm install` or `yarn` or `bun install`), start a development server:
    
    ```bash
    npm run dev
    
    # or start the server and open the app in a new browser tab
    npm run dev -- --open
    ```
    
    ## Building
    
    To create a production version of your app:
    
    ```bash
    npm run build
    ```
    
    You can preview the production build with `npm run preview`.
    
    > To deploy your app, you may need to install an [adapter](https://kit.svelte.dev/docs/adapters) for your target environment.
    

    # create-svelte
    
    Everything you need to build a Svelte project, powered by [`create-svelte`](https://github.com/sveltejs/kit/tree/master/packages/create-svelte).
    
    ## Creating a project
    
    If you're seeing this, you've probably already done this step. Congrats!
    
    ```bash
    # create a new project in the current directory
    npm create svelte@latest
    
    # create a new project in my-app
    npm create svelte@latest my-app
    ```
    
    ## Developing
    
    Once you've created a project and installed dependencies with `npm install` (or `pnpm install` or `yarn` or `bun install`), start a development server:
    
    ```bash
    npm run dev
    
    # or start the server and open the app in a new browser tab
    npm run dev -- --open
    ```
    
    ## Building
    
    To create a production version of your app:
    
    ```bash
    npm run build
    ```
    
    You can preview the production build with `npm run preview`.
    
    > To deploy your app, you may need to install an [adapter](https://kit.svelte.dev/docs/adapters) for your target environment.</content>
</page>

<page>
  <title>Svelte TanStack Query Playground Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/examples/playground</url>
  <content>    <script lang="ts">
      import { useQueryClient } from '@tanstack/svelte-query'
      import TodosList from './TodosList.svelte'
      import EditTodo from './EditTodo.svelte'
      import AddTodo from './AddTodo.svelte'
      import { views, editingIndex } from '../lib/stores.svelte'
    
      const queryClient = useQueryClient()
    </script>
    
    <div>
      <div>
        <button onclick={() => queryClient.invalidateQueries()}>
          Force Refetch All
        </button>
      </div>
      <br />
      <hr />
    
      {#each views.value as view}
        <div>
          <TodosList initialFilter={view} />
          <br />
        </div>
      {/each}
    
      <button
        onclick={() => {
          views.value.push('')
        }}
      >
        Add Filter List
      </button>
      <hr />
    
      {#if editingIndex.value !== null}
        <EditTodo />
        <hr />
      {/if}
    
      <AddTodo />
    </div>
    

    <script lang="ts">
      import { useQueryClient } from '@tanstack/svelte-query'
      import TodosList from './TodosList.svelte'
      import EditTodo from './EditTodo.svelte'
      import AddTodo from './AddTodo.svelte'
      import { views, editingIndex } from '../lib/stores.svelte'
    
      const queryClient = useQueryClient()
    </script>
    
    <div>
      <div>
        <button onclick={() => queryClient.invalidateQueries()}>
          Force Refetch All
        </button>
      </div>
      <br />
      <hr />
    
      {#each views.value as view}
        <div>
          <TodosList initialFilter={view} />
          <br />
        </div>
      {/each}
    
      <button
        onclick={() => {
          views.value.push('')
        }}
      >
        Add Filter List
      </button>
      <hr />
    
      {#if editingIndex.value !== null}
        <EditTodo />
        <hr />
      {/if}
    
      <AddTodo />
    </div></content>
</page>

<page>
  <title>Svelte TanStack Query Load More Infinite Scroll Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/examples/load-more-infinite-scroll</url>
  <content>    # create-svelte
    
    Everything you need to build a Svelte project, powered by [`create-svelte`](https://github.com/sveltejs/kit/tree/master/packages/create-svelte).
    
    ## Creating a project
    
    If you're seeing this, you've probably already done this step. Congrats!
    
    ```bash
    # create a new project in the current directory
    npm create svelte@latest
    
    # create a new project in my-app
    npm create svelte@latest my-app
    ```
    
    ## Developing
    
    Once you've created a project and installed dependencies with `npm install` (or `pnpm install` or `yarn` or `bun install`), start a development server:
    
    ```bash
    npm run dev
    
    # or start the server and open the app in a new browser tab
    npm run dev -- --open
    ```
    
    ## Building
    
    To create a production version of your app:
    
    ```bash
    npm run build
    ```
    
    You can preview the production build with `npm run preview`.
    
    > To deploy your app, you may need to install an [adapter](https://kit.svelte.dev/docs/adapters) for your target environment.
    

    # create-svelte
    
    Everything you need to build a Svelte project, powered by [`create-svelte`](https://github.com/sveltejs/kit/tree/master/packages/create-svelte).
    
    ## Creating a project
    
    If you're seeing this, you've probably already done this step. Congrats!
    
    ```bash
    # create a new project in the current directory
    npm create svelte@latest
    
    # create a new project in my-app
    npm create svelte@latest my-app
    ```
    
    ## Developing
    
    Once you've created a project and installed dependencies with `npm install` (or `pnpm install` or `yarn` or `bun install`), start a development server:
    
    ```bash
    npm run dev
    
    # or start the server and open the app in a new browser tab
    npm run dev -- --open
    ```
    
    ## Building
    
    To create a production version of your app:
    
    ```bash
    npm run build
    ```
    
    You can preview the production build with `npm run preview`.
    
    > To deploy your app, you may need to install an [adapter](https://kit.svelte.dev/docs/adapters) for your target environment.</content>
</page>

<page>
  <title>Svelte TanStack Query Auto Refetching Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/examples/auto-refetching</url>
  <content>    # create-svelte
    
    Everything you need to build a Svelte project, powered by [`create-svelte`](https://github.com/sveltejs/kit/tree/master/packages/create-svelte).
    
    ## Creating a project
    
    If you're seeing this, you've probably already done this step. Congrats!
    
    ```bash
    # create a new project in the current directory
    npm create svelte@latest
    
    # create a new project in my-app
    npm create svelte@latest my-app
    ```
    
    ## Developing
    
    Once you've created a project and installed dependencies with `npm install` (or `pnpm install` or `yarn` or `bun install`), start a development server:
    
    ```bash
    npm run dev
    
    # or start the server and open the app in a new browser tab
    npm run dev -- --open
    ```
    
    ## Building
    
    To create a production version of your app:
    
    ```bash
    npm run build
    ```
    
    You can preview the production build with `npm run preview`.
    
    > To deploy your app, you may need to install an [adapter](https://kit.svelte.dev/docs/adapters) for your target environment.
    

    # create-svelte
    
    Everything you need to build a Svelte project, powered by [`create-svelte`](https://github.com/sveltejs/kit/tree/master/packages/create-svelte).
    
    ## Creating a project
    
    If you're seeing this, you've probably already done this step. Congrats!
    
    ```bash
    # create a new project in the current directory
    npm create svelte@latest
    
    # create a new project in my-app
    npm create svelte@latest my-app
    ```
    
    ## Developing
    
    Once you've created a project and installed dependencies with `npm install` (or `pnpm install` or `yarn` or `bun install`), start a development server:
    
    ```bash
    npm run dev
    
    # or start the server and open the app in a new browser tab
    npm run dev -- --open
    ```
    
    ## Building
    
    To create a production version of your app:
    
    ```bash
    npm run build
    ```
    
    You can preview the production build with `npm run preview`.
    
    > To deploy your app, you may need to install an [adapter](https://kit.svelte.dev/docs/adapters) for your target environment.</content>
</page>

<page>
  <title>Overview | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/overview</url>
  <content>> IMPORTANT: This library is currently in an experimental stage. This means that breaking changes will happen in minor AND patch releases. Upgrade carefully. If you use this in production while in experimental stage, please lock your version to a patch-level version to avoid unexpected breaking changes.

The @tanstack/angular-query-experimental package offers a 1st-class API for using TanStack Query via Angular.

[](#feedback-welcome)[Feedback welcome!](#feedback-welcome)
-----------------------------------------------------------

We are in the process of getting to a stable API for TanStack Query on Angular. If you have any feedback, please contact us at the [TanStack Discord](https://tlinz.com/discord) server or [visit this discussion](https://github.com/TanStack/query/discussions/6293) on Github.

[](#supported-angular-versions)[Supported Angular Versions](#supported-angular-versions)
----------------------------------------------------------------------------------------

TanStack Query is compatible with Angular v16 and higher.

TanStack Query (FKA React Query) is often described as the missing data-fetching library for web applications, but in more technical terms, it makes **fetching, caching, synchronizing and updating server state** in your web applications a breeze.

[](#motivation)[Motivation](#motivation)
----------------------------------------

Most core web frameworks **do not** come with an opinionated way of fetching or updating data in a holistic way. Because of this developers end up building either meta-frameworks which encapsulate strict opinions about data-fetching, or they invent their own ways of fetching data. This usually means cobbling together component-based state and side-effects, or using more general purpose state management libraries to store and provide asynchronous data throughout their apps.

While most traditional state management libraries are great for working with client state, they are **not so great at working with async or server state**. This is because **server state is totally different**. For starters, server state:

*   Is persisted remotely in a location you may not control or own
*   Requires asynchronous APIs for fetching and updating
*   Implies shared ownership and can be changed by other people without your knowledge
*   Can potentially become "out of date" in your applications if you're not careful

Once you grasp the nature of server state in your application, **even more challenges will arise** as you go, for example:

*   Caching... (possibly the hardest thing to do in programming)
*   Deduping multiple requests for the same data into a single request
*   Updating "out of date" data in the background
*   Knowing when data is "out of date"
*   Reflecting updates to data as quickly as possible
*   Performance optimizations like pagination and lazy loading data
*   Managing memory and garbage collection of server state
*   Memoizing query results with structural sharing

If you're not overwhelmed by that list, then that must mean that you've probably solved all of your server state problems already and deserve an award. However, if you are like a vast majority of people, you either have yet to tackle all or most of these challenges and we're only scratching the surface!

TanStack Query is hands down one of the _best_ libraries for managing server state. It works amazingly well **out-of-the-box, with zero-config, and can be customized** to your liking as your application grows.

TanStack Query allows you to defeat and overcome the tricky challenges and hurdles of _server state_ and control your app data before it starts to control you.

On a more technical note, TanStack Query will likely:

*   Help you remove **many** lines of complicated and misunderstood code from your application and replace with just a handful of lines of Angular Query logic.
*   Make your application more maintainable and easier to build new features without worrying about wiring up new server state data sources
*   Have a direct impact on your end-users by making your application feel faster and more responsive than ever before.
*   Potentially help you save on bandwidth and increase memory performance

[](#enough-talk-show-me-some-code-already)[Enough talk, show me some code already!](#enough-talk-show-me-some-code-already)
---------------------------------------------------------------------------------------------------------------------------

In the example below, you can see TanStack Query in its most basic and simple form being used to fetch the GitHub stats for the TanStack Query GitHub project itself:

[Open in StackBlitz](https://stackblitz.com/github/TanStack/query/tree/main/examples/angular/simple)

    import { ChangeDetectionStrategy, Component, inject } from '@angular/core'
    import { HttpClient } from '@angular/common/http'
    import { CommonModule } from '@angular/common'
    import { injectQuery } from '@tanstack/angular-query-experimental'
    import { lastValueFrom } from 'rxjs'
    
    @Component({
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: 'simple-example',
      template: `
        @if (query.isPending()) {
          Loading...
        }
        @if (query.error()) {
          An error has occurred: {{ query.error().message }}
        }
        @if (query.data(); as data) {
          <h1>{{ data.name }}</h1>
          <p>{{ data.description }}</p>
          <strong>üëÄ {{ data.subscribers_count }}</strong>
          <strong>‚ú® {{ data.stargazers_count }}</strong>
          <strong>üç¥ {{ data.forks_count }}</strong>
        }
      `
    })
    export class SimpleExampleComponent {
      http = inject(HttpClient)
    
      query = injectQuery(() => ({
        queryKey: ['repoData'],
        queryFn: () =>
          lastValueFrom(
            this.http.get<Response>('https://api.github.com/repos/tanstack/query'),
          ),
      }))
    }
    
    interface Response {
      name: string
      description: string
      subscribers_count: number
      stargazers_count: number
      forks_count: number
    }
    

    import { ChangeDetectionStrategy, Component, inject } from '@angular/core'
    import { HttpClient } from '@angular/common/http'
    import { CommonModule } from '@angular/common'
    import { injectQuery } from '@tanstack/angular-query-experimental'
    import { lastValueFrom } from 'rxjs'
    
    @Component({
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: 'simple-example',
      template: `
        @if (query.isPending()) {
          Loading...
        }
        @if (query.error()) {
          An error has occurred: {{ query.error().message }}
        }
        @if (query.data(); as data) {
          <h1>{{ data.name }}</h1>
          <p>{{ data.description }}</p>
          <strong>üëÄ {{ data.subscribers_count }}</strong>
          <strong>‚ú® {{ data.stargazers_count }}</strong>
          <strong>üç¥ {{ data.forks_count }}</strong>
        }
      `
    })
    export class SimpleExampleComponent {
      http = inject(HttpClient)
    
      query = injectQuery(() => ({
        queryKey: ['repoData'],
        queryFn: () =>
          lastValueFrom(
            this.http.get<Response>('https://api.github.com/repos/tanstack/query'),
          ),
      }))
    }
    
    interface Response {
      name: string
      description: string
      subscribers_count: number
      stargazers_count: number
      forks_count: number
    }
    

[](#you-talked-me-into-it-so-what-now)[You talked me into it, so what now?](#you-talked-me-into-it-so-what-now)
---------------------------------------------------------------------------------------------------------------

*   Learn TanStack Query at your own pace with our amazingly thorough [Walkthrough Guide](https://tanstack.com/query/latest/docs/framework/angular/installation) and [API Reference](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectQuery)</content>
</page>

<page>
  <title>Svelte TanStack Query Optimistic Updates Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/examples/optimistic-updates</url>
  <content>    # create-svelte
    
    Everything you need to build a Svelte project, powered by [`create-svelte`](https://github.com/sveltejs/kit/tree/master/packages/create-svelte).
    
    ## Creating a project
    
    If you're seeing this, you've probably already done this step. Congrats!
    
    ```bash
    # create a new project in the current directory
    npm create svelte@latest
    
    # create a new project in my-app
    npm create svelte@latest my-app
    ```
    
    ## Developing
    
    Once you've created a project and installed dependencies with `npm install` (or `pnpm install` or `yarn` or `bun install`), start a development server:
    
    ```bash
    npm run dev
    
    # or start the server and open the app in a new browser tab
    npm run dev -- --open
    ```
    
    ## Building
    
    To create a production version of your app:
    
    ```bash
    npm run build
    ```
    
    You can preview the production build with `npm run preview`.
    
    > To deploy your app, you may need to install an [adapter](https://kit.svelte.dev/docs/adapters) for your target environment.
    

    # create-svelte
    
    Everything you need to build a Svelte project, powered by [`create-svelte`](https://github.com/sveltejs/kit/tree/master/packages/create-svelte).
    
    ## Creating a project
    
    If you're seeing this, you've probably already done this step. Congrats!
    
    ```bash
    # create a new project in the current directory
    npm create svelte@latest
    
    # create a new project in my-app
    npm create svelte@latest my-app
    ```
    
    ## Developing
    
    Once you've created a project and installed dependencies with `npm install` (or `pnpm install` or `yarn` or `bun install`), start a development server:
    
    ```bash
    npm run dev
    
    # or start the server and open the app in a new browser tab
    npm run dev -- --open
    ```
    
    ## Building
    
    To create a production version of your app:
    
    ```bash
    npm run build
    ```
    
    You can preview the production build with `npm run preview`.
    
    > To deploy your app, you may need to install an [adapter](https://kit.svelte.dev/docs/adapters) for your target environment.</content>
</page>

<page>
  <title>Installation | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/installation</url>
  <content>> IMPORTANT: This library is currently in an experimental stage. This means that breaking changes will happen in minor AND patch releases. Upgrade carefully. If you use this in production while in experimental stage, please lock your version to a patch-level version to avoid unexpected breaking changes.

### [](#npm)[NPM](#npm)

_Angular Query is compatible with Angular v16 and higher_

    npm i @tanstack/angular-query-experimental
    

    npm i @tanstack/angular-query-experimental
    

or

    pnpm add @tanstack/angular-query-experimental
    

    pnpm add @tanstack/angular-query-experimental
    

or

    yarn add @tanstack/angular-query-experimental
    

    yarn add @tanstack/angular-query-experimental
    

or

    bun add @tanstack/angular-query-experimental
    

    bun add @tanstack/angular-query-experimental
    

> Wanna give it a spin before you download? Try out the [simple](https://tanstack.com/query/latest/docs/framework/angular/examples/simple) or [basic](https://tanstack.com/query/latest/docs/framework/angular/examples/basic) examples!</content>
</page>

<page>
  <title>Quick Start | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/quick-start</url>
  <content>> IMPORTANT: This library is currently in an experimental stage. This means that breaking changes will happen in minor AND patch releases. Upgrade carefully. If you use this in production while in experimental stage, please lock your version to a patch-level version to avoid unexpected breaking changes.

If you're looking for a fully functioning example, please have a look at our [basic codesandbox example](https://tanstack.com/query/latest/docs/framework/angular/examples/basic)

### [](#provide-the-client-to-your-app)[Provide the client to your App](#provide-the-client-to-your-app)

    import { provideHttpClient } from '@angular/common/http'
    import {
      provideTanStackQuery,
      QueryClient,
    } from '@tanstack/angular-query-experimental'
    
    bootstrapApplication(AppComponent, {
      providers: [provideHttpClient(), provideTanStackQuery(new QueryClient())],
    })
    

    import { provideHttpClient } from '@angular/common/http'
    import {
      provideTanStackQuery,
      QueryClient,
    } from '@tanstack/angular-query-experimental'
    
    bootstrapApplication(AppComponent, {
      providers: [provideHttpClient(), provideTanStackQuery(new QueryClient())],
    })
    

or in a NgModule-based app

    import { provideHttpClient } from '@angular/common/http'
    import {
      provideTanStackQuery,
      QueryClient,
    } from '@tanstack/angular-query-experimental'
    
    @NgModule({
      declarations: [AppComponent],
      imports: [BrowserModule],
      providers: [provideTanStackQuery(new QueryClient())],
      bootstrap: [AppComponent],
    })
    export class AppModule {}
    

    import { provideHttpClient } from '@angular/common/http'
    import {
      provideTanStackQuery,
      QueryClient,
    } from '@tanstack/angular-query-experimental'
    
    @NgModule({
      declarations: [AppComponent],
      imports: [BrowserModule],
      providers: [provideTanStackQuery(new QueryClient())],
      bootstrap: [AppComponent],
    })
    export class AppModule {}
    

### [](#component-with-query-and-mutation)[Component with query and mutation](#component-with-query-and-mutation)

    import { Component, Injectable, inject } from '@angular/core'
    import { HttpClient } from '@angular/common/http'
    import { lastValueFrom } from 'rxjs'
    
    import {
      injectMutation,
      injectQuery,
      QueryClient
    } from '@tanstack/angular-query-experimental'
    
    @Component({
      template: `
        <div>
          <button (click)="onAddTodo()">Add Todo</button>
    
          <ul>
            @for (todo of query.data(); track todo.title) {
              <li>{{ todo.title }}</li>
            }
          </ul>
        </div>
      `,
    })
    export class TodosComponent {
      todoService = inject(TodoService)
      queryClient = inject(QueryClient)
    
      query = injectQuery(() => ({
        queryKey: ['todos'],
        queryFn: () => this.todoService.getTodos(),
      }))
    
      mutation = injectMutation(() => ({
        mutationFn: (todo: Todo) => this.todoService.addTodo(todo),
        onSuccess: () => {
          this.queryClient.invalidateQueries({ queryKey: ['todos'] })
        },
      }))
    
      onAddTodo() {
        this.mutation.mutate({
          id: Date.now().toString(),
          title: 'Do Laundry',
        })
      }
    }
    
    @Injectable({ providedIn: 'root' })
    export class TodoService {
      private http = inject(HttpClient)
    
      getTodos(): Promise<Todo[]> {
        return lastValueFrom(
          this.http.get<Todo[]>('https://jsonplaceholder.typicode.com/todos'),
        )
      }
    
      addTodo(todo: Todo): Promise<Todo> {
        return lastValueFrom(
          this.http.post<Todo>('https://jsonplaceholder.typicode.com/todos', todo),
        )
      }
    }
    
    interface Todo {
      id: string
      title: string
    }
    

    import { Component, Injectable, inject } from '@angular/core'
    import { HttpClient } from '@angular/common/http'
    import { lastValueFrom } from 'rxjs'
    
    import {
      injectMutation,
      injectQuery,
      QueryClient
    } from '@tanstack/angular-query-experimental'
    
    @Component({
      template: `
        <div>
          <button (click)="onAddTodo()">Add Todo</button>
    
          <ul>
            @for (todo of query.data(); track todo.title) {
              <li>{{ todo.title }}</li>
            }
          </ul>
        </div>
      `,
    })
    export class TodosComponent {
      todoService = inject(TodoService)
      queryClient = inject(QueryClient)
    
      query = injectQuery(() => ({
        queryKey: ['todos'],
        queryFn: () => this.todoService.getTodos(),
      }))
    
      mutation = injectMutation(() => ({
        mutationFn: (todo: Todo) => this.todoService.addTodo(todo),
        onSuccess: () => {
          this.queryClient.invalidateQueries({ queryKey: ['todos'] })
        },
      }))
    
      onAddTodo() {
        this.mutation.mutate({
          id: Date.now().toString(),
          title: 'Do Laundry',
        })
      }
    }
    
    @Injectable({ providedIn: 'root' })
    export class TodoService {
      private http = inject(HttpClient)
    
      getTodos(): Promise<Todo[]> {
        return lastValueFrom(
          this.http.get<Todo[]>('https://jsonplaceholder.typicode.com/todos'),
        )
      }
    
      addTodo(todo: Todo): Promise<Todo> {
        return lastValueFrom(
          this.http.post<Todo>('https://jsonplaceholder.typicode.com/todos', todo),
        )
      }
    }
    
    interface Todo {
      id: string
      title: string
    }</content>
</page>

<page>
  <title>Devtools | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/devtools</url>
  <content>> For Chrome, Firefox, and Edge users: Third-party browser extensions are available for debugging TanStack Query directly in browser DevTools. These provide the same functionality as the framework-specific devtools packages:
> 
> *   [Devtools for Chrome](https://chromewebstore.google.com/detail/tanstack-query-devtools/annajfchloimdhceglpgglpeepfghfai)
> *   [Devtools for Firefox](https://addons.mozilla.org/en-US/firefox/addon/tanstack-query-devtools/)
> *   [Devtools for Edge](https://microsoftedge.microsoft.com/addons/detail/tanstack-query-devtools/edmdpkgkacmjopodhfolmphdenmddobj)

The devtools help you debug and inspect your queries and mutations. You can enable the devtools by adding withDevtools to provideTanStackQuery.

By default, Angular Query Devtools are only included in development mode bundles, so you don't need to worry about excluding them during a production build.

    import {
      QueryClient,
      provideTanStackQuery,
    } from '@tanstack/angular-query-experimental'
    
    import { withDevtools } from '@tanstack/angular-query-experimental/devtools'
    
    export const appConfig: ApplicationConfig = {
      providers: [provideTanStackQuery(new QueryClient(), withDevtools())],
    }
    

    import {
      QueryClient,
      provideTanStackQuery,
    } from '@tanstack/angular-query-experimental'
    
    import { withDevtools } from '@tanstack/angular-query-experimental/devtools'
    
    export const appConfig: ApplicationConfig = {
      providers: [provideTanStackQuery(new QueryClient(), withDevtools())],
    }
    

Devtools are automatically excluded from production builds. However, it might be desirable to lazy load the devtools in production.

To use withDevtools in production builds, import using the production sub-path. The function exported from the production subpath is identical to the main one, but won't be excluded from production builds.

    import { withDevtools } from '@tanstack/angular-query-experimental/devtools/production'
    

    import { withDevtools } from '@tanstack/angular-query-experimental/devtools/production'
    

To control when devtools are loaded, you can use the loadDevtools option.

When not setting the option or setting it to 'auto', the devtools will be loaded automatically only when Angular runs in development mode.

    import { withDevtools } from '@tanstack/angular-query-experimental/devtools'
    
    provideTanStackQuery(new QueryClient(), withDevtools())
    
    // which is equivalent to
    provideTanStackQuery(
      new QueryClient(),
      withDevtools(() => ({ loadDevtools: 'auto' })),
    )
    

    import { withDevtools } from '@tanstack/angular-query-experimental/devtools'
    
    provideTanStackQuery(new QueryClient(), withDevtools())
    
    // which is equivalent to
    provideTanStackQuery(
      new QueryClient(),
      withDevtools(() => ({ loadDevtools: 'auto' })),
    )
    

When setting the option to true, the devtools will be loaded in both development and production mode.

This is useful if you want to load devtools based on [Angular environment configurations](https://angular.dev/tools/cli/environments). E.g. you could set this to true when the application is running on your production build staging environment.

    import { environment } from './environments/environment'
    // Make sure to use the production sub-path to load devtools in production builds
    import { withDevtools } from '@tanstack/angular-query-experimental/devtools/production'
    
    provideTanStackQuery(
      new QueryClient(),
      withDevtools(() => ({ loadDevtools: environment.loadDevtools })),
    )
    

    import { environment } from './environments/environment'
    // Make sure to use the production sub-path to load devtools in production builds
    import { withDevtools } from '@tanstack/angular-query-experimental/devtools/production'
    
    provideTanStackQuery(
      new QueryClient(),
      withDevtools(() => ({ loadDevtools: environment.loadDevtools })),
    )
    

When setting the option to false, the devtools will not be loaded.

    provideTanStackQuery(
      new QueryClient(),
      withDevtools(() => ({ loadDevtools: false })),
    )
    

    provideTanStackQuery(
      new QueryClient(),
      withDevtools(() => ({ loadDevtools: false })),
    )
    

[](#derive-options-through-reactivity)[Derive options through reactivity](#derive-options-through-reactivity)
-------------------------------------------------------------------------------------------------------------

Options are passed to withDevtools from a callback function to support reactivity through signals. In the following example a signal is created from a RxJS observable that emits on a keyboard shortcut. When the derived signal is set to true, the devtools are lazily loaded.

The example below always loads devtools in development mode and loads on-demand in production mode when a keyboard shortcut is pressed.

    import { Injectable, isDevMode } from '@angular/core'
    import { fromEvent, map, scan } from 'rxjs'
    import { toSignal } from '@angular/core/rxjs-interop'
    
    @Injectable({ providedIn: 'root' })
    export class DevtoolsOptionsManager {
      loadDevtools = toSignal(
        fromEvent<KeyboardEvent>(document, 'keydown').pipe(
          map(
            (event): boolean =>
              event.metaKey && event.ctrlKey && event.shiftKey && event.key === 'D',
          ),
          scan((acc, curr) => acc || curr, isDevMode()),
        ),
        {
          initialValue: isDevMode(),
        },
      )
    }
    

    import { Injectable, isDevMode } from '@angular/core'
    import { fromEvent, map, scan } from 'rxjs'
    import { toSignal } from '@angular/core/rxjs-interop'
    
    @Injectable({ providedIn: 'root' })
    export class DevtoolsOptionsManager {
      loadDevtools = toSignal(
        fromEvent<KeyboardEvent>(document, 'keydown').pipe(
          map(
            (event): boolean =>
              event.metaKey && event.ctrlKey && event.shiftKey && event.key === 'D',
          ),
          scan((acc, curr) => acc || curr, isDevMode()),
        ),
        {
          initialValue: isDevMode(),
        },
      )
    }
    

If you want to use an injectable such as a service in the callback you can use deps. The injected value will be passed as parameter to the callback function.

This is similar to deps in Angular's [useFactory](https://angular.dev/guide/di/dependency-injection-providers#factory-providers-usefactory) provider.

    // ...
    // üëá Note we import from the production sub-path to enable devtools lazy loading in production builds
    import { withDevtools } from '@tanstack/angular-query-experimental/devtools/production'
    
    export const appConfig: ApplicationConfig = {
      providers: [
        provideHttpClient(),
        provideTanStackQuery(
          new QueryClient(),
          withDevtools(
            (devToolsOptionsManager: DevtoolsOptionsManager) => ({
              loadDevtools: devToolsOptionsManager.loadDevtools(),
            }),
            {
              // `deps` is used to inject and pass `DevtoolsOptionsManager` to the `withDevtools` callback.
              deps: [DevtoolsOptionsManager],
            },
          ),
        ),
      ],
    }
    

    // ...
    // üëá Note we import from the production sub-path to enable devtools lazy loading in production builds
    import { withDevtools } from '@tanstack/angular-query-experimental/devtools/production'
    
    export const appConfig: ApplicationConfig = {
      providers: [
        provideHttpClient(),
        provideTanStackQuery(
          new QueryClient(),
          withDevtools(
            (devToolsOptionsManager: DevtoolsOptionsManager) => ({
              loadDevtools: devToolsOptionsManager.loadDevtools(),
            }),
            {
              // `deps` is used to inject and pass `DevtoolsOptionsManager` to the `withDevtools` callback.
              deps: [DevtoolsOptionsManager],
            },
          ),
        ),
      ],
    }
    

### [](#options-returned-from-the-callback)[Options returned from the callback](#options-returned-from-the-callback)

Of these options loadDevtools, client, position, errorTypes, buttonPosition, and initialIsOpen support reactivity through signals.

*   loadDevtools?: 'auto' | boolean
    *   Defaults to auto: lazily loads devtools when in development mode. Skips loading in production mode.
    *   Use this to control if the devtools are loaded.
*   initialIsOpen?: Boolean
    *   Set this to true if you want the tools to default to being open
*   buttonPosition?: "top-left" | "top-right" | "bottom-left" | "bottom-right" | "relative"
    *   Defaults to bottom-right
    *   The position of the TanStack logo to open and close the devtools panel
    *   If relative, the button is placed in the location that you render the devtools.
*   position?: "top" | "bottom" | "left" | "right"
    *   Defaults to bottom
    *   The position of the Angular Query devtools panel
*   client?: QueryClient,
    *   Use this to use a custom QueryClient. Otherwise, the QueryClient provided through provideTanStackQuery will be injected.
*   errorTypes?: { name: string; initializer: (query: Query) => TError}\[\]
    *   Use this to predefine some errors that can be triggered on your queries. Initializer will be called (with the specific query) when that error is toggled on from the UI. It must return an Error.
*   styleNonce?: string
    *   Use this to pass a nonce to the style tag that is added to the document head. This is useful if you are using a Content Security Policy (CSP) nonce to allow inline styles.
*   shadowDOMTarget?: ShadowRoot
    *   Default behavior will apply the devtool's styles to the head tag within the DOM.
    *   Use this to pass a shadow DOM target to the devtools so that the styles will be applied within the shadow DOM instead of within the head tag in the light DOM.
*   hideDisabledQueries?: boolean
    *   Set this to true to hide disabled queries from the devtools panel.</content>
</page>

<page>
  <title>TypeScript | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/typescript</url>
  <content>TanStack Query is now written in **TypeScript** to make sure the library and your projects are type-safe!

Things to keep in mind:

*   Types currently require using TypeScript **v4.7** or greater
*   Changes to types in this repository are considered **non-breaking** and are usually released as **patch** semver changes (otherwise every type enhancement would be a major version!).
*   It is **highly recommended that you lock your angular-query-experimental package version to a specific patch release and upgrade with the expectation that types may be fixed or upgraded between any release**
*   The non-type-related public API of TanStack Query and - after the experimental phase, the angular-query package still follow semver very strictly.

[](#type-inference)[Type Inference](#type-inference)
----------------------------------------------------

Types in TanStack Query generally flow through very well so that you don't have to provide type annotations for yourself

    @Component({
      // ...
      template: `@let data = query.data();`,
      //               ^? data: number | undefined
    })
    class MyComponent {
      query = injectQuery(() => ({
        queryKey: ['test'],
        queryFn: () => Promise.resolve(5),
      }))
    }
    

    @Component({
      // ...
      template: `@let data = query.data();`,
      //               ^? data: number | undefined
    })
    class MyComponent {
      query = injectQuery(() => ({
        queryKey: ['test'],
        queryFn: () => Promise.resolve(5),
      }))
    }
    

    @Component({
      // ...
      template: `@let data = query.data();`,
      //               ^? data: string | undefined
    })
    class MyComponent {
      query = injectQuery(() => ({
        queryKey: ['test'],
        queryFn: () => Promise.resolve(5),
        select: (data) => data.toString(),
      }))
    }
    

    @Component({
      // ...
      template: `@let data = query.data();`,
      //               ^? data: string | undefined
    })
    class MyComponent {
      query = injectQuery(() => ({
        queryKey: ['test'],
        queryFn: () => Promise.resolve(5),
        select: (data) => data.toString(),
      }))
    }
    

This works best if your queryFn has a well-defined returned type. Keep in mind that most data fetching libraries return any per default, so make sure to extract it to a properly typed function.

In this example we pass Group\[\] to the type parameter of HttpClient's get method.

    @Component({
      template: `@let data = query.data();`,
      //               ^? data: Group[] | undefined
    })
    class MyComponent {
      http = inject(HttpClient)
    
      query = injectQuery(() => ({
        queryKey: ['groups'],
        queryFn: () => lastValueFrom(this.http.get<Group[]>('/groups')),
      }))
    }
    

    @Component({
      template: `@let data = query.data();`,
      //               ^? data: Group[] | undefined
    })
    class MyComponent {
      http = inject(HttpClient)
    
      query = injectQuery(() => ({
        queryKey: ['groups'],
        queryFn: () => lastValueFrom(this.http.get<Group[]>('/groups')),
      }))
    }
    

[](#type-narrowing)[Type Narrowing](#type-narrowing)
----------------------------------------------------

TanStack Query uses a [discriminated union type](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#discriminated-unions) for the query result, discriminated by the status field and the derived status boolean flags. This will allow you to check for e.g. isSuccess() status to make data defined:

    @Component({
      // ...
      template: `
        @if (query.isSuccess()) {
          @let data = query.data();
          //    ^? data: number
        }
      `,
    })
    class MyComponent {
      query = injectQuery(() => ({
        queryKey: ['test'],
        queryFn: () => Promise.resolve(5),
      }))
    }
    

    @Component({
      // ...
      template: `
        @if (query.isSuccess()) {
          @let data = query.data();
          //    ^? data: number
        }
      `,
    })
    class MyComponent {
      query = injectQuery(() => ({
        queryKey: ['test'],
        queryFn: () => Promise.resolve(5),
      }))
    }
    

> TypeScript currently does not support discriminated unions on object methods. Narrowing on signal fields on objects such as query results only works on signals returning a boolean. Prefer using isSuccess() and similar boolean status signals over status() === 'success'.

[](#typing-the-error-field)[Typing the error field](#typing-the-error-field)
----------------------------------------------------------------------------

The type for error defaults to Error, because that is what most users expect.

    @Component({
      // ...
      template: `@let error = query.error();`,
      //                ^? error: Error | null
    })
    class MyComponent {
      query = injectQuery(() => ({
        queryKey: ['groups'],
        queryFn: fetchGroups
      }))
    }
    

    @Component({
      // ...
      template: `@let error = query.error();`,
      //                ^? error: Error | null
    })
    class MyComponent {
      query = injectQuery(() => ({
        queryKey: ['groups'],
        queryFn: fetchGroups
      }))
    }
    

If you want to throw a custom error, or something that isn't an Error at all, you can specify the type of the error field:

    @Component({
      // ...
      template: `@let error = query.error();`,
      //                ^? error: string | null
    })
    class MyComponent {
      query = injectQuery<Group[], string>(() => ({
        queryKey: ['groups'],
        queryFn: fetchGroups,
      }))
    }
    

    @Component({
      // ...
      template: `@let error = query.error();`,
      //                ^? error: string | null
    })
    class MyComponent {
      query = injectQuery<Group[], string>(() => ({
        queryKey: ['groups'],
        queryFn: fetchGroups,
      }))
    }
    

However, this has the drawback that type inference for all other generics of injectQuery will not work anymore. It is generally not considered a good practice to throw something that isn't an Error, so if you have a subclass like AxiosError you can use _type narrowing_ to make the error field more specific:

    import axios from 'axios'
    
    query = injectQuery(() => ({ queryKey: ['groups'], queryFn: fetchGroups }))
    
    computed(() => {
      const error = query.error()
      //     ^? error: Error | null
    
      if (axios.isAxiosError(error)) {
        error
        // ^? const error: AxiosError
      }
    })
    

    import axios from 'axios'
    
    query = injectQuery(() => ({ queryKey: ['groups'], queryFn: fetchGroups }))
    
    computed(() => {
      const error = query.error()
      //     ^? error: Error | null
    
      if (axios.isAxiosError(error)) {
        error
        // ^? const error: AxiosError
      }
    })
    

### [](#registering-a-global-error)[Registering a global Error](#registering-a-global-error)

TanStack Query v5 allows for a way to set a global Error type for everything, without having to specify generics on call-sides, by amending the Register interface. This will make sure inference still works, but the error field will be of the specified type. If you want to enforce that call-sides must do explicit type-narrowing, set defaultError to unknown:

    import '@tanstack/angular-query-experimental'
    
    declare module '@tanstack/angular-query-experimental' {
      interface Register {
        // Use unknown so call sites must narrow explicitly.
        defaultError: unknown
      }
    }
    
    const query = injectQuery(() => ({
      queryKey: ['groups'],
      queryFn: fetchGroups,
    }))
    
    computed(() => {
      const error = query.error()
      //      ^? error: unknown | null
    })
    

    import '@tanstack/angular-query-experimental'
    
    declare module '@tanstack/angular-query-experimental' {
      interface Register {
        // Use unknown so call sites must narrow explicitly.
        defaultError: unknown
      }
    }
    
    const query = injectQuery(() => ({
      queryKey: ['groups'],
      queryFn: fetchGroups,
    }))
    
    computed(() => {
      const error = query.error()
      //      ^? error: unknown | null
    })
    

### [](#registering-global-meta)[Registering global Meta](#registering-global-meta)

Similarly to registering a [global error type](#registering-a-global-error) you can also register a global Meta type. This ensures the optional meta field on [queries](https://tanstack.com/query/latest/docs/framework/angular/reference/injectQuery) and [mutations](https://tanstack.com/query/latest/docs/framework/angular/reference/injectMutation) stays consistent and is type-safe. Note that the registered type must extend Record<string, unknown> so that meta remains an object.

    import '@tanstack/angular-query-experimental'
    
    interface MyMeta extends Record<string, unknown> {
      // Your meta type definition.
    }
    
    declare module '@tanstack/angular-query-experimental' {
      interface Register {
        queryMeta: MyMeta
        mutationMeta: MyMeta
      }
    }
    

    import '@tanstack/angular-query-experimental'
    
    interface MyMeta extends Record<string, unknown> {
      // Your meta type definition.
    }
    
    declare module '@tanstack/angular-query-experimental' {
      interface Register {
        queryMeta: MyMeta
        mutationMeta: MyMeta
      }
    }
    

[](#typing-query-and-mutation-keys)[Typing query and mutation keys](#typing-query-and-mutation-keys)
----------------------------------------------------------------------------------------------------

### [](#registering-the-query-and-mutation-key-types)[Registering the query and mutation key types](#registering-the-query-and-mutation-key-types)

Also similarly to registering a [global error type](#registering-a-global-error), you can also register a global QueryKey and MutationKey type. This allows you to provide more structure to your keys, that matches your application's hierarchy, and have them be typed across all of the library's surface area. Note that the registered type must extend the Array type, so that your keys remain an array.

    import '@tanstack/angular-query-experimental'
    
    type QueryKey = ['dashboard' | 'marketing', ...ReadonlyArray<unknown>]
    
    declare module '@tanstack/angular-query-experimental' {
      interface Register {
        queryKey: QueryKey
        mutationKey: QueryKey
      }
    }
    

    import '@tanstack/angular-query-experimental'
    
    type QueryKey = ['dashboard' | 'marketing', ...ReadonlyArray<unknown>]
    
    declare module '@tanstack/angular-query-experimental' {
      interface Register {
        queryKey: QueryKey
        mutationKey: QueryKey
      }
    }
    

[](#typing-query-options)[Typing Query Options](#typing-query-options)
----------------------------------------------------------------------

If you inline query options into injectQuery, you'll get automatic type inference. However, you might want to extract the query options into a separate function to share them between injectQuery and e.g. prefetchQuery or manage them in a service. In that case, you'd lose type inference. To get it back, you can use the queryOptions helper:

    @Injectable({
      providedIn: 'root',
    })
    export class QueriesService {
      private http = inject(HttpClient)
    
      post(postId: number) {
        return queryOptions({
          queryKey: ['post', postId],
          queryFn: () => {
            return lastValueFrom(
              this.http.get<Post>(
                `https://jsonplaceholder.typicode.com/posts/${postId}`,
              ),
            )
          },
        })
      }
    }
    
    @Component({
      // ...
    })
    export class Component {
      queryClient = inject(QueryClient)
    
      postId = signal(1)
    
      queries = inject(QueriesService)
      optionsSignal = computed(() => this.queries.post(this.postId()))
    
      postQuery = injectQuery(() => this.queries.post(1))
      postQuery = injectQuery(() => this.queries.post(this.postId()))
    
      // You can also pass a signal which returns query options
      postQuery = injectQuery(this.optionsSignal)
    
      someMethod() {
        this.queryClient.prefetchQuery(this.queries.post(23))
      }
    }
    

    @Injectable({
      providedIn: 'root',
    })
    export class QueriesService {
      private http = inject(HttpClient)
    
      post(postId: number) {
        return queryOptions({
          queryKey: ['post', postId],
          queryFn: () => {
            return lastValueFrom(
              this.http.get<Post>(
                `https://jsonplaceholder.typicode.com/posts/${postId}`,
              ),
            )
          },
        })
      }
    }
    
    @Component({
      // ...
    })
    export class Component {
      queryClient = inject(QueryClient)
    
      postId = signal(1)
    
      queries = inject(QueriesService)
      optionsSignal = computed(() => this.queries.post(this.postId()))
    
      postQuery = injectQuery(() => this.queries.post(1))
      postQuery = injectQuery(() => this.queries.post(this.postId()))
    
      // You can also pass a signal which returns query options
      postQuery = injectQuery(this.optionsSignal)
    
      someMethod() {
        this.queryClient.prefetchQuery(this.queries.post(23))
      }
    }
    

Further, the queryKey returned from queryOptions knows about the queryFn associated with it, and we can leverage that type information to make functions like queryClient.getQueryData aware of those types as well:

    data = this.queryClient.getQueryData(groupOptions().queryKey)
    // ^? data: Post | undefined
    

    data = this.queryClient.getQueryData(groupOptions().queryKey)
    // ^? data: Post | undefined
    

Without queryOptions, the type of data would be unknown, unless we'd pass a type parameter:

    data = queryClient.getQueryData<Post>(['post', 1])
    

    data = queryClient.getQueryData<Post>(['post', 1])
    

[](#typing-mutation-options)[Typing Mutation Options](#typing-mutation-options)
-------------------------------------------------------------------------------

Similarly to queryOptions, you can use mutationOptions to extract mutation options into a separate function:

    export class QueriesService {
      private http = inject(HttpClient)
    
      updatePost(id: number) {
        return mutationOptions({
          mutationFn: (post: Post) => Promise.resolve(post),
          mutationKey: ['updatePost', id],
          onSuccess: (newPost) => {
            //           ^? newPost: Post
            this.queryClient.setQueryData(['posts', id], newPost)
          },
        })
      }
    }
    

    export class QueriesService {
      private http = inject(HttpClient)
    
      updatePost(id: number) {
        return mutationOptions({
          mutationFn: (post: Post) => Promise.resolve(post),
          mutationKey: ['updatePost', id],
          onSuccess: (newPost) => {
            //           ^? newPost: Post
            this.queryClient.setQueryData(['posts', id], newPost)
          },
        })
      }
    }
    

[](#typesafe-disabling-of-queries-using-skiptoken)[Typesafe disabling of queries using skipToken](#typesafe-disabling-of-queries-using-skiptoken)
-------------------------------------------------------------------------------------------------------------------------------------------------

If you are using TypeScript, you can use the skipToken to disable a query. This is useful when you want to disable a query based on a condition, but you still want to keep the query to be type safe. Read more about it in the [Disabling Queries](https://tanstack.com/query/latest/docs/framework/angular/guides/disabling-queries) guide.</content>
</page>

<page>
  <title>Zoneless Angular | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/zoneless</url>
  <content>Because the Angular adapter for TanStack Query is built on signals, it fully supports Zoneless!

Among Zoneless benefits are improved performance and debugging experience. For details see the [Angular documentation](https://angular.dev/guide/zoneless).

> Besides Zoneless, ZoneJS change detection is also fully supported.

> When using Zoneless, ensure you are on Angular v19 or later to take advantage of the PendingTasks integration that keeps ApplicationRef.whenStable() in sync with ongoing queries and mutations.</content>
</page>

<page>
  <title>Important Defaults | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/guides/important-defaults</url>
  <content>Out of the box, TanStack Query is configured with **aggressive but sane** defaults. **Sometimes these defaults can catch new users off guard or make learning/debugging difficult if they are unknown by the user.** Keep them in mind as you continue to learn and use TanStack Query:

*   Query instances via injectQuery or injectInfiniteQuery by default **consider cached data as stale**.

> To change this behavior, you can configure your queries both globally and per-query using the staleTime option. Specifying a longer staleTime means queries will not refetch their data as often

*   A Query that has a staleTime set is considered **fresh** until that staleTime has elapsed.
    
    *   set staleTime to e.g. 2 \* 60 \* 1000 to make sure data is read from the cache, without triggering any kinds of refetches, for 2 minutes, or until the Query is [invalidated manually](https://tanstack.com/query/latest/docs/framework/angular/guides/query-invalidation).
    *   set staleTime to Infinity to never trigger a refetch until the Query is [invalidated manually](https://tanstack.com/query/latest/docs/framework/angular/guides/query-invalidation).
    *   set staleTime to 'static' to **never** trigger a refetch, even if the Query is [invalidated manually](https://tanstack.com/query/latest/docs/framework/angular/guides/query-invalidation).
*   Stale queries are refetched automatically in the background when:
    
    *   New instances of the query mount
    *   The window is refocused
    *   The network is reconnected

> Setting staleTime is the recommended way to avoid excessive refetches, but you can also customize the points in time for refetches by setting options like refetchOnMount, refetchOnWindowFocus and refetchOnReconnect.

*   Queries can optionally be configured with a refetchInterval to trigger refetches periodically, which is independent of the staleTime setting.
    
*   Query results that have no more active instances of injectQuery, injectInfiniteQuery or query observers are labeled as "inactive" and remain in the cache in case they are used again at a later time.
    
*   By default, "inactive" queries are garbage collected after **5 minutes**.
    
    > To change this, you can alter the default gcTime for queries to something other than 1000 \* 60 \* 5 milliseconds.
    
*   Queries that fail are **silently retried 3 times, with exponential backoff delay** before capturing and displaying an error to the UI.
    
    > To change this, you can alter the default retry and retryDelay options for queries to something other than 3 and the default exponential backoff function.
    
*   Query results by default are **structurally shared to detect if data has actually changed** and if not, **the data reference remains unchanged** to better help with value stabilization with regards to setting signal values. If this concept sounds foreign, then don't worry about it! 99.9% of the time you will not need to disable this and it makes your app more performant at zero cost to you.
    
    > Structural sharing only works with JSON-compatible values, any other value types will always be considered as changed. If you are seeing performance issues because of large responses for example, you can disable this feature with the config.structuralSharing flag. If you are dealing with non-JSON compatible values in your query responses and still want to detect if data has changed or not, you can provide your own custom function as config.structuralSharing to compute a value from the old and new responses, retaining references as required.</content>
</page>

<page>
  <title>Angular HttpClient and other data fetching clients | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/angular-httpclient-and-other-data-fetching-clients</url>
  <content>Because TanStack Query's fetching mechanisms are agnostically built on Promises, you can use literally any asynchronous data fetching client, including the browser native fetch API, graphql-request, and more.

[](#using-angulars-httpclient-for-data-fetching)[Using Angular's HttpClient for data fetching](#using-angulars-httpclient-for-data-fetching)
--------------------------------------------------------------------------------------------------------------------------------------------

HttpClient is a powerful and integrated part of Angular, which gives the following benefits:

*   Mock responses in unit tests using [provideHttpClientTesting](https://angular.dev/guide/http/testing).
*   [Interceptors](https://angular.dev/guide/http/interceptors) can be used for a wide range of functionality including adding authentication headers, performing logging, etc. While some data fetching libraries have their own interceptor system, HttpClient interceptors are integrated with Angular's dependency injection system.
*   HttpClient automatically informs [PendingTasks](https://angular.dev/api/core/PendingTasks#), which enables Angular to be aware of pending requests. Unit tests and SSR can use the resulting application _stableness_ information to wait for pending requests to finish. This makes unit testing much easier for [Zoneless](https://angular.dev/guide/zoneless) applications.
*   When using SSR, HttpClient will [cache requests](https://angular.dev/guide/ssr#caching-data-when-using-HttpClient) performed on the server. This will prevent unneeded requests on the client. HttpClient SSR caching works out of the box. TanStack Query has its own hydration functionality which may be more powerful but requires some setup. Which one fits your needs best depends on your use case.

### [](#using-observables-in-queryfn)[Using observables in queryFn](#using-observables-in-queryfn)

As TanStack Query is a promise based library, observables from HttpClient need to be converted to promises. This can be done with the lastValueFrom or firstValueFrom functions from rxjs.

    @Component({
      // ...
    })
    class ExampleComponent {
      private readonly http = inject(HttpClient)
    
      readonly query = injectQuery(() => ({
        queryKey: ['repoData'],
        queryFn: () =>
          lastValueFrom(
            this.http.get('https://api.github.com/repos/tanstack/query'),
          ),
      }))
    }
    

    @Component({
      // ...
    })
    class ExampleComponent {
      private readonly http = inject(HttpClient)
    
      readonly query = injectQuery(() => ({
        queryKey: ['repoData'],
        queryFn: () =>
          lastValueFrom(
            this.http.get('https://api.github.com/repos/tanstack/query'),
          ),
      }))
    }
    

> Since Angular is moving towards RxJS as an optional dependency, it's expected that HttpClient will also support promises in the future.
> 
> Support for observables in TanStack Query for Angular is planned.

[](#comparison-table)[Comparison table](#comparison-table)
----------------------------------------------------------

| Data fetching client | Pros | Cons |
| --- | --- | --- |
| **Angular HttpClient** | Featureful and very well integrated with Angular. | Observables need to be converted to Promises. |
| **Fetch** | Browser native API, so adds nothing to bundle size. | Barebones API which lacks many features. |
| **Specialized libraries such as graphql-request** | Specialized features for specific use cases. | If it's not an Angular library it won't integrate well with the framework. |</content>
</page>

<page>
  <title>Query Keys | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/guides/query-keys</url>
  <content>At its core, TanStack Query manages query caching for you based on query keys. Query keys have to be an Array at the top level, and can be as simple as an Array with a single string, or as complex as an array of many strings and nested objects. As long as the query key is serializable using JSON.stringify, and **unique to the query's data**, you can use it!

[](#simple-query-keys)[Simple Query Keys](#simple-query-keys)
-------------------------------------------------------------

The simplest form of a key is an array with constants values. This format is useful for:

*   Generic List/Index resources
*   Non-hierarchical resources

    // A list of todos
    injectQuery(() => ({ queryKey: ['todos'], ... }))
    
    // Something else, whatever!
    injectQuery(() => ({ queryKey: ['something', 'special'], ... }))
    

    // A list of todos
    injectQuery(() => ({ queryKey: ['todos'], ... }))
    
    // Something else, whatever!
    injectQuery(() => ({ queryKey: ['something', 'special'], ... }))
    

[](#array-keys-with-variables)[Array Keys with variables](#array-keys-with-variables)
-------------------------------------------------------------------------------------

When a query needs more information to uniquely describe its data, you can use an array with a string and any number of serializable objects to describe it. This is useful for:

*   Hierarchical or nested resources
    *   It's common to pass an ID, index, or other primitive to uniquely identify the item
*   Queries with additional parameters
    *   It's common to pass an object of additional options

    // An individual todo
    injectQuery(() => ({queryKey: ['todo', 5], ...}))
    
    // An individual todo in a "preview" format
    injectQuery(() => ({queryKey: ['todo', 5, {preview: true}], ...}))
    
    // A list of todos that are "done"
    injectQuery(() => ({queryKey: ['todos', {type: 'done'}], ...}))
    

    // An individual todo
    injectQuery(() => ({queryKey: ['todo', 5], ...}))
    
    // An individual todo in a "preview" format
    injectQuery(() => ({queryKey: ['todo', 5, {preview: true}], ...}))
    
    // A list of todos that are "done"
    injectQuery(() => ({queryKey: ['todos', {type: 'done'}], ...}))
    

[](#query-keys-are-hashed-deterministically)[Query Keys are hashed deterministically!](#query-keys-are-hashed-deterministically)
--------------------------------------------------------------------------------------------------------------------------------

This means that no matter the order of keys in objects, all of the following queries are considered equal:

    injectQuery(() => ({ queryKey: ['todos', { status, page }], ... }))
    injectQuery(() => ({ queryKey: ['todos', { page, status }], ...}))
    injectQuery(() => ({ queryKey: ['todos', { page, status, other: undefined }], ... }))
    

    injectQuery(() => ({ queryKey: ['todos', { status, page }], ... }))
    injectQuery(() => ({ queryKey: ['todos', { page, status }], ...}))
    injectQuery(() => ({ queryKey: ['todos', { page, status, other: undefined }], ... }))
    

The following query keys, however, are not equal. Array item order matters!

    injectQuery(() => ({ queryKey: ['todos', status, page], ... }))
    injectQuery(() => ({ queryKey: ['todos', page, status], ...}))
    injectQuery(() => ({ queryKey: ['todos', undefined, page, status], ...}))
    

    injectQuery(() => ({ queryKey: ['todos', status, page], ... }))
    injectQuery(() => ({ queryKey: ['todos', page, status], ...}))
    injectQuery(() => ({ queryKey: ['todos', undefined, page, status], ...}))
    

[](#if-your-query-function-depends-on-a-variable-include-it-in-your-query-key)[If your query function depends on a variable, include it in your query key](#if-your-query-function-depends-on-a-variable-include-it-in-your-query-key)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Since query keys uniquely describe the data they are fetching, they should include any variables you use in your query function that **change**. For example:

    todoId = signal(-1)
    
    injectQuery(() => ({
      enabled: todoId() > 0,
      queryKey: ['todos', todoId()],
      queryFn: () => fetchTodoById(todoId()),
    }))
    

    todoId = signal(-1)
    
    injectQuery(() => ({
      enabled: todoId() > 0,
      queryKey: ['todos', todoId()],
      queryFn: () => fetchTodoById(todoId()),
    }))
    

Note that query keys act as dependencies for your query functions. Adding dependent variables to your query key will ensure that queries are cached independently, and that any time a variable changes, _queries will be refetched automatically_ (depending on your staleTime settings). See the [exhaustive-deps](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps) section for more information and examples.</content>
</page>

<page>
  <title>Query Functions | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/guides/query-functions</url>
  <content>A query function can be literally any function that **returns a promise**. The promise that is returned should either **resolve the data** or **throw an error**.

All of the following are valid query function configurations:

    injectQuery(() => ({ queryKey: ['todos'], queryFn: fetchAllTodos }))
    injectQuery(() => ({ queryKey: ['todos', todoId], queryFn: () => fetchTodoById(todoId) })
    injectQuery(() => ({
      queryKey: ['todos', todoId],
      queryFn: async () => {
        const data = await fetchTodoById(todoId)
        return data
      },
    }))
    injectQuery(() => ({
      queryKey: ['todos', todoId],
      queryFn: ({ queryKey }) => fetchTodoById(queryKey[1]),
    }))
    

    injectQuery(() => ({ queryKey: ['todos'], queryFn: fetchAllTodos }))
    injectQuery(() => ({ queryKey: ['todos', todoId], queryFn: () => fetchTodoById(todoId) })
    injectQuery(() => ({
      queryKey: ['todos', todoId],
      queryFn: async () => {
        const data = await fetchTodoById(todoId)
        return data
      },
    }))
    injectQuery(() => ({
      queryKey: ['todos', todoId],
      queryFn: ({ queryKey }) => fetchTodoById(queryKey[1]),
    }))
    

[](#handling-and-throwing-errors)[Handling and Throwing Errors](#handling-and-throwing-errors)
----------------------------------------------------------------------------------------------

For TanStack Query to determine a query has errored, the query function **must throw** or return a **rejected Promise**. Any error that is thrown in the query function will be persisted on the error state of the query.

    todos = injectQuery(() => ({
      queryKey: ['todos', todoId()],
      queryFn: async () => {
        if (somethingGoesWrong) {
          throw new Error('Oh no!')
        }
        if (somethingElseGoesWrong) {
          return Promise.reject(new Error('Oh no!'))
        }
    
        return data
      },
    }))
    

    todos = injectQuery(() => ({
      queryKey: ['todos', todoId()],
      queryFn: async () => {
        if (somethingGoesWrong) {
          throw new Error('Oh no!')
        }
        if (somethingElseGoesWrong) {
          return Promise.reject(new Error('Oh no!'))
        }
    
        return data
      },
    }))
    

[](#usage-with-fetch-and-other-clients-that-do-not-throw-by-default)[Usage with fetch and other clients that do not throw by default](#usage-with-fetch-and-other-clients-that-do-not-throw-by-default)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

While most utilities like axios or graphql-request automatically throw errors for unsuccessful HTTP calls, some utilities like fetch do not throw errors by default. If that's the case, you'll need to throw them on your own. Here is a simple way to do that with the popular fetch API:

    todos = injectQuery(() => ({
      queryKey: ['todos', todoId()],
      queryFn: async () => {
        const response = await fetch('/todos/' + todoId)
        if (!response.ok) {
          throw new Error('Network response was not ok')
        }
        return response.json()
      },
    }))
    

    todos = injectQuery(() => ({
      queryKey: ['todos', todoId()],
      queryFn: async () => {
        const response = await fetch('/todos/' + todoId)
        if (!response.ok) {
          throw new Error('Network response was not ok')
        }
        return response.json()
      },
    }))
    

[](#query-function-variables)[Query Function Variables](#query-function-variables)
----------------------------------------------------------------------------------

Query keys are not just for uniquely identifying the data you are fetching, but are also conveniently passed into your query function as part of the QueryFunctionContext. While not always necessary, this makes it possible to extract your query functions if needed:

    result = injectQuery(() => ({
      queryKey: ['todos', { status: status(), page: page() }],
      queryFn: fetchTodoList,
    }))
    
    // Access the key, status and page variables in your query function!
    function fetchTodoList({ queryKey }) {
      const [_key, { status, page }] = queryKey
      return new Promise()
    }
    

    result = injectQuery(() => ({
      queryKey: ['todos', { status: status(), page: page() }],
      queryFn: fetchTodoList,
    }))
    
    // Access the key, status and page variables in your query function!
    function fetchTodoList({ queryKey }) {
      const [_key, { status, page }] = queryKey
      return new Promise()
    }
    

### [](#queryfunctioncontext)[QueryFunctionContext](#queryfunctioncontext)

The QueryFunctionContext is the object passed to each query function. It consists of:

*   queryKey: QueryKey: [Query Keys](https://tanstack.com/query/latest/docs/framework/angular/guides/query-keys)
*   client: QueryClient: [QueryClient](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   signal?: AbortSignal
    *   [AbortSignal](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) instance provided by TanStack Query
    *   Can be used for [Query Cancellation](https://tanstack.com/query/latest/docs/framework/angular/guides/query-cancellation)
*   meta: Record<string, unknown> | undefined
    *   an optional field you can fill with additional information about your query

Additionally, [Infinite Queries](https://tanstack.com/query/latest/docs/framework/angular/guides/infinite-queries) get the following options passed:

*   pageParam: TPageParam
    *   the page parameter used to fetch the current page
*   direction: 'forward' | 'backward'
    *   **deprecated**
    *   the direction of the current page fetch
    *   To get access to the direction of the current page fetch, please add a direction to pageParam from getNextPageParam and getPreviousPageParam.</content>
</page>

<page>
  <title>Queries | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/guides/queries</url>
  <content>[](#query-basics)[Query Basics](#query-basics)
----------------------------------------------

A query is a declarative dependency on an asynchronous source of data that is tied to a **unique key**. A query can be used with any Promise based method (including GET and POST methods) to fetch data from a server. If your method modifies data on the server, we recommend using [Mutations](https://tanstack.com/query/latest/docs/framework/angular/guides/mutations) instead.

To subscribe to a query in your components or services, call injectQuery with at least:

*   A **unique key for the query**
*   A function that returns a promise or observable that:
    *   Resolves the data, or
    *   Throws an error

    import { injectQuery } from '@tanstack/angular-query-experimental'
    
    export class TodosComponent {
      info = injectQuery(() => ({ queryKey: ['todos'], queryFn: fetchTodoList }))
    }
    

    import { injectQuery } from '@tanstack/angular-query-experimental'
    
    export class TodosComponent {
      info = injectQuery(() => ({ queryKey: ['todos'], queryFn: fetchTodoList }))
    }
    

The **unique key** you provide is used internally for refetching, caching, and sharing your queries throughout your application.

The query result returned by injectQuery contains all of the information about the query that you'll need for templating and any other usage of the data:

    result = injectQuery(() => ({ queryKey: ['todos'], queryFn: fetchTodoList }))
    

    result = injectQuery(() => ({ queryKey: ['todos'], queryFn: fetchTodoList }))
    

The result object contains a few very important states you'll need to be aware of to be productive. A query can only be in one of the following states at any given moment:

*   isPending or status === 'pending' - The query has no data yet
*   isError or status === 'error' - The query encountered an error
*   isSuccess or status === 'success' - The query was successful and data is available

Beyond those primary states, more information is available depending on the state of the query:

*   error - If the query is in an isError state, the error is available via the error property.
*   data - If the query is in an isSuccess state, the data is available via the data property.
*   isFetching - In any state, if the query is fetching at any time (including background refetching) isFetching will be true.

For **most** queries, it's usually sufficient to check for the isPending state, then the isError state, then finally, assume that the data is available and render the successful state:

    @Component({
      selector: 'todos',
      template: `
        @if (todos.isPending()) {
          <span>Loading...</span>
        } @else if (todos.isError()) {
          <span>Error: {{ todos.error()?.message }}</span>
        } @else {
          <!-- We can assume by this point that status === 'success' -->
          @for (todo of todos.data(); track todo.id) {
            <li>{{ todo.title }}</li>
          } @empty {
            <li>No todos found</li>
          }
        }
      `,
    })
    export class PostsComponent {
      todos = injectQuery(() => ({
        queryKey: ['todos'],
        queryFn: fetchTodoList,
      }))
    }
    

    @Component({
      selector: 'todos',
      template: `
        @if (todos.isPending()) {
          <span>Loading...</span>
        } @else if (todos.isError()) {
          <span>Error: {{ todos.error()?.message }}</span>
        } @else {
          <!-- We can assume by this point that status === 'success' -->
          @for (todo of todos.data(); track todo.id) {
            <li>{{ todo.title }}</li>
          } @empty {
            <li>No todos found</li>
          }
        }
      `,
    })
    export class PostsComponent {
      todos = injectQuery(() => ({
        queryKey: ['todos'],
        queryFn: fetchTodoList,
      }))
    }
    

If booleans aren't your thing, you can always use the status state as well:

    @Component({
      selector: 'todos',
      template: `
        @switch (todos.status()) {
          @case ('pending') {
            <span>Loading...</span>
          }
          @case ('error') {
            <span>Error: {{ todos.error()?.message }}</span>
          }
          <!-- also status === 'success', but "else" logic works, too -->
          @default {
            <ul>
              @for (todo of todos.data(); track todo.id) {
                <li>{{ todo.title }}</li>
              } @empty {
                <li>No todos found</li>
              }
            </ul>
          }
        }
      `,
    })
    class TodosComponent {}
    

    @Component({
      selector: 'todos',
      template: `
        @switch (todos.status()) {
          @case ('pending') {
            <span>Loading...</span>
          }
          @case ('error') {
            <span>Error: {{ todos.error()?.message }}</span>
          }
          <!-- also status === 'success', but "else" logic works, too -->
          @default {
            <ul>
              @for (todo of todos.data(); track todo.id) {
                <li>{{ todo.title }}</li>
              } @empty {
                <li>No todos found</li>
              }
            </ul>
          }
        }
      `,
    })
    class TodosComponent {}
    

TypeScript will also narrow the type of data correctly if you've checked for pending and error before accessing it.

### [](#fetchstatus)[FetchStatus](#fetchstatus)

In addition to the status field, you will also get an additional fetchStatus property with the following options:

*   fetchStatus === 'fetching' - The query is currently fetching.
*   fetchStatus === 'paused' - The query wanted to fetch, but it is paused. Read more about this in the [Network Mode](https://tanstack.com/query/latest/docs/framework/angular/guides/network-mode) guide.
*   fetchStatus === 'idle' - The query is not doing anything at the moment.

### [](#why-two-different-states)[Why two different states?](#why-two-different-states)

Background refetches and stale-while-revalidate logic make all combinations for status and fetchStatus possible. For example:

*   a query in success status will usually be in idle fetchStatus, but it could also be in fetching if a background refetch is happening.
*   a query that mounts and has no data will usually be in pending status and fetching fetchStatus, but it could also be paused if there is no network connection.

So keep in mind that a query can be in pending state without actually fetching data. As a rule of thumb:

*   The status gives information about the data: Do we have any or not?
*   The fetchStatus gives information about the queryFn: Is it running or not?</content>
</page>

<page>
  <title>Svelte TanStack Query Star Wars Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/examples/star-wars</url>
  <content>md

    # Example
    
    This example is a rewrite of the React Query star-wars example.
    
    To run this example:
    
    - `npm install`
    - `npm run dev`
    

    # Example
    
    This example is a rewrite of the React Query star-wars example.
    
    To run this example:
    
    - `npm install`
    - `npm run dev`</content>
</page>

<page>
  <title>Query Options | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/guides/query-options</url>
  <content>One of the best ways to share queryKey and queryFn between multiple places, yet keep them co-located to one another, is to use the queryOptions helper. At runtime, this helper just returns whatever you pass into it, but it has a lot of advantages when using it [with TypeScript](https://tanstack.com/query/latest/docs/framework/angular/typescript#typing-query-options). You can define all possible options for a query in one place, and you'll also get type inference and type safety for all of them.

    import { queryOptions } from '@tanstack/angular-query-experimental'
    
    @Injectable({
      providedIn: 'root',
    })
    export class QueriesService {
      private http = inject(HttpClient)
    
      post(postId: number) {
        return queryOptions({
          queryKey: ['post', postId],
          queryFn: () => {
            return lastValueFrom(
              this.http.get<Post>(
                `https://jsonplaceholder.typicode.com/posts/${postId}`,
              ),
            )
          },
        })
      }
    }
    
    // usage:
    
    postId = input.required({
      transform: numberAttribute,
    })
    queries = inject(QueriesService)
    
    postQuery = injectQuery(() => this.queries.post(this.postId()))
    
    queryClient.prefetchQuery(this.queries.post(23))
    queryClient.setQueryData(this.queries.post(42).queryKey, newPost)
    

    import { queryOptions } from '@tanstack/angular-query-experimental'
    
    @Injectable({
      providedIn: 'root',
    })
    export class QueriesService {
      private http = inject(HttpClient)
    
      post(postId: number) {
        return queryOptions({
          queryKey: ['post', postId],
          queryFn: () => {
            return lastValueFrom(
              this.http.get<Post>(
                `https://jsonplaceholder.typicode.com/posts/${postId}`,
              ),
            )
          },
        })
      }
    }
    
    // usage:
    
    postId = input.required({
      transform: numberAttribute,
    })
    queries = inject(QueriesService)
    
    postQuery = injectQuery(() => this.queries.post(this.postId()))
    
    queryClient.prefetchQuery(this.queries.post(23))
    queryClient.setQueryData(this.queries.post(42).queryKey, newPost)
    

For Infinite Queries, a separate [infiniteQueryOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/infiniteQueryOptions) helper is available.

You can still override some options at the component level. A very common and useful pattern is to create per-component [select](https://tanstack.com/query/latest/docs/framework/angular/guides/render-optimizations#select) functions:

    // Type inference still works, so query.data will be the return type of select instead of queryFn
    queries = inject(QueriesService)
    
    query = injectQuery(() => ({
      ...groupOptions(1),
      select: (data) => data.title,
    }))
    

    // Type inference still works, so query.data will be the return type of select instead of queryFn
    queries = inject(QueriesService)
    
    query = injectQuery(() => ({
      ...groupOptions(1),
      select: (data) => data.title,
    }))</content>
</page>

<page>
  <title>Network Mode | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/guides/network-mode</url>
  <content>TanStack Query provides three different network modes to distinguish how [Queries](https://tanstack.com/query/latest/docs/framework/angular/guides/queries) and [Mutations](https://tanstack.com/query/latest/docs/framework/angular/guides/mutations) should behave if you have no network connection. This mode can be set for each Query / Mutation individually, or globally via the query / mutation defaults.

Since TanStack Query is most often used for data fetching in combination with data fetching libraries, the default network mode is [online](#network-mode-online).

[](#network-mode-online)[Network Mode: online](#network-mode-online)
--------------------------------------------------------------------

In this mode, Queries and Mutations will not fire unless you have network connection. This is the default mode. If a fetch is initiated for a query, it will always stay in the state (pending, error, success) it is in if the fetch cannot be made because there is no network connection. However, a [fetchStatus](https://tanstack.com/query/latest/docs/framework/angular/guides/queries#fetchstatus) is exposed additionally. This can be either:

*   fetching: The queryFn is really executing - a request is in-flight.
*   paused: The query is not executing - it is paused until you have connection again
*   idle: The query is not fetching and not paused

The flags isFetching and isPaused are derived from this state and exposed for convenience.

> Keep in mind that it might not be enough to check for pending state to show a loading spinner. Queries can be in state: 'pending', but fetchStatus: 'paused' if they are mounting for the first time, and you have no network connection.

If a query runs because you are online, but you go offline while the fetch is still happening, TanStack Query will also pause the retry mechanism. Paused queries will then continue to run once you re-gain network connection. This is independent of refetchOnReconnect (which also defaults to true in this mode), because it is not a refetch, but rather a continue. If the query has been [cancelled](https://tanstack.com/query/latest/docs/framework/angular/guides/query-cancellation) in the meantime, it will not continue.

[](#network-mode-always)[Network Mode: always](#network-mode-always)
--------------------------------------------------------------------

In this mode, TanStack Query will always fetch and ignore the online / offline state. This is likely the mode you want to choose if you use TanStack Query in an environment where you don't need an active network connection for your Queries to work - e.g. if you just read from AsyncStorage, or if you just want to return Promise.resolve(5) from your queryFn.

*   Queries will never be paused because you have no network connection.
*   Retries will also not pause - your Query will go to error state if it fails.
*   refetchOnReconnect defaults to false in this mode, because reconnecting to the network is not a good indicator anymore that stale queries should be refetched. You can still turn it on if you want.

[](#network-mode-offlinefirst)[Network Mode: offlineFirst](#network-mode-offlinefirst)
--------------------------------------------------------------------------------------

This mode is the middle ground between the first two options, where TanStack Query will run the queryFn once, but then pause retries. This is very handy if you have a serviceWorker that intercepts a request for caching like in an [offline-first PWA](https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Offline_Service_workers), or if you use HTTP caching via the [Cache-Control header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#the_cache-control_header).

In those situations, the first fetch might succeed because it comes from an offline storage / cache. However, if there is a cache miss, the network request will go out and fail, in which case this mode behaves like an online query - pausing retries.

The [TanStack Query Devtools](https://tanstack.com/query/latest/docs/framework/angular/devtools) will show Queries in a paused state if they would be fetching, but there is no network connection. There is also a toggle button to _Mock offline behavior_. Please note that this button will _not_ actually mess with your network connection (you can do that in the browser devtools), but it will set the [OnlineManager](https://tanstack.com/query/latest/docs/reference/onlineManager) in an offline state.

[](#signature)[Signature](#signature)
-------------------------------------

*   networkMode: 'online' | 'always' | 'offlineFirst'
    *   optional
    *   defaults to 'online'</content>
</page>

<page>
  <title>Parallel Queries | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/guides/parallel-queries</url>
  <content>"Parallel" queries are queries that are executed in parallel, or at the same time so as to maximize fetching concurrency.

[](#manual-parallel-queries)[Manual Parallel Queries](#manual-parallel-queries)
-------------------------------------------------------------------------------

When the number of parallel queries does not change, there is **no extra effort** to use parallel queries. Just use any number of TanStack Query's injectQuery and injectInfiniteQuery functions side-by-side!

    export class AppComponent {
      // The following queries will execute in parallel
      usersQuery = injectQuery(() => ({ queryKey: ['users'], queryFn: fetchUsers }))
      teamsQuery = injectQuery(() => ({ queryKey: ['teams'], queryFn: fetchTeams }))
      projectsQuery = injectQuery(() => ({
        queryKey: ['projects'],
        queryFn: fetchProjects,
      }))
    }
    

    export class AppComponent {
      // The following queries will execute in parallel
      usersQuery = injectQuery(() => ({ queryKey: ['users'], queryFn: fetchUsers }))
      teamsQuery = injectQuery(() => ({ queryKey: ['teams'], queryFn: fetchTeams }))
      projectsQuery = injectQuery(() => ({
        queryKey: ['projects'],
        queryFn: fetchProjects,
      }))
    }
    

[](#dynamic-parallel-queries-with-injectqueries)[Dynamic Parallel Queries with injectQueries](#dynamic-parallel-queries-with-injectqueries)
-------------------------------------------------------------------------------------------------------------------------------------------

TanStack Query provides injectQueries, which you can use to dynamically execute as many queries in parallel as you'd like.

injectQueries accepts an **options object** with a **queries key** whose value is an **array of query objects**. It returns an **array of query results**:

    export class AppComponent {
      users = signal<Array<User>>([])
    
      // Please note injectQueries is under development and this code does not work yet
      userQueries = injectQueries(() => ({
        queries: users().map((user) => {
          return {
            queryKey: ['user', user.id],
            queryFn: () => fetchUserById(user.id),
          }
        }),
      }))
    }
    

    export class AppComponent {
      users = signal<Array<User>>([])
    
      // Please note injectQueries is under development and this code does not work yet
      userQueries = injectQueries(() => ({
        queries: users().map((user) => {
          return {
            queryKey: ['user', user.id],
            queryFn: () => fetchUserById(user.id),
          }
        }),
      }))
    }</content>
</page>

<page>
  <title>Background Fetching Indicators | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/guides/background-fetching-indicators</url>
  <content>A query's status === 'pending' state is sufficient enough to show the initial hard-loading state for a query, but sometimes you may want to display an additional indicator that a query is refetching in the background. To do this, queries also supply you with an isFetching boolean that you can use to show that it's in a fetching state, regardless of the state of the status variable:

    @Component({
      selector: 'todos',
      template: `
        @if (todosQuery.isPending()) {
          Loading...
        } @else if (todosQuery.isError()) {
          An error has occurred: {{ todosQuery.error().message }}
        } @else if (todosQuery.isSuccess()) {
          @if (todosQuery.isFetching()) {
            Refreshing...
          }
          @for (todos of todosQuery.data(); track todo.id) {
            <todo [todo]="todo" />
          }
        }
      `,
    })
    class TodosComponent {
      todosQuery = injectQuery(() => ({
        queryKey: ['todos'],
        queryFn: fetchTodos,
      }))
    }
    

    @Component({
      selector: 'todos',
      template: `
        @if (todosQuery.isPending()) {
          Loading...
        } @else if (todosQuery.isError()) {
          An error has occurred: {{ todosQuery.error().message }}
        } @else if (todosQuery.isSuccess()) {
          @if (todosQuery.isFetching()) {
            Refreshing...
          }
          @for (todos of todosQuery.data(); track todo.id) {
            <todo [todo]="todo" />
          }
        }
      `,
    })
    class TodosComponent {
      todosQuery = injectQuery(() => ({
        queryKey: ['todos'],
        queryFn: fetchTodos,
      }))
    }
    

[](#displaying-global-background-fetching-loading-state)[Displaying Global Background Fetching Loading State](#displaying-global-background-fetching-loading-state)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------

In addition to individual query loading states, if you would like to show a global loading indicator when **any** queries are fetching (including in the background), you can use the injectIsFetching function:

    import { injectIsFetching } from '@tanstack/angular-query-experimental'
    
    @Component({
      selector: 'global-loading-indicator',
      template: `
        @if (isFetching()) {
          <div>Queries are fetching in the background...</div>
        }
      `,
    })
    export class GlobalLoadingIndicatorComponent {
      isFetching = injectIsFetching()
    }
    

    import { injectIsFetching } from '@tanstack/angular-query-experimental'
    
    @Component({
      selector: 'global-loading-indicator',
      template: `
        @if (isFetching()) {
          <div>Queries are fetching in the background...</div>
        }
      `,
    })
    export class GlobalLoadingIndicatorComponent {
      isFetching = injectIsFetching()
    }</content>
</page>

<page>
  <title>Window Focus Refetching | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/guides/window-focus-refetching</url>
  <content>If a user leaves your application and returns and the query data is stale, **TanStack Query automatically requests fresh data for you in the background**. You can disable this globally or per-query using the refetchOnWindowFocus option:

#### [](#disabling-globally)[Disabling Globally](#disabling-globally)

    export const appConfig: ApplicationConfig = {
      providers: [
        provideTanStackQuery(
          new QueryClient({
            defaultOptions: {
              queries: {
                refetchOnWindowFocus: false, // default: true
              },
            },
          }),
        ),
      ],
    }
    

    export const appConfig: ApplicationConfig = {
      providers: [
        provideTanStackQuery(
          new QueryClient({
            defaultOptions: {
              queries: {
                refetchOnWindowFocus: false, // default: true
              },
            },
          }),
        ),
      ],
    }
    

#### [](#disabling-per-query)[Disabling Per-Query](#disabling-per-query)

    injectQuery(() => ({
      queryKey: ['todos'],
      queryFn: fetchTodos,
      refetchOnWindowFocus: false,
    }))
    

    injectQuery(() => ({
      queryKey: ['todos'],
      queryFn: fetchTodos,
      refetchOnWindowFocus: false,
    }))
    

[](#custom-window-focus-event)[Custom Window Focus Event](#custom-window-focus-event)
-------------------------------------------------------------------------------------

In rare circumstances, you may want to manage your own window focus events that trigger TanStack Query to revalidate. To do this, TanStack Query provides a focusManager.setEventListener function that supplies you the callback that should be fired when the window is focused and allows you to set up your own events. When calling focusManager.setEventListener, the previously set handler is removed (which in most cases will be the default handler) and your new handler is used instead. For example, this is the default handler:

    focusManager.setEventListener((handleFocus) => {
      // Listen to visibilitychange
      if (typeof window !== 'undefined' && window.addEventListener) {
        const visibilitychangeHandler = () => {
          handleFocus(document.visibilityState === 'visible')
        }
        window.addEventListener('visibilitychange', visibilitychangeHandler, false)
        return () => {
          // Be sure to unsubscribe if a new handler is set
          window.removeEventListener('visibilitychange', visibilitychangeHandler)
        }
      }
    })
    

    focusManager.setEventListener((handleFocus) => {
      // Listen to visibilitychange
      if (typeof window !== 'undefined' && window.addEventListener) {
        const visibilitychangeHandler = () => {
          handleFocus(document.visibilityState === 'visible')
        }
        window.addEventListener('visibilitychange', visibilitychangeHandler, false)
        return () => {
          // Be sure to unsubscribe if a new handler is set
          window.removeEventListener('visibilitychange', visibilitychangeHandler)
        }
      }
    })
    

[](#managing-focus-state)[Managing focus state](#managing-focus-state)
----------------------------------------------------------------------

    import { focusManager } from '@tanstack/angular-query-experimental'
    
    // Override the default focus state
    focusManager.setFocused(true)
    
    // Fallback to the default focus check
    focusManager.setFocused(undefined)
    

    import { focusManager } from '@tanstack/angular-query-experimental'
    
    // Override the default focus state
    focusManager.setFocused(true)
    
    // Fallback to the default focus check
    focusManager.setFocused(undefined)</content>
</page>

<page>
  <title>Disabling/Pausing Queries | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/guides/disabling-queries</url>
  <content>If you ever want to disable a query from automatically running, you can use the enabled = false option. The enabled option also accepts a callback that returns a boolean.

When enabled is false:

*   If the query has cached data, then the query will be initialized in the status === 'success' or isSuccess state.
*   If the query does not have cached data, then the query will start in the status === 'pending' and fetchStatus === 'idle' state.
*   The query will not automatically fetch on mount.
*   The query will not automatically refetch in the background.
*   The query will ignore query client invalidateQueries and refetchQueries calls that would normally result in the query refetching.
*   refetch returned from injectQuery can be used to manually trigger the query to fetch. However, it will not work with skipToken.

> TypeScript users may prefer to use [skipToken](#typesafe-disabling-of-queries-using-skiptoken) as an alternative to enabled = false.

    @Component({
      selector: 'todos',
      template: `<div>
        <button (click)="query.refetch()">Fetch Todos</button>
    
        @if (query.data()) {
          <ul>
            @for (todo of query.data(); track todo.id) {
              <li>{{ todo.title }}</li>
            }
          </ul>
        } @else {
          @if (query.isError()) {
            <span>Error: {{ query.error().message }}</span>
          } @else if (query.isLoading()) {
            <span>Loading...</span>
          } @else if (!query.isLoading() && !query.isError()) {
            <span>Not ready ...</span>
          }
        }
    
        <div>{{ query.isLoading() ? 'Fetching...' : '' }}</div>
      </div>`,
    })
    export class TodosComponent {
      query = injectQuery(() => ({
        queryKey: ['todos'],
        queryFn: fetchTodoList,
        enabled: false,
      }))
    }
    

    @Component({
      selector: 'todos',
      template: `<div>
        <button (click)="query.refetch()">Fetch Todos</button>
    
        @if (query.data()) {
          <ul>
            @for (todo of query.data(); track todo.id) {
              <li>{{ todo.title }}</li>
            }
          </ul>
        } @else {
          @if (query.isError()) {
            <span>Error: {{ query.error().message }}</span>
          } @else if (query.isLoading()) {
            <span>Loading...</span>
          } @else if (!query.isLoading() && !query.isError()) {
            <span>Not ready ...</span>
          }
        }
    
        <div>{{ query.isLoading() ? 'Fetching...' : '' }}</div>
      </div>`,
    })
    export class TodosComponent {
      query = injectQuery(() => ({
        queryKey: ['todos'],
        queryFn: fetchTodoList,
        enabled: false,
      }))
    }
    

Permanently disabling a query opts out of many great features that TanStack Query has to offer (like background refetches), and it's also not the idiomatic way. It takes you from the declarative approach (defining dependencies when your query should run) into an imperative mode (fetch whenever I click here). It is also not possible to pass parameters to refetch. Oftentimes, all you want is a lazy query that defers the initial fetch:

[](#lazy-queries)[Lazy Queries](#lazy-queries)
----------------------------------------------

The enabled option can not only be used to permanently disable a query, but also to enable / disable it at a later time. A good example would be a filter form where you only want to fire off the first request once the user has entered a filter value:

    @Component({
      selector: 'todos',
      template: `
        <div>
          // üöÄ applying the filter will enable and execute the query
          <filters-form onApply="filter.set" />
          <todos-table data="query.data()" />
        </div>
      `,
    })
    export class TodosComponent {
      filter = signal('')
    
      todosQuery = injectQuery(() => ({
        queryKey: ['todos', this.filter()],
        queryFn: () => fetchTodos(this.filter()),
        enabled: !!this.filter(),
      }))
    }
    

    @Component({
      selector: 'todos',
      template: `
        <div>
          // üöÄ applying the filter will enable and execute the query
          <filters-form onApply="filter.set" />
          <todos-table data="query.data()" />
        </div>
      `,
    })
    export class TodosComponent {
      filter = signal('')
    
      todosQuery = injectQuery(() => ({
        queryKey: ['todos', this.filter()],
        queryFn: () => fetchTodos(this.filter()),
        enabled: !!this.filter(),
      }))
    }
    

### [](#isloading-previously-isinitialloading)[isLoading (Previously: isInitialLoading)](#isloading-previously-isinitialloading)

Lazy queries will be in status: 'pending' right from the start because pending means that there is no data yet. This is technically true, however, since we are not currently fetching any data (as the query is not _enabled_), it also means you likely cannot use this flag to show a loading spinner.

If you are using disabled or lazy queries, you can use the isLoading flag instead. It's a derived flag that is computed from:

isPending && isFetching

so it will only be true if the query is currently fetching for the first time.

[](#typesafe-disabling-of-queries-using-skiptoken)[Typesafe disabling of queries using skipToken](#typesafe-disabling-of-queries-using-skiptoken)
-------------------------------------------------------------------------------------------------------------------------------------------------

If you are using TypeScript, you can use the skipToken to disable a query. This is useful when you want to disable a query based on a condition, but you still want to keep the query to be type safe.

> **IMPORTANT**: refetch from injectQuery will not work with skipToken. Calling refetch() on a query that uses skipToken will result in a Missing queryFn error because there is no valid query function to execute. If you need to manually trigger queries, consider using enabled: false instead, which allows refetch() to work properly. Other than this limitation, skipToken works the same as enabled: false.

    import { skipToken, injectQuery } from '@tanstack/query-angular'
    
    @Component({
      selector: 'todos',
      template: `
        <div>
          // üöÄ applying the filter will enable and execute the query
          <filters-form onApply="filter.set" />
          <todos-table data="query.data()" />
        </div>
      `,
    })
    export class TodosComponent {
      filter = signal('')
    
      todosQuery = injectQuery(() => ({
        queryKey: ['todos', this.filter()],
        queryFn: this.filter() ? () => fetchTodos(this.filter()) : skipToken,
      }))
    }
    

    import { skipToken, injectQuery } from '@tanstack/query-angular'
    
    @Component({
      selector: 'todos',
      template: `
        <div>
          // üöÄ applying the filter will enable and execute the query
          <filters-form onApply="filter.set" />
          <todos-table data="query.data()" />
        </div>
      `,
    })
    export class TodosComponent {
      filter = signal('')
    
      todosQuery = injectQuery(() => ({
        queryKey: ['todos', this.filter()],
        queryFn: this.filter() ? () => fetchTodos(this.filter()) : skipToken,
      }))
    }</content>
</page>

<page>
  <title>Infinite Queries | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/guides/infinite-queries</url>
  <content>Rendering lists that can additively "load more" data onto an existing set of data or "infinite scroll" is also a very common UI pattern. TanStack Query supports a useful version of injectQuery called injectInfiniteQuery for querying these types of lists.

When using injectInfiniteQuery, you'll notice a few things are different:

*   data is now an object containing infinite query data:
*   data.pages array containing the fetched pages
*   data.pageParams array containing the page params used to fetch the pages
*   The fetchNextPage and fetchPreviousPage functions are now available (fetchNextPage is required)
*   The initialPageParam option is now available (and required) to specify the initial page param
*   The getNextPageParam and getPreviousPageParam options are available for both determining if there is more data to load and the information to fetch it. This information is supplied as an additional parameter in the query function
*   A hasNextPage boolean is now available and is true if getNextPageParam returns a value other than null or undefined
*   A hasPreviousPage boolean is now available and is true if getPreviousPageParam returns a value other than null or undefined
*   The isFetchingNextPage and isFetchingPreviousPage booleans are now available to distinguish between a background refresh state and a loading more state

> Note: Options initialData or placeholderData need to conform to the same structure of an object with data.pages and data.pageParams properties.

[](#example)[Example](#example)
-------------------------------

Let's assume we have an API that returns pages of projects 3 at a time based on a cursor index along with a cursor that can be used to fetch the next group of projects:

    fetch('/api/projects?cursor=0')
    // { data: [...], nextCursor: 3}
    fetch('/api/projects?cursor=3')
    // { data: [...], nextCursor: 6}
    fetch('/api/projects?cursor=6')
    // { data: [...], nextCursor: 9}
    fetch('/api/projects?cursor=9')
    // { data: [...] }
    

    fetch('/api/projects?cursor=0')
    // { data: [...], nextCursor: 3}
    fetch('/api/projects?cursor=3')
    // { data: [...], nextCursor: 6}
    fetch('/api/projects?cursor=6')
    // { data: [...], nextCursor: 9}
    fetch('/api/projects?cursor=9')
    // { data: [...] }
    

With this information, we can create a "Load More" UI by:

*   Waiting for injectInfiniteQuery to request the first group of data by default
*   Returning the information for the next query in getNextPageParam
*   Calling fetchNextPage function

    import { Component, computed, inject } from '@angular/core'
    import { injectInfiniteQuery } from '@tanstack/angular-query-experimental'
    import { lastValueFrom } from 'rxjs'
    import { ProjectsService } from './projects-service'
    
    @Component({
      selector: 'example',
      templateUrl: './example.component.html',
    })
    export class Example {
      projectsService = inject(ProjectsService)
    
      query = injectInfiniteQuery(() => ({
        queryKey: ['projects'],
        queryFn: async ({ pageParam }) => {
          return lastValueFrom(this.projectsService.getProjects(pageParam))
        },
        initialPageParam: 0,
        getPreviousPageParam: (firstPage) => firstPage.previousId ?? undefined,
        getNextPageParam: (lastPage) => lastPage.nextId ?? undefined,
        maxPages: 3,
      }))
    
      nextButtonDisabled = computed(
        () => !this.#hasNextPage() || this.#isFetchingNextPage(),
      )
      nextButtonText = computed(() =>
        this.#isFetchingNextPage()
          ? 'Loading more...'
          : this.#hasNextPage()
            ? 'Load newer'
            : 'Nothing more to load',
      )
    
      #hasNextPage = this.query.hasNextPage
      #isFetchingNextPage = this.query.isFetchingNextPage
    }
    

    import { Component, computed, inject } from '@angular/core'
    import { injectInfiniteQuery } from '@tanstack/angular-query-experimental'
    import { lastValueFrom } from 'rxjs'
    import { ProjectsService } from './projects-service'
    
    @Component({
      selector: 'example',
      templateUrl: './example.component.html',
    })
    export class Example {
      projectsService = inject(ProjectsService)
    
      query = injectInfiniteQuery(() => ({
        queryKey: ['projects'],
        queryFn: async ({ pageParam }) => {
          return lastValueFrom(this.projectsService.getProjects(pageParam))
        },
        initialPageParam: 0,
        getPreviousPageParam: (firstPage) => firstPage.previousId ?? undefined,
        getNextPageParam: (lastPage) => lastPage.nextId ?? undefined,
        maxPages: 3,
      }))
    
      nextButtonDisabled = computed(
        () => !this.#hasNextPage() || this.#isFetchingNextPage(),
      )
      nextButtonText = computed(() =>
        this.#isFetchingNextPage()
          ? 'Loading more...'
          : this.#hasNextPage()
            ? 'Load newer'
            : 'Nothing more to load',
      )
    
      #hasNextPage = this.query.hasNextPage
      #isFetchingNextPage = this.query.isFetchingNextPage
    }
    

    <div>
      @if (query.isPending()) {
      <p>Loading...</p>
      } @else if (query.isError()) {
      <span>Error: {{ query?.error().message }}</span>
      } @else { @for (page of query?.data().pages; track $index) { @for (project of
      page.data; track project.id) {
      <p>{{ project.name }} {{ project.id }}</p>
      } }
      <div>
        <button (click)="query.fetchNextPage()" [disabled]="nextButtonDisabled()">
          {{ nextButtonText() }}
        </button>
      </div>
      }
    </div>
    

    <div>
      @if (query.isPending()) {
      <p>Loading...</p>
      } @else if (query.isError()) {
      <span>Error: {{ query?.error().message }}</span>
      } @else { @for (page of query?.data().pages; track $index) { @for (project of
      page.data; track project.id) {
      <p>{{ project.name }} {{ project.id }}</p>
      } }
      <div>
        <button (click)="query.fetchNextPage()" [disabled]="nextButtonDisabled()">
          {{ nextButtonText() }}
        </button>
      </div>
      }
    </div>
    

It's essential to understand that calling fetchNextPage while an ongoing fetch is in progress runs the risk of overwriting data refreshes happening in the background. This situation becomes particularly critical when rendering a list and triggering fetchNextPage simultaneously.

Remember, there can only be a single ongoing fetch for an InfiniteQuery. A single cache entry is shared for all pages, attempting to fetch twice simultaneously might lead to data overwrites.

If you intend to enable simultaneous fetching, you can utilize the { cancelRefetch: false } option (default: true) within fetchNextPage.

To ensure a seamless querying process without conflicts, it's highly recommended to verify that the query is not in an isFetching state, especially if the user won't directly control that call.

    @Component({
      template: ` <list-component (endReached)="fetchNextPage()" /> `,
    })
    export class Example {
      query = injectInfiniteQuery(() => ({
        queryKey: ['projects'],
        queryFn: async ({ pageParam }) => {
          return lastValueFrom(this.projectsService.getProjects(pageParam))
        },
      }))
    
      fetchNextPage() {
        // Do nothing if already fetching
        if (this.query.isFetching()) return
        this.query.fetchNextPage()
      }
    }
    

    @Component({
      template: ` <list-component (endReached)="fetchNextPage()" /> `,
    })
    export class Example {
      query = injectInfiniteQuery(() => ({
        queryKey: ['projects'],
        queryFn: async ({ pageParam }) => {
          return lastValueFrom(this.projectsService.getProjects(pageParam))
        },
      }))
    
      fetchNextPage() {
        // Do nothing if already fetching
        if (this.query.isFetching()) return
        this.query.fetchNextPage()
      }
    }
    

[](#what-happens-when-an-infinite-query-needs-to-be-refetched)[What happens when an infinite query needs to be refetched?](#what-happens-when-an-infinite-query-needs-to-be-refetched)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

When an infinite query becomes stale and needs to be refetched, each group is fetched sequentially, starting from the first one. This ensures that even if the underlying data is mutated, we're not using stale cursors and potentially getting duplicates or skipping records. If an infinite query's results are ever removed from the queryCache, the pagination restarts at the initial state with only the initial group being requested.

[](#what-if-i-want-to-implement-a-bi-directional-infinite-list)[What if I want to implement a bi-directional infinite list?](#what-if-i-want-to-implement-a-bi-directional-infinite-list)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Bi-directional lists can be implemented by using the getPreviousPageParam, fetchPreviousPage, hasPreviousPage and isFetchingPreviousPage properties and functions.

    query = injectInfiniteQuery(() => ({
      queryKey: ['projects'],
      queryFn: fetchProjects,
      getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
      getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,
    }))
    

    query = injectInfiniteQuery(() => ({
      queryKey: ['projects'],
      queryFn: fetchProjects,
      getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
      getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,
    }))
    

[](#what-if-i-want-to-show-the-pages-in-reversed-order)[What if I want to show the pages in reversed order?](#what-if-i-want-to-show-the-pages-in-reversed-order)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------

Sometimes you may want to show the pages in reversed order. If this is case, you can use the select option:

    query = injectInfiniteQuery(() => ({
      queryKey: ['projects'],
      queryFn: fetchProjects,
      select: (data) => ({
        pages: [...data.pages].reverse(),
        pageParams: [...data.pageParams].reverse(),
      }),
    }))
    

    query = injectInfiniteQuery(() => ({
      queryKey: ['projects'],
      queryFn: fetchProjects,
      select: (data) => ({
        pages: [...data.pages].reverse(),
        pageParams: [...data.pageParams].reverse(),
      }),
    }))
    

[](#what-if-i-want-to-manually-update-the-infinite-query)[What if I want to manually update the infinite query?](#what-if-i-want-to-manually-update-the-infinite-query)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

### [](#manually-removing-first-page)[Manually removing first page:](#manually-removing-first-page)

    queryClient.setQueryData(['projects'], (data) => ({
      pages: data.pages.slice(1),
      pageParams: data.pageParams.slice(1),
    }))
    

    queryClient.setQueryData(['projects'], (data) => ({
      pages: data.pages.slice(1),
      pageParams: data.pageParams.slice(1),
    }))
    

### [](#manually-removing-a-single-value-from-an-individual-page)[Manually removing a single value from an individual page:](#manually-removing-a-single-value-from-an-individual-page)

    const newPagesArray =
      oldPagesArray?.pages.map((page) =>
        page.filter((val) => val.id !== updatedId),
      ) ?? []
    
    queryClient.setQueryData(['projects'], (data) => ({
      pages: newPagesArray,
      pageParams: data.pageParams,
    }))
    

    const newPagesArray =
      oldPagesArray?.pages.map((page) =>
        page.filter((val) => val.id !== updatedId),
      ) ?? []
    
    queryClient.setQueryData(['projects'], (data) => ({
      pages: newPagesArray,
      pageParams: data.pageParams,
    }))
    

### [](#keep-only-the-first-page)[Keep only the first page:](#keep-only-the-first-page)

    queryClient.setQueryData(['projects'], (data) => ({
      pages: data.pages.slice(0, 1),
      pageParams: data.pageParams.slice(0, 1),
    }))
    

    queryClient.setQueryData(['projects'], (data) => ({
      pages: data.pages.slice(0, 1),
      pageParams: data.pageParams.slice(0, 1),
    }))
    

Make sure to always keep the same data structure of pages and pageParams!

[](#what-if-i-want-to-limit-the-number-of-pages)[What if I want to limit the number of pages?](#what-if-i-want-to-limit-the-number-of-pages)
--------------------------------------------------------------------------------------------------------------------------------------------

In some use cases you may want to limit the number of pages stored in the query data to improve the performance and UX:

*   when the user can load a large number of pages (memory usage)
*   when you have to refetch an infinite query that contains dozens of pages (network usage: all the pages are sequentially fetched)

The solution is to use a "Limited Infinite Query". This is made possible by using the maxPages option in conjunction with getNextPageParam and getPreviousPageParam to allow fetching pages when needed in both directions.

In the following example only 3 pages are kept in the query data pages array. If a refetch is needed, only 3 pages will be refetched sequentially.

    injectInfiniteQuery(() => ({
      queryKey: ['projects'],
      queryFn: fetchProjects,
      initialPageParam: 0,
      getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
      getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,
      maxPages: 3,
    }))
    

    injectInfiniteQuery(() => ({
      queryKey: ['projects'],
      queryFn: fetchProjects,
      initialPageParam: 0,
      getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
      getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,
      maxPages: 3,
    }))
    

[](#what-if-my-api-doesnt-return-a-cursor)[What if my API doesn't return a cursor?](#what-if-my-api-doesnt-return-a-cursor)
---------------------------------------------------------------------------------------------------------------------------

If your API doesn't return a cursor, you can use the pageParam as a cursor. Because getNextPageParam and getPreviousPageParam also get the pageParamof the current page, you can use it to calculate the next / previous page param.

    injectInfiniteQuery(() => ({
      queryKey: ['projects'],
      queryFn: fetchProjects,
      initialPageParam: 0,
      getNextPageParam: (lastPage, allPages, lastPageParam) => {
        if (lastPage.length === 0) {
          return undefined
        }
        return lastPageParam + 1
      },
      getPreviousPageParam: (firstPage, allPages, firstPageParam) => {
        if (firstPageParam <= 1) {
          return undefined
        }
        return firstPageParam - 1
      },
    }))
    

    injectInfiniteQuery(() => ({
      queryKey: ['projects'],
      queryFn: fetchProjects,
      initialPageParam: 0,
      getNextPageParam: (lastPage, allPages, lastPageParam) => {
        if (lastPage.length === 0) {
          return undefined
        }
        return lastPageParam + 1
      },
      getPreviousPageParam: (firstPage, allPages, firstPageParam) => {
        if (firstPageParam <= 1) {
          return undefined
        }
        return firstPageParam - 1
      },
    }))
    

[](#further-reading)[Further reading](#further-reading)
-------------------------------------------------------

To get a better understanding of how Infinite Queries work under the hood, see the article [How Infinite Queries work](https://tkdodo.eu/blog/how-infinite-queries-work).</content>
</page>

<page>
  <title>Query Retries | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/guides/query-retries</url>
  <content>When a injectQuery query fails (the query function throws an error), TanStack Query will automatically retry the query if that query's request has not reached the max number of consecutive retries (defaults to 3) or a function is provided to determine if a retry is allowed.

You can configure retries both on a global level and an individual query level.

*   Setting retry = false will disable retries.
*   Setting retry = 6 will retry failing requests 6 times before showing the final error thrown by the function.
*   Setting retry = true will infinitely retry failing requests.
*   Setting retry = (failureCount, error) => ... allows for custom logic based on why the request failed.

    import { injectQuery } from '@tanstack/angular-query-experimental'
    
    // Make a specific query retry a certain number of times
    const result = injectQuery(() => ({
      queryKey: ['todos', 1],
      queryFn: fetchTodoListPage,
      retry: 10, // Will retry failed requests 10 times before displaying an error
    }))
    

    import { injectQuery } from '@tanstack/angular-query-experimental'
    
    // Make a specific query retry a certain number of times
    const result = injectQuery(() => ({
      queryKey: ['todos', 1],
      queryFn: fetchTodoListPage,
      retry: 10, // Will retry failed requests 10 times before displaying an error
    }))
    

> Info: Contents of the error property will be part of failureReason response property of injectQuery until the last retry attempt. So in above example any error contents will be part of failureReason property for first 9 retry attempts (Overall 10 attempts) and finally they will be part of error after last attempt if error persists after all retry attempts.

[](#retry-delay)[Retry Delay](#retry-delay)
-------------------------------------------

By default, retries in TanStack Query do not happen immediately after a request fails. As is standard, a back-off delay is gradually applied to each retry attempt.

The default retryDelay is set to double (starting at 1000ms) with each attempt, but not exceed 30 seconds:

    // Configure for all queries
    import {
      QueryCache,
      QueryClient,
      QueryClientProvider,
    } from '@tanstack/angular-query-experimental'
    
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
        },
      },
    })
    
    bootstrapApplication(AppComponent, {
      providers: [provideTanStackQuery(queryClient)],
    })
    

    // Configure for all queries
    import {
      QueryCache,
      QueryClient,
      QueryClientProvider,
    } from '@tanstack/angular-query-experimental'
    
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
        },
      },
    })
    
    bootstrapApplication(AppComponent, {
      providers: [provideTanStackQuery(queryClient)],
    })
    

Though it is not recommended, you can obviously override the retryDelay function/integer in both the Plugin and individual query options. If set to an integer instead of a function the delay will always be the same amount of time:

    const result = injectQuery(() => ({
      queryKey: ['todos'],
      queryFn: fetchTodoList,
      retryDelay: 1000, // Will always wait 1000ms to retry, regardless of how many retries
    }))
    

    const result = injectQuery(() => ({
      queryKey: ['todos'],
      queryFn: fetchTodoList,
      retryDelay: 1000, // Will always wait 1000ms to retry, regardless of how many retries
    }))
    

[](#background-retry-behavior)[Background Retry Behavior](#background-retry-behavior)
-------------------------------------------------------------------------------------

When using refetchInterval with refetchIntervalInBackground: true, retries will pause when the browser tab is inactive. This happens because retries respect the same focus behavior as regular refetches.

If you need continuous retries in the background, consider disabling retries and implementing a custom refetch strategy:

    const result = injectQuery({
      queryKey: ['todos'],
      queryFn: fetchTodos,
      refetchInterval: (query) => {
        // Refetch more frequently when in error state
        return query.state.status === 'error' ? 5000 : 30000
      },
      refetchIntervalInBackground: true,
      retry: false, // Disable built-in retries
    })
    

    const result = injectQuery({
      queryKey: ['todos'],
      queryFn: fetchTodos,
      refetchInterval: (query) => {
        // Refetch more frequently when in error state
        return query.state.status === 'error' ? 5000 : 30000
      },
      refetchIntervalInBackground: true,
      retry: false, // Disable built-in retries
    })
    

This approach lets you control retry timing manually while keeping refetches active in the background.</content>
</page>

<page>
  <title>Paginated / Lagged Queries | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/guides/paginated-queries</url>
  <content>Rendering paginated data is a very common UI pattern and in TanStack Query, it "just works" by including the page information in the query key:

    const result = injectQuery(() => ({
      queryKey: ['projects', page()],
      queryFn: fetchProjects,
    }))
    

    const result = injectQuery(() => ({
      queryKey: ['projects', page()],
      queryFn: fetchProjects,
    }))
    

However, if you run this simple example, you might notice something strange:

**The UI jumps in and out of the success and pending states because each new page is treated like a brand new query.**

This experience is not optimal and unfortunately is how many tools today insist on working. But not TanStack Query! As you may have guessed, TanStack Query comes with an awesome feature called placeholderData that allows us to get around this.

[](#better-paginated-queries-with-placeholderdata)[Better Paginated Queries with placeholderData](#better-paginated-queries-with-placeholderdata)
-------------------------------------------------------------------------------------------------------------------------------------------------

Consider the following example where we would ideally want to increment a pageIndex (or cursor) for a query. If we were to use injectQuery, **it would still technically work fine**, but the UI would jump in and out of the success and pending states as different queries are created and destroyed for each page or cursor. By setting placeholderData to (previousData) => previousData or keepPreviousData function exported from TanStack Query, we get a few new things:

*   **The data from the last successful fetch is available while new data is being requested, even though the query key has changed**.
*   When the new data arrives, the previous data is seamlessly swapped to show the new data.
*   isPlaceholderData is made available to know what data the query is currently providing you

    @Component({
      selector: 'pagination-example',
      template: `
        <div>
          <p>
            In this example, each page of data remains visible as the next page is
            fetched. The buttons and capability to proceed to the next page are also
            suppressed until the next page cursor is known. Each page is cached as a
            normal query too, so when going to previous pages, you'll see them
            instantaneously while they are also re-fetched invisibly in the
            background.
          </p>
          @if (query.status() === 'pending') {
            <div>Loading...</div>
          } @else if (query.status() === 'error') {
            <div>Error: {{ query.error().message }}</div>
          } @else {
            <!-- 'data' will either resolve to the latest page's data -->
            <!-- or if fetching a new page, the last successful page's data -->
            <div>
              @for (project of query.data().projects; track project.id) {
                <p>{{ project.name }}</p>
              }
            </div>
          }
    
          <div>Current Page: {{ page() + 1 }}</div>
          <button (click)="previousPage()" [disabled]="page() === 0">
            Previous Page
          </button>
          <button
            (click)="nextPage()"
            [disabled]="query.isPlaceholderData() || !query.data()?.hasMore"
          >
            Next Page
          </button>
          <!-- Since the last page's data potentially sticks around between page requests, -->
          <!-- we can use 'isFetching' to show a background loading -->
          <!-- indicator since our status === 'pending' state won't be triggered -->
          @if (query.isFetching()) {
            <span> Loading...</span>
          }
        </div>
      `,
    })
    export class PaginationExampleComponent {
      page = signal(0)
      queryClient = inject(QueryClient)
    
      query = injectQuery(() => ({
        queryKey: ['projects', this.page()],
        queryFn: () => lastValueFrom(fetchProjects(this.page())),
        placeholderData: keepPreviousData,
        staleTime: 5000,
      }))
    
      constructor() {
        effect(() => {
          // Prefetch the next page!
          if (!this.query.isPlaceholderData() && this.query.data()?.hasMore) {
            this.#queryClient.prefetchQuery({
              queryKey: ['projects', this.page() + 1],
              queryFn: () => lastValueFrom(fetchProjects(this.page() + 1)),
            })
          }
        })
      }
    
      previousPage() {
        this.page.update((old) => Math.max(old - 1, 0))
      }
    
      nextPage() {
        this.page.update((old) => (this.query.data()?.hasMore ? old + 1 : old))
      }
    }
    

    @Component({
      selector: 'pagination-example',
      template: `
        <div>
          <p>
            In this example, each page of data remains visible as the next page is
            fetched. The buttons and capability to proceed to the next page are also
            suppressed until the next page cursor is known. Each page is cached as a
            normal query too, so when going to previous pages, you'll see them
            instantaneously while they are also re-fetched invisibly in the
            background.
          </p>
          @if (query.status() === 'pending') {
            <div>Loading...</div>
          } @else if (query.status() === 'error') {
            <div>Error: {{ query.error().message }}</div>
          } @else {
            <!-- 'data' will either resolve to the latest page's data -->
            <!-- or if fetching a new page, the last successful page's data -->
            <div>
              @for (project of query.data().projects; track project.id) {
                <p>{{ project.name }}</p>
              }
            </div>
          }
    
          <div>Current Page: {{ page() + 1 }}</div>
          <button (click)="previousPage()" [disabled]="page() === 0">
            Previous Page
          </button>
          <button
            (click)="nextPage()"
            [disabled]="query.isPlaceholderData() || !query.data()?.hasMore"
          >
            Next Page
          </button>
          <!-- Since the last page's data potentially sticks around between page requests, -->
          <!-- we can use 'isFetching' to show a background loading -->
          <!-- indicator since our status === 'pending' state won't be triggered -->
          @if (query.isFetching()) {
            <span> Loading...</span>
          }
        </div>
      `,
    })
    export class PaginationExampleComponent {
      page = signal(0)
      queryClient = inject(QueryClient)
    
      query = injectQuery(() => ({
        queryKey: ['projects', this.page()],
        queryFn: () => lastValueFrom(fetchProjects(this.page())),
        placeholderData: keepPreviousData,
        staleTime: 5000,
      }))
    
      constructor() {
        effect(() => {
          // Prefetch the next page!
          if (!this.query.isPlaceholderData() && this.query.data()?.hasMore) {
            this.#queryClient.prefetchQuery({
              queryKey: ['projects', this.page() + 1],
              queryFn: () => lastValueFrom(fetchProjects(this.page() + 1)),
            })
          }
        })
      }
    
      previousPage() {
        this.page.update((old) => Math.max(old - 1, 0))
      }
    
      nextPage() {
        this.page.update((old) => (this.query.data()?.hasMore ? old + 1 : old))
      }
    }
    

[](#lagging-infinite-query-results-with-placeholderdata)[Lagging Infinite Query results with placeholderData](#lagging-infinite-query-results-with-placeholderdata)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------

While not as common, the placeholderData option also works flawlessly with the injectInfiniteQuery function, so you can seamlessly allow your users to continue to see cached data while infinite query keys change over time.</content>
</page>

<page>
  <title>Placeholder Query Data | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/guides/placeholder-query-data</url>
  <content>[](#what-is-placeholder-data)[What is placeholder data?](#what-is-placeholder-data)
-----------------------------------------------------------------------------------

Placeholder data allows a query to behave as if it already has data, similar to the initialData option, but **the data is not persisted to the cache**. This comes in handy for situations where you have enough partial (or fake) data to render the query successfully while the actual data is fetched in the background.

> Example: An individual blog post query could pull "preview" data from a parent list of blog posts that only include title and a small snippet of the post body. You would not want to persist this partial data to the query result of the individual query, but it is useful for showing the content layout as quickly as possible while the actual query finishes to fetch the entire object.

There are a few ways to supply placeholder data for a query to the cache before you need it:

*   Declaratively:
    *   Provide placeholderData to a query to prepopulate its cache if empty
*   Imperatively:
    *   [Prefetch or fetch the data using queryClient and the placeholderData option](https://tanstack.com/query/latest/docs/framework/angular/guides/prefetching)

When we use placeholderData, our Query will not be in a pending state - it will start out as being in success state, because we have data to display - even if that data is just "placeholder" data. To distinguish it from "real" data, we will also have the isPlaceholderData flag set to true on the Query result.

[](#placeholder-data-as-a-value)[Placeholder Data as a Value](#placeholder-data-as-a-value)
-------------------------------------------------------------------------------------------

    class TodosComponent {
      result = injectQuery(() => ({
        queryKey: ['todos'],
        queryFn: () => fetch('/todos'),
        placeholderData: placeholderTodos,
      }))
    }
    

    class TodosComponent {
      result = injectQuery(() => ({
        queryKey: ['todos'],
        queryFn: () => fetch('/todos'),
        placeholderData: placeholderTodos,
      }))
    }
    

[](#placeholder-data-as-a-function)[Placeholder Data as a Function](#placeholder-data-as-a-function)
----------------------------------------------------------------------------------------------------

placeholderData can also be a function, where you can get access to the data and Query meta information of a "previous" successful Query. This is useful for situations where you want to use the data from one query as the placeholder data for another query. When the QueryKey changes, e.g. from \['todos', 1\] to \['todos', 2\], we can keep displaying "old" data instead of having to show a loading spinner while data is _transitioning_ from one Query to the next. For more information, see [Paginated Queries](https://tanstack.com/query/latest/docs/framework/angular/guides/paginated-queries).

    class TodosComponent {
      result = injectQuery(() => ({
        queryKey: ['todos', id()],
        queryFn: () => fetch(`/todos/${id}`),
        placeholderData: (previousData, previousQuery) => previousData,
      }))
    }
    

    class TodosComponent {
      result = injectQuery(() => ({
        queryKey: ['todos', id()],
        queryFn: () => fetch(`/todos/${id}`),
        placeholderData: (previousData, previousQuery) => previousData,
      }))
    }
    

### [](#placeholder-data-from-cache)[Placeholder Data from Cache](#placeholder-data-from-cache)

In some circumstances, you may be able to provide the placeholder data for a query from the cached result of another. A good example of this would be searching the cached data from a blog post list query for a preview version of the post, then using that as the placeholder data for your individual post query:

    export class BlogPostComponent {
      postId = input.required<number>()
      queryClient = inject(QueryClient)
    
      result = injectQuery(() => ({
        queryKey: ['blogPost', this.postId()],
        queryFn: () => fetch(`/blogPosts/${this.postId()}`),
        placeholderData: () => {
          // Use the smaller/preview version of the blogPost from the 'blogPosts'
          // query as the placeholder data for this blogPost query
          return this.queryClient
            .getQueryData(['blogPosts'])
            ?.find((d) => d.id === this.postId())
        },
      }))
    }
    

    export class BlogPostComponent {
      postId = input.required<number>()
      queryClient = inject(QueryClient)
    
      result = injectQuery(() => ({
        queryKey: ['blogPost', this.postId()],
        queryFn: () => fetch(`/blogPosts/${this.postId()}`),
        placeholderData: () => {
          // Use the smaller/preview version of the blogPost from the 'blogPosts'
          // query as the placeholder data for this blogPost query
          return this.queryClient
            .getQueryData(['blogPosts'])
            ?.find((d) => d.id === this.postId())
        },
      }))
    }</content>
</page>

<page>
  <title>Dependent Queries | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/guides/dependent-queries</url>
  <content>[](#injectquery-dependent-query)[injectQuery dependent Query](#injectquery-dependent-query)
-------------------------------------------------------------------------------------------

Dependent (or serial) queries depend on previous ones to finish before they can execute. To achieve this, it's as easy as using the enabled option to tell a query when it is ready to run:

    // Get the user
    userQuery = injectQuery(() => ({
      queryKey: ['user', email],
      queryFn: getUserByEmail,
    }))
    
    // Then get the user's projects
    projectsQuery = injectQuery(() => ({
      queryKey: ['projects', this.userQuery.data()?.id],
      queryFn: getProjectsByUser,
      // The query will not execute until the user id exists
      enabled: !!this.userQuery.data()?.id,
    }))
    

    // Get the user
    userQuery = injectQuery(() => ({
      queryKey: ['user', email],
      queryFn: getUserByEmail,
    }))
    
    // Then get the user's projects
    projectsQuery = injectQuery(() => ({
      queryKey: ['projects', this.userQuery.data()?.id],
      queryFn: getProjectsByUser,
      // The query will not execute until the user id exists
      enabled: !!this.userQuery.data()?.id,
    }))
    

The projects query will start in:

    status: 'pending'
    isPending: true
    fetchStatus: 'idle'
    

    status: 'pending'
    isPending: true
    fetchStatus: 'idle'
    

As soon as the user is available, the projects query will be enabled and will then transition to:

    status: 'pending'
    isPending: true
    fetchStatus: 'fetching'
    

    status: 'pending'
    isPending: true
    fetchStatus: 'fetching'
    

Once we have the projects, it will go to:

    status: 'success'
    isPending: false
    fetchStatus: 'idle'
    

    status: 'success'
    isPending: false
    fetchStatus: 'idle'
    

[](#injectqueries-dependent-query)[injectQueries dependent Query](#injectqueries-dependent-query)
-------------------------------------------------------------------------------------------------

Dynamic parallel query - injectQueries can depend on a previous query also, here's how to achieve this:

    // injectQueries is under development for Angular Query
    

    // injectQueries is under development for Angular Query
    

**Note** that injectQueries return an **array of query results**

[](#a-note-about-performance)[A note about performance](#a-note-about-performance)
----------------------------------------------------------------------------------

Dependent queries by definition constitutes a form of [request waterfall](https://tanstack.com/query/latest/docs/framework/angular/guides/request-waterfalls), which hurts performance. If we pretend both queries take the same amount of time, doing them serially instead of in parallel always takes twice as much time, which is especially hurtful when it happens on a client that has high latency. If you can, it's always better to restructure the backend APIs so that both queries can be fetched in parallel, though that might not always be practically feasible.

In the example above, instead of first fetching getUserByEmail to be able to getProjectsByUser, introducing a new getProjectsByUserEmail query would flatten the waterfall.</content>
</page>

<page>
  <title>Mutation Options | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/guides/mutation-options</url>
  <content>One of the best ways to share mutation options between multiple places, is to use the mutationOptions helper. At runtime, this helper just returns whatever you pass into it, but it has a lot of advantages when using it [with TypeScript](https://tanstack.com/query/latest/docs/framework/angular/typescript#typing-query-options.md). You can define all possible options for a mutation in one place, and you'll also get type inference and type safety for all of them.

    export class QueriesService {
      private http = inject(HttpClient)
    
      updatePost(id: number) {
        return mutationOptions({
          mutationFn: (post: Post) => Promise.resolve(post),
          mutationKey: ['updatePost', id],
          onSuccess: (newPost) => {
            //           ^? newPost: Post
            this.queryClient.setQueryData(['posts', id], newPost)
          },
        })
      }
    }
    

    export class QueriesService {
      private http = inject(HttpClient)
    
      updatePost(id: number) {
        return mutationOptions({
          mutationFn: (post: Post) => Promise.resolve(post),
          mutationKey: ['updatePost', id],
          onSuccess: (newPost) => {
            //           ^? newPost: Post
            this.queryClient.setQueryData(['posts', id], newPost)
          },
        })
      }
    }</content>
</page>

<page>
  <title>Mutations | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/guides/mutations</url>
  <content>Unlike queries, mutations are typically used to create/update/delete data or perform server side-effects. For this purpose, TanStack Query exports a injectMutation function.

Here's an example of a mutation that adds a new todo to the server:

    @Component({
      template: `
        <div>
          @if (mutation.isPending()) {
            <span>Adding todo...</span>
          } @else if (mutation.isError()) {
            <div>An error occurred: {{ mutation.error()?.message }}</div>
          } @else if (mutation.isSuccess()) {
            <div>Todo added!</div>
          }
          <button (click)="mutation.mutate(1)">Create Todo</button>
        </div>
      `,
    })
    export class TodosComponent {
      todoService = inject(TodoService)
      mutation = injectMutation(() => ({
        mutationFn: (todoId: number) =>
          lastValueFrom(this.todoService.create(todoId)),
      }))
    }
    

    @Component({
      template: `
        <div>
          @if (mutation.isPending()) {
            <span>Adding todo...</span>
          } @else if (mutation.isError()) {
            <div>An error occurred: {{ mutation.error()?.message }}</div>
          } @else if (mutation.isSuccess()) {
            <div>Todo added!</div>
          }
          <button (click)="mutation.mutate(1)">Create Todo</button>
        </div>
      `,
    })
    export class TodosComponent {
      todoService = inject(TodoService)
      mutation = injectMutation(() => ({
        mutationFn: (todoId: number) =>
          lastValueFrom(this.todoService.create(todoId)),
      }))
    }
    

A mutation can only be in one of the following states at any given moment:

*   isIdle or status === 'idle' - The mutation is currently idle or in a fresh/reset state
*   isPending or status === 'pending' - The mutation is currently running
*   isError or status === 'error' - The mutation encountered an error
*   isSuccess or status === 'success' - The mutation was successful and mutation data is available

Beyond those primary states, more information is available depending on the state of the mutation:

*   error - If the mutation is in an error state, the error is available via the error property.
*   data - If the mutation is in a success state, the data is available via the data property.

In the example above, you also saw that you can pass variables to your mutations function by calling the mutate function with a **single variable or object**.

Even with just variables, mutations aren't all that special, but when used with the onSuccess option, the [Query Client's invalidateQueries method](https://tanstack.com/query/latest/docs/reference/QueryClient#queryclientinvalidatequeries) and the [Query Client's setQueryData method](https://tanstack.com/query/latest/docs/reference/QueryClient#queryclientsetquerydata), mutations become a very powerful tool.

[](#resetting-mutation-state)[Resetting Mutation State](#resetting-mutation-state)
----------------------------------------------------------------------------------

It's sometimes the case that you need to clear the error or data of a mutation request. To do this, you can use the reset function to handle this:

    @Component({
      selector: 'todo-item',
      imports: [ReactiveFormsModule],
      template: `
        <form [formGroup]="todoForm" (ngSubmit)="onCreateTodo()">
          @if (mutation.error()) {
            <h5 (click)="mutation.reset()">{{ mutation.error() }}</h5>
          }
          <input type="text" formControlName="title" />
          <br />
          <button type="submit">Create Todo</button>
        </form>
      `,
    })
    export class TodosComponent {
      mutation = injectMutation(() => ({
        mutationFn: createTodo,
      }))
    
      fb = inject(NonNullableFormBuilder)
    
      todoForm = this.fb.group({
        title: this.fb.control('', {
          validators: [Validators.required],
        }),
      })
    
      title = toSignal(this.todoForm.controls.title.valueChanges, {
        initialValue: '',
      })
    
      onCreateTodo = () => {
        this.mutation.mutate(this.title())
      }
    }
    

    @Component({
      selector: 'todo-item',
      imports: [ReactiveFormsModule],
      template: `
        <form [formGroup]="todoForm" (ngSubmit)="onCreateTodo()">
          @if (mutation.error()) {
            <h5 (click)="mutation.reset()">{{ mutation.error() }}</h5>
          }
          <input type="text" formControlName="title" />
          <br />
          <button type="submit">Create Todo</button>
        </form>
      `,
    })
    export class TodosComponent {
      mutation = injectMutation(() => ({
        mutationFn: createTodo,
      }))
    
      fb = inject(NonNullableFormBuilder)
    
      todoForm = this.fb.group({
        title: this.fb.control('', {
          validators: [Validators.required],
        }),
      })
    
      title = toSignal(this.todoForm.controls.title.valueChanges, {
        initialValue: '',
      })
    
      onCreateTodo = () => {
        this.mutation.mutate(this.title())
      }
    }
    

[](#mutation-side-effects)[Mutation Side Effects](#mutation-side-effects)
-------------------------------------------------------------------------

injectMutation comes with some helper options that allow quick and easy side-effects at any stage during the mutation lifecycle. These come in handy for both [invalidating and refetching queries after mutations](https://tanstack.com/query/latest/docs/framework/angular/guides/invalidations-from-mutations) and even [optimistic updates](https://tanstack.com/query/latest/docs/framework/angular/guides/optimistic-updates)

    mutation = injectMutation(() => ({
      mutationFn: addTodo,
      onMutate: (variables, context) => {
        // A mutation is about to happen!
    
        // Optionally return a result containing data to use when for example rolling back
        return { id: 1 }
      },
      onError: (error, variables, onMutateResult, context) => {
        // An error happened!
        console.log(`rolling back optimistic update with id ${onMutateResult.id}`)
      },
      onSuccess: (data, variables, onMutateResult, context) => {
        // Boom baby!
      },
      onSettled: (data, error, variables, onMutateResult, context) => {
        // Error or success... doesn't matter!
      },
    }))
    

    mutation = injectMutation(() => ({
      mutationFn: addTodo,
      onMutate: (variables, context) => {
        // A mutation is about to happen!
    
        // Optionally return a result containing data to use when for example rolling back
        return { id: 1 }
      },
      onError: (error, variables, onMutateResult, context) => {
        // An error happened!
        console.log(`rolling back optimistic update with id ${onMutateResult.id}`)
      },
      onSuccess: (data, variables, onMutateResult, context) => {
        // Boom baby!
      },
      onSettled: (data, error, variables, onMutateResult, context) => {
        // Error or success... doesn't matter!
      },
    }))
    

When returning a promise in any of the callback functions it will first be awaited before the next callback is called:

    mutation = injectMutation(() => ({
      mutationFn: addTodo,
      onSuccess: async () => {
        console.log("I'm first!")
      },
      onSettled: async () => {
        console.log("I'm second!")
      },
    }))
    

    mutation = injectMutation(() => ({
      mutationFn: addTodo,
      onSuccess: async () => {
        console.log("I'm first!")
      },
      onSettled: async () => {
        console.log("I'm second!")
      },
    }))
    

You might find that you want to **trigger additional callbacks** beyond the ones defined on injectMutation when calling mutate. This can be used to trigger component-specific side effects. To do that, you can provide any of the same callback options to the mutate function after your mutation variable. Supported options include: onSuccess, onError and onSettled. Please keep in mind that those additional callbacks won't run if your component gets destroyed _before_ the mutation finishes.

    mutation = injectMutation(() => ({
      mutationFn: addTodo,
      onSuccess: (data, variables, onMutateResult, context) => {
        // I will fire first
      },
      onError: (error, variables, onMutateResult, context) => {
        // I will fire first
      },
      onSettled: (data, error, variables, onMutateResult, context) => {
        // I will fire first
      },
    }))
    
    mutation.mutate(todo, {
      onSuccess: (data, variables, onMutateResult, context) => {
        // I will fire second!
      },
      onError: (error, variables, onMutateResult, context) => {
        // I will fire second!
      },
      onSettled: (data, error, variables, onMutateResult, context) => {
        // I will fire second!
      },
    })
    

    mutation = injectMutation(() => ({
      mutationFn: addTodo,
      onSuccess: (data, variables, onMutateResult, context) => {
        // I will fire first
      },
      onError: (error, variables, onMutateResult, context) => {
        // I will fire first
      },
      onSettled: (data, error, variables, onMutateResult, context) => {
        // I will fire first
      },
    }))
    
    mutation.mutate(todo, {
      onSuccess: (data, variables, onMutateResult, context) => {
        // I will fire second!
      },
      onError: (error, variables, onMutateResult, context) => {
        // I will fire second!
      },
      onSettled: (data, error, variables, onMutateResult, context) => {
        // I will fire second!
      },
    })
    

### [](#consecutive-mutations)[Consecutive mutations](#consecutive-mutations)

There is a slight difference in handling onSuccess, onError and onSettled callbacks when it comes to consecutive mutations. When passed to the mutate function, they will be fired up only _once_ and only if the component is still active. This is due to the fact that mutation observer is removed and resubscribed every time when the mutate function is called. On the contrary, injectMutation handlers execute for each mutate call.

> Be aware that most likely, mutationFn passed to injectMutation is asynchronous. In that case, the order in which mutations are fulfilled may differ from the order of mutate function calls.

    export class Example {
      mutation = injectMutation(() => ({
        mutationFn: addTodo,
        onSuccess: (data, variables, onMutateResult, context) => {
          // Will be called 3 times
        },
      }))
    
      doMutations() {
        ;['Todo 1', 'Todo 2', 'Todo 3'].forEach((todo) => {
          this.mutation.mutate(todo, {
            onSuccess: (data, variables, onMutateResult, context) => {
              // Will execute only once, for the last mutation (Todo 3),
              // regardless which mutation resolves first
            },
          })
        })
      }
    }
    

    export class Example {
      mutation = injectMutation(() => ({
        mutationFn: addTodo,
        onSuccess: (data, variables, onMutateResult, context) => {
          // Will be called 3 times
        },
      }))
    
      doMutations() {
        ;['Todo 1', 'Todo 2', 'Todo 3'].forEach((todo) => {
          this.mutation.mutate(todo, {
            onSuccess: (data, variables, onMutateResult, context) => {
              // Will execute only once, for the last mutation (Todo 3),
              // regardless which mutation resolves first
            },
          })
        })
      }
    }
    

[](#promises)[Promises](#promises)
----------------------------------

Use mutateAsync instead of mutate to get a promise which will resolve on success or throw on an error. This can for example be used to compose side effects.

    mutation = injectMutation(() => ({ mutationFn: addTodo }))
    
    try {
      const todo = await mutation.mutateAsync(todo)
      console.log(todo)
    } catch (error) {
      console.error(error)
    } finally {
      console.log('done')
    }
    

    mutation = injectMutation(() => ({ mutationFn: addTodo }))
    
    try {
      const todo = await mutation.mutateAsync(todo)
      console.log(todo)
    } catch (error) {
      console.error(error)
    } finally {
      console.log('done')
    }
    

[](#retry)[Retry](#retry)
-------------------------

By default, TanStack Query will not retry a mutation on error, but it is possible with the retry option:

    mutation = injectMutation(() => ({
      mutationFn: addTodo,
      retry: 3,
    }))
    

    mutation = injectMutation(() => ({
      mutationFn: addTodo,
      retry: 3,
    }))
    

If mutations fail because the device is offline, they will be retried in the same order when the device reconnects.

[](#persist-mutations)[Persist mutations](#persist-mutations)
-------------------------------------------------------------

Mutations can be persisted to storage if needed and resumed at a later point. This can be done with the hydration functions:

    const queryClient = new QueryClient()
    
    // Define the "addTodo" mutation
    queryClient.setMutationDefaults(['addTodo'], {
      mutationFn: addTodo,
      onMutate: async (variables, context) => {
        // Cancel current queries for the todos list
        await context.client.cancelQueries({ queryKey: ['todos'] })
    
        // Create optimistic todo
        const optimisticTodo = { id: uuid(), title: variables.title }
    
        // Add optimistic todo to todos list
        context.client.setQueryData(['todos'], (old) => [...old, optimisticTodo])
    
        // Return result with the optimistic todo
        return { optimisticTodo }
      },
      onSuccess: (result, variables, onMutateResult, context) => {
        // Replace optimistic todo in the todos list with the result
        context.client.setQueryData(['todos'], (old) =>
          old.map((todo) =>
            todo.id === onMutateResult.optimisticTodo.id ? result : todo,
          ),
        )
      },
      onError: (error, variables, onMutateResult, context) => {
        // Remove optimistic todo from the todos list
        context.client.setQueryData(['todos'], (old) =>
          old.filter((todo) => todo.id !== onMutateResult.optimisticTodo.id),
        )
      },
      retry: 3,
    })
    
    class someComponent {
      // Start mutation in some component:
      mutation = injectMutation(() => ({ mutationKey: ['addTodo'] }))
    
      someMethod() {
        mutation.mutate({ title: 'title' })
      }
    }
    
    // If the mutation has been paused because the device is for example offline,
    // Then the paused mutation can be dehydrated when the application quits:
    const state = dehydrate(queryClient)
    
    // The mutation can then be hydrated again when the application is started:
    hydrate(queryClient, state)
    
    // Resume the paused mutations:
    queryClient.resumePausedMutations()
    

    const queryClient = new QueryClient()
    
    // Define the "addTodo" mutation
    queryClient.setMutationDefaults(['addTodo'], {
      mutationFn: addTodo,
      onMutate: async (variables, context) => {
        // Cancel current queries for the todos list
        await context.client.cancelQueries({ queryKey: ['todos'] })
    
        // Create optimistic todo
        const optimisticTodo = { id: uuid(), title: variables.title }
    
        // Add optimistic todo to todos list
        context.client.setQueryData(['todos'], (old) => [...old, optimisticTodo])
    
        // Return result with the optimistic todo
        return { optimisticTodo }
      },
      onSuccess: (result, variables, onMutateResult, context) => {
        // Replace optimistic todo in the todos list with the result
        context.client.setQueryData(['todos'], (old) =>
          old.map((todo) =>
            todo.id === onMutateResult.optimisticTodo.id ? result : todo,
          ),
        )
      },
      onError: (error, variables, onMutateResult, context) => {
        // Remove optimistic todo from the todos list
        context.client.setQueryData(['todos'], (old) =>
          old.filter((todo) => todo.id !== onMutateResult.optimisticTodo.id),
        )
      },
      retry: 3,
    })
    
    class someComponent {
      // Start mutation in some component:
      mutation = injectMutation(() => ({ mutationKey: ['addTodo'] }))
    
      someMethod() {
        mutation.mutate({ title: 'title' })
      }
    }
    
    // If the mutation has been paused because the device is for example offline,
    // Then the paused mutation can be dehydrated when the application quits:
    const state = dehydrate(queryClient)
    
    // The mutation can then be hydrated again when the application is started:
    hydrate(queryClient, state)
    
    // Resume the paused mutations:
    queryClient.resumePausedMutations()
    

### [](#persisting-offline-mutations)[Persisting Offline mutations](#persisting-offline-mutations)

If you persist offline mutations with the [persistQueryClient plugin](https://tanstack.com/query/latest/docs/framework/angular/plugins/persistQueryClient), mutations cannot be resumed when the page is reloaded unless you provide a default mutation function.

This is a technical limitation. When persisting to an external storage, only the state of mutations is persisted, as functions cannot be serialized. After hydration, the component that triggers the mutation might not be initialized, so calling resumePausedMutations might yield an error: No mutationFn found.

We also have an extensive [offline example](https://tanstack.com/query/latest/docs/framework/angular/examples/offline) that covers both queries and mutations.

[](#mutation-scopes)[Mutation Scopes](#mutation-scopes)
-------------------------------------------------------

Per default, all mutations run in parallel - even if you invoke .mutate() of the same mutation multiple times. Mutations can be given a scope with an id to avoid that. All mutations with the same scope.id will run in serial, which means when they are triggered, they will start in isPaused: true state if there is already a mutation for that scope in progress. They will be put into a queue and will automatically resume once their time in the queue has come.

    const mutation = injectMutation({
      mutationFn: addTodo,
      scope: {
        id: 'todo',
      },
    })
    

    const mutation = injectMutation({
      mutationFn: addTodo,
      scope: {
        id: 'todo',
      },
    })</content>
</page>

<page>
  <title>Query Invalidation | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/guides/query-invalidation</url>
  <content>Waiting for queries to become stale before they are fetched again doesn't always work, especially when you know for a fact that a query's data is out of date because of something the user has done. For that purpose, the QueryClient has an invalidateQueries method that lets you intelligently mark queries as stale and potentially refetch them too!

    // Invalidate every query in the cache
    queryClient.invalidateQueries()
    // Invalidate every query with a key that starts with `todos`
    queryClient.invalidateQueries({ queryKey: ['todos'] })
    

    // Invalidate every query in the cache
    queryClient.invalidateQueries()
    // Invalidate every query with a key that starts with `todos`
    queryClient.invalidateQueries({ queryKey: ['todos'] })
    

> Note: Where other libraries that use normalized caches would attempt to update local queries with the new data either imperatively or via schema inference, TanStack Query gives you the tools to avoid the manual labor that comes with maintaining normalized caches and instead prescribes **targeted invalidation, background-refetching and ultimately atomic updates**.

When a query is invalidated with invalidateQueries, two things happen:

*   It is marked as stale. This stale state overrides any staleTime configurations being used in injectQuery or related functions
*   If the query is currently being rendered via injectQuery or related functions, it will also be refetched in the background

[](#query-matching-with-invalidatequeries)[Query Matching with invalidateQueries](#query-matching-with-invalidatequeries)
-------------------------------------------------------------------------------------------------------------------------

When using APIs like invalidateQueries and removeQueries (and others that support partial query matching), you can match multiple queries by their prefix, or get really specific and match an exact query. For information on the types of filters you can use, please see [Query Filters](https://tanstack.com/query/latest/docs/framework/angular/guides/filters#query-filters).

In this example, we can use the todos prefix to invalidate any queries that start with todos in their query key:

    import { injectQuery, QueryClient } from '@tanstack/angular-query-experimental'
    
    class QueryInvalidationExample {
      queryClient = inject(QueryClient)
    
      invalidateQueries() {
        this.queryClient.invalidateQueries({ queryKey: ['todos'] })
      }
    
      // Both queries below will be invalidated
      todoListQuery = injectQuery(() => ({
        queryKey: ['todos'],
        queryFn: fetchTodoList,
      }))
      todoListQuery = injectQuery(() => ({
        queryKey: ['todos', { page: 1 }],
        queryFn: fetchTodoList,
      }))
    }
    

    import { injectQuery, QueryClient } from '@tanstack/angular-query-experimental'
    
    class QueryInvalidationExample {
      queryClient = inject(QueryClient)
    
      invalidateQueries() {
        this.queryClient.invalidateQueries({ queryKey: ['todos'] })
      }
    
      // Both queries below will be invalidated
      todoListQuery = injectQuery(() => ({
        queryKey: ['todos'],
        queryFn: fetchTodoList,
      }))
      todoListQuery = injectQuery(() => ({
        queryKey: ['todos', { page: 1 }],
        queryFn: fetchTodoList,
      }))
    }
    

You can even invalidate queries with specific variables by passing a more specific query key to the invalidateQueries method:

    queryClient.invalidateQueries({
      queryKey: ['todos', { type: 'done' }],
    })
    
    // The query below will be invalidated
    todoListQuery = injectQuery(() => ({
      queryKey: ['todos', { type: 'done' }],
      queryFn: fetchTodoList,
    }))
    
    // However, the following query below will NOT be invalidated
    todoListQuery = injectQuery(() => ({
      queryKey: ['todos'],
      queryFn: fetchTodoList,
    }))
    

    queryClient.invalidateQueries({
      queryKey: ['todos', { type: 'done' }],
    })
    
    // The query below will be invalidated
    todoListQuery = injectQuery(() => ({
      queryKey: ['todos', { type: 'done' }],
      queryFn: fetchTodoList,
    }))
    
    // However, the following query below will NOT be invalidated
    todoListQuery = injectQuery(() => ({
      queryKey: ['todos'],
      queryFn: fetchTodoList,
    }))
    

The invalidateQueries API is very flexible, so even if you want to **only** invalidate todos queries that don't have any more variables or subkeys, you can pass an exact: true option to the invalidateQueries method:

    queryClient.invalidateQueries({
      queryKey: ['todos'],
      exact: true,
    })
    
    // The query below will be invalidated
    todoListQuery = injectQuery(() => ({
      queryKey: ['todos'],
      queryFn: fetchTodoList,
    }))
    
    // However, the following query below will NOT be invalidated
    const todoListQuery = injectQuery(() => ({
      queryKey: ['todos', { type: 'done' }],
      queryFn: fetchTodoList,
    }))
    

    queryClient.invalidateQueries({
      queryKey: ['todos'],
      exact: true,
    })
    
    // The query below will be invalidated
    todoListQuery = injectQuery(() => ({
      queryKey: ['todos'],
      queryFn: fetchTodoList,
    }))
    
    // However, the following query below will NOT be invalidated
    const todoListQuery = injectQuery(() => ({
      queryKey: ['todos', { type: 'done' }],
      queryFn: fetchTodoList,
    }))
    

If you find yourself wanting **even more** granularity, you can pass a predicate function to the invalidateQueries method. This function will receive each Query instance from the query cache and allow you to return true or false for whether you want to invalidate that query:

    queryClient.invalidateQueries({
      predicate: (query) =>
        query.queryKey[0] === 'todos' && query.queryKey[1]?.version >= 10,
    })
    
    // The query below will be invalidated
    todoListQuery = injectQuery(() => ({
      queryKey: ['todos', { version: 20 }],
      queryFn: fetchTodoList,
    }))
    
    // The query below will be invalidated
    todoListQuery = injectQuery(() => ({
      queryKey: ['todos', { version: 10 }],
      queryFn: fetchTodoList,
    }))
    
    // However, the following query below will NOT be invalidated
    todoListQuery = injectQuery(() => ({
      queryKey: ['todos', { version: 5 }],
      queryFn: fetchTodoList,
    }))
    

    queryClient.invalidateQueries({
      predicate: (query) =>
        query.queryKey[0] === 'todos' && query.queryKey[1]?.version >= 10,
    })
    
    // The query below will be invalidated
    todoListQuery = injectQuery(() => ({
      queryKey: ['todos', { version: 20 }],
      queryFn: fetchTodoList,
    }))
    
    // The query below will be invalidated
    todoListQuery = injectQuery(() => ({
      queryKey: ['todos', { version: 10 }],
      queryFn: fetchTodoList,
    }))
    
    // However, the following query below will NOT be invalidated
    todoListQuery = injectQuery(() => ({
      queryKey: ['todos', { version: 5 }],
      queryFn: fetchTodoList,
    }))</content>
</page>

<page>
  <title>Invalidations from Mutations | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/guides/invalidations-from-mutations</url>
  <content>Invalidating queries is only half the battle. Knowing **when** to invalidate them is the other half. Usually when a mutation in your app succeeds, it's VERY likely that there are related queries in your application that need to be invalidated and possibly refetched to account for the new changes from your mutation.

For example, assume we have a mutation to post a new todo:

    mutation = injectMutation(() => ({
      mutationFn: postTodo,
    }))
    

    mutation = injectMutation(() => ({
      mutationFn: postTodo,
    }))
    

When a successful postTodo mutation happens, we likely want all todos queries to get invalidated and possibly refetched to show the new todo item. To do this, you can use injectMutation's onSuccess options and the client's invalidateQueries function:

    import { injectMutation, useQueryClient } from '@tanstack/react-query'
    
    const queryClient = useQueryClient()
    
    // When this mutation succeeds, invalidate any queries with the `todos` or `reminders` query key
    const mutation = injectMutation({
      mutationFn: addTodo,
      onSuccess: async () => {
        // If you're invalidating a single query
        await queryClient.invalidateQueries({ queryKey: ['todos'] })
    
        // If you're invalidating multiple queries
        await Promise.all([
          queryClient.invalidateQueries({ queryKey: ['todos'] }),
          queryClient.invalidateQueries({ queryKey: ['reminders'] }),
        ])
      },
    })
    

    import { injectMutation, useQueryClient } from '@tanstack/react-query'
    
    const queryClient = useQueryClient()
    
    // When this mutation succeeds, invalidate any queries with the `todos` or `reminders` query key
    const mutation = injectMutation({
      mutationFn: addTodo,
      onSuccess: async () => {
        // If you're invalidating a single query
        await queryClient.invalidateQueries({ queryKey: ['todos'] })
    
        // If you're invalidating multiple queries
        await Promise.all([
          queryClient.invalidateQueries({ queryKey: ['todos'] }),
          queryClient.invalidateQueries({ queryKey: ['reminders'] }),
        ])
      },
    })
    

Returning a Promise on onSuccess makes sure the data is updated before the mutation is entirely complete (i.e., isPending is true until onSuccess is fulfilled)

    import {
      injectMutation,
      QueryClient,
    } from '@tanstack/angular-query-experimental'
    
    export class TodosComponent {
      queryClient = inject(QueryClient)
    
      // When this mutation succeeds, invalidate any queries with the `todos` or `reminders` query key
      mutation = injectMutation(() => ({
        mutationFn: addTodo,
        onSuccess: () => {
          this.queryClient.invalidateQueries({ queryKey: ['todos'] })
          this.queryClient.invalidateQueries({ queryKey: ['reminders'] })
        },
      }))
    }
    

    import {
      injectMutation,
      QueryClient,
    } from '@tanstack/angular-query-experimental'
    
    export class TodosComponent {
      queryClient = inject(QueryClient)
    
      // When this mutation succeeds, invalidate any queries with the `todos` or `reminders` query key
      mutation = injectMutation(() => ({
        mutationFn: addTodo,
        onSuccess: () => {
          this.queryClient.invalidateQueries({ queryKey: ['todos'] })
          this.queryClient.invalidateQueries({ queryKey: ['reminders'] })
        },
      }))
    }
    

[](#further-reading)[Further reading](#further-reading)
-------------------------------------------------------

For a technique to automatically invalidate Queries after Mutations, have a look at [TkDodo's article on Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/automatic-query-invalidation-after-mutations).</content>
</page>

<page>
  <title>Initial Query Data | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/guides/initial-query-data</url>
  <content>There are many ways to supply initial data for a query to the cache before you need it:

*   Declaratively:
    *   Provide initialData to a query to prepopulate its cache if empty
*   Imperatively:
    *   [Prefetch the data using queryClient.prefetchQuery](https://tanstack.com/query/latest/docs/framework/angular/guides/prefetching)
    *   [Manually place the data into the cache using queryClient.setQueryData](https://tanstack.com/query/latest/docs/framework/angular/guides/prefetching)

[](#using-initialdata-to-prepopulate-a-query)[Using initialData to prepopulate a query](#using-initialdata-to-prepopulate-a-query)
----------------------------------------------------------------------------------------------------------------------------------

There may be times when you already have the initial data for a query available in your app and can simply provide it directly to your query. If and when this is the case, you can use the config.initialData option to set the initial data for a query and skip the initial loading state!

> IMPORTANT: initialData is persisted to the cache, so it is not recommended to provide placeholder, partial or incomplete data to this option and instead use placeholderData

    result = injectQuery(() => ({
      queryKey: ['todos'],
      queryFn: () => fetch('/todos'),
      initialData: initialTodos,
    }))
    

    result = injectQuery(() => ({
      queryKey: ['todos'],
      queryFn: () => fetch('/todos'),
      initialData: initialTodos,
    }))
    

### [](#staletime-and-initialdataupdatedat)[staleTime and initialDataUpdatedAt](#staletime-and-initialdataupdatedat)

By default, initialData is treated as totally fresh, as if it were just fetched. This also means that it will affect how it is interpreted by the staleTime option.

*   If you configure your query observer with initialData, and no staleTime (the default staleTime: 0), the query will immediately refetch:

    // Will show initialTodos immediately, but also immediately refetch todos
    // when an instance of the component or service is created
    result = injectQuery(() => ({
      queryKey: ['todos'],
      queryFn: () => fetch('/todos'),
      initialData: initialTodos,
    }))
    

    // Will show initialTodos immediately, but also immediately refetch todos
    // when an instance of the component or service is created
    result = injectQuery(() => ({
      queryKey: ['todos'],
      queryFn: () => fetch('/todos'),
      initialData: initialTodos,
    }))
    

*   If you configure your query observer with initialData and a staleTime of 1000 ms, the data will be considered fresh for that same amount of time, as if it was just fetched from your query function.

    // Show initialTodos immediately, but won't refetch until
    // another interaction event is encountered after 1000 ms
    result = injectQuery(() => ({
      queryKey: ['todos'],
      queryFn: () => fetch('/todos'),
      initialData: initialTodos,
      staleTime: 1000,
    }))
    

    // Show initialTodos immediately, but won't refetch until
    // another interaction event is encountered after 1000 ms
    result = injectQuery(() => ({
      queryKey: ['todos'],
      queryFn: () => fetch('/todos'),
      initialData: initialTodos,
      staleTime: 1000,
    }))
    

*   So what if your initialData isn't totally fresh? That leaves us with the last configuration that is actually the most accurate and uses an option called initialDataUpdatedAt. This option allows you to pass a numeric JS timestamp in milliseconds of when the initialData itself was last updated, e.g. what Date.now() provides. Take note that if you have a unix timestamp, you'll need to convert it to a JS timestamp by multiplying it by 1000.

    // Show initialTodos immediately, but won't refetch until
    // another interaction event is encountered after 1000 ms
    result = injectQuery(() => ({
      queryKey: ['todos'],
      queryFn: () => fetch('/todos'),
      initialData: initialTodos,
      staleTime: 60 * 1000, // 1 minute
      // This could be 10 seconds ago or 10 minutes ago
      initialDataUpdatedAt: initialTodosUpdatedTimestamp, // eg. 1608412420052
    }))
    

    // Show initialTodos immediately, but won't refetch until
    // another interaction event is encountered after 1000 ms
    result = injectQuery(() => ({
      queryKey: ['todos'],
      queryFn: () => fetch('/todos'),
      initialData: initialTodos,
      staleTime: 60 * 1000, // 1 minute
      // This could be 10 seconds ago or 10 minutes ago
      initialDataUpdatedAt: initialTodosUpdatedTimestamp, // eg. 1608412420052
    }))
    

This option allows the staleTime to be used for its original purpose, determining how fresh the data needs to be, while also allowing the data to be refetched on initialization if the initialData is older than the staleTime. In the example above, our data needs to be fresh within 1 minute, and we can hint to the query when the initialData was last updated so the query can decide for itself whether the data needs to be refetched again or not.

> If you would rather treat your data as **prefetched data**, we recommend that you use the prefetchQuery or fetchQuery APIs to populate the cache beforehand, thus letting you configure your staleTime independently from your initialData

### [](#initial-data-function)[Initial Data Function](#initial-data-function)

If the process for accessing a query's initial data is intensive or just not something you want to perform on every service or component instance, you can pass a function as the initialData value. This function will be executed only once when the query is initialized, saving you precious memory and/or CPU:

    result = injectQuery(() => ({
      queryKey: ['todos'],
      queryFn: () => fetch('/todos'),
      initialData: () => getExpensiveTodos(),
    }))
    

    result = injectQuery(() => ({
      queryKey: ['todos'],
      queryFn: () => fetch('/todos'),
      initialData: () => getExpensiveTodos(),
    }))
    

### [](#initial-data-from-cache)[Initial Data from Cache](#initial-data-from-cache)

In some circumstances, you may be able to provide the initial data for a query from the cached result of another. A good example of this would be searching the cached data from a todos list query for an individual todo item, then using that as the initial data for your individual todo query:

    result = injectQuery(() => ({
      queryKey: ['todo', this.todoId()],
      queryFn: () => fetch('/todos'),
      initialData: () => {
        // Use a todo from the 'todos' query as the initial data for this todo query
        return this.queryClient
          .getQueryData(['todos'])
          ?.find((d) => d.id === this.todoId())
      },
    }))
    

    result = injectQuery(() => ({
      queryKey: ['todo', this.todoId()],
      queryFn: () => fetch('/todos'),
      initialData: () => {
        // Use a todo from the 'todos' query as the initial data for this todo query
        return this.queryClient
          .getQueryData(['todos'])
          ?.find((d) => d.id === this.todoId())
      },
    }))
    

### [](#initial-data-from-the-cache-with-initialdataupdatedat)[Initial Data from the cache with initialDataUpdatedAt](#initial-data-from-the-cache-with-initialdataupdatedat)

Getting initial data from the cache means the source query you're using to look up the initial data from is likely old. Instead of using an artificial staleTime to keep your query from refetching immediately, it's suggested that you pass the source query's dataUpdatedAt to initialDataUpdatedAt. This provides the query instance with all the information it needs to determine if and when the query needs to be refetched, regardless of initial data being provided.

    result = injectQuery(() => ({
      queryKey: ['todos', this.todoId()],
      queryFn: () => fetch(`/todos/${this.todoId()}`),
      initialData: () =>
        queryClient.getQueryData(['todos'])?.find((d) => d.id === this.todoId()),
      initialDataUpdatedAt: () =>
        queryClient.getQueryState(['todos'])?.dataUpdatedAt,
    }))
    

    result = injectQuery(() => ({
      queryKey: ['todos', this.todoId()],
      queryFn: () => fetch(`/todos/${this.todoId()}`),
      initialData: () =>
        queryClient.getQueryData(['todos'])?.find((d) => d.id === this.todoId()),
      initialDataUpdatedAt: () =>
        queryClient.getQueryState(['todos'])?.dataUpdatedAt,
    }))
    

### [](#conditional-initial-data-from-cache)[Conditional Initial Data from Cache](#conditional-initial-data-from-cache)

If the source query you're using to look up the initial data from is old, you may not want to use the cached data at all and just fetch from the server. To make this decision easier, you can use the queryClient.getQueryState method instead to get more information about the source query, including a state.dataUpdatedAt timestamp you can use to decide if the query is "fresh" enough for your needs:

    result = injectQuery(() => ({
      queryKey: ['todo', this.todoId()],
      queryFn: () => fetch(`/todos/${this.todoId()}`),
      initialData: () => {
        // Get the query state
        const state = queryClient.getQueryState(['todos'])
    
        // If the query exists and has data that is no older than 10 seconds...
        if (state && Date.now() - state.dataUpdatedAt <= 10 * 1000) {
          // return the individual todo
          return state.data.find((d) => d.id === this.todoId())
        }
    
        // Otherwise, return undefined and let it fetch from a hard loading state!
      },
    }))
    

    result = injectQuery(() => ({
      queryKey: ['todo', this.todoId()],
      queryFn: () => fetch(`/todos/${this.todoId()}`),
      initialData: () => {
        // Get the query state
        const state = queryClient.getQueryState(['todos'])
    
        // If the query exists and has data that is no older than 10 seconds...
        if (state && Date.now() - state.dataUpdatedAt <= 10 * 1000) {
          // return the individual todo
          return state.data.find((d) => d.id === this.todoId())
        }
    
        // Otherwise, return undefined and let it fetch from a hard loading state!
      },
    }))</content>
</page>

<page>
  <title>Optimistic Updates | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/guides/optimistic-updates</url>
  <content>Angular Query provides two ways to optimistically update your UI before a mutation has completed. You can either use the onMutate option to update your cache directly, or leverage the returned variables to update your UI from the injectMutation result.

[](#via-the-ui)[Via the UI](#via-the-ui)
----------------------------------------

This is the simpler variant, as it doesn't interact with the cache directly.

    addTodo = injectMutation(() => ({
      mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
      // make sure to _return_ the Promise from the query invalidation
      // so that the mutation stays in `pending` state until the refetch is finished
      onSettled: async () => {
        return await queryClient.invalidateQueries({ queryKey: ['todos'] })
      },
    }))
    

    addTodo = injectMutation(() => ({
      mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
      // make sure to _return_ the Promise from the query invalidation
      // so that the mutation stays in `pending` state until the refetch is finished
      onSettled: async () => {
        return await queryClient.invalidateQueries({ queryKey: ['todos'] })
      },
    }))
    

you will then have access to addTodo.variables, which contain the added todo. In your UI list, where the query is rendered, you can append another item to the list while the mutation isPending:

    @Component({
      template: `
        @for (todo of todos.data(); track todo.id) {
          <li>{{ todo.title }}</li>
        }
        @if (addTodo.isPending()) {
          <li style="opacity: 0.5">{{ addTodo.variables() }}</li>
        }
      `,
    })
    class TodosComponent {}
    

    @Component({
      template: `
        @for (todo of todos.data(); track todo.id) {
          <li>{{ todo.title }}</li>
        }
        @if (addTodo.isPending()) {
          <li style="opacity: 0.5">{{ addTodo.variables() }}</li>
        }
      `,
    })
    class TodosComponent {}
    

We're rendering a temporary item with a different opacity as long as the mutation is pending. Once it completes, the item will automatically no longer be rendered. Given that the refetch succeeded, we should see the item as a "normal item" in our list.

If the mutation errors, the item will also disappear. But we could continue to show it, if we want, by checking for the isError state of the mutation. variables are _not_ cleared when the mutation errors, so we can still access them, maybe even show a retry button:

    @Component({
      template: `
        @if (addTodo.isError()) {
          <li style="color: red">
            {{ addTodo.variables() }}
            <button (click)="addTodo.mutate(addTodo.variables())">Retry</button>
          </li>
        }
      `,
    })
    class TodosComponent {}
    

    @Component({
      template: `
        @if (addTodo.isError()) {
          <li style="color: red">
            {{ addTodo.variables() }}
            <button (click)="addTodo.mutate(addTodo.variables())">Retry</button>
          </li>
        }
      `,
    })
    class TodosComponent {}
    

### [](#if-the-mutation-and-the-query-dont-live-in-the-same-component)[If the mutation and the query don't live in the same component](#if-the-mutation-and-the-query-dont-live-in-the-same-component)

This approach works very well if the mutation and the query live in the same component. However, you also get access to all mutations in other components via the dedicated injectMutationState function. It is best combined with a mutationKey:

    // somewhere in your app
    addTodo = injectMutation(() => ({
      mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
      onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
      mutationKey: ['addTodo'],
    }))
    
    // access variables somewhere else
    
    mutationState = injectMutationState<string>(() => ({
      filters: { mutationKey: ['addTodo'], status: 'pending' },
      select: (mutation) => mutation.state.variables,
    }))
    

    // somewhere in your app
    addTodo = injectMutation(() => ({
      mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
      onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
      mutationKey: ['addTodo'],
    }))
    
    // access variables somewhere else
    
    mutationState = injectMutationState<string>(() => ({
      filters: { mutationKey: ['addTodo'], status: 'pending' },
      select: (mutation) => mutation.state.variables,
    }))
    

variables will be an Array, because there might be multiple mutations running at the same time. If we need a unique key for the items, we can also select mutation.state.submittedAt. This will even make displaying concurrent optimistic updates a breeze.

[](#via-the-cache)[Via the cache](#via-the-cache)
-------------------------------------------------

When you optimistically update your state before performing a mutation, there is a chance that the mutation will fail. In most of these failure cases, you can just trigger a refetch for your optimistic queries to revert them to their true server state. In some circumstances though, refetching may not work correctly and the mutation error could represent some type of server issue that won't make it possible to refetch. In this event, you can instead choose to roll back your update.

To do this, injectMutation's onMutate handler option allows you to return a value that will later be passed to both onError and onSettled handlers as the last argument. In most cases, it is most useful to pass a rollback function.

### [](#updating-a-list-of-todos-when-adding-a-new-todo)[Updating a list of todos when adding a new todo](#updating-a-list-of-todos-when-adding-a-new-todo)

    queryClient = inject(QueryClient)
    
    updateTodo = injectMutation(() => ({
      mutationFn: updateTodo,
      // When mutate is called:
      onMutate: async (newTodo, context) => {
        // Cancel any outgoing refetches
        // (so they don't overwrite our optimistic update)
        await context.client.cancelQueries({ queryKey: ['todos'] })
    
        // Snapshot the previous value
        const previousTodos = context.client.getQueryData(['todos'])
    
        // Optimistically update to the new value
        context.client.setQueryData(['todos'], (old) => [...old, newTodo])
    
        // Return a result object with the snapshotted value
        return { previousTodos }
      },
      // If the mutation fails,
      // use the result returned from onMutate to roll back
      onError: (err, newTodo, onMutateResult, context) => {
        context.client.setQueryData(['todos'], onMutateResult.previousTodos)
      },
      // Always refetch after error or success:
      onSettled: (data, error, variables, onMutateResult, context) => {
        context.client.invalidateQueries({ queryKey: ['todos'] })
      },
    }))
    

    queryClient = inject(QueryClient)
    
    updateTodo = injectMutation(() => ({
      mutationFn: updateTodo,
      // When mutate is called:
      onMutate: async (newTodo, context) => {
        // Cancel any outgoing refetches
        // (so they don't overwrite our optimistic update)
        await context.client.cancelQueries({ queryKey: ['todos'] })
    
        // Snapshot the previous value
        const previousTodos = context.client.getQueryData(['todos'])
    
        // Optimistically update to the new value
        context.client.setQueryData(['todos'], (old) => [...old, newTodo])
    
        // Return a result object with the snapshotted value
        return { previousTodos }
      },
      // If the mutation fails,
      // use the result returned from onMutate to roll back
      onError: (err, newTodo, onMutateResult, context) => {
        context.client.setQueryData(['todos'], onMutateResult.previousTodos)
      },
      // Always refetch after error or success:
      onSettled: (data, error, variables, onMutateResult, context) => {
        context.client.invalidateQueries({ queryKey: ['todos'] })
      },
    }))
    

### [](#updating-a-single-todo)[Updating a single todo](#updating-a-single-todo)

    queryClient = inject(QueryClient)
    
    updateTodo = injectMutation(() => ({
      mutationFn: updateTodo,
      // When mutate is called:
      onMutate: async (newTodo, context) => {
        // Cancel any outgoing refetches
        // (so they don't overwrite our optimistic update)
        await context.client.cancelQueries({ queryKey: ['todos', newTodo.id] })
    
        // Snapshot the previous value
        const previousTodo = context.client.getQueryData(['todos', newTodo.id])
    
        // Optimistically update to the new value
        context.client.setQueryData(['todos', newTodo.id], newTodo)
    
        // Return a result with the previous and new todo
        return { previousTodo, newTodo }
      },
      // If the mutation fails, use the result we returned above
      onError: (err, newTodo, onMutateResult, context) => {
        context.client.setQueryData(
          ['todos', onMutateResult.newTodo.id],
          onMutateResult.previousTodo,
        )
      },
      // Always refetch after error or success:
      onSettled: (newTodo, error, variables, onMutateResult, context) => {
        context.client.invalidateQueries({ queryKey: ['todos', newTodo.id] })
      },
    }))
    

    queryClient = inject(QueryClient)
    
    updateTodo = injectMutation(() => ({
      mutationFn: updateTodo,
      // When mutate is called:
      onMutate: async (newTodo, context) => {
        // Cancel any outgoing refetches
        // (so they don't overwrite our optimistic update)
        await context.client.cancelQueries({ queryKey: ['todos', newTodo.id] })
    
        // Snapshot the previous value
        const previousTodo = context.client.getQueryData(['todos', newTodo.id])
    
        // Optimistically update to the new value
        context.client.setQueryData(['todos', newTodo.id], newTodo)
    
        // Return a result with the previous and new todo
        return { previousTodo, newTodo }
      },
      // If the mutation fails, use the result we returned above
      onError: (err, newTodo, onMutateResult, context) => {
        context.client.setQueryData(
          ['todos', onMutateResult.newTodo.id],
          onMutateResult.previousTodo,
        )
      },
      // Always refetch after error or success:
      onSettled: (newTodo, error, variables, onMutateResult, context) => {
        context.client.invalidateQueries({ queryKey: ['todos', newTodo.id] })
      },
    }))
    

You can also use the onSettled function in place of the separate onError and onSuccess handlers if you wish:

    injectMutation({
      mutationFn: updateTodo,
      // ...
      onSettled: (newTodo, error, variables, onMutateResult, context) => {
        if (error) {
          // do something
        }
      },
    })
    

    injectMutation({
      mutationFn: updateTodo,
      // ...
      onSettled: (newTodo, error, variables, onMutateResult, context) => {
        if (error) {
          // do something
        }
      },
    })
    

[](#when-to-use-what)[When to use what](#when-to-use-what)
----------------------------------------------------------

If you only have one place where the optimistic result should be shown, using variables and updating the UI directly is the approach that requires less code and is generally easier to reason about. For example, you don't need to handle rollbacks at all.

However, if you have multiple places on the screen that would require to know about the update, manipulating the cache directly will take care of this for you automatically.

[](#further-reading)[Further reading](#further-reading)
-------------------------------------------------------

Have a look at the guide by TkDodo on [Concurrent Optimistic Updates](https://tkdodo.eu/blog/concurrent-optimistic-updates-in-react-query).</content>
</page>

<page>
  <title>Query Cancellation | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/guides/query-cancellation</url>
  <content>TanStack Query provides each query function with an [AbortSignal instance](https://developer.mozilla.org/docs/Web/API/AbortSignal). When a query becomes out-of-date or inactive, this signal will become aborted. This means that all queries are cancellable, and you can respond to the cancellation inside your query function if desired. The best part about this is that it allows you to continue to use normal async/await syntax while getting all the benefits of automatic cancellation.

[](#default-behavior)[Default behavior](#default-behavior)
----------------------------------------------------------

By default, queries that unmount or become unused before their promises are resolved are _not_ cancelled. This means that after the promise has resolved, the resulting data will be available in the cache. This is helpful if you've started receiving a query, but then unmount the component before it finishes. If you mount the component again and the query has not been garbage collected yet, data will be available.

However, if you consume the AbortSignal, the Promise will be cancelled (e.g. aborting the fetch) and therefore, also the Query must be cancelled. Cancelling the query will result in its state being _reverted_ to its previous state.

[](#using-httpclient)[Using HttpClient](#using-httpclient)
----------------------------------------------------------

    import { HttpClient } from '@angular/common/http'
    import { injectQuery } from '@tanstack/angular-query-experimental'
    
    postQuery = injectQuery(() => ({
      enabled: this.postId() > 0,
      queryKey: ['post', this.postId()],
      queryFn: async (context): Promise<Post> => {
        const abort$ = fromEvent(context.signal, 'abort')
        return lastValueFrom(this.getPost$(this.postId()).pipe(takeUntil(abort$)))
      },
    }))
    

    import { HttpClient } from '@angular/common/http'
    import { injectQuery } from '@tanstack/angular-query-experimental'
    
    postQuery = injectQuery(() => ({
      enabled: this.postId() > 0,
      queryKey: ['post', this.postId()],
      queryFn: async (context): Promise<Post> => {
        const abort$ = fromEvent(context.signal, 'abort')
        return lastValueFrom(this.getPost$(this.postId()).pipe(takeUntil(abort$)))
      },
    }))
    

[](#using-fetch)[Using fetch](#using-fetch)
-------------------------------------------

    query = injectQuery(() => ({
      queryKey: ['todos'],
      queryFn: async ({ signal }) => {
        const todosResponse = await fetch('/todos', {
          // Pass the signal to one fetch
          signal,
        })
        const todos = await todosResponse.json()
    
        const todoDetails = todos.map(async ({ details }) => {
          const response = await fetch(details, {
            // Or pass it to several
            signal,
          })
          return response.json()
        })
    
        return Promise.all(todoDetails)
      },
    }))
    

    query = injectQuery(() => ({
      queryKey: ['todos'],
      queryFn: async ({ signal }) => {
        const todosResponse = await fetch('/todos', {
          // Pass the signal to one fetch
          signal,
        })
        const todos = await todosResponse.json()
    
        const todoDetails = todos.map(async ({ details }) => {
          const response = await fetch(details, {
            // Or pass it to several
            signal,
          })
          return response.json()
        })
    
        return Promise.all(todoDetails)
      },
    }))
    

[](#using-axios)[Using axios](#using-axios)
-------------------------------------------

    import axios from 'axios'
    
    const query = injectQuery(() => ({
      queryKey: ['todos'],
      queryFn: ({ signal }) =>
        axios.get('/todos', {
          // Pass the signal to `axios`
          signal,
        }),
    }))
    

    import axios from 'axios'
    
    const query = injectQuery(() => ({
      queryKey: ['todos'],
      queryFn: ({ signal }) =>
        axios.get('/todos', {
          // Pass the signal to `axios`
          signal,
        }),
    }))
    

[](#manual-cancellation)[Manual Cancellation](#manual-cancellation)
-------------------------------------------------------------------

You might want to cancel a query manually. For example, if the request takes a long time to finish, you can allow the user to click a cancel button to stop the request. To do this, you just need to call queryClient.cancelQueries({ queryKey }), which will cancel the query and revert it back to its previous state. If you have consumed the signal passed to the query function, TanStack Query will additionally also cancel the Promise.

    @Component({
      template: `<button (click)="onCancel()">Cancel</button>`,
    })
    export class TodosComponent {
      query = injectQuery(() => ({
        queryKey: ['todos'],
        queryFn: async ({ signal }) => {
          const resp = await fetch('/todos', { signal })
          return resp.json()
        },
      }))
    
      queryClient = inject(QueryClient)
    
      onCancel() {
        this.queryClient.cancelQueries(['todos'])
      }
    }
    

    @Component({
      template: `<button (click)="onCancel()">Cancel</button>`,
    })
    export class TodosComponent {
      query = injectQuery(() => ({
        queryKey: ['todos'],
        queryFn: async ({ signal }) => {
          const resp = await fetch('/todos', { signal })
          return resp.json()
        },
      }))
    
      queryClient = inject(QueryClient)
    
      onCancel() {
        this.queryClient.cancelQueries(['todos'])
      }
    }</content>
</page>

<page>
  <title>Filters | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/guides/filters</url>
  <content>Some methods within TanStack Query accept a QueryFilters or MutationFilters object.

[](#query-filters)[Query Filters](#query-filters)
-------------------------------------------------

A query filter is an object with certain conditions to match a query with:

    // Cancel all queries
    await queryClient.cancelQueries()
    
    // Remove all inactive queries that begin with `posts` in the key
    queryClient.removeQueries({ queryKey: ['posts'], type: 'inactive' })
    
    // Refetch all active queries
    await queryClient.refetchQueries({ type: 'active' })
    
    // Refetch all active queries that begin with `posts` in the key
    await queryClient.refetchQueries({ queryKey: ['posts'], type: 'active' })
    

    // Cancel all queries
    await queryClient.cancelQueries()
    
    // Remove all inactive queries that begin with `posts` in the key
    queryClient.removeQueries({ queryKey: ['posts'], type: 'inactive' })
    
    // Refetch all active queries
    await queryClient.refetchQueries({ type: 'active' })
    
    // Refetch all active queries that begin with `posts` in the key
    await queryClient.refetchQueries({ queryKey: ['posts'], type: 'active' })
    

A query filter object supports the following properties:

*   queryKey?: QueryKey
    *   Set this property to define a query key to match on.
*   exact?: boolean
    *   If you don't want to search queries inclusively by query key, you can pass the exact: true option to return only the query with the exact query key you have passed.
*   type?: 'active' | 'inactive' | 'all'
    *   Defaults to all
    *   When set to active it will match active queries.
    *   When set to inactive it will match inactive queries.
*   stale?: boolean
    *   When set to true it will match stale queries.
    *   When set to false it will match fresh queries.
*   fetchStatus?: FetchStatus
    *   When set to fetching it will match queries that are currently fetching.
    *   When set to paused it will match queries that wanted to fetch, but have been paused.
    *   When set to idle it will match queries that are not fetching.
*   predicate?: (query: Query) => boolean
    *   This predicate function will be used as a final filter on all matching queries. If no other filters are specified, this function will be evaluated against every query in the cache.

[](#mutation-filters)[Mutation Filters](#mutation-filters)
----------------------------------------------------------

A mutation filter is an object with certain conditions to match a mutation with:

    // Get the number of all fetching mutations
    await queryClient.isMutating()
    
    // Filter mutations by mutationKey
    await queryClient.isMutating({ mutationKey: ['post'] })
    
    // Filter mutations using a predicate function
    await queryClient.isMutating({
      predicate: (mutation) => mutation.state.variables?.id === 1,
    })
    

    // Get the number of all fetching mutations
    await queryClient.isMutating()
    
    // Filter mutations by mutationKey
    await queryClient.isMutating({ mutationKey: ['post'] })
    
    // Filter mutations using a predicate function
    await queryClient.isMutating({
      predicate: (mutation) => mutation.state.variables?.id === 1,
    })
    

A mutation filter object supports the following properties:

*   mutationKey?: MutationKey
    *   Set this property to define a mutation key to match on.
*   exact?: boolean
    *   If you don't want to search mutations inclusively by mutation key, you can pass the exact: true option to return only the mutation with the exact mutation key you have passed.
*   status?: MutationStatus
    *   Allows for filtering mutations according to their status.
*   predicate?: (mutation: Mutation) => boolean
    *   This predicate function will be used as a final filter on all matching mutations. If no other filters are specified, this function will be evaluated against every mutation in the cache.

[](#utils)[Utils](#utils)
-------------------------

### [](#matchquery)[matchQuery](#matchquery)

    const isMatching = matchQuery(filters, query)
    

    const isMatching = matchQuery(filters, query)
    

Returns a boolean that indicates whether a query matches the provided set of query filters.

### [](#matchmutation)[matchMutation](#matchmutation)

    const isMatching = matchMutation(filters, mutation)
    

    const isMatching = matchMutation(filters, mutation)
    

Returns a boolean that indicates whether a mutation matches the provided set of mutation filters.</content>
</page>

<page>
  <title>Caching Examples | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/guides/caching</url>
  <content>> Please thoroughly read the [Important Defaults](https://tanstack.com/query/latest/docs/framework/angular/guides/important-defaults) before reading this guide

[](#basic-example)[Basic Example](#basic-example)
-------------------------------------------------

This caching example illustrates the story and lifecycle of:

*   Query Instances with and without cache data
*   Background Refetching
*   Inactive Queries
*   Garbage Collection

Let's assume we are using the default gcTime of **5 minutes** and the default staleTime of 0.

*   A new instance of injectQuery(() => ({ queryKey: \['todos'\], queryFn: fetchTodos })) initializes.
    *   Since no other queries have been made with the \['todos'\] query key, this query will show a hard loading state and make a network request to fetch the data.
    *   When the network request has completed, the returned data will be cached under the \['todos'\] key.
    *   The date will be marked as stale after the configured staleTime (defaults to 0, or immediately).
*   A second instance of injectQuery(() => ({ queryKey: \['todos'\], queryFn: fetchTodos }) initializes elsewhere.
    *   Since the cache already has data for the \['todos'\] key from the first query, that data is immediately returned from the cache.
    *   The new instance triggers a new network request using its query function.
        *   Note that regardless of whether both fetchTodos query functions are identical or not, both queries' [status](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectQuery) are updated (including isFetching, isPending, and other related values) because they have the same query key.
    *   When the request completes successfully, the cache's data under the \['todos'\] key is updated with the new data, and both instances are updated with the new data.
*   Both instances of the injectQuery(() => ({ queryKey: \['todos'\], queryFn: fetchTodos }) query are destroyed and no longer in use.
    *   Since there are no more active instances of this query, a garbage collection timeout is set using gcTime to delete and garbage collect the query (defaults to **5 minutes**).
*   Before the cache timeout has completed, another instance of injectQuery(() => ({ queryKey: \['todos'\], queyFn: fetchTodos }) mounts. The query immediately returns the available cached data while the fetchTodos function is being run in the background. When it completes successfully, it will populate the cache with fresh data.
*   The final instance of injectQuery(() => ({ queryKey: \['todos'\], queryFn: fetchTodos }) gets destroyed.
*   No more instances of injectQuery(() => ({ queryKey: \['todos'\], queryFn: fetchTodos }) appear within **5 minutes**.
    *   The cached data under the \['todos'\] key is deleted and garbage collected.

For more advanced use-cases, see [injectQuery](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectQuery).</content>
</page>

<page>
  <title>Default Query Function | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/guides/default-query-function</url>
  <content>If you find yourself wishing for whatever reason that you could just share the same query function for your entire app and just use query keys to identify what it should fetch, you can do that by providing a **default query function** to TanStack Query:

    // Define a default query function that will receive the query key
    const defaultQueryFn: QueryFunction = async ({ queryKey }) => {
      const { data } = await axios.get(
        `https://jsonplaceholder.typicode.com${queryKey[0]}`,
      )
      return data
    }
    
    // provide the default query function to your app with defaultOptions
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          queryFn: defaultQueryFn,
        },
      },
    })
    
    bootstrapApplication(MyAppComponent, {
      providers: [provideTanStackQuery(queryClient)],
    })
    
    export class PostsComponent {
      // All you have to do now is pass a key!
      postsQuery = injectQuery<Array<Post>>(() => ({
        queryKey: ['/posts'],
      }))
      // ...
    }
    
    export class PostComponent {
      // You can even leave out the queryFn and just go straight into options
      postQuery = injectQuery<Post>(() => ({
        enabled: this.postIdSignal() > 0,
        queryKey: [`/posts/${this.postIdSignal()}`],
      }))
      // ...
    }
    

    // Define a default query function that will receive the query key
    const defaultQueryFn: QueryFunction = async ({ queryKey }) => {
      const { data } = await axios.get(
        `https://jsonplaceholder.typicode.com${queryKey[0]}`,
      )
      return data
    }
    
    // provide the default query function to your app with defaultOptions
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          queryFn: defaultQueryFn,
        },
      },
    })
    
    bootstrapApplication(MyAppComponent, {
      providers: [provideTanStackQuery(queryClient)],
    })
    
    export class PostsComponent {
      // All you have to do now is pass a key!
      postsQuery = injectQuery<Array<Post>>(() => ({
        queryKey: ['/posts'],
      }))
      // ...
    }
    
    export class PostComponent {
      // You can even leave out the queryFn and just go straight into options
      postQuery = injectQuery<Post>(() => ({
        enabled: this.postIdSignal() > 0,
        queryKey: [`/posts/${this.postIdSignal()}`],
      }))
      // ...
    }
    

If you ever want to override the default queryFn, you can just provide your own like you normally would.</content>
</page>

<page>
  <title>Testing | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/guides/testing</url>
  <content>Most Angular tests using TanStack Query will involve services or components that call injectQuery/injectMutation.

TanStack Query's inject\* functions integrate with [PendingTasks](https://angular.dev/api/core/PendingTasks) which ensures the framework is aware of in-progress queries and mutations.

This means tests and SSR can wait until mutations and queries resolve. In unit tests you can use ApplicationRef.whenStable() or fixture.whenStable() to await query completion. This works for both Zone.js and Zoneless setups.

> This integration requires Angular 19 or later. Earlier versions of Angular do not support PendingTasks.

[](#testbed-setup)[TestBed setup](#testbed-setup)
-------------------------------------------------

Create a fresh QueryClient for every spec and provide it with provideTanStackQuery or provideQueryClient. This keeps caches isolated and lets you change default options per test:

    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          retry: false, // ‚úÖ faster failure tests
        },
      },
    })
    
    TestBed.configureTestingModule({
      providers: [provideTanStackQuery(queryClient)],
    })
    

    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          retry: false, // ‚úÖ faster failure tests
        },
      },
    })
    
    TestBed.configureTestingModule({
      providers: [provideTanStackQuery(queryClient)],
    })
    

> If your applications actual TanStack Query config is used in unit tests, make sure withDevtools is not accidentally included in test providers. This can cause slow tests. It is best to keep test and production configs separate.

If you share helpers, remember to call queryClient.clear() (or build a new instance) in afterEach so data from one test never bleeds into another.

[](#first-query-test)[First query test](#first-query-test)
----------------------------------------------------------

Query tests typically run inside TestBed.runInInjectionContext, then wait for stability:

    const appRef = TestBed.inject(ApplicationRef)
    const query = TestBed.runInInjectionContext(() =>
      injectQuery(() => ({
        queryKey: ['greeting'],
        queryFn: () => 'Hello',
      })),
    )
    
    TestBed.tick() // Trigger effect
    
    // Application is stable when queries are idle
    await appRef.whenStable()
    
    expect(query.status()).toBe('success')
    expect(query.data()).toBe('Hello')
    

    const appRef = TestBed.inject(ApplicationRef)
    const query = TestBed.runInInjectionContext(() =>
      injectQuery(() => ({
        queryKey: ['greeting'],
        queryFn: () => 'Hello',
      })),
    )
    
    TestBed.tick() // Trigger effect
    
    // Application is stable when queries are idle
    await appRef.whenStable()
    
    expect(query.status()).toBe('success')
    expect(query.data()).toBe('Hello')
    

PendingTasks will have whenStable() resolve after the query settles. When using fake timers (Vitest), advance the clock and a microtask before awaiting stability:

    await vi.advanceTimersByTimeAsync(0)
    await Promise.resolve()
    await appRef.whenStable()
    

    await vi.advanceTimersByTimeAsync(0)
    await Promise.resolve()
    await appRef.whenStable()
    

[](#testing-components)[Testing components](#testing-components)
----------------------------------------------------------------

For components, bootstrap them through TestBed.createComponent, then await fixture.whenStable():

    const fixture = TestBed.createComponent(ExampleComponent)
    
    await fixture.whenStable()
    expect(fixture.componentInstance.query.data()).toEqual({ value: 42 })
    

    const fixture = TestBed.createComponent(ExampleComponent)
    
    await fixture.whenStable()
    expect(fixture.componentInstance.query.data()).toEqual({ value: 42 })
    

[](#handling-retries)[Handling retries](#handling-retries)
----------------------------------------------------------

Retries slow failing tests because the default backoff runs three times. Set retry: false (or a specific number) through defaultOptions or per query to keep tests fast. If a query intentionally retries, assert on the final state rather than intermediate counts.

[](#httpclient--network-stubs)[HttpClient & network stubs](#httpclient--network-stubs)
--------------------------------------------------------------------------------------

Angular's HttpClientTestingModule plays nicely with PendingTasks. Register it alongside the Query provider and flush responses through HttpTestingController:

    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
      providers: [provideTanStackQuery(queryClient)],
    })
    
    const httpCtrl = TestBed.inject(HttpTestingController)
    const query = TestBed.runInInjectionContext(() =>
      injectQuery(() => ({
        queryKey: ['todos'],
        queryFn: () => lastValueFrom(TestBed.inject(HttpClient).get('/api/todos')),
      })),
    )
    
    const fixturePromise = TestBed.inject(ApplicationRef).whenStable()
    httpCtrl.expectOne('/api/todos').flush([{ id: 1 }])
    await fixturePromise
    
    expect(query.data()).toEqual([{ id: 1 }])
    httpCtrl.verify()
    

    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
      providers: [provideTanStackQuery(queryClient)],
    })
    
    const httpCtrl = TestBed.inject(HttpTestingController)
    const query = TestBed.runInInjectionContext(() =>
      injectQuery(() => ({
        queryKey: ['todos'],
        queryFn: () => lastValueFrom(TestBed.inject(HttpClient).get('/api/todos')),
      })),
    )
    
    const fixturePromise = TestBed.inject(ApplicationRef).whenStable()
    httpCtrl.expectOne('/api/todos').flush([{ id: 1 }])
    await fixturePromise
    
    expect(query.data()).toEqual([{ id: 1 }])
    httpCtrl.verify()
    

Use the same pattern for infinite queries: call fetchNextPage(), advance timers if you are faking time, then await stability and assert on data().pages.

    const infinite = TestBed.runInInjectionContext(() =>
      injectInfiniteQuery(() => ({
        queryKey: ['pages'],
        queryFn: ({ pageParam = 1 }) => fetchPage(pageParam),
        getNextPageParam: (last, all) => all.length + 1,
      })),
    )
    
    await appRef.whenStable()
    expect(infinite.data().pages).toHaveLength(1)
    
    await infinite.fetchNextPage()
    await vi.advanceTimersByTimeAsync(0)
    await appRef.whenStable()
    
    expect(infinite.data().pages).toHaveLength(2)
    

    const infinite = TestBed.runInInjectionContext(() =>
      injectInfiniteQuery(() => ({
        queryKey: ['pages'],
        queryFn: ({ pageParam = 1 }) => fetchPage(pageParam),
        getNextPageParam: (last, all) => all.length + 1,
      })),
    )
    
    await appRef.whenStable()
    expect(infinite.data().pages).toHaveLength(1)
    
    await infinite.fetchNextPage()
    await vi.advanceTimersByTimeAsync(0)
    await appRef.whenStable()
    
    expect(infinite.data().pages).toHaveLength(2)
    

[](#mutations-and-optimistic-updates)[Mutations and optimistic updates](#mutations-and-optimistic-updates)
----------------------------------------------------------------------------------------------------------

    const mutation = TestBed.runInInjectionContext(() =>
      injectMutation(() => ({
        mutationFn: async (input: string) => input.toUpperCase(),
      })),
    )
    
    mutation.mutate('test')
    
    // Trigger effect
    TestBed.tick()
    
    await appRef.whenStable()
    
    expect(mutation.isSuccess()).toBe(true)
    expect(mutation.data()).toBe('TEST')
    

    const mutation = TestBed.runInInjectionContext(() =>
      injectMutation(() => ({
        mutationFn: async (input: string) => input.toUpperCase(),
      })),
    )
    
    mutation.mutate('test')
    
    // Trigger effect
    TestBed.tick()
    
    await appRef.whenStable()
    
    expect(mutation.isSuccess()).toBe(true)
    expect(mutation.data()).toBe('TEST')
    

[](#quick-checklist)[Quick checklist](#quick-checklist)
-------------------------------------------------------

*   Fresh QueryClient per test (and clear it afterwards)
*   Disable or control retries to avoid timeouts
*   Advance timers + microtasks before whenStable() when using fake timers
*   Use HttpClientTestingModule or your preferred mock to assert network calls
*   Await whenStable() after every refetch, fetchNextPage, or mutation
*   Prefer TestBed.runInInjectionContext for service tests and fixture.whenStable() for component tests</content>
</page>

<page>
  <title>Scroll Restoration | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/guides/scroll-restoration</url>
  <content>Traditionally, when you navigate to a previously visited page on a web browser, you would find that the page would be scrolled to the exact position where you were before you navigated away from that page. This is called **scroll restoration** and has been in a bit of a regression since web applications have started moving towards client side data fetching. With TanStack Query however, that's no longer the case.

Out of the box, "scroll restoration" for all queries (including paginated and infinite queries) Just Works‚Ñ¢Ô∏è in TanStack Query. The reason for this is that query results are cached and able to be retrieved synchronously when a query is rendered. As long as your queries are being cached long enough (the default time is 5 minutes) and have not been garbage collected, scroll restoration will work out of the box all the time.</content>
</page>

<page>
  <title>Does TanStack Query replace Redux, MobX or other global state managers? | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/guides/does-this-replace-client-state</url>
  <content>Well, let's start with a few important items:

*   TanStack Query is a **server-state** library, responsible for managing asynchronous operations between your server and client
*   Redux, MobX, Zustand, etc. are **client-state** libraries that _can be used to store asynchronous data, albeit inefficiently when compared to a tool like TanStack Query_

With those points in mind, the short answer is that TanStack Query **replaces the boilerplate code and related wiring used to manage cache data in your client-state and replaces it with just a few lines of code.**

For a vast majority of applications, the truly **globally accessible client state** that is left over after migrating all of your async code to TanStack Query is usually very tiny.

> There are still some circumstances where an application might indeed have a massive amount of synchronous client-only state (like a visual designer or music production application), in which case, you will probably still want a client state manager. In this situation it's important to note that **TanStack Query is not a replacement for local/client state management**. However, you can use TanStack Query alongside most client state managers with zero issues.

[](#a-contrived-example)[A Contrived Example](#a-contrived-example)
-------------------------------------------------------------------

Here we have some "global" state being managed by a global state library:

    const globalState = {
      projects,
      teams,
      tasks,
      users,
      themeMode,
      sidebarStatus,
    }
    

    const globalState = {
      projects,
      teams,
      tasks,
      users,
      themeMode,
      sidebarStatus,
    }
    

Currently, the global state manager is caching 4 types of server-state: projects, teams, tasks, and users. If we were to move these server-state assets to TanStack Query, our remaining global state would look more like this:

    const globalState = {
      themeMode,
      sidebarStatus,
    }
    

    const globalState = {
      themeMode,
      sidebarStatus,
    }
    

This also means that with a few function calls to injectQuery and injectMutation, we also get to remove any boilerplate code that was used to manage our server state e.g.

*   Connectors
*   Action Creators
*   Middlewares
*   Reducers
*   Loading/Error/Result states
*   Contexts

With all of those things removed, you may ask yourself, **"Is it worth it to keep using our client state manager for this tiny global state?"**

**And that's up to you!**

But TanStack Query's role is clear. It removes asynchronous wiring and boilerplate from your application and replaces it with just a few lines of code.

What are you waiting for, give it a go already!</content>
</page>

<page>
  <title>@tanstack/angular-query-experimental | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/index</url>
  <content>Guides & Concepts

*   [
    
    Important Defaults
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/important-defaults)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/queries)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/query-keys)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/query-functions)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/query-options)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/network-mode)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/parallel-queries)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/disabling-queries)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/query-retries)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/paginated-queries)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/infinite-queries)
*   [
    
    Initial Query Data
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/placeholder-query-data)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/mutations)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/mutation-options)
*   [
    
    Query Invalidation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/invalidations-from-mutations)
*   [
    
    Optimistic Updates
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/optimistic-updates)
*   [
    
    Query Cancellation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-cancellation)
*   [
    
    Scroll Restoration
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/scroll-restoration)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/filters)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/caching)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/default-query-function)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/testing)
*   [
    
    Does this replace state managers?
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/does-this-replace-client-state)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Examples

*   [](https://tanstack.com/query/latest/docs/framework/angular/examples/simple)
*   [](https://tanstack.com/query/latest/docs/framework/angular/examples/basic)
*   [
    
    Auto Refetching / Polling / Realtime
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/auto-refetching)
*   [
    
    Optimistic Updates
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/optimistic-updates)
*   [](https://tanstack.com/query/latest/docs/framework/angular/examples/pagination)
*   [
    
    Infinite query with maxPages
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/infinite-query-with-max-pages)
*   [](https://tanstack.com/query/latest/docs/framework/angular/examples/router)
*   [](https://tanstack.com/query/latest/docs/framework/angular/examples/rxjs)
*   [
    
    Query options from a service
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/query-options-from-a-service)
*   [
    
    Devtools embedded panel
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/devtools-panel)

Guides & Concepts

*   [
    
    Important Defaults
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/important-defaults)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/queries)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/query-keys)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/query-functions)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/query-options)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/network-mode)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/parallel-queries)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/disabling-queries)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/query-retries)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/paginated-queries)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/infinite-queries)
*   [
    
    Initial Query Data
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/placeholder-query-data)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/mutations)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/mutation-options)
*   [
    
    Query Invalidation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/invalidations-from-mutations)
*   [
    
    Optimistic Updates
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/optimistic-updates)
*   [
    
    Query Cancellation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-cancellation)
*   [
    
    Scroll Restoration
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/scroll-restoration)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/filters)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/caching)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/default-query-function)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/testing)
*   [
    
    Does this replace state managers?
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/does-this-replace-client-state)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Examples

*   [](https://tanstack.com/query/latest/docs/framework/angular/examples/simple)
*   [](https://tanstack.com/query/latest/docs/framework/angular/examples/basic)
*   [
    
    Auto Refetching / Polling / Realtime
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/auto-refetching)
*   [
    
    Optimistic Updates
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/optimistic-updates)
*   [](https://tanstack.com/query/latest/docs/framework/angular/examples/pagination)
*   [
    
    Infinite query with maxPages
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/infinite-query-with-max-pages)
*   [](https://tanstack.com/query/latest/docs/framework/angular/examples/router)
*   [](https://tanstack.com/query/latest/docs/framework/angular/examples/rxjs)
*   [
    
    Query options from a service
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/query-options-from-a-service)
*   [
    
    Devtools embedded panel
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/devtools-panel)

[](#tanstackangular-query-experimental)[@tanstack/angular-query-experimental](#tanstackangular-query-experimental)
------------------------------------------------------------------------------------------------------------------

[](#interfaces)[Interfaces](#interfaces)
----------------------------------------

*   [BaseMutationNarrowing](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/BaseMutationNarrowing)
*   [BaseQueryNarrowing](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/BaseQueryNarrowing)
*   [CreateBaseQueryOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/CreateBaseQueryOptions)
*   [CreateInfiniteQueryOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/CreateInfiniteQueryOptions)
*   [CreateMutationOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/CreateMutationOptions)
*   [CreateQueryOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/CreateQueryOptions)
*   [InjectInfiniteQueryOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/InjectInfiniteQueryOptions)
*   [InjectIsFetchingOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/InjectIsFetchingOptions)
*   [InjectIsMutatingOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/InjectIsMutatingOptions)
*   [InjectMutationOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/InjectMutationOptions)
*   [InjectMutationStateOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/InjectMutationStateOptions)
*   [InjectQueryOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/InjectQueryOptions)
*   [QueryFeature](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/QueryFeature)

[](#type-aliases)[Type Aliases](#type-aliases)
----------------------------------------------

*   [CreateBaseMutationResult](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/CreateBaseMutationResult)
*   [CreateBaseQueryResult](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/CreateBaseQueryResult)
*   [CreateInfiniteQueryResult](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/CreateInfiniteQueryResult)
*   [CreateMutateAsyncFunction](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/CreateMutateAsyncFunction)
*   [CreateMutateFunction](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/CreateMutateFunction)
*   [CreateMutationResult](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/CreateMutationResult)
*   [CreateQueryResult](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/CreateQueryResult)
*   [DefinedCreateInfiniteQueryResult](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/DefinedCreateInfiniteQueryResult)
*   [DefinedCreateQueryResult](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/DefinedCreateQueryResult)
*   [DefinedInitialDataInfiniteOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/DefinedInitialDataInfiniteOptions)
*   [DefinedInitialDataOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/DefinedInitialDataOptions)
*   [DevtoolsFeature](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/DevtoolsFeature)
*   [PersistQueryClientFeature](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/PersistQueryClientFeature)
*   [QueriesOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/QueriesOptions)
*   [QueriesResults](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/QueriesResults)
*   [QueryFeatures](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/QueryFeatures)
*   [UndefinedInitialDataInfiniteOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/UndefinedInitialDataInfiniteOptions)
*   [UndefinedInitialDataOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/UndefinedInitialDataOptions)
*   [UnusedSkipTokenInfiniteOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/UnusedSkipTokenInfiniteOptions)
*   [UnusedSkipTokenOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/UnusedSkipTokenOptions)

[](#functions)[Functions](#functions)
-------------------------------------

*   [infiniteQueryOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/infiniteQueryOptions)
*   [injectInfiniteQuery](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectInfiniteQuery)
*   [injectIsFetching](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectIsFetching)
*   [injectIsMutating](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectIsMutating)
*   [injectIsRestoring](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectIsRestoring)
*   [injectMutation](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectMutation)
*   [injectMutationState](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectMutationState)
*   [injectQuery](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectQuery)
*   [~injectQueryClient~](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectQueryClient)
*   [mutationOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/mutationOptions)
*   [~provideAngularQuery~](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/provideAngularQuery)
*   [provideIsRestoring](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/provideIsRestoring)
*   [provideQueryClient](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/provideQueryClient)
*   [provideTanStackQuery](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/provideTanStackQuery)
*   [queryFeature](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/queryFeature)
*   [queryOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/queryOptions)

[Edit on GitHub](https://github.com/tanstack/query/edit/main/docs/framework/angular/reference/index.md)</content>
</page>

<page>
  <title>injectMutation | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectMutation</url>
  <content>[](#function-injectmutation)[Function: injectMutation()](#function-injectmutation)
----------------------------------------------------------------------------------

    function injectMutation<TData, TError, TVariables, TOnMutateResult>(injectMutationFn, options?): CreateMutationResult<TData, TError, TVariables, TOnMutateResult>;
    

    function injectMutation<TData, TError, TVariables, TOnMutateResult>(injectMutationFn, options?): CreateMutationResult<TData, TError, TVariables, TOnMutateResult>;
    

Defined in: [inject-mutation.ts:45](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/inject-mutation.ts#L45)

Injects a mutation: an imperative function that can be invoked which typically performs server side effects.

Unlike queries, mutations are not run automatically.

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tdata)[TData](#tdata)

TData = unknown

### [](#terror)[TError](#terror)

TError = Error

### [](#tvariables)[TVariables](#tvariables)

TVariables = void

### [](#tonmutateresult)[TOnMutateResult](#tonmutateresult)

TOnMutateResult = unknown

[](#parameters)[Parameters](#parameters)
----------------------------------------

### [](#injectmutationfn)[injectMutationFn](#injectmutationfn)

() => [CreateMutationOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/CreateMutationOptions)<TData, TError, TVariables, TOnMutateResult\>

A function that returns mutation options.

### [](#options)[options?](#options)

[InjectMutationOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/InjectMutationOptions)

Additional configuration

[](#returns)[Returns](#returns)
-------------------------------

[CreateMutationResult](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/CreateMutationResult)<TData, TError, TVariables, TOnMutateResult\>

The mutation.</content>
</page>

<page>
  <title>injectQuery | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectQuery</url>
  <content>[](#function-injectquery)[Function: injectQuery()](#function-injectquery)
-------------------------------------------------------------------------

Injects a query: a declarative dependency on an asynchronous source of data that is tied to a unique key.

**Basic example**

    class ServiceOrComponent {
      query = injectQuery(() => ({
        queryKey: ['repoData'],
        queryFn: () =>
          this.#http.get<Response>('https://api.github.com/repos/tanstack/query'),
      }))
    }
    

    class ServiceOrComponent {
      query = injectQuery(() => ({
        queryKey: ['repoData'],
        queryFn: () =>
          this.#http.get<Response>('https://api.github.com/repos/tanstack/query'),
      }))
    }
    

Similar to computed from Angular, the function passed to injectQuery will be run in the reactive context. In the example below, the query will be automatically enabled and executed when the filter signal changes to a truthy value. When the filter signal changes back to a falsy value, the query will be disabled.

**Reactive example**

    class ServiceOrComponent {
      filter = signal('')
    
      todosQuery = injectQuery(() => ({
        queryKey: ['todos', this.filter()],
        queryFn: () => fetchTodos(this.filter()),
        // Signals can be combined with expressions
        enabled: !!this.filter(),
      }))
    }
    

    class ServiceOrComponent {
      filter = signal('')
    
      todosQuery = injectQuery(() => ({
        queryKey: ['todos', this.filter()],
        queryFn: () => fetchTodos(this.filter()),
        // Signals can be combined with expressions
        enabled: !!this.filter(),
      }))
    }
    

[](#param)[Param](#param)
-------------------------

A function that returns query options.

[](#param-1)[Param](#param-1)
-----------------------------

Additional configuration

[](#see)[See](#see)
-------------------

[https://tanstack.com/query/latest/docs/framework/angular/guides/queries](https://tanstack.com/query/latest/docs/framework/angular/guides/queries)

[](#call-signature)[Call Signature](#call-signature)
----------------------------------------------------

    function injectQuery<TQueryFnData, TError, TData, TQueryKey>(injectQueryFn, options?): DefinedCreateQueryResult<TData, TError>;
    

    function injectQuery<TQueryFnData, TError, TData, TQueryKey>(injectQueryFn, options?): DefinedCreateQueryResult<TData, TError>;
    

Defined in: [inject-query.ts:65](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/inject-query.ts#L65)

Injects a query: a declarative dependency on an asynchronous source of data that is tied to a unique key.

**Basic example**

    class ServiceOrComponent {
      query = injectQuery(() => ({
        queryKey: ['repoData'],
        queryFn: () =>
          this.#http.get<Response>('https://api.github.com/repos/tanstack/query'),
      }))
    }
    

    class ServiceOrComponent {
      query = injectQuery(() => ({
        queryKey: ['repoData'],
        queryFn: () =>
          this.#http.get<Response>('https://api.github.com/repos/tanstack/query'),
      }))
    }
    

Similar to computed from Angular, the function passed to injectQuery will be run in the reactive context. In the example below, the query will be automatically enabled and executed when the filter signal changes to a truthy value. When the filter signal changes back to a falsy value, the query will be disabled.

**Reactive example**

    class ServiceOrComponent {
      filter = signal('')
    
      todosQuery = injectQuery(() => ({
        queryKey: ['todos', this.filter()],
        queryFn: () => fetchTodos(this.filter()),
        // Signals can be combined with expressions
        enabled: !!this.filter(),
      }))
    }
    

    class ServiceOrComponent {
      filter = signal('')
    
      todosQuery = injectQuery(() => ({
        queryKey: ['todos', this.filter()],
        queryFn: () => fetchTodos(this.filter()),
        // Signals can be combined with expressions
        enabled: !!this.filter(),
      }))
    }
    

### [](#type-parameters)[Type Parameters](#type-parameters)

#### [](#tqueryfndata)[TQueryFnData](#tqueryfndata)

TQueryFnData = unknown

#### [](#terror)[TError](#terror)

TError = Error

#### [](#tdata)[TData](#tdata)

TData = TQueryFnData

#### [](#tquerykey)[TQueryKey](#tquerykey)

TQueryKey _extends_ readonly unknown\[\] = readonly unknown\[\]

### [](#parameters)[Parameters](#parameters)

#### [](#injectqueryfn)[injectQueryFn](#injectqueryfn)

() => [DefinedInitialDataOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/DefinedInitialDataOptions)<TQueryFnData, TError, TData, TQueryKey\>

A function that returns query options.

#### [](#options)[options?](#options)

[InjectQueryOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/InjectQueryOptions)

Additional configuration

### [](#returns)[Returns](#returns)

[DefinedCreateQueryResult](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/DefinedCreateQueryResult)<TData, TError\>

The query result.

### [](#see-1)[See](#see-1)

[https://tanstack.com/query/latest/docs/framework/angular/guides/queries](https://tanstack.com/query/latest/docs/framework/angular/guides/queries)

[](#call-signature-1)[Call Signature](#call-signature-1)
--------------------------------------------------------

    function injectQuery<TQueryFnData, TError, TData, TQueryKey>(injectQueryFn, options?): CreateQueryResult<TData, TError>;
    

    function injectQuery<TQueryFnData, TError, TData, TQueryKey>(injectQueryFn, options?): CreateQueryResult<TData, TError>;
    

Defined in: [inject-query.ts:116](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/inject-query.ts#L116)

Injects a query: a declarative dependency on an asynchronous source of data that is tied to a unique key.

**Basic example**

    class ServiceOrComponent {
      query = injectQuery(() => ({
        queryKey: ['repoData'],
        queryFn: () =>
          this.#http.get<Response>('https://api.github.com/repos/tanstack/query'),
      }))
    }
    

    class ServiceOrComponent {
      query = injectQuery(() => ({
        queryKey: ['repoData'],
        queryFn: () =>
          this.#http.get<Response>('https://api.github.com/repos/tanstack/query'),
      }))
    }
    

Similar to computed from Angular, the function passed to injectQuery will be run in the reactive context. In the example below, the query will be automatically enabled and executed when the filter signal changes to a truthy value. When the filter signal changes back to a falsy value, the query will be disabled.

**Reactive example**

    class ServiceOrComponent {
      filter = signal('')
    
      todosQuery = injectQuery(() => ({
        queryKey: ['todos', this.filter()],
        queryFn: () => fetchTodos(this.filter()),
        // Signals can be combined with expressions
        enabled: !!this.filter(),
      }))
    }
    

    class ServiceOrComponent {
      filter = signal('')
    
      todosQuery = injectQuery(() => ({
        queryKey: ['todos', this.filter()],
        queryFn: () => fetchTodos(this.filter()),
        // Signals can be combined with expressions
        enabled: !!this.filter(),
      }))
    }
    

### [](#type-parameters-1)[Type Parameters](#type-parameters-1)

#### [](#tqueryfndata-1)[TQueryFnData](#tqueryfndata-1)

TQueryFnData = unknown

#### [](#terror-1)[TError](#terror-1)

TError = Error

#### [](#tdata-1)[TData](#tdata-1)

TData = TQueryFnData

#### [](#tquerykey-1)[TQueryKey](#tquerykey-1)

TQueryKey _extends_ readonly unknown\[\] = readonly unknown\[\]

### [](#parameters-1)[Parameters](#parameters-1)

#### [](#injectqueryfn-1)[injectQueryFn](#injectqueryfn-1)

() => [UndefinedInitialDataOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/UndefinedInitialDataOptions)<TQueryFnData, TError, TData, TQueryKey\>

A function that returns query options.

#### [](#options-1)[options?](#options-1)

[InjectQueryOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/InjectQueryOptions)

Additional configuration

### [](#returns-1)[Returns](#returns-1)

[CreateQueryResult](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/CreateQueryResult)<TData, TError\>

The query result.

### [](#see-2)[See](#see-2)

[https://tanstack.com/query/latest/docs/framework/angular/guides/queries](https://tanstack.com/query/latest/docs/framework/angular/guides/queries)

[](#call-signature-2)[Call Signature](#call-signature-2)
--------------------------------------------------------

    function injectQuery<TQueryFnData, TError, TData, TQueryKey>(injectQueryFn, options?): CreateQueryResult<TData, TError>;
    

    function injectQuery<TQueryFnData, TError, TData, TQueryKey>(injectQueryFn, options?): CreateQueryResult<TData, TError>;
    

Defined in: [inject-query.ts:167](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/inject-query.ts#L167)

Injects a query: a declarative dependency on an asynchronous source of data that is tied to a unique key.

**Basic example**

    class ServiceOrComponent {
      query = injectQuery(() => ({
        queryKey: ['repoData'],
        queryFn: () =>
          this.#http.get<Response>('https://api.github.com/repos/tanstack/query'),
      }))
    }
    

    class ServiceOrComponent {
      query = injectQuery(() => ({
        queryKey: ['repoData'],
        queryFn: () =>
          this.#http.get<Response>('https://api.github.com/repos/tanstack/query'),
      }))
    }
    

Similar to computed from Angular, the function passed to injectQuery will be run in the reactive context. In the example below, the query will be automatically enabled and executed when the filter signal changes to a truthy value. When the filter signal changes back to a falsy value, the query will be disabled.

**Reactive example**

    class ServiceOrComponent {
      filter = signal('')
    
      todosQuery = injectQuery(() => ({
        queryKey: ['todos', this.filter()],
        queryFn: () => fetchTodos(this.filter()),
        // Signals can be combined with expressions
        enabled: !!this.filter(),
      }))
    }
    

    class ServiceOrComponent {
      filter = signal('')
    
      todosQuery = injectQuery(() => ({
        queryKey: ['todos', this.filter()],
        queryFn: () => fetchTodos(this.filter()),
        // Signals can be combined with expressions
        enabled: !!this.filter(),
      }))
    }
    

### [](#type-parameters-2)[Type Parameters](#type-parameters-2)

#### [](#tqueryfndata-2)[TQueryFnData](#tqueryfndata-2)

TQueryFnData = unknown

#### [](#terror-2)[TError](#terror-2)

TError = Error

#### [](#tdata-2)[TData](#tdata-2)

TData = TQueryFnData

#### [](#tquerykey-2)[TQueryKey](#tquerykey-2)

TQueryKey _extends_ readonly unknown\[\] = readonly unknown\[\]

### [](#parameters-2)[Parameters](#parameters-2)

#### [](#injectqueryfn-2)[injectQueryFn](#injectqueryfn-2)

() => [CreateQueryOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/CreateQueryOptions)<TQueryFnData, TError, TData, TQueryKey\>

A function that returns query options.

#### [](#options-2)[options?](#options-2)

[InjectQueryOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/InjectQueryOptions)

Additional configuration

### [](#returns-2)[Returns](#returns-2)

[CreateQueryResult](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/CreateQueryResult)<TData, TError\>

The query result.

### [](#see-3)[See](#see-3)

[https://tanstack.com/query/latest/docs/framework/angular/guides/queries](https://tanstack.com/query/latest/docs/framework/angular/guides/queries)</content>
</page>

<page>
  <title>Angular TanStack Query Simple Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/examples/simple</url>
  <content>    import { ChangeDetectionStrategy, Component } from '@angular/core'
    import { SimpleExampleComponent } from './components/simple-example.component'
    
    @Component({
      selector: 'app-root',
      changeDetection: ChangeDetectionStrategy.OnPush,
      imports: [SimpleExampleComponent],
      template: `<simple-example />`,
    })
    export class AppComponent {}
    

    import { ChangeDetectionStrategy, Component } from '@angular/core'
    import { SimpleExampleComponent } from './components/simple-example.component'
    
    @Component({
      selector: 'app-root',
      changeDetection: ChangeDetectionStrategy.OnPush,
      imports: [SimpleExampleComponent],
      template: `<simple-example />`,
    })
    export class AppComponent {}</content>
</page>

<page>
  <title>Angular TanStack Query Auto Refetching Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/examples/auto-refetching</url>
  <content>    import { ChangeDetectionStrategy, Component } from '@angular/core'
    import { AutoRefetchingExampleComponent } from './components/auto-refetching.component'
    
    @Component({
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: 'app-root',
      template: `<auto-refetching-example />`,
      imports: [AutoRefetchingExampleComponent],
    })
    export class AppComponent {}
    

    import { ChangeDetectionStrategy, Component } from '@angular/core'
    import { AutoRefetchingExampleComponent } from './components/auto-refetching.component'
    
    @Component({
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: 'app-root',
      template: `<auto-refetching-example />`,
      imports: [AutoRefetchingExampleComponent],
    })
    export class AppComponent {}</content>
</page>

<page>
  <title>Angular TanStack Query Basic Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/examples/basic</url>
  <content>    import { ChangeDetectionStrategy, Component, signal } from '@angular/core'
    import { PostComponent } from './components/post.component'
    import { PostsComponent } from './components/posts.component'
    
    @Component({
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: 'basic-example',
      templateUrl: './app.component.html',
      imports: [PostComponent, PostsComponent],
    })
    export class BasicExampleComponent {
      readonly postId = signal(-1)
    }
    

    import { ChangeDetectionStrategy, Component, signal } from '@angular/core'
    import { PostComponent } from './components/post.component'
    import { PostsComponent } from './components/posts.component'
    
    @Component({
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: 'basic-example',
      templateUrl: './app.component.html',
      imports: [PostComponent, PostsComponent],
    })
    export class BasicExampleComponent {
      readonly postId = signal(-1)
    }</content>
</page>

<page>
  <title>Angular TanStack Query Optimistic Updates Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/examples/optimistic-updates</url>
  <content>    import { ChangeDetectionStrategy, Component } from '@angular/core'
    import { OptimisticUpdatesComponent } from './components/optimistic-updates.component'
    
    @Component({
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: 'app-root',
      template: `<optimistic-updates />`,
      imports: [OptimisticUpdatesComponent],
    })
    export class AppComponent {}
    

    import { ChangeDetectionStrategy, Component } from '@angular/core'
    import { OptimisticUpdatesComponent } from './components/optimistic-updates.component'
    
    @Component({
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: 'app-root',
      template: `<optimistic-updates />`,
      imports: [OptimisticUpdatesComponent],
    })
    export class AppComponent {}</content>
</page>

<page>
  <title>Angular TanStack Query Pagination Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/examples/pagination</url>
  <content>    import { ChangeDetectionStrategy, Component } from '@angular/core'
    import { ExampleComponent } from './components/example.component'
    
    @Component({
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: 'app-root',
      template: `<example />`,
      imports: [ExampleComponent],
    })
    export class AppComponent {}
    

    import { ChangeDetectionStrategy, Component } from '@angular/core'
    import { ExampleComponent } from './components/example.component'
    
    @Component({
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: 'app-root',
      template: `<example />`,
      imports: [ExampleComponent],
    })
    export class AppComponent {}</content>
</page>

<page>
  <title>Angular TanStack Query Infinite Query With Max Pages Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/examples/infinite-query-with-max-pages</url>
  <content>    import { ChangeDetectionStrategy, Component } from '@angular/core'
    import { ExampleComponent } from './components/example.component'
    
    @Component({
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: 'app-root',
      template: `<example />`,
      imports: [ExampleComponent],
    })
    export class AppComponent {}
    

    import { ChangeDetectionStrategy, Component } from '@angular/core'
    import { ExampleComponent } from './components/example.component'
    
    @Component({
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: 'app-root',
      template: `<example />`,
      imports: [ExampleComponent],
    })
    export class AppComponent {}</content>
</page>

<page>
  <title>Overview | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/overview</url>
  <content>Solid Query is the official SolidJS adapter of TanStack Query that makes **fetching, caching, synchronizing and updating server state** in your web applications a breeze.

[](#motivation)[Motivation](#motivation)
----------------------------------------

SolidJS has been gaining popularity as a fast, reactive, and declarative library for building user interfaces. It comes packed with a lot of features out of the box. Primitives like createSignal, createStore are great for managing client state. And, unlike other UI libraries, SolidJS has strong opinions about managing asynchronous data. The createResource API is a great primitive for handling server state in SolidJS apps. A resource is a special kind of signal that can be used to trigger Suspense boundaries when the data is in a loading state.

    import { createResource, ErrorBoundary, Suspense } from 'solid-js'
    import { render } from 'solid-js/web'
    
    function App() {
      const [repository] = createResource(async () => {
        const result = await fetch('https://api.github.com/repos/TanStack/query')
        if (!result.ok) throw new Error('Failed to fetch data')
        return result.json()
      })
    
      return (
        <div>
          <div>Static Content</div>
          {/* An error while fetching will be caught by the ErrorBoundary */}
          <ErrorBoundary fallback={<div>Something went wrong!</div>}>
            {/* Suspense will trigger a loading state while the data is being fetched */}
            <Suspense fallback={<div>Loading...</div>}>
              <div>{repository()?.updated_at}</div>
            </Suspense>
          </ErrorBoundary>
        </div>
      )
    }
    
    const root = document.getElementById('root')
    
    render(() => <App />, root!)
    

    import { createResource, ErrorBoundary, Suspense } from 'solid-js'
    import { render } from 'solid-js/web'
    
    function App() {
      const [repository] = createResource(async () => {
        const result = await fetch('https://api.github.com/repos/TanStack/query')
        if (!result.ok) throw new Error('Failed to fetch data')
        return result.json()
      })
    
      return (
        <div>
          <div>Static Content</div>
          {/* An error while fetching will be caught by the ErrorBoundary */}
          <ErrorBoundary fallback={<div>Something went wrong!</div>}>
            {/* Suspense will trigger a loading state while the data is being fetched */}
            <Suspense fallback={<div>Loading...</div>}>
              <div>{repository()?.updated_at}</div>
            </Suspense>
          </ErrorBoundary>
        </div>
      )
    }
    
    const root = document.getElementById('root')
    
    render(() => <App />, root!)
    

This is amazing! In a few lines of code, you can fetch data from an API and handle loading and error states. But, as your application grows in complexity, you will need more features to manage server state effectively. This is because **server state is totally different from client state**. For starters, server state:

*   Is persisted remotely in a location you do not control or own
*   Requires asynchronous APIs for fetching and updating
*   Implies shared ownership and can be changed by other people without your knowledge
*   Can potentially become "out of date" in your applications if you're not careful

Once you grasp the nature of server state in your application, **even more challenges will arise** as you go, for example:

*   Caching... (possibly the hardest thing to do in programming)
*   Deduping multiple requests for the same data into a single request
*   Updating "out of date" data in the background
*   Knowing when data is "out of date"
*   Reflecting updates to data as quickly as possible
*   Performance optimizations like pagination and lazy loading data
*   Managing memory and garbage collection of server state
*   Memoizing query results with structural sharing

This is where **Solid Query** comes in. The library wraps around createResource and provides a set of hooks and utilities to manage server state effectively. It works amazingly well **out-of-the-box, with zero-config, and can be customized** to your liking as your application grows.

On a more technical note, Solid Query will likely:

*   Help you remove **many** lines of complicated and misunderstood code from your application and replace with just a handful of lines of Solid Query logic.
*   Make your application more maintainable and easier to build new features without worrying about wiring up new server state data sources
*   Have a direct impact on your end-users by making your application feel faster and more responsive than ever before.
*   Potentially help you save on bandwidth and increase memory performance

[](#enough-talk-show-me-some-code-already)[Enough talk, show me some code already!](#enough-talk-show-me-some-code-already)
---------------------------------------------------------------------------------------------------------------------------

In the example below, you can see Solid Query in its most basic and simple form being used to fetch the GitHub stats for the TanStack Query GitHub project itself:

    import { ErrorBoundary, Suspense } from 'solid-js'
    import {
      useQuery,
      QueryClient,
      QueryClientProvider,
    } from '@tanstack/solid-query'
    
    function App() {
      const repositoryQuery = useQuery(() => ({
        queryKey: ['TanStack Query'],
        queryFn: async () => {
          const result = await fetch('https://api.github.com/repos/TanStack/query')
          if (!result.ok) throw new Error('Failed to fetch data')
          return result.json()
        },
        staleTime: 1000 * 60 * 5, // 5 minutes
        throwOnError: true, // Throw an error if the query fails
      }))
    
      return (
        <div>
          <div>Static Content</div>
          {/* An error while fetching will be caught by the ErrorBoundary */}
          <ErrorBoundary fallback={<div>Something went wrong!</div>}>
            {/* Suspense will trigger a loading state while the data is being fetched */}
            <Suspense fallback={<div>Loading...</div>}>
              {/* 
                The `data` property on a query is a SolidJS resource  
                so it will work with Suspense and transitions out of the box! 
              */}
              <div>{repositoryQuery.data?.updated_at}</div>
            </Suspense>
          </ErrorBoundary>
        </div>
      )
    }
    
    const root = document.getElementById('root')
    const client = new QueryClient()
    
    render(
      () => (
        <QueryClientProvider client={client}>
          <App />
        </QueryClientProvider>
      ),
      root!,
    )
    

    import { ErrorBoundary, Suspense } from 'solid-js'
    import {
      useQuery,
      QueryClient,
      QueryClientProvider,
    } from '@tanstack/solid-query'
    
    function App() {
      const repositoryQuery = useQuery(() => ({
        queryKey: ['TanStack Query'],
        queryFn: async () => {
          const result = await fetch('https://api.github.com/repos/TanStack/query')
          if (!result.ok) throw new Error('Failed to fetch data')
          return result.json()
        },
        staleTime: 1000 * 60 * 5, // 5 minutes
        throwOnError: true, // Throw an error if the query fails
      }))
    
      return (
        <div>
          <div>Static Content</div>
          {/* An error while fetching will be caught by the ErrorBoundary */}
          <ErrorBoundary fallback={<div>Something went wrong!</div>}>
            {/* Suspense will trigger a loading state while the data is being fetched */}
            <Suspense fallback={<div>Loading...</div>}>
              {/* 
                The `data` property on a query is a SolidJS resource  
                so it will work with Suspense and transitions out of the box! 
              */}
              <div>{repositoryQuery.data?.updated_at}</div>
            </Suspense>
          </ErrorBoundary>
        </div>
      )
    }
    
    const root = document.getElementById('root')
    const client = new QueryClient()
    
    render(
      () => (
        <QueryClientProvider client={client}>
          <App />
        </QueryClientProvider>
      ),
      root!,
    )
    

[](#well-that-seems-like-more-lines-of-code-to-do-the-same-thing)[Well, that seems like more lines of code to do the same thing?](#well-that-seems-like-more-lines-of-code-to-do-the-same-thing)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Yes it is! But, these few lines of code unlock a whole new world of possibilities. In the example above, your query is cached for 5 minutes, meaning that if a new component mounts anywhere in your app that uses the same query within 5 minutes, it will not re-fetch the data but instead use the cached data. This is just one of the many features that Solid Query provides out of the box. Some other features include:

*   **Automatic Refetching**: Queries automatically refetch in the background when they become "stale" (out of date according to the staleTime option)
*   **Automatic Caching**: Queries are cached by default and shared across your application
*   **Request Deduplication**: Multiple components can share the same query and make one request
*   **Automatic Garbage Collection**: Queries are garbage collected when they are no longer needed
*   **Window Focus Refetching**: Queries automatically refetch when the application comes back into focus
*   **Pagination**: Built-in support for pagination
*   **Request Cancellation**: Automatically cancels outdated or unwanted requests
*   **Polling/Realtime**: It's easy to add polling or realtime updates to your queries with a simple refetchInterval option
*   **SSR Support**: Solid Query works great with server-side rendering
*   **Optimistic Updates**: Easily update your cache with optimistic updates
*   **And much more...**</content>
</page>

<page>
  <title>Angular TanStack Query Router Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/examples/router</url>
  <content>    import { ChangeDetectionStrategy, Component } from '@angular/core'
    import { RouterOutlet } from '@angular/router'
    
    @Component({
      selector: 'app-root',
      changeDetection: ChangeDetectionStrategy.OnPush,
      imports: [RouterOutlet],
      templateUrl: './app.component.html',
    })
    export class AppComponent {}
    

    import { ChangeDetectionStrategy, Component } from '@angular/core'
    import { RouterOutlet } from '@angular/router'
    
    @Component({
      selector: 'app-root',
      changeDetection: ChangeDetectionStrategy.OnPush,
      imports: [RouterOutlet],
      templateUrl: './app.component.html',
    })
    export class AppComponent {}</content>
</page>

<page>
  <title>Quick Start | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/quick-start</url>
  <content>The @tanstack/solid-query package provides a 1st-class API for using TanStack Query with SolidJS.

[](#example)[Example](#example)
-------------------------------

    import {
      QueryClient,
      QueryClientProvider,
      useQuery,
    } from '@tanstack/solid-query'
    import { Switch, Match, For } from 'solid-js'
    
    const queryClient = new QueryClient()
    
    function Example() {
      const query = useQuery(() => ({
        queryKey: ['todos'],
        queryFn: fetchTodos,
      }))
    
      return (
        <div>
          <Switch>
            <Match when={query.isPending}>
              <p>Loading...</p>
            </Match>
            <Match when={query.isError}>
              <p>Error: {query.error.message}</p>
            </Match>
            <Match when={query.isSuccess}>
              <For each={query.data}>{(todo) => <p>{todo.title}</p>}</For>
            </Match>
          </Switch>
        </div>
      )
    }
    
    function App() {
      return (
        <QueryClientProvider client={queryClient}>
          <Example />
        </QueryClientProvider>
      )
    }
    

    import {
      QueryClient,
      QueryClientProvider,
      useQuery,
    } from '@tanstack/solid-query'
    import { Switch, Match, For } from 'solid-js'
    
    const queryClient = new QueryClient()
    
    function Example() {
      const query = useQuery(() => ({
        queryKey: ['todos'],
        queryFn: fetchTodos,
      }))
    
      return (
        <div>
          <Switch>
            <Match when={query.isPending}>
              <p>Loading...</p>
            </Match>
            <Match when={query.isError}>
              <p>Error: {query.error.message}</p>
            </Match>
            <Match when={query.isSuccess}>
              <For each={query.data}>{(todo) => <p>{todo.title}</p>}</For>
            </Match>
          </Switch>
        </div>
      )
    }
    
    function App() {
      return (
        <QueryClientProvider client={queryClient}>
          <Example />
        </QueryClientProvider>
      )
    }
    

[](#available-functions)[Available Functions](#available-functions)
-------------------------------------------------------------------

Solid Query offers useful primitives and functions that will make managing server state in SolidJS apps easier.

*   useQuery
*   createQueries
*   createInfiniteQueries
*   createMutation
*   useIsFetching
*   useIsMutating
*   useQueryClient
*   QueryClient
*   QueryClientProvider

[](#important-differences-between-solid-query--react-query)[Important Differences between Solid Query & React Query](#important-differences-between-solid-query--react-query)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Solid Query offers an API similar to React Query, but there are some key differences to be mindful of.

*   Arguments to solid-query primitives (like useQuery, createMutation, useIsFetching) listed above are functions, so that they can be tracked in a reactive scope.

    // ‚ùå react version
    useQuery({
      queryKey: ['todos', todo],
      queryFn: fetchTodos,
    })
    
    // ‚úÖ solid version
    useQuery(() => ({
      queryKey: ['todos', todo],
      queryFn: fetchTodos,
    }))
    

    // ‚ùå react version
    useQuery({
      queryKey: ['todos', todo],
      queryFn: fetchTodos,
    })
    
    // ‚úÖ solid version
    useQuery(() => ({
      queryKey: ['todos', todo],
      queryFn: fetchTodos,
    }))
    

*   Suspense works for queries out of the box if you access the query data inside a <Suspense> boundary.

    import { For, Suspense } from 'solid-js'
    
    function Example() {
      const query = useQuery(() => ({
        queryKey: ['todos'],
        queryFn: fetchTodos,
      }))
      return (
        <div>
          {/* ‚úÖ Will trigger loading fallback, data accessed in a suspense boundary. */}
          <Suspense fallback={'Loading...'}>
            <For each={query.data}>{(todo) => <div>{todo.title}</div>}</For>
          </Suspense>
          {/* ‚ùå Will not trigger loading fallback, data not accessed in a suspense boundary. */}
          <For each={query.data}>{(todo) => <div>{todo.title}</div>}</For>
        </div>
      )
    }
    

    import { For, Suspense } from 'solid-js'
    
    function Example() {
      const query = useQuery(() => ({
        queryKey: ['todos'],
        queryFn: fetchTodos,
      }))
      return (
        <div>
          {/* ‚úÖ Will trigger loading fallback, data accessed in a suspense boundary. */}
          <Suspense fallback={'Loading...'}>
            <For each={query.data}>{(todo) => <div>{todo.title}</div>}</For>
          </Suspense>
          {/* ‚ùå Will not trigger loading fallback, data not accessed in a suspense boundary. */}
          <For each={query.data}>{(todo) => <div>{todo.title}</div>}</For>
        </div>
      )
    }
    

*   Solid Query primitives (createX) do not support destructuring. The return value from these functions is a store, and their properties are only tracked in a reactive context.

    import {
      QueryClient,
      QueryClientProvider,
      useQuery,
    } from '@tanstack/solid-query'
    import { Match, Switch } from 'solid-js'
    
    const queryClient = new QueryClient()
    
    export default function App() {
      return (
        <QueryClientProvider client={queryClient}>
          <Example />
        </QueryClientProvider>
      )
    }
    
    function Example() {
      // ‚ùå react version -- supports destructing outside reactive context
      // const { isPending, error, data } = useQuery({
      //   queryKey: ['repoData'],
      //   queryFn: () =>
      //     fetch('https://api.github.com/repos/tannerlinsley/react-query').then(
      //       (res) => res.json()
      //     ),
      // })
    
      // ‚úÖ solid version -- does not support destructuring outside reactive context
      const query = useQuery(() => ({
        queryKey: ['repoData'],
        queryFn: () =>
          fetch('https://api.github.com/repos/tannerlinsley/react-query').then(
            (res) => res.json(),
          ),
      }))
    
      // ‚úÖ access query properties in JSX reactive context
      return (
        <Switch>
          <Match when={query.isPending}>Loading...</Match>
          <Match when={query.isError}>Error: {query.error.message}</Match>
          <Match when={query.isSuccess}>
            <div>
              <h1>{query.data.name}</h1>
              <p>{query.data.description}</p>
              <strong>üëÄ {query.data.subscribers_count}</strong>{' '}
              <strong>‚ú® {query.data.stargazers_count}</strong>{' '}
              <strong>üç¥ {query.data.forks_count}</strong>
            </div>
          </Match>
        </Switch>
      )
    }
    

    import {
      QueryClient,
      QueryClientProvider,
      useQuery,
    } from '@tanstack/solid-query'
    import { Match, Switch } from 'solid-js'
    
    const queryClient = new QueryClient()
    
    export default function App() {
      return (
        <QueryClientProvider client={queryClient}>
          <Example />
        </QueryClientProvider>
      )
    }
    
    function Example() {
      // ‚ùå react version -- supports destructing outside reactive context
      // const { isPending, error, data } = useQuery({
      //   queryKey: ['repoData'],
      //   queryFn: () =>
      //     fetch('https://api.github.com/repos/tannerlinsley/react-query').then(
      //       (res) => res.json()
      //     ),
      // })
    
      // ‚úÖ solid version -- does not support destructuring outside reactive context
      const query = useQuery(() => ({
        queryKey: ['repoData'],
        queryFn: () =>
          fetch('https://api.github.com/repos/tannerlinsley/react-query').then(
            (res) => res.json(),
          ),
      }))
    
      // ‚úÖ access query properties in JSX reactive context
      return (
        <Switch>
          <Match when={query.isPending}>Loading...</Match>
          <Match when={query.isError}>Error: {query.error.message}</Match>
          <Match when={query.isSuccess}>
            <div>
              <h1>{query.data.name}</h1>
              <p>{query.data.description}</p>
              <strong>üëÄ {query.data.subscribers_count}</strong>{' '}
              <strong>‚ú® {query.data.stargazers_count}</strong>{' '}
              <strong>üç¥ {query.data.forks_count}</strong>
            </div>
          </Match>
        </Switch>
      )
    }
    

*   Signals and store values can be passed in directly to function arguments. Solid Query will update the query store automatically.

    import {
      QueryClient,
      QueryClientProvider,
      useQuery,
    } from '@tanstack/solid-query'
    import { createSignal, For } from 'solid-js'
    
    const queryClient = new QueryClient()
    
    function Example() {
      const [enabled, setEnabled] = createSignal(false)
      const [todo, setTodo] = createSignal(0)
    
      // ‚úÖ passing a signal directly is safe and observers update
      // automatically when the value of a signal changes
      const todosQuery = useQuery(() => ({
        queryKey: ['todos'],
        queryFn: fetchTodos,
        enabled: enabled(),
      }))
    
      const todoDetailsQuery = useQuery(() => ({
        queryKey: ['todo', todo()],
        queryFn: fetchTodo,
        enabled: todo() > 0,
      }))
    
      return (
        <div>
          <Switch>
            <Match when={todosQuery.isPending}>
              <p>Loading...</p>
            </Match>
            <Match when={todosQuery.isError}>
              <p>Error: {todosQuery.error.message}</p>
            </Match>
            <Match when={todosQuery.isSuccess}>
              <For each={todosQuery.data}>
                {(todo) => (
                  <button onClick={() => setTodo(todo.id)}>{todo.title}</button>
                )}
              </For>
            </Match>
          </Switch>
          <button onClick={() => setEnabled(!enabled())}>Toggle enabled</button>
        </div>
      )
    }
    
    function App() {
      return (
        <QueryClientProvider client={queryClient}>
          <Example />
        </QueryClientProvider>
      )
    }
    

    import {
      QueryClient,
      QueryClientProvider,
      useQuery,
    } from '@tanstack/solid-query'
    import { createSignal, For } from 'solid-js'
    
    const queryClient = new QueryClient()
    
    function Example() {
      const [enabled, setEnabled] = createSignal(false)
      const [todo, setTodo] = createSignal(0)
    
      // ‚úÖ passing a signal directly is safe and observers update
      // automatically when the value of a signal changes
      const todosQuery = useQuery(() => ({
        queryKey: ['todos'],
        queryFn: fetchTodos,
        enabled: enabled(),
      }))
    
      const todoDetailsQuery = useQuery(() => ({
        queryKey: ['todo', todo()],
        queryFn: fetchTodo,
        enabled: todo() > 0,
      }))
    
      return (
        <div>
          <Switch>
            <Match when={todosQuery.isPending}>
              <p>Loading...</p>
            </Match>
            <Match when={todosQuery.isError}>
              <p>Error: {todosQuery.error.message}</p>
            </Match>
            <Match when={todosQuery.isSuccess}>
              <For each={todosQuery.data}>
                {(todo) => (
                  <button onClick={() => setTodo(todo.id)}>{todo.title}</button>
                )}
              </For>
            </Match>
          </Switch>
          <button onClick={() => setEnabled(!enabled())}>Toggle enabled</button>
        </div>
      )
    }
    
    function App() {
      return (
        <QueryClientProvider client={queryClient}>
          <Example />
        </QueryClientProvider>
      )
    }
    

*   Errors can be caught and reset using SolidJS' native ErrorBoundary component. Set throwOnError or the suspense option to true to make sure errors are thrown to the ErrorBoundary
    
*   Since Property tracking is handled through Solid's fine grained reactivity, options like notifyOnChangeProps are not needed</content>
</page>

<page>
  <title>Angular TanStack Query Rxjs Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/examples/rxjs</url>
  <content>    import { ChangeDetectionStrategy, Component } from '@angular/core'
    import { ExampleComponent } from './components/example.component'
    
    @Component({
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: 'app-root',
      template: `<example />`,
      imports: [ExampleComponent],
    })
    export class AppComponent {}
    

    import { ChangeDetectionStrategy, Component } from '@angular/core'
    import { ExampleComponent } from './components/example.component'
    
    @Component({
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: 'app-root',
      template: `<example />`,
      imports: [ExampleComponent],
    })
    export class AppComponent {}</content>
</page>

<page>
  <title>Installation | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/installation</url>
  <content>You can install Solid Query via [NPM](https://npmjs.com/), or a good ol' <script> via [ESM.sh](https://esm.sh/).

### [](#npm)[NPM](#npm)

    npm i @tanstack/solid-query
    

    npm i @tanstack/solid-query
    

or

    pnpm add @tanstack/solid-query
    

    pnpm add @tanstack/solid-query
    

or

    yarn add @tanstack/solid-query
    

    yarn add @tanstack/solid-query
    

or

    bun add @tanstack/solid-query
    

    bun add @tanstack/solid-query
    

> Wanna give it a spin before you download? Try out the [simple](https://tanstack.com/query/latest/docs/framework/solid/examples/simple) or [basic](https://tanstack.com/query/latest/docs/framework/solid/examples/basic) examples!

### [](#cdn)[CDN](#cdn)

If you're not using a module bundler or package manager, you can also use this library via an ESM-compatible CDN such as [ESM.sh](https://esm.sh/). Simply add a <script type="module"> tag to the bottom of your HTML file:

    <script type="module">
      import { QueryClient } from 'https://esm.sh/@tanstack/solid-query'
    </script>
    

    <script type="module">
      import { QueryClient } from 'https://esm.sh/@tanstack/solid-query'
    </script>
    

### [](#requirements)[Requirements](#requirements)

Solid Query is optimized for modern browsers. It is compatible with the following browsers config

    Chrome >= 91
    Firefox >= 90
    Edge >= 91
    Safari >= 15
    iOS >= 15
    Opera >= 77
    

    Chrome >= 91
    Firefox >= 90
    Edge >= 91
    Safari >= 15
    iOS >= 15
    Opera >= 77
    

> Depending on your environment, you might need to add polyfills. If you want to support older browsers, you need to transpile the library from node\_modules yourselves.</content>
</page>

<page>
  <title>Devtools | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/devtools</url>
  <content>Wave your hands in the air and shout hooray because Solid Query comes with dedicated devtools! ü•≥

When you begin your Solid Query journey, you'll want these devtools by your side. They help visualize all of the inner workings of Solid Query and will likely save you hours of debugging if you find yourself in a pinch!

> For Chrome, Firefox, and Edge users: Third-party browser extensions are available for debugging TanStack Query directly in browser DevTools. These provide the same functionality as the framework-specific devtools packages:
> 
> *   [Devtools for Chrome](https://chromewebstore.google.com/detail/tanstack-query-devtools/annajfchloimdhceglpgglpeepfghfai)
> *   [Devtools for Firefox](https://addons.mozilla.org/en-US/firefox/addon/tanstack-query-devtools/)
> *   [Devtools for Edge](https://microsoftedge.microsoft.com/addons/detail/tanstack-query-devtools/edmdpkgkacmjopodhfolmphdenmddobj)

The devtools are a separate package that you need to install:

    npm i @tanstack/solid-query-devtools
    

    npm i @tanstack/solid-query-devtools
    

or

    pnpm add @tanstack/solid-query-devtools
    

    pnpm add @tanstack/solid-query-devtools
    

or

    yarn add @tanstack/solid-query-devtools
    

    yarn add @tanstack/solid-query-devtools
    

or

    bun add @tanstack/solid-query-devtools
    

    bun add @tanstack/solid-query-devtools
    

You can import the devtools like this:

    import { SolidQueryDevtools } from '@tanstack/solid-query-devtools'
    

    import { SolidQueryDevtools } from '@tanstack/solid-query-devtools'
    

By default, Solid Query Devtools are only included in bundles when isServer === true ([isServer](https://github.com/solidjs/solid/blob/a72d393a07b22f9b7496e5eb93712188ccce0d28/packages/solid/web/src/index.ts#L37) comes from the solid-js/web package), so you don't need to worry about excluding them during a production build.

[](#floating-mode)[Floating Mode](#floating-mode)
-------------------------------------------------

Floating Mode will mount the devtools as a fixed, floating element in your app and provide a toggle in the corner of the screen to show and hide the devtools. This toggle state will be stored and remembered in localStorage across reloads.

Place the following code as high in your Solid app as you can. The closer it is to the root of the page, the better it will work!

    import { SolidQueryDevtools } from '@tanstack/solid-query-devtools'
    
    function App() {
      return (
        <QueryClientProvider client={queryClient}>
          {/* The rest of your application */}
          <SolidQueryDevtools initialIsOpen={false} />
        </QueryClientProvider>
      )
    }
    

    import { SolidQueryDevtools } from '@tanstack/solid-query-devtools'
    
    function App() {
      return (
        <QueryClientProvider client={queryClient}>
          {/* The rest of your application */}
          <SolidQueryDevtools initialIsOpen={false} />
        </QueryClientProvider>
      )
    }
    

### [](#options)[Options](#options)

*   initialIsOpen: boolean
    *   Set this true if you want the dev tools to default to being open
*   buttonPosition?: "top-left" | "top-right" | "bottom-left" | "bottom-right"
    *   Defaults to bottom-right
    *   The position of the Solid Query logo to open and close the devtools panel
*   position?: "top" | "bottom" | "left" | "right"
    *   Defaults to bottom
    *   The position of the Solid Query devtools panel
*   client?: QueryClient,
    *   Use this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.
*   errorTypes?: { name: string; initializer: (query: Query) => TError}
    *   Use this to predefine some errors that can be triggered on your queries. Initializer will be called (with the specific query) when that error is toggled on from the UI. It must return an Error.
*   styleNonce?: string
    *   Use this to pass a nonce to the style tag that is added to the document head. This is useful if you are using a Content Security Policy (CSP) nonce to allow inline styles.
*   shadowDOMTarget?: ShadowRoot
    *   Default behavior will apply the devtool's styles to the head tag within the DOM.
    *   Use this to pass a shadow DOM target to the devtools so that the styles will be applied within the shadow DOM instead of within the head tag in the light DOM.</content>
</page>

<page>
  <title>TypeScript | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/typescript</url>
  <content>Solid Query is written in **TypeScript** to make sure the library and your projects are type-safe!

Things to keep in mind:

*   Types currently require using TypeScript **v4.7** or greater
*   Changes to types in this repository are considered **non-breaking** and are usually released as **patch** semver changes (otherwise every type enhancement would be a major version!).
*   It is **highly recommended that you lock your solid-query package version to a specific patch release and upgrade with the expectation that types may be fixed or upgraded between any release**
*   The non-type-related public API of Solid Query still follows semver very strictly.

[](#type-inference)[Type Inference](#type-inference)
----------------------------------------------------

Types in Solid Query generally flow through very well so that you don't have to provide type annotations for yourself

    import { useQuery } from '@tanstack/solid-query'
    
    const query = useQuery(() => ({
      queryKey: ['number'],
      queryFn: () => Promise.resolve(5),
    }))
    
    query.data
    //    ^? (property) data: number | undefined
    

    import { useQuery } from '@tanstack/solid-query'
    
    const query = useQuery(() => ({
      queryKey: ['number'],
      queryFn: () => Promise.resolve(5),
    }))
    
    query.data
    //    ^? (property) data: number | undefined
    

[typescript playground](https://www.typescriptlang.org/play/?#code/JYWwDg9gTgLgBAbzgYygUwIYzQRQK5pQCecAvnAGZQQhwDkAAjBgHYDOzyA1gPRsQAbYABMAtAEcCxOgFgAUPOQR28SYRIBeFOiy4pRABQGAlHA0A+OAYTy4duGuIBpNEQBccANp0WeEACNCOgBdABo4W3tHIgAxFg8TM0sABWoQYDY0ADp0fgEANzQDAFZjeVJjMoU5aKzhLAx5Hh57OAA9AH55brkgA)

    import { useQuery } from '@tanstack/solid-query'
    
    const query = useQuery(() => ({
      queryKey: ['test'],
      queryFn: () => Promise.resolve(5),
      select: (data) => data.toString(),
    }))
    
    query.data
    //    ^? (property) data: string | undefined
    

    import { useQuery } from '@tanstack/solid-query'
    
    const query = useQuery(() => ({
      queryKey: ['test'],
      queryFn: () => Promise.resolve(5),
      select: (data) => data.toString(),
    }))
    
    query.data
    //    ^? (property) data: string | undefined
    

[typescript playground](https://www.typescriptlang.org/play/?#code/JYWwDg9gTgLgBAbzgYygUwIYzQRQK5pQCecAvnAGZQQhwDkAAjBgHYDOzyA1gPRsQAbYABMAtAEcCxOgFgAUPOQR28SYRIBeFOiy4pRABQGAlHA0A+OAYTy4duGuIBpNEQBccANp1sHOgF0AGjhbe0ciADEWDxMzSwAFahBgNjQAOnR+AQA3NAMAVmNA0LtUgTRkGBjhLAxTCzga5jSYCABlGChgFgBzE2K5UmNjeXlwtKaMeR4eezgAPQB+UYU5IA)

This works best if your queryFn has a well-defined returned type. Keep in mind that most data fetching libraries return any per default, so make sure to extract it to a properly typed function:

    const fetchGroups = (): Promise<Group[]> =>
      axios.get('/groups').then((response) => response.data)
    
    const query = useQuery(() => ({
      queryKey: ['groups'],
      queryFn: fetchGroups,
    }))
    
    query.data
    //    ^? (property) data: Group[] | undefined
    

    const fetchGroups = (): Promise<Group[]> =>
      axios.get('/groups').then((response) => response.data)
    
    const query = useQuery(() => ({
      queryKey: ['groups'],
      queryFn: fetchGroups,
    }))
    
    query.data
    //    ^? (property) data: Group[] | undefined
    

[typescript playground](https://www.typescriptlang.org/play/?ssl=11&ssc=4&pln=6&pc=1#code/JYWwDg9gTgLgBAbzgYygUwIYzQRQK5pQCecAvnAGZQQhwDkAAjBgHYDOzyA1gPRsQAbYABMAtAEcCxOgFgAUKEiw4GAB7AIbStVp01GtrLnyYRMGjgBxanjBwAvIjgiAXHBZ4QAI0Jl585Ah2eAo0GGQAC2sIWy1HAAoASjcABR1gNjQAHmjbAG0AXQA+BxL9TQA6AHMw+LoeKpswQ0SKmAi0Fnj0Nkh2C3sSnr7MiuEsDET-OUDguElCEkdUTGx8Rfik0rh4hHk4A-mpIgBpNCI3PLpGmOa6AoAaOH3DheIAMRY3UPCoprYHvJSIkpsY5G8iGMJvIeDxDnAAHoAfmm8iAA)

[](#type-narrowing)[Type Narrowing](#type-narrowing)
----------------------------------------------------

Solid Query uses a [discriminated union type](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#discriminated-unions) for the query result, discriminated by the status field and the derived status boolean flags. This will allow you to check for e.g. success status to make data defined:

    const query = useQuery(() => ({
      queryKey: ['number'],
      queryFn: () => Promise.resolve(5),
    }))
    
    if (query.isSuccess) {
      const data = query.data
      //     ^? const data: number
    }
    

    const query = useQuery(() => ({
      queryKey: ['number'],
      queryFn: () => Promise.resolve(5),
    }))
    
    if (query.isSuccess) {
      const data = query.data
      //     ^? const data: number
    }
    

[typescript playground](https://www.typescriptlang.org/play/?#code/JYWwDg9gTgLgBAbzgYygUwIYzQRQK5pQCecAvnAGZQQhwDkAAjBgHYDOzyA1gPRsQAbYABMAtAEcCxOgFgAUKEixEKdFjQBRChTTJ45KjXr8hYgFZtZc+cgjt4kwiQC8qzNnxOAFF4CUcZwA+OC8EeTg4R2IAaTQiAC44AG06FjwQACNCOgBdABpwyKkiADEWRL8A4IAFahBgNjQAOnQTADc0LwBWXwK5Ul9feXlgChCooiaGgGU8ZGQ0NjZ-MLkIiNt7OGEsDACipyad5kKInh51iIA9AH55UmHrOSA)

[](#typing-the-error-field)[Typing the error field](#typing-the-error-field)
----------------------------------------------------------------------------

The type for error defaults to Error, because that is what most users expect.

    const query = useQuery(() => ({
      queryKey: ['groups'],
      queryFn: fetchGroups,
    }))
    
    query.error
    //    ^? (property) error: Error | null
    

    const query = useQuery(() => ({
      queryKey: ['groups'],
      queryFn: fetchGroups,
    }))
    
    query.error
    //    ^? (property) error: Error | null
    

[typescript playground](https://www.typescriptlang.org/play/?#code/JYWwDg9gTgLgBAbzgYygUwIYzQRQK5pQCecAvnAGZQQhwDkAAjBgHYDOzyA1gPRsQAbYABMAtAEcCxOgFgAUKEiw4GAB7AIbStVp01GtrLnyYRMGjgBxanjBwAvIjgiAXHBZ4QAI0Jl585Ah2eAo0GGQAC2sIWy1HAAoASjcABR1gNjQAHmjbAG0AXQA+BxL9TQA6AHMw+LoeKpswQ0SKmAi0Fnj0Nkh2C3sSnr7MiuEsDET-OUDguElCEkdUTGx8Rfik0rh4hHk4A-mpIgBpNCI3PLpGmOa6AoAaOH3DheIAMRY3UPCoprYHvJSIkpsY5G8iBVCNQoPIeDxDnAAHoAfmm8iAA)

If you want to throw a custom error, or something that isn't an Error at all, you can specify the type of the error field:

    const query = useQuery<Group[], string>(() => ({
      queryKey: ['groups'],
      queryFn: fetchGroups,
    }))
    
    query.error
    //    ^? (property) error: string | null
    

    const query = useQuery<Group[], string>(() => ({
      queryKey: ['groups'],
      queryFn: fetchGroups,
    }))
    
    query.error
    //    ^? (property) error: string | null
    

However, this has the drawback that type inference for all other generics of useQuery will not work anymore. It is generally not considered a good practice to throw something that isn't an Error, so if you have a subclass like AxiosError you can use _type narrowing_ to make the error field more specific:

    import axios from 'axios'
    
    const query = useQuery(() => ({
      queryKey: ['groups'],
      queryFn: fetchGroups,
    }))
    
    query.error
    //    ^? (property) error: Error | null
    
    if (axios.isAxiosError(query.error)) {
      query.error
      //    ^? (property) error: AxiosError
    }
    

    import axios from 'axios'
    
    const query = useQuery(() => ({
      queryKey: ['groups'],
      queryFn: fetchGroups,
    }))
    
    query.error
    //    ^? (property) error: Error | null
    
    if (axios.isAxiosError(query.error)) {
      query.error
      //    ^? (property) error: AxiosError
    }
    

[typescript playground](https://www.typescriptlang.org/play/?#code/JYWwDg9gTgLgBAbzgYygUwIYzQRQK5pQCecAvnAGZQQhwDkAAjBgHYDOzyA1gPRsQAbYABMAtAEcCxOgFgAUKEiw4GAB7AIbStVp01GtrLnyYRMGjgBxanjBwAvIjgiAXHBZ4QAI0Jl585Ah2eAo0GGQAC2sIWy1HAAoASjcABR1gNjQAHmjbAG0AXQA+BxL9TQA6AHMw+LoeKpswQ0SKmAi0Fnj0Nkh2C3sSnr7MiuEsDET-OUDguElCEkdUTGx8Rfik0rh4hHk4A-mpIgBpNCI3PLpGmOa6AoAaOH3DheIAMRY3UPCoprYHvJSIkpsY5G8iBVCNQoPIeDxDnAAHoAfmmwAoO3KbAqGQAgupNABRKAw+IQqGk6AgxAvA4U6HQOlweGI1FA+RAA)

    import '@tanstack/solid-query'
    
    declare module '@tanstack/solid-query' {
      interface Register {
        // Use unknown so call sites must narrow explicitly.
        defaultError: unknown
      }
    }
    
    const query = useQuery(() => ({
      queryKey: ['groups'],
      queryFn: fetchGroups,
    }))
    
    query.error
    //    ^? (property) error: unknown | null
    

    import '@tanstack/solid-query'
    
    declare module '@tanstack/solid-query' {
      interface Register {
        // Use unknown so call sites must narrow explicitly.
        defaultError: unknown
      }
    }
    
    const query = useQuery(() => ({
      queryKey: ['groups'],
      queryFn: fetchGroups,
    }))
    
    query.error
    //    ^? (property) error: unknown | null
    

Similarly to registering a [global error type](#registering-a-global-error) you can also register a global Meta type. This ensures the optional meta field on [queries](https://tanstack.com/query/latest/docs/framework/solid/reference/useQuery) and [mutations](https://tanstack.com/query/latest/docs/framework/solid/reference/useMutation) stays consistent and is type-safe. Note that the registered type must extend Record<string, unknown> so that meta remains an object.

    import '@tanstack/solid-query'
    
    interface MyMeta extends Record<string, unknown> {
      // Your meta type definition.
    }
    
    declare module '@tanstack/solid-query' {
      interface Register {
        queryMeta: MyMeta
        mutationMeta: MyMeta
      }
    }
    

    import '@tanstack/solid-query'
    
    interface MyMeta extends Record<string, unknown> {
      // Your meta type definition.
    }
    
    declare module '@tanstack/solid-query' {
      interface Register {
        queryMeta: MyMeta
        mutationMeta: MyMeta
      }
    }
    

[](#typing-query-options)[Typing Query Options](#typing-query-options)
----------------------------------------------------------------------

If you inline query options into useQuery, you'll get automatic type inference. However, you might want to extract the query options into a separate function to share them between useQuery and e.g. prefetchQuery. In that case, you'd lose type inference. To get it back, you can use queryOptions helper:

    import { queryOptions } from '@tanstack/solid-query'
    
    function groupOptions() {
      return queryOptions({
        queryKey: ['groups'],
        queryFn: fetchGroups,
        staleTime: 5 * 1000,
      })
    }
    
    useQuery(groupOptions)
    queryClient.prefetchQuery(groupOptions())
    

    import { queryOptions } from '@tanstack/solid-query'
    
    function groupOptions() {
      return queryOptions({
        queryKey: ['groups'],
        queryFn: fetchGroups,
        staleTime: 5 * 1000,
      })
    }
    
    useQuery(groupOptions)
    queryClient.prefetchQuery(groupOptions())
    

Further, the queryKey returned from queryOptions knows about the queryFn associated with it, and we can leverage that type information to make functions like queryClient.getQueryData aware of those types as well:

    function groupOptions() {
      return queryOptions({
        queryKey: ['groups'],
        queryFn: fetchGroups,
        staleTime: 5 * 1000,
      })
    }
    
    const data = queryClient.getQueryData(groupOptions().queryKey)
    //    ^? const data: Group[] | undefined
    

    function groupOptions() {
      return queryOptions({
        queryKey: ['groups'],
        queryFn: fetchGroups,
        staleTime: 5 * 1000,
      })
    }
    
    const data = queryClient.getQueryData(groupOptions().queryKey)
    //    ^? const data: Group[] | undefined
    

Without queryOptions, the type of data would be unknown, unless we'd pass a generic to it:

    const data = queryClient.getQueryData<Group[]>(['groups'])
    

    const data = queryClient.getQueryData<Group[]>(['groups'])
    

[](#typesafe-disabling-of-queries-using-skiptoken)[Typesafe disabling of queries using skipToken](#typesafe-disabling-of-queries-using-skiptoken)
-------------------------------------------------------------------------------------------------------------------------------------------------

If you are using TypeScript, you can use the skipToken to disable a query. This is useful when you want to disable a query based on a condition, but you still want to keep the query to be type safe.

Read more about it in the [Disabling Queries](https://tanstack.com/query/latest/docs/framework/solid/guides/disabling-queries) guide.</content>
</page>

<page>
  <title>Important Defaults | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/guides/important-defaults</url>
  <content>Out of the box, TanStack Query is configured with **aggressive but sane** defaults. **Sometimes these defaults can catch new users off guard or make learning/debugging difficult if they are unknown by the user.** Keep them in mind as you continue to learn and use TanStack Query:

*   Query instances via useQuery or useInfiniteQuery by default **consider cached data as stale**.

> To change this behavior, you can configure your queries both globally and per-query using the staleTime option. Specifying a longer staleTime means queries will not refetch their data as often

*   A Query that has a staleTime set is considered **fresh** until that staleTime has elapsed.
    
    *   set staleTime to e.g. 2 \* 60 \* 1000 to make sure data is read from the cache, without triggering any kinds of refetches, for 2 minutes, or until the Query is [invalidated manually](https://tanstack.com/query/latest/docs/framework/solid/guides/query-invalidation).
    *   set staleTime to Infinity to never trigger a refetch until the Query is [invalidated manually](https://tanstack.com/query/latest/docs/framework/solid/guides/query-invalidation).
    *   set staleTime to 'static' to **never** trigger a refetch, even if the Query is [invalidated manually](https://tanstack.com/query/latest/docs/framework/solid/guides/query-invalidation).
*   Stale queries are refetched automatically in the background when:
    
    *   New instances of the query mount
    *   The window is refocused
    *   The network is reconnected

> Setting staleTime is the recommended way to avoid excessive refetches, but you can also customize the points in time for refetches by setting options like refetchOnMount, refetchOnWindowFocus and refetchOnReconnect.

*   Queries can optionally be configured with a refetchInterval to trigger refetches periodically, which is independent of the staleTime setting.
    
*   Query results that have no more active instances of useQuery, useInfiniteQuery or query observers are labeled as "inactive" and remain in the cache in case they are used again at a later time.
    
*   By default, "inactive" queries are garbage collected after **5 minutes**.
    
    > To change this, you can alter the default gcTime for queries to something other than 1000 \* 60 \* 5 milliseconds.
    
*   Queries that fail are **silently retried 3 times, with exponential backoff delay** before capturing and displaying an error to the UI.
    
    > To change this, you can alter the default retry and retryDelay options for queries to something other than 3 and the default exponential backoff function.
    
*   Query results by default are **structurally shared to detect if data has actually changed** and if not, **the data reference remains unchanged** to better help with value stabilization with regards to useMemo and useCallback. If this concept sounds foreign, then don't worry about it! 99.9% of the time you will not need to disable this and it makes your app more performant at zero cost to you.
    
    > Structural sharing only works with JSON-compatible values, any other value types will always be considered as changed. If you are seeing performance issues because of large responses for example, you can disable this feature with the config.structuralSharing flag. If you are dealing with non-JSON compatible values in your query responses and still want to detect if data has changed or not, you can provide your own custom function as config.structuralSharing to compute a value from the old and new responses, retaining references as required.
    

[](#further-reading)[Further Reading](#further-reading)
-------------------------------------------------------

Have a look at the following articles from our [Community Resources](https://tanstack.com/query/latest/docs/community-resources) for further explanations of the defaults:

*   [Practical React Query](https://tkdodo.eu/blog/practical-react-query)
*   [React Query as a State Manager](https://tkdodo.eu/blog/react-query-as-a-state-manager)
*   [Thinking in React Query](https://tkdodo.eu/blog/thinking-in-react-query)</content>
</page>

<page>
  <title>Queries | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/guides/queries</url>
  <content>[](#query-basics)[Query Basics](#query-basics)
----------------------------------------------

A query is a declarative dependency on an asynchronous source of data that is tied to a **unique key**. A query can be used with any Promise based method (including GET and POST methods) to fetch data from a server. If your method modifies data on the server, we recommend using [Mutations](https://tanstack.com/query/latest/docs/framework/solid/guides/mutations) instead.

To subscribe to a query in your components or custom hooks, call the useQuery hook with at least:

*   A **unique key for the query**
*   A function that returns a promise that:
    *   Resolves the data, or
    *   Throws an error

    import { useQuery } from '@tanstack/solid-query'
    
    function App() {
      const info = useQuery(() => { queryKey: ['todos'], queryFn: fetchTodoList })
    }
    

    import { useQuery } from '@tanstack/solid-query'
    
    function App() {
      const info = useQuery(() => { queryKey: ['todos'], queryFn: fetchTodoList })
    }
    

The **unique key** you provide is used internally for refetching, caching, and sharing your queries throughout your application.

The query result returned by useQuery contains all of the information about the query that you'll need for templating and any other usage of the data:

    const result = useQuery(() => { queryKey: ['todos'], queryFn: fetchTodoList })
    

    const result = useQuery(() => { queryKey: ['todos'], queryFn: fetchTodoList })
    

The result object contains a few very important states you'll need to be aware of to be productive. A query can only be in one of the following states at any given moment:

*   isPending or status === 'pending' - The query has no data yet
*   isError or status === 'error' - The query encountered an error
*   isSuccess or status === 'success' - The query was successful and data is available

Beyond those primary states, more information is available depending on the state of the query:

*   error - If the query is in an isError state, the error is available via the error property.
*   data - If the query is in an isSuccess state, the data is available via the data property.
*   isFetching - In any state, if the query is fetching at any time (including background refetching) isFetching will be true.

For **most** queries, it's usually sufficient to check for the isPending state, then the isError state, then finally, assume that the data is available and render the successful state:

    function Todos() {
      const { isPending, isError, data, error } = useQuery(() => {
        queryKey: ['todos'],
        queryFn: fetchTodoList,
      })
    
      if (isPending) {
        return <span>Loading...</span>
      }
    
      if (isError) {
        return <span>Error: {error.message}</span>
      }
    
      // We can assume by this point that `isSuccess === true`
      return (
        <ul>
          {data.map((todo) => (
            <li key={todo.id}>{todo.title}</li>
          ))}
        </ul>
      )
    }
    

    function Todos() {
      const { isPending, isError, data, error } = useQuery(() => {
        queryKey: ['todos'],
        queryFn: fetchTodoList,
      })
    
      if (isPending) {
        return <span>Loading...</span>
      }
    
      if (isError) {
        return <span>Error: {error.message}</span>
      }
    
      // We can assume by this point that `isSuccess === true`
      return (
        <ul>
          {data.map((todo) => (
            <li key={todo.id}>{todo.title}</li>
          ))}
        </ul>
      )
    }
    

If booleans aren't your thing, you can always use the status state as well:

    function Todos() {
      const { status, data, error } = useQuery(() => {
        queryKey: ['todos'],
        queryFn: fetchTodoList,
      })
    
      if (status === 'pending') {
        return <span>Loading...</span>
      }
    
      if (status === 'error') {
        return <span>Error: {error.message}</span>
      }
    
      // also status === 'success', but "else" logic works, too
      return (
        <ul>
          {data.map((todo) => (
            <li key={todo.id}>{todo.title}</li>
          ))}
        </ul>
      )
    }
    

    function Todos() {
      const { status, data, error } = useQuery(() => {
        queryKey: ['todos'],
        queryFn: fetchTodoList,
      })
    
      if (status === 'pending') {
        return <span>Loading...</span>
      }
    
      if (status === 'error') {
        return <span>Error: {error.message}</span>
      }
    
      // also status === 'success', but "else" logic works, too
      return (
        <ul>
          {data.map((todo) => (
            <li key={todo.id}>{todo.title}</li>
          ))}
        </ul>
      )
    }
    

TypeScript will also narrow the type of data correctly if you've checked for pending and error before accessing it.

### [](#fetchstatus)[FetchStatus](#fetchstatus)

In addition to the status field, you will also get an additional fetchStatus property with the following options:

*   fetchStatus === 'fetching' - The query is currently fetching.
*   fetchStatus === 'paused' - The query wanted to fetch, but it is paused. Read more about this in the [Network Mode](https://tanstack.com/query/latest/docs/framework/solid/guides/network-mode) guide.
*   fetchStatus === 'idle' - The query is not doing anything at the moment.

### [](#why-two-different-states)[Why two different states?](#why-two-different-states)

Background refetches and stale-while-revalidate logic make all combinations for status and fetchStatus possible. For example:

*   a query in success status will usually be in idle fetchStatus, but it could also be in fetching if a background refetch is happening.
*   a query that mounts and has no data will usually be in pending status and fetching fetchStatus, but it could also be paused if there is no network connection.

So keep in mind that a query can be in pending state without actually fetching data. As a rule of thumb:

*   The status gives information about the data: Do we have any or not?
*   The fetchStatus gives information about the queryFn: Is it running or not?

[](#further-reading)[Further Reading](#further-reading)
-------------------------------------------------------

For an alternative way of performing status checks, have a look at [this article by TkDodo](https://tkdodo.eu/blog/status-checks-in-react-query).</content>
</page>

<page>
  <title>Query Keys | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/guides/query-keys</url>
  <content>At its core, TanStack Query manages query caching for you based on query keys. Query keys have to be an Array at the top level, and can be as simple as an Array with a single string, or as complex as an array of many strings and nested objects. As long as the query key is serializable using JSON.stringify, and **unique to the query's data**, you can use it!

[](#simple-query-keys)[Simple Query Keys](#simple-query-keys)
-------------------------------------------------------------

The simplest form of a key is an array with constants values. This format is useful for:

*   Generic List/Index resources
*   Non-hierarchical resources

    // A list of todos
    useQuery(() => { queryKey: ['todos'], ... })
    
    // Something else, whatever!
    useQuery(() => { queryKey: ['something', 'special'], ... })
    

    // A list of todos
    useQuery(() => { queryKey: ['todos'], ... })
    
    // Something else, whatever!
    useQuery(() => { queryKey: ['something', 'special'], ... })
    

[](#array-keys-with-variables)[Array Keys with variables](#array-keys-with-variables)
-------------------------------------------------------------------------------------

When a query needs more information to uniquely describe its data, you can use an array with a string and any number of serializable objects to describe it. This is useful for:

*   Hierarchical or nested resources
    *   It's common to pass an ID, index, or other primitive to uniquely identify the item
*   Queries with additional parameters
    *   It's common to pass an object of additional options

    // An individual todo
    useQuery(() => { queryKey: ['todo', 5], ... })
    
    // An individual todo in a "preview" format
    useQuery(() => { queryKey: ['todo', 5, { preview: true }], ...})
    
    // A list of todos that are "done"
    useQuery(() => { queryKey: ['todos', { type: 'done' }], ... })
    

    // An individual todo
    useQuery(() => { queryKey: ['todo', 5], ... })
    
    // An individual todo in a "preview" format
    useQuery(() => { queryKey: ['todo', 5, { preview: true }], ...})
    
    // A list of todos that are "done"
    useQuery(() => { queryKey: ['todos', { type: 'done' }], ... })
    

[](#query-keys-are-hashed-deterministically)[Query Keys are hashed deterministically!](#query-keys-are-hashed-deterministically)
--------------------------------------------------------------------------------------------------------------------------------

This means that no matter the order of keys in objects, all of the following queries are considered equal:

    useQuery(() => { queryKey: ['todos', { status, page }], ... })
    useQuery(() => { queryKey: ['todos', { page, status }], ...})
    useQuery(() => { queryKey: ['todos', { page, status, other: undefined }], ... })
    

    useQuery(() => { queryKey: ['todos', { status, page }], ... })
    useQuery(() => { queryKey: ['todos', { page, status }], ...})
    useQuery(() => { queryKey: ['todos', { page, status, other: undefined }], ... })
    

The following query keys, however, are not equal. Array item order matters!

    useQuery(() => { queryKey: ['todos', status, page], ... })
    useQuery(() => { queryKey: ['todos', page, status], ...})
    useQuery(() => { queryKey: ['todos', undefined, page, status], ...})
    

    useQuery(() => { queryKey: ['todos', status, page], ... })
    useQuery(() => { queryKey: ['todos', page, status], ...})
    useQuery(() => { queryKey: ['todos', undefined, page, status], ...})
    

[](#if-your-query-function-depends-on-a-variable-include-it-in-your-query-key)[If your query function depends on a variable, include it in your query key](#if-your-query-function-depends-on-a-variable-include-it-in-your-query-key)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Since query keys uniquely describe the data they are fetching, they should include any variables you use in your query function that **change**. For example:

    function Todos({ todoId }) {
      const result = useQuery(() => {
        queryKey: ['todos', todoId],
        queryFn: () => fetchTodoById(todoId),
      })
    }
    

    function Todos({ todoId }) {
      const result = useQuery(() => {
        queryKey: ['todos', todoId],
        queryFn: () => fetchTodoById(todoId),
      })
    }
    

Note that query keys act as dependencies for your query functions. Adding dependent variables to your query key will ensure that queries are cached independently, and that any time a variable changes, _queries will be refetched automatically_ (depending on your staleTime settings). See the [exhaustive-deps](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps) section for more information and examples.

[](#further-reading)[Further reading](#further-reading)
-------------------------------------------------------

For tips on organizing Query Keys in larger applications, have a look at [Effective React Query Keys](https://tkdodo.eu/blog/effective-react-query-keys) and check the [Query Key Factory Package](https://github.com/lukemorales/query-key-factory) from the [Community Resources](https://tanstack.com/query/latest/docs/community-resources).</content>
</page>

<page>
  <title>Query Functions | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/guides/query-functions</url>
  <content>A query function can be literally any function that **returns a promise**. The promise that is returned should either **resolve the data** or **throw an error**.

All of the following are valid query function configurations:

    useQuery(() => { queryKey: ['todos'], queryFn: fetchAllTodos })
    useQuery(() => { queryKey: ['todos', todoId], queryFn: () => fetchTodoById(todoId) })
    useQuery(() => {
      queryKey: ['todos', todoId],
      queryFn: async () => {
        const data = await fetchTodoById(todoId)
        return data
      },
    })
    useQuery(() => {
      queryKey: ['todos', todoId],
      queryFn: ({ queryKey }) => fetchTodoById(queryKey[1]),
    })
    

    useQuery(() => { queryKey: ['todos'], queryFn: fetchAllTodos })
    useQuery(() => { queryKey: ['todos', todoId], queryFn: () => fetchTodoById(todoId) })
    useQuery(() => {
      queryKey: ['todos', todoId],
      queryFn: async () => {
        const data = await fetchTodoById(todoId)
        return data
      },
    })
    useQuery(() => {
      queryKey: ['todos', todoId],
      queryFn: ({ queryKey }) => fetchTodoById(queryKey[1]),
    })
    

[](#handling-and-throwing-errors)[Handling and Throwing Errors](#handling-and-throwing-errors)
----------------------------------------------------------------------------------------------

For TanStack Query to determine a query has errored, the query function **must throw** or return a **rejected Promise**. Any error that is thrown in the query function will be persisted on the error state of the query.

    const { error } = useQuery(() => {
      queryKey: ['todos', todoId],
      queryFn: async () => {
        if (somethingGoesWrong) {
          throw new Error('Oh no!')
        }
        if (somethingElseGoesWrong) {
          return Promise.reject(new Error('Oh no!'))
        }
    
        return data
      },
    })
    

    const { error } = useQuery(() => {
      queryKey: ['todos', todoId],
      queryFn: async () => {
        if (somethingGoesWrong) {
          throw new Error('Oh no!')
        }
        if (somethingElseGoesWrong) {
          return Promise.reject(new Error('Oh no!'))
        }
    
        return data
      },
    })
    

[](#usage-with-fetch-and-other-clients-that-do-not-throw-by-default)[Usage with fetch and other clients that do not throw by default](#usage-with-fetch-and-other-clients-that-do-not-throw-by-default)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

While most utilities like axios or graphql-request automatically throw errors for unsuccessful HTTP calls, some utilities like fetch do not throw errors by default. If that's the case, you'll need to throw them on your own. Here is a simple way to do that with the popular fetch API:

    useQuery(() => {
      queryKey: ['todos', todoId],
      queryFn: async () => {
        const response = await fetch('/todos/' + todoId)
        if (!response.ok) {
          throw new Error('Network response was not ok')
        }
        return response.json()
      },
    })
    

    useQuery(() => {
      queryKey: ['todos', todoId],
      queryFn: async () => {
        const response = await fetch('/todos/' + todoId)
        if (!response.ok) {
          throw new Error('Network response was not ok')
        }
        return response.json()
      },
    })
    

[](#query-function-variables)[Query Function Variables](#query-function-variables)
----------------------------------------------------------------------------------

Query keys are not just for uniquely identifying the data you are fetching, but are also conveniently passed into your query function as part of the QueryFunctionContext. While not always necessary, this makes it possible to extract your query functions if needed:

    function Todos({ status, page }) {
      const result = useQuery(() => {
        queryKey: ['todos', { status, page }],
        queryFn: fetchTodoList,
      })
    }
    
    // Access the key, status and page variables in your query function!
    function fetchTodoList({ queryKey }) {
      const [_key, { status, page }] = queryKey
      return new Promise()
    }
    

    function Todos({ status, page }) {
      const result = useQuery(() => {
        queryKey: ['todos', { status, page }],
        queryFn: fetchTodoList,
      })
    }
    
    // Access the key, status and page variables in your query function!
    function fetchTodoList({ queryKey }) {
      const [_key, { status, page }] = queryKey
      return new Promise()
    }
    

### [](#queryfunctioncontext)[QueryFunctionContext](#queryfunctioncontext)

The QueryFunctionContext is the object passed to each query function. It consists of:

*   queryKey: QueryKey: [Query Keys](https://tanstack.com/query/latest/docs/framework/solid/guides/query-keys)
*   client: QueryClient: [QueryClient](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   signal?: AbortSignal
    *   [AbortSignal](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) instance provided by TanStack Query
    *   Can be used for [Query Cancellation](https://tanstack.com/query/latest/docs/framework/solid/guides/query-cancellation)
*   meta: Record<string, unknown> | undefined
    *   an optional field you can fill with additional information about your query

Additionally, [Infinite Queries](https://tanstack.com/query/latest/docs/framework/solid/guides/infinite-queries) get the following options passed:

*   pageParam: TPageParam
    *   the page parameter used to fetch the current page
*   direction: 'forward' | 'backward'
    *   **deprecated**
    *   the direction of the current page fetch
    *   To get access to the direction of the current page fetch, please add a direction to pageParam from getNextPageParam and getPreviousPageParam.</content>
</page>

<page>
  <title>Query Options | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/guides/query-options</url>
  <content>One of the best ways to share queryKey and queryFn between multiple places, yet keep them co-located to one another, is to use the queryOptions helper. At runtime, this helper just returns whatever you pass into it, but it has a lot of advantages when using it [with TypeScript](https://tanstack.com/query/latest/docs/framework/solid/typescript#typing-query-options). You can define all possible options for a query in one place, and you'll also get type inference and type safety for all of them.

    import { queryOptions } from '@tanstack/solid-query'
    
    function groupOptions(id: number) {
      return queryOptions({
        queryKey: ['groups', id],
        queryFn: () => fetchGroups(id),
        staleTime: 5 * 1000,
      })
    }
    
    // usage:
    
    useQuery(() => groupOptions(1))
    useSuspenseQuery(groupOptions(5))
    useQueries(() => {
      queries: [groupOptions(1), groupOptions(2)],
    })
    queryClient.prefetchQuery(groupOptions(23))
    queryClient.setQueryData(groupOptions(42).queryKey, newGroups)
    

    import { queryOptions } from '@tanstack/solid-query'
    
    function groupOptions(id: number) {
      return queryOptions({
        queryKey: ['groups', id],
        queryFn: () => fetchGroups(id),
        staleTime: 5 * 1000,
      })
    }
    
    // usage:
    
    useQuery(() => groupOptions(1))
    useSuspenseQuery(groupOptions(5))
    useQueries(() => {
      queries: [groupOptions(1), groupOptions(2)],
    })
    queryClient.prefetchQuery(groupOptions(23))
    queryClient.setQueryData(groupOptions(42).queryKey, newGroups)
    

For Infinite Queries, a separate [infiniteQueryOptions](https://tanstack.com/query/latest/docs/framework/solid/reference/infiniteQueryOptions) helper is available.

You can still override some options at the component level. A very common and useful pattern is to create per-component [select](https://tanstack.com/query/latest/docs/framework/solid/guides/render-optimizations#select) functions:

    // Type inference still works, so query.data will be the return type of select instead of queryFn
    
    const query = useQuery(() => {
      ...groupOptions(1),
      select: (data) => data.groupName,
    })
    

    // Type inference still works, so query.data will be the return type of select instead of queryFn
    
    const query = useQuery(() => {
      ...groupOptions(1),
      select: (data) => data.groupName,
    })</content>
</page>

<page>
  <title>Network Mode | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/guides/network-mode</url>
  <content>TanStack Query provides three different network modes to distinguish how [Queries](https://tanstack.com/query/latest/docs/framework/solid/guides/queries) and [Mutations](https://tanstack.com/query/latest/docs/framework/solid/guides/mutations) should behave if you have no network connection. This mode can be set for each Query / Mutation individually, or globally via the query / mutation defaults.

Since TanStack Query is most often used for data fetching in combination with data fetching libraries, the default network mode is [online](#network-mode-online).

[](#network-mode-online)[Network Mode: online](#network-mode-online)
--------------------------------------------------------------------

In this mode, Queries and Mutations will not fire unless you have network connection. This is the default mode. If a fetch is initiated for a query, it will always stay in the state (pending, error, success) it is in if the fetch cannot be made because there is no network connection. However, a [fetchStatus](https://tanstack.com/query/latest/docs/framework/solid/guides/queries#fetchstatus) is exposed additionally. This can be either:

*   fetching: The queryFn is really executing - a request is in-flight.
*   paused: The query is not executing - it is paused until you have connection again
*   idle: The query is not fetching and not paused

The flags isFetching and isPaused are derived from this state and exposed for convenience.

> Keep in mind that it might not be enough to check for pending state to show a loading spinner. Queries can be in state: 'pending', but fetchStatus: 'paused' if they are mounting for the first time, and you have no network connection.

If a query runs because you are online, but you go offline while the fetch is still happening, TanStack Query will also pause the retry mechanism. Paused queries will then continue to run once you re-gain network connection. This is independent of refetchOnReconnect (which also defaults to true in this mode), because it is not a refetch, but rather a continue. If the query has been [cancelled](https://tanstack.com/query/latest/docs/framework/solid/guides/query-cancellation) in the meantime, it will not continue.

[](#network-mode-always)[Network Mode: always](#network-mode-always)
--------------------------------------------------------------------

In this mode, TanStack Query will always fetch and ignore the online / offline state. This is likely the mode you want to choose if you use TanStack Query in an environment where you don't need an active network connection for your Queries to work - e.g. if you just read from AsyncStorage, or if you just want to return Promise.resolve(5) from your queryFn.

*   Queries will never be paused because you have no network connection.
*   Retries will also not pause - your Query will go to error state if it fails.
*   refetchOnReconnect defaults to false in this mode, because reconnecting to the network is not a good indicator anymore that stale queries should be refetched. You can still turn it on if you want.

[](#network-mode-offlinefirst)[Network Mode: offlineFirst](#network-mode-offlinefirst)
--------------------------------------------------------------------------------------

This mode is the middle ground between the first two options, where TanStack Query will run the queryFn once, but then pause retries. This is very handy if you have a serviceWorker that intercepts a request for caching like in an [offline-first PWA](https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Offline_Service_workers), or if you use HTTP caching via the [Cache-Control header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#the_cache-control_header).

In those situations, the first fetch might succeed because it comes from an offline storage / cache. However, if there is a cache miss, the network request will go out and fail, in which case this mode behaves like an online query - pausing retries.

The [TanStack Query Devtools](https://tanstack.com/query/latest/docs/framework/solid/devtools) will show Queries in a paused state if they would be fetching, but there is no network connection. There is also a toggle button to _Mock offline behavior_. Please note that this button will _not_ actually mess with your network connection (you can do that in the browser devtools), but it will set the [OnlineManager](https://tanstack.com/query/latest/docs/reference/onlineManager) in an offline state.

[](#signature)[Signature](#signature)
-------------------------------------

*   networkMode: 'online' | 'always' | 'offlineFirst'
    *   optional
    *   defaults to 'online'</content>
</page>

<page>
  <title>Parallel Queries | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/guides/parallel-queries</url>
  <content>"Parallel" queries are queries that are executed in parallel, or at the same time so as to maximize fetching concurrency.

[](#manual-parallel-queries)[Manual Parallel Queries](#manual-parallel-queries)
-------------------------------------------------------------------------------

When the number of parallel queries does not change, there is **no extra effort** to use parallel queries. Just use any number of TanStack Query's useQuery and useInfiniteQuery hooks side-by-side!

    function App () {
      // The following queries will execute in parallel
      const usersQuery = useQuery(() => { queryKey: ['users'], queryFn: fetchUsers })
      const teamsQuery = useQuery(() => { queryKey: ['teams'], queryFn: fetchTeams })
      const projectsQuery = useQuery(() => { queryKey: ['projects'], queryFn: fetchProjects })
      ...
    }
    

    function App () {
      // The following queries will execute in parallel
      const usersQuery = useQuery(() => { queryKey: ['users'], queryFn: fetchUsers })
      const teamsQuery = useQuery(() => { queryKey: ['teams'], queryFn: fetchTeams })
      const projectsQuery = useQuery(() => { queryKey: ['projects'], queryFn: fetchProjects })
      ...
    }
    

> When using React Query in suspense mode, this pattern of parallelism does not work, since the first query would throw a promise internally and would suspend the component before the other queries run. To get around this, you'll either need to use the useSuspenseQueries hook (which is suggested) or orchestrate your own parallelism with separate components for each useSuspenseQuery instance.

[](#dynamic-parallel-queries-with-usequeries)[Dynamic Parallel Queries with useQueries](#dynamic-parallel-queries-with-usequeries)
----------------------------------------------------------------------------------------------------------------------------------

If the number of queries you need to execute is changing from render to render, you cannot use manual querying since that would violate the rules of hooks. Instead, TanStack Query provides a useQueries hook, which you can use to dynamically execute as many queries in parallel as you'd like.

useQueries accepts an **options object** with a **queries key** whose value is an **array of query objects**. It returns an **array of query results**:

    function App({ users }) {
      const userQueries = useQueries(() => {
        queries: users.map((user) => {
          return {
            queryKey: ['user', user.id],
            queryFn: () => fetchUserById(user.id),
          }
        }),
      })
    }
    

    function App({ users }) {
      const userQueries = useQueries(() => {
        queries: users.map((user) => {
          return {
            queryKey: ['user', user.id],
            queryFn: () => fetchUserById(user.id),
          }
        }),
      })
    }</content>
</page>

<page>
  <title>Dependent Queries | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/guides/dependent-queries</url>
  <content>[](#usequery-dependent-query)[useQuery dependent Query](#usequery-dependent-query)
----------------------------------------------------------------------------------

Dependent (or serial) queries depend on previous ones to finish before they can execute. To achieve this, it's as easy as using the enabled option to tell a query when it is ready to run:

    // Get the user
    const { data: user } = useQuery(() => {
      queryKey: ['user', email],
      queryFn: getUserByEmail,
    })
    
    const userId = user?.id
    
    // Then get the user's projects
    const {
      status,
      fetchStatus,
      data: projects,
    } = useQuery(() => {
      queryKey: ['projects', userId],
      queryFn: getProjectsByUser,
      // The query will not execute until the userId exists
      enabled: !!userId,
    })
    

    // Get the user
    const { data: user } = useQuery(() => {
      queryKey: ['user', email],
      queryFn: getUserByEmail,
    })
    
    const userId = user?.id
    
    // Then get the user's projects
    const {
      status,
      fetchStatus,
      data: projects,
    } = useQuery(() => {
      queryKey: ['projects', userId],
      queryFn: getProjectsByUser,
      // The query will not execute until the userId exists
      enabled: !!userId,
    })
    

The projects query will start in:

    status: 'pending'
    isPending: true
    fetchStatus: 'idle'
    

    status: 'pending'
    isPending: true
    fetchStatus: 'idle'
    

As soon as the user is available, the projects query will be enabled and will then transition to:

    status: 'pending'
    isPending: true
    fetchStatus: 'fetching'
    

    status: 'pending'
    isPending: true
    fetchStatus: 'fetching'
    

Once we have the projects, it will go to:

    status: 'success'
    isPending: false
    fetchStatus: 'idle'
    

    status: 'success'
    isPending: false
    fetchStatus: 'idle'
    

[](#usequeries-dependent-query)[useQueries dependent Query](#usequeries-dependent-query)
----------------------------------------------------------------------------------------

Dynamic parallel query - useQueries can depend on a previous query also, here's how to achieve this:

    // Get the users ids
    const { data: userIds } = useQuery(() => {
      queryKey: ['users'],
      queryFn: getUsersData,
      select: (users) => users.map((user) => user.id),
    })
    
    // Then get the users messages
    const usersMessages = useQueries(() => {
      queries: userIds
        ? userIds.map((id) => {
            return {
              queryKey: ['messages', id],
              queryFn: () => getMessagesByUsers(id),
            }
          })
        : [], // if userIds is undefined, an empty array will be returned
    })
    

    // Get the users ids
    const { data: userIds } = useQuery(() => {
      queryKey: ['users'],
      queryFn: getUsersData,
      select: (users) => users.map((user) => user.id),
    })
    
    // Then get the users messages
    const usersMessages = useQueries(() => {
      queries: userIds
        ? userIds.map((id) => {
            return {
              queryKey: ['messages', id],
              queryFn: () => getMessagesByUsers(id),
            }
          })
        : [], // if userIds is undefined, an empty array will be returned
    })
    

**Note** that useQueries return an **array of query results**

[](#a-note-about-performance)[A note about performance](#a-note-about-performance)
----------------------------------------------------------------------------------

Dependent queries by definition constitutes a form of [request waterfall](https://tanstack.com/query/latest/docs/framework/solid/guides/request-waterfalls), which hurts performance. If we pretend both queries take the same amount of time, doing them serially instead of in parallel always takes twice as much time, which is especially hurtful when it happens on a client that has high latency. If you can, it's always better to restructure the backend APIs so that both queries can be fetched in parallel, though that might not always be practically feasible.

In the example above, instead of first fetching getUserByEmail to be able to getProjectsByUser, introducing a new getProjectsByUserEmail query would flatten the waterfall.</content>
</page>

<page>
  <title>Background Fetching Indicators | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/guides/background-fetching-indicators</url>
  <content>A query's status === 'pending' state is sufficient enough to show the initial hard-loading state for a query, but sometimes you may want to display an additional indicator that a query is refetching in the background. To do this, queries also supply you with an isFetching boolean that you can use to show that it's in a fetching state, regardless of the state of the status variable:

    function Todos() {
      const {
        status,
        data: todos,
        error,
        isFetching,
      } = useQuery({
        queryKey: ['todos'],
        queryFn: fetchTodos,
      })
    
      return status === 'pending' ? (
        <span>Loading...</span>
      ) : status === 'error' ? (
        <span>Error: {error.message}</span>
      ) : (
        <>
          {isFetching ? <div>Refreshing...</div> : null}
    
          <div>
            {todos.map((todo) => (
              <Todo todo={todo} />
            ))}
          </div>
        </>
      )
    }
    

    function Todos() {
      const {
        status,
        data: todos,
        error,
        isFetching,
      } = useQuery({
        queryKey: ['todos'],
        queryFn: fetchTodos,
      })
    
      return status === 'pending' ? (
        <span>Loading...</span>
      ) : status === 'error' ? (
        <span>Error: {error.message}</span>
      ) : (
        <>
          {isFetching ? <div>Refreshing...</div> : null}
    
          <div>
            {todos.map((todo) => (
              <Todo todo={todo} />
            ))}
          </div>
        </>
      )
    }
    

[](#displaying-global-background-fetching-loading-state)[Displaying Global Background Fetching Loading State](#displaying-global-background-fetching-loading-state)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------

In addition to individual query loading states, if you would like to show a global loading indicator when **any** queries are fetching (including in the background), you can use the useIsFetching hook:

    import { useIsFetching } from '@tanstack/react-query'
    
    function GlobalLoadingIndicator() {
      const isFetching = useIsFetching()
    
      return isFetching ? (
        <div>Queries are fetching in the background...</div>
      ) : null
    }
    

    import { useIsFetching } from '@tanstack/react-query'
    
    function GlobalLoadingIndicator() {
      const isFetching = useIsFetching()
    
      return isFetching ? (
        <div>Queries are fetching in the background...</div>
      ) : null
    }</content>
</page>

<page>
  <title>Window Focus Refetching | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/guides/window-focus-refetching</url>
  <content>If a user leaves your application and returns and the query data is stale, **TanStack Query automatically requests fresh data for you in the background**. You can disable this globally or per-query using the refetchOnWindowFocus option:

#### [](#disabling-globally)[Disabling Globally](#disabling-globally)

    //
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          refetchOnWindowFocus: false, // default: true
        },
      },
    })
    
    function App() {
      return <QueryClientProvider client={queryClient}>...</QueryClientProvider>
    }
    

    //
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          refetchOnWindowFocus: false, // default: true
        },
      },
    })
    
    function App() {
      return <QueryClientProvider client={queryClient}>...</QueryClientProvider>
    }
    

#### [](#disabling-per-query)[Disabling Per-Query](#disabling-per-query)

    useQuery(() => {
      queryKey: ['todos'],
      queryFn: fetchTodos,
      refetchOnWindowFocus: false,
    })
    

    useQuery(() => {
      queryKey: ['todos'],
      queryFn: fetchTodos,
      refetchOnWindowFocus: false,
    })
    

[](#custom-window-focus-event)[Custom Window Focus Event](#custom-window-focus-event)
-------------------------------------------------------------------------------------

In rare circumstances, you may want to manage your own window focus events that trigger TanStack Query to revalidate. To do this, TanStack Query provides a focusManager.setEventListener function that supplies you the callback that should be fired when the window is focused and allows you to set up your own events. When calling focusManager.setEventListener, the previously set handler is removed (which in most cases will be the default handler) and your new handler is used instead. For example, this is the default handler:

    focusManager.setEventListener((handleFocus) => {
      // Listen to visibilitychange
      if (typeof window !== 'undefined' && window.addEventListener) {
        const visibilitychangeHandler = () => {
          handleFocus(document.visibilityState === 'visible')
        }
        window.addEventListener('visibilitychange', visibilitychangeHandler, false)
        return () => {
          // Be sure to unsubscribe if a new handler is set
          window.removeEventListener('visibilitychange', visibilitychangeHandler)
        }
      }
    })
    

    focusManager.setEventListener((handleFocus) => {
      // Listen to visibilitychange
      if (typeof window !== 'undefined' && window.addEventListener) {
        const visibilitychangeHandler = () => {
          handleFocus(document.visibilityState === 'visible')
        }
        window.addEventListener('visibilitychange', visibilitychangeHandler, false)
        return () => {
          // Be sure to unsubscribe if a new handler is set
          window.removeEventListener('visibilitychange', visibilitychangeHandler)
        }
      }
    })
    

[](#managing-focus-in-react-native)[Managing Focus in React Native](#managing-focus-in-react-native)
----------------------------------------------------------------------------------------------------

Instead of event listeners on window, React Native provides focus information through the [AppState module](https://reactnative.dev/docs/appstate#app-states). You can use the AppState "change" event to trigger an update when the app state changes to "active":

    import { AppState } from 'react-native'
    import { focusManager } from '@tanstack/solid-query'
    
    function onAppStateChange(status: AppStateStatus) {
      if (Platform.OS !== 'web') {
        focusManager.setFocused(status === 'active')
      }
    }
    
    useEffect(() => {
      const subscription = AppState.addEventListener('change', onAppStateChange)
    
      return () => subscription.remove()
    }, [])
    

    import { AppState } from 'react-native'
    import { focusManager } from '@tanstack/solid-query'
    
    function onAppStateChange(status: AppStateStatus) {
      if (Platform.OS !== 'web') {
        focusManager.setFocused(status === 'active')
      }
    }
    
    useEffect(() => {
      const subscription = AppState.addEventListener('change', onAppStateChange)
    
      return () => subscription.remove()
    }, [])
    

[](#managing-focus-state)[Managing focus state](#managing-focus-state)
----------------------------------------------------------------------

    import { focusManager } from '@tanstack/solid-query'
    
    // Override the default focus state
    focusManager.setFocused(true)
    
    // Fallback to the default focus check
    focusManager.setFocused(undefined)
    

    import { focusManager } from '@tanstack/solid-query'
    
    // Override the default focus state
    focusManager.setFocused(true)
    
    // Fallback to the default focus check
    focusManager.setFocused(undefined)</content>
</page>

<page>
  <title>Disabling/Pausing Queries | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/guides/disabling-queries</url>
  <content>If you ever want to disable a query from automatically running, you can use the enabled = false option. The enabled option also accepts a callback that returns a boolean.

When enabled is false:

*   If the query has cached data, then the query will be initialized in the status === 'success' or isSuccess state.
*   If the query does not have cached data, then the query will start in the status === 'pending' and fetchStatus === 'idle' state.
*   The query will not automatically fetch on mount.
*   The query will not automatically refetch in the background.
*   The query will ignore query client invalidateQueries and refetchQueries calls that would normally result in the query refetching.
*   refetch returned from useQuery can be used to manually trigger the query to fetch. However, it will not work with skipToken.

> TypeScript users may prefer to use [skipToken](#typesafe-disabling-of-queries-using-skiptoken) as an alternative to enabled = false.

    function Todos() {
      const { isLoading, isError, data, error, refetch, isFetching } = useQuery(() => {
        queryKey: ['todos'],
        queryFn: fetchTodoList,
        enabled: false,
      })
    
      return (
        <div>
          <button onClick={() => refetch()}>Fetch Todos</button>
    
          {data ? (
            <ul>
              {data.map((todo) => (
                <li key={todo.id}>{todo.title}</li>
              ))}
            </ul>
          ) : isError ? (
            <span>Error: {error.message}</span>
          ) : isLoading ? (
            <span>Loading...</span>
          ) : (
            <span>Not ready ...</span>
          )}
    
          <div>{isFetching ? 'Fetching...' : null}</div>
        </div>
      )
    }
    

    function Todos() {
      const { isLoading, isError, data, error, refetch, isFetching } = useQuery(() => {
        queryKey: ['todos'],
        queryFn: fetchTodoList,
        enabled: false,
      })
    
      return (
        <div>
          <button onClick={() => refetch()}>Fetch Todos</button>
    
          {data ? (
            <ul>
              {data.map((todo) => (
                <li key={todo.id}>{todo.title}</li>
              ))}
            </ul>
          ) : isError ? (
            <span>Error: {error.message}</span>
          ) : isLoading ? (
            <span>Loading...</span>
          ) : (
            <span>Not ready ...</span>
          )}
    
          <div>{isFetching ? 'Fetching...' : null}</div>
        </div>
      )
    }
    

Permanently disabling a query opts out of many great features that TanStack Query has to offer (like background refetches), and it's also not the idiomatic way. It takes you from the declarative approach (defining dependencies when your query should run) into an imperative mode (fetch whenever I click here). It is also not possible to pass parameters to refetch. Oftentimes, all you want is a lazy query that defers the initial fetch:

[](#lazy-queries)[Lazy Queries](#lazy-queries)
----------------------------------------------

The enabled option can not only be used to permanently disable a query, but also to enable / disable it at a later time. A good example would be a filter form where you only want to fire off the first request once the user has entered a filter value:

    function Todos() {
      const [filter, setFilter] = React.useState('')
    
      const { data } = useQuery(() => {
        queryKey: ['todos', filter],
        queryFn: () => fetchTodos(filter),
        // ‚¨áÔ∏è disabled as long as the filter is empty
        enabled: !!filter,
      })
    
      return (
        <div>
          // üöÄ applying the filter will enable and execute the query
          <FiltersForm onApply={setFilter} />
          {data && <TodosTable data={data} />}
        </div>
      )
    }
    

    function Todos() {
      const [filter, setFilter] = React.useState('')
    
      const { data } = useQuery(() => {
        queryKey: ['todos', filter],
        queryFn: () => fetchTodos(filter),
        // ‚¨áÔ∏è disabled as long as the filter is empty
        enabled: !!filter,
      })
    
      return (
        <div>
          // üöÄ applying the filter will enable and execute the query
          <FiltersForm onApply={setFilter} />
          {data && <TodosTable data={data} />}
        </div>
      )
    }
    

### [](#isloading-previously-isinitialloading)[isLoading (Previously: isInitialLoading)](#isloading-previously-isinitialloading)

Lazy queries will be in status: 'pending' right from the start because pending means that there is no data yet. This is technically true, however, since we are not currently fetching any data (as the query is not _enabled_), it also means you likely cannot use this flag to show a loading spinner.

If you are using disabled or lazy queries, you can use the isLoading flag instead. It's a derived flag that is computed from:

isPending && isFetching

so it will only be true if the query is currently fetching for the first time.

[](#typesafe-disabling-of-queries-using-skiptoken)[Typesafe disabling of queries using skipToken](#typesafe-disabling-of-queries-using-skiptoken)
-------------------------------------------------------------------------------------------------------------------------------------------------

If you are using TypeScript, you can use the skipToken to disable a query. This is useful when you want to disable a query based on a condition, but you still want to keep the query to be type safe.

> **IMPORTANT**: refetch from useQuery will not work with skipToken. Calling refetch() on a query that uses skipToken will result in a Missing queryFn error because there is no valid query function to execute. If you need to manually trigger queries, consider using enabled: false instead, which allows refetch() to work properly. Other than this limitation, skipToken works the same as enabled: false.

    import { skipToken, useQuery } from '@tanstack/solid-query'
    
    function Todos() {
      const [filter, setFilter] = React.useState<string | undefined>()
    
      const { data } = useQuery(() => {
        queryKey: ['todos', filter],
        // ‚¨áÔ∏è disabled as long as the filter is undefined or empty
        queryFn: filter ? () => fetchTodos(filter) : skipToken,
      })
    
      return (
        <div>
          // üöÄ applying the filter will enable and execute the query
          <FiltersForm onApply={setFilter} />
          {data && <TodosTable data={data} />}
        </div>
      )
    }
    

    import { skipToken, useQuery } from '@tanstack/solid-query'
    
    function Todos() {
      const [filter, setFilter] = React.useState<string | undefined>()
    
      const { data } = useQuery(() => {
        queryKey: ['todos', filter],
        // ‚¨áÔ∏è disabled as long as the filter is undefined or empty
        queryFn: filter ? () => fetchTodos(filter) : skipToken,
      })
    
      return (
        <div>
          // üöÄ applying the filter will enable and execute the query
          <FiltersForm onApply={setFilter} />
          {data && <TodosTable data={data} />}
        </div>
      )
    }</content>
</page>

<page>
  <title>Query Retries | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/guides/query-retries</url>
  <content>When a useQuery query fails (the query function throws an error), TanStack Query will automatically retry the query if that query's request has not reached the max number of consecutive retries (defaults to 3) or a function is provided to determine if a retry is allowed.

You can configure retries both on a global level and an individual query level.

*   Setting retry = false will disable retries.
*   Setting retry = 6 will retry failing requests 6 times before showing the final error thrown by the function.
*   Setting retry = true will infinitely retry failing requests.
*   Setting retry = (failureCount, error) => ... allows for custom logic based on why the request failed.

> On the server, retries default to 0 to make server rendering as fast as possible.

    import { useQuery } from '@tanstack/solid-query'
    
    // Make a specific query retry a certain number of times
    const result = useQuery(() => {
      queryKey: ['todos', 1],
      queryFn: fetchTodoListPage,
      retry: 10, // Will retry failed requests 10 times before displaying an error
    })
    

    import { useQuery } from '@tanstack/solid-query'
    
    // Make a specific query retry a certain number of times
    const result = useQuery(() => {
      queryKey: ['todos', 1],
      queryFn: fetchTodoListPage,
      retry: 10, // Will retry failed requests 10 times before displaying an error
    })
    

> Info: Contents of the error property will be part of failureReason response property of useQuery until the last retry attempt. So in above example any error contents will be part of failureReason property for first 9 retry attempts (Overall 10 attempts) and finally they will be part of error after last attempt if error persists after all retry attempts.

[](#retry-delay)[Retry Delay](#retry-delay)
-------------------------------------------

By default, retries in TanStack Query do not happen immediately after a request fails. As is standard, a back-off delay is gradually applied to each retry attempt.

The default retryDelay is set to double (starting at 1000ms) with each attempt, but not exceed 30 seconds:

    // Configure for all queries
    import {
      QueryCache,
      QueryClient,
      QueryClientProvider,
    } from '@tanstack/solid-query'
    
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
        },
      },
    })
    
    function App() {
      return <QueryClientProvider client={queryClient}>...</QueryClientProvider>
    }
    

    // Configure for all queries
    import {
      QueryCache,
      QueryClient,
      QueryClientProvider,
    } from '@tanstack/solid-query'
    
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
        },
      },
    })
    
    function App() {
      return <QueryClientProvider client={queryClient}>...</QueryClientProvider>
    }
    

Though it is not recommended, you can obviously override the retryDelay function/integer in both the Provider and individual query options. If set to an integer instead of a function the delay will always be the same amount of time:

    const result = useQuery(() => {
      queryKey: ['todos'],
      queryFn: fetchTodoList,
      retryDelay: 1000, // Will always wait 1000ms to retry, regardless of how many retries
    })
    

    const result = useQuery(() => {
      queryKey: ['todos'],
      queryFn: fetchTodoList,
      retryDelay: 1000, // Will always wait 1000ms to retry, regardless of how many retries
    })
    

[](#background-retry-behavior)[Background Retry Behavior](#background-retry-behavior)
-------------------------------------------------------------------------------------

When using refetchInterval with refetchIntervalInBackground: true, retries will pause when the browser tab is inactive. This happens because retries respect the same focus behavior as regular refetches.

If you need continuous retries in the background, consider disabling retries and implementing a custom refetch strategy:

    const result = useQuery(() => {
      queryKey: ['todos'],
      queryFn: fetchTodos,
      refetchInterval: (query) => {
        // Refetch more frequently when in error state
        return query.state.status === 'error' ? 5000 : 30000
      },
      refetchIntervalInBackground: true,
      retry: false, // Disable built-in retries
    })
    

    const result = useQuery(() => {
      queryKey: ['todos'],
      queryFn: fetchTodos,
      refetchInterval: (query) => {
        // Refetch more frequently when in error state
        return query.state.status === 'error' ? 5000 : 30000
      },
      refetchIntervalInBackground: true,
      retry: false, // Disable built-in retries
    })
    

This approach lets you control retry timing manually while keeping refetches active in the background.</content>
</page>

<page>
  <title>Paginated / Lagged Queries | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/guides/paginated-queries</url>
  <content>Rendering paginated data is a very common UI pattern and in TanStack Query, it "just works" by including the page information in the query key:

    const result = useQuery(() => {
      queryKey: ['projects', page],
      queryFn: () => fetchProjects(page),
    })
    

    const result = useQuery(() => {
      queryKey: ['projects', page],
      queryFn: () => fetchProjects(page),
    })
    

However, if you run this simple example, you might notice something strange:

**The UI jumps in and out of the success and pending states because each new page is treated like a brand new query.**

This experience is not optimal and unfortunately is how many tools today insist on working. But not TanStack Query! As you may have guessed, TanStack Query comes with an awesome feature called placeholderData that allows us to get around this.

[](#better-paginated-queries-with-placeholderdata)[Better Paginated Queries with placeholderData](#better-paginated-queries-with-placeholderdata)
-------------------------------------------------------------------------------------------------------------------------------------------------

Consider the following example where we would ideally want to increment a pageIndex (or cursor) for a query. If we were to use useQuery, **it would still technically work fine**, but the UI would jump in and out of the success and pending states as different queries are created and destroyed for each page or cursor. By setting placeholderData to (previousData) => previousData or keepPreviousData function exported from TanStack Query, we get a few new things:

*   **The data from the last successful fetch is available while new data is being requested, even though the query key has changed**.
*   When the new data arrives, the previous data is seamlessly swapped to show the new data.
*   isPlaceholderData is made available to know what data the query is currently providing you

    import { keepPreviousData, useQuery } from '@tanstack/solid-query'
    import React from 'react'
    
    function Todos() {
      const [page, setPage] = React.useState(0)
    
      const fetchProjects = (page = 0) =>
        fetch('/api/projects?page=' + page).then((res) => res.json())
    
      const { isPending, isError, error, data, isFetching, isPlaceholderData } =
        useQuery(() => {
          queryKey: ['projects', page],
          queryFn: () => fetchProjects(page),
          placeholderData: keepPreviousData,
        })
    
      return (
        <div>
          {isPending ? (
            <div>Loading...</div>
          ) : isError ? (
            <div>Error: {error.message}</div>
          ) : (
            <div>
              {data.projects.map((project) => (
                <p key={project.id}>{project.name}</p>
              ))}
            </div>
          )}
          <span>Current Page: {page + 1}</span>
          <button
            onClick={() => setPage((old) => Math.max(old - 1, 0))}
            disabled={page === 0}
          >
            Previous Page
          </button>
          <button
            onClick={() => {
              if (!isPlaceholderData && data.hasMore) {
                setPage((old) => old + 1)
              }
            }}
            // Disable the Next Page button until we know a next page is available
            disabled={isPlaceholderData || !data?.hasMore}
          >
            Next Page
          </button>
          {isFetching ? <span> Loading...</span> : null}
        </div>
      )
    }
    

    import { keepPreviousData, useQuery } from '@tanstack/solid-query'
    import React from 'react'
    
    function Todos() {
      const [page, setPage] = React.useState(0)
    
      const fetchProjects = (page = 0) =>
        fetch('/api/projects?page=' + page).then((res) => res.json())
    
      const { isPending, isError, error, data, isFetching, isPlaceholderData } =
        useQuery(() => {
          queryKey: ['projects', page],
          queryFn: () => fetchProjects(page),
          placeholderData: keepPreviousData,
        })
    
      return (
        <div>
          {isPending ? (
            <div>Loading...</div>
          ) : isError ? (
            <div>Error: {error.message}</div>
          ) : (
            <div>
              {data.projects.map((project) => (
                <p key={project.id}>{project.name}</p>
              ))}
            </div>
          )}
          <span>Current Page: {page + 1}</span>
          <button
            onClick={() => setPage((old) => Math.max(old - 1, 0))}
            disabled={page === 0}
          >
            Previous Page
          </button>
          <button
            onClick={() => {
              if (!isPlaceholderData && data.hasMore) {
                setPage((old) => old + 1)
              }
            }}
            // Disable the Next Page button until we know a next page is available
            disabled={isPlaceholderData || !data?.hasMore}
          >
            Next Page
          </button>
          {isFetching ? <span> Loading...</span> : null}
        </div>
      )
    }
    

[](#lagging-infinite-query-results-with-placeholderdata)[Lagging Infinite Query results with placeholderData](#lagging-infinite-query-results-with-placeholderdata)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------

While not as common, the placeholderData option also works flawlessly with the useInfiniteQuery hook, so you can seamlessly allow your users to continue to see cached data while infinite query keys change over time.</content>
</page>

<page>
  <title>Infinite Queries | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/guides/infinite-queries</url>
  <content>Rendering lists that can additively "load more" data onto an existing set of data or "infinite scroll" is also a very common UI pattern. TanStack Query supports a useful version of useQuery called useInfiniteQuery for querying these types of lists.

When using useInfiniteQuery, you'll notice a few things are different:

*   data is now an object containing infinite query data:
*   data.pages array containing the fetched pages
*   data.pageParams array containing the page params used to fetch the pages
*   The fetchNextPage and fetchPreviousPage functions are now available (fetchNextPage is required)
*   The initialPageParam option is now available (and required) to specify the initial page param
*   The getNextPageParam and getPreviousPageParam options are available for both determining if there is more data to load and the information to fetch it. This information is supplied as an additional parameter in the query function
*   A hasNextPage boolean is now available and is true if getNextPageParam returns a value other than null or undefined
*   A hasPreviousPage boolean is now available and is true if getPreviousPageParam returns a value other than null or undefined
*   The isFetchingNextPage and isFetchingPreviousPage booleans are now available to distinguish between a background refresh state and a loading more state

> Note: Options initialData or placeholderData need to conform to the same structure of an object with data.pages and data.pageParams properties.

[](#example)[Example](#example)
-------------------------------

Let's assume we have an API that returns pages of projects 3 at a time based on a cursor index along with a cursor that can be used to fetch the next group of projects:

    fetch('/api/projects?cursor=0')
    // { data: [...], nextCursor: 3}
    fetch('/api/projects?cursor=3')
    // { data: [...], nextCursor: 6}
    fetch('/api/projects?cursor=6')
    // { data: [...], nextCursor: 9}
    fetch('/api/projects?cursor=9')
    // { data: [...] }
    

    fetch('/api/projects?cursor=0')
    // { data: [...], nextCursor: 3}
    fetch('/api/projects?cursor=3')
    // { data: [...], nextCursor: 6}
    fetch('/api/projects?cursor=6')
    // { data: [...], nextCursor: 9}
    fetch('/api/projects?cursor=9')
    // { data: [...] }
    

With this information, we can create a "Load More" UI by:

*   Waiting for useInfiniteQuery to request the first group of data by default
*   Returning the information for the next query in getNextPageParam
*   Calling fetchNextPage function

    import { useInfiniteQuery } from '@tanstack/solid-query'
    
    function Projects() {
      const fetchProjects = async ({ pageParam }) => {
        const res = await fetch('/api/projects?cursor=' + pageParam)
        return res.json()
      }
    
      const {
        data,
        error,
        fetchNextPage,
        hasNextPage,
        isFetching,
        isFetchingNextPage,
        status,
      } = useInfiniteQuery(() => {
        queryKey: ['projects'],
        queryFn: fetchProjects,
        initialPageParam: 0,
        getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
      })
    
      return status === 'pending' ? (
        <p>Loading...</p>
      ) : status === 'error' ? (
        <p>Error: {error.message}</p>
      ) : (
        <>
          {data.pages.map((group, i) => (
            <React.Fragment key={i}>
              {group.data.map((project) => (
                <p key={project.id}>{project.name}</p>
              ))}
            </React.Fragment>
          ))}
          <div>
            <button
              onClick={() => fetchNextPage()}
              disabled={!hasNextPage || isFetching}
            >
              {isFetchingNextPage
                ? 'Loading more...'
                : hasNextPage
                  ? 'Load More'
                  : 'Nothing more to load'}
            </button>
          </div>
          <div>{isFetching && !isFetchingNextPage ? 'Fetching...' : null}</div>
        </>
      )
    }
    

    import { useInfiniteQuery } from '@tanstack/solid-query'
    
    function Projects() {
      const fetchProjects = async ({ pageParam }) => {
        const res = await fetch('/api/projects?cursor=' + pageParam)
        return res.json()
      }
    
      const {
        data,
        error,
        fetchNextPage,
        hasNextPage,
        isFetching,
        isFetchingNextPage,
        status,
      } = useInfiniteQuery(() => {
        queryKey: ['projects'],
        queryFn: fetchProjects,
        initialPageParam: 0,
        getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
      })
    
      return status === 'pending' ? (
        <p>Loading...</p>
      ) : status === 'error' ? (
        <p>Error: {error.message}</p>
      ) : (
        <>
          {data.pages.map((group, i) => (
            <React.Fragment key={i}>
              {group.data.map((project) => (
                <p key={project.id}>{project.name}</p>
              ))}
            </React.Fragment>
          ))}
          <div>
            <button
              onClick={() => fetchNextPage()}
              disabled={!hasNextPage || isFetching}
            >
              {isFetchingNextPage
                ? 'Loading more...'
                : hasNextPage
                  ? 'Load More'
                  : 'Nothing more to load'}
            </button>
          </div>
          <div>{isFetching && !isFetchingNextPage ? 'Fetching...' : null}</div>
        </>
      )
    }
    

It's essential to understand that calling fetchNextPage while an ongoing fetch is in progress runs the risk of overwriting data refreshes happening in the background. This situation becomes particularly critical when rendering a list and triggering fetchNextPage simultaneously.

Remember, there can only be a single ongoing fetch for an InfiniteQuery. A single cache entry is shared for all pages, attempting to fetch twice simultaneously might lead to data overwrites.

If you intend to enable simultaneous fetching, you can utilize the { cancelRefetch: false } option (default: true) within fetchNextPage.

To ensure a seamless querying process without conflicts, it's highly recommended to verify that the query is not in an isFetching state, especially if the user won't directly control that call.

    <List onEndReached={() => hasNextPage && !isFetching && fetchNextPage()} />
    

    <List onEndReached={() => hasNextPage && !isFetching && fetchNextPage()} />
    

[](#what-happens-when-an-infinite-query-needs-to-be-refetched)[What happens when an infinite query needs to be refetched?](#what-happens-when-an-infinite-query-needs-to-be-refetched)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

When an infinite query becomes stale and needs to be refetched, each group is fetched sequentially, starting from the first one. This ensures that even if the underlying data is mutated, we're not using stale cursors and potentially getting duplicates or skipping records. If an infinite query's results are ever removed from the queryCache, the pagination restarts at the initial state with only the initial group being requested.

[](#what-if-i-want-to-implement-a-bi-directional-infinite-list)[What if I want to implement a bi-directional infinite list?](#what-if-i-want-to-implement-a-bi-directional-infinite-list)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Bi-directional lists can be implemented by using the getPreviousPageParam, fetchPreviousPage, hasPreviousPage and isFetchingPreviousPage properties and functions.

    useInfiniteQuery(() => {
      queryKey: ['projects'],
      queryFn: fetchProjects,
      initialPageParam: 0,
      getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
      getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,
    })
    

    useInfiniteQuery(() => {
      queryKey: ['projects'],
      queryFn: fetchProjects,
      initialPageParam: 0,
      getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
      getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,
    })
    

[](#what-if-i-want-to-show-the-pages-in-reversed-order)[What if I want to show the pages in reversed order?](#what-if-i-want-to-show-the-pages-in-reversed-order)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------

Sometimes you may want to show the pages in reversed order. If this is case, you can use the select option:

    useInfiniteQuery(() => {
      queryKey: ['projects'],
      queryFn: fetchProjects,
      select: (data) => ({
        pages: [...data.pages].reverse(),
        pageParams: [...data.pageParams].reverse(),
      }),
    })
    

    useInfiniteQuery(() => {
      queryKey: ['projects'],
      queryFn: fetchProjects,
      select: (data) => ({
        pages: [...data.pages].reverse(),
        pageParams: [...data.pageParams].reverse(),
      }),
    })
    

[](#what-if-i-want-to-manually-update-the-infinite-query)[What if I want to manually update the infinite query?](#what-if-i-want-to-manually-update-the-infinite-query)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

### [](#manually-removing-first-page)[Manually removing first page:](#manually-removing-first-page)

    queryClient.setQueryData(['projects'], (data) => ({
      pages: data.pages.slice(1),
      pageParams: data.pageParams.slice(1),
    }))
    

    queryClient.setQueryData(['projects'], (data) => ({
      pages: data.pages.slice(1),
      pageParams: data.pageParams.slice(1),
    }))
    

### [](#manually-removing-a-single-value-from-an-individual-page)[Manually removing a single value from an individual page:](#manually-removing-a-single-value-from-an-individual-page)

    const newPagesArray =
      oldPagesArray?.pages.map((page) =>
        page.filter((val) => val.id !== updatedId),
      ) ?? []
    
    queryClient.setQueryData(['projects'], (data) => ({
      pages: newPagesArray,
      pageParams: data.pageParams,
    }))
    

    const newPagesArray =
      oldPagesArray?.pages.map((page) =>
        page.filter((val) => val.id !== updatedId),
      ) ?? []
    
    queryClient.setQueryData(['projects'], (data) => ({
      pages: newPagesArray,
      pageParams: data.pageParams,
    }))
    

### [](#keep-only-the-first-page)[Keep only the first page:](#keep-only-the-first-page)

    queryClient.setQueryData(['projects'], (data) => ({
      pages: data.pages.slice(0, 1),
      pageParams: data.pageParams.slice(0, 1),
    }))
    

    queryClient.setQueryData(['projects'], (data) => ({
      pages: data.pages.slice(0, 1),
      pageParams: data.pageParams.slice(0, 1),
    }))
    

Make sure to always keep the same data structure of pages and pageParams!

[](#what-if-i-want-to-limit-the-number-of-pages)[What if I want to limit the number of pages?](#what-if-i-want-to-limit-the-number-of-pages)
--------------------------------------------------------------------------------------------------------------------------------------------

In some use cases you may want to limit the number of pages stored in the query data to improve the performance and UX:

*   when the user can load a large number of pages (memory usage)
*   when you have to refetch an infinite query that contains dozens of pages (network usage: all the pages are sequentially fetched)

The solution is to use a "Limited Infinite Query". This is made possible by using the maxPages option in conjunction with getNextPageParam and getPreviousPageParam to allow fetching pages when needed in both directions.

In the following example only 3 pages are kept in the query data pages array. If a refetch is needed, only 3 pages will be refetched sequentially.

    useInfiniteQuery(() => {
      queryKey: ['projects'],
      queryFn: fetchProjects,
      initialPageParam: 0,
      getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
      getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,
      maxPages: 3,
    })
    

    useInfiniteQuery(() => {
      queryKey: ['projects'],
      queryFn: fetchProjects,
      initialPageParam: 0,
      getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
      getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,
      maxPages: 3,
    })
    

[](#what-if-my-api-doesnt-return-a-cursor)[What if my API doesn't return a cursor?](#what-if-my-api-doesnt-return-a-cursor)
---------------------------------------------------------------------------------------------------------------------------

If your API doesn't return a cursor, you can use the pageParam as a cursor. Because getNextPageParam and getPreviousPageParam also get the pageParamof the current page, you can use it to calculate the next / previous page param.

    return useInfiniteQuery(() => {
      queryKey: ['projects'],
      queryFn: fetchProjects,
      initialPageParam: 0,
      getNextPageParam: (lastPage, allPages, lastPageParam) => {
        if (lastPage.length === 0) {
          return undefined
        }
        return lastPageParam + 1
      },
      getPreviousPageParam: (firstPage, allPages, firstPageParam) => {
        if (firstPageParam <= 1) {
          return undefined
        }
        return firstPageParam - 1
      },
    })
    

    return useInfiniteQuery(() => {
      queryKey: ['projects'],
      queryFn: fetchProjects,
      initialPageParam: 0,
      getNextPageParam: (lastPage, allPages, lastPageParam) => {
        if (lastPage.length === 0) {
          return undefined
        }
        return lastPageParam + 1
      },
      getPreviousPageParam: (firstPage, allPages, firstPageParam) => {
        if (firstPageParam <= 1) {
          return undefined
        }
        return firstPageParam - 1
      },
    })
    

[](#further-reading)[Further reading](#further-reading)
-------------------------------------------------------

To get a better understanding of how Infinite Queries work under the hood, see the article [How Infinite Queries work](https://tkdodo.eu/blog/how-infinite-queries-work).</content>
</page>

<page>
  <title>Initial Query Data | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/guides/initial-query-data</url>
  <content>There are many ways to supply initial data for a query to the cache before you need it:

*   Declaratively:
    *   Provide initialData to a query to prepopulate its cache if empty
*   Imperatively:
    *   [Prefetch the data using queryClient.prefetchQuery](https://tanstack.com/query/latest/docs/framework/solid/guides/prefetching)
    *   [Manually place the data into the cache using queryClient.setQueryData](https://tanstack.com/query/latest/docs/framework/solid/guides/prefetching)

[](#using-initialdata-to-prepopulate-a-query)[Using initialData to prepopulate a query](#using-initialdata-to-prepopulate-a-query)
----------------------------------------------------------------------------------------------------------------------------------

There may be times when you already have the initial data for a query available in your app and can simply provide it directly to your query. If and when this is the case, you can use the config.initialData option to set the initial data for a query and skip the initial loading state!

> IMPORTANT: initialData is persisted to the cache, so it is not recommended to provide placeholder, partial or incomplete data to this option and instead use placeholderData

    const result = useQuery(() => {
      queryKey: ['todos'],
      queryFn: () => fetch('/todos'),
      initialData: initialTodos,
    })
    

    const result = useQuery(() => {
      queryKey: ['todos'],
      queryFn: () => fetch('/todos'),
      initialData: initialTodos,
    })
    

### [](#staletime-and-initialdataupdatedat)[staleTime and initialDataUpdatedAt](#staletime-and-initialdataupdatedat)

By default, initialData is treated as totally fresh, as if it were just fetched. This also means that it will affect how it is interpreted by the staleTime option.

*   If you configure your query observer with initialData, and no staleTime (the default staleTime: 0), the query will immediately refetch when it mounts:
    
        // Will show initialTodos immediately, but also immediately refetch todos after mount
        const result = useQuery(() => {
          queryKey: ['todos'],
          queryFn: () => fetch('/todos'),
          initialData: initialTodos,
        })
        
    
        // Will show initialTodos immediately, but also immediately refetch todos after mount
        const result = useQuery(() => {
          queryKey: ['todos'],
          queryFn: () => fetch('/todos'),
          initialData: initialTodos,
        })
        
    
*   If you configure your query observer with initialData and a staleTime of 1000 ms, the data will be considered fresh for that same amount of time, as if it was just fetched from your query function.
    
        // Show initialTodos immediately, but won't refetch until another interaction event is encountered after 1000 ms
        const result = useQuery(() => {
          queryKey: ['todos'],
          queryFn: () => fetch('/todos'),
          initialData: initialTodos,
          staleTime: 1000,
        })
        
    
        // Show initialTodos immediately, but won't refetch until another interaction event is encountered after 1000 ms
        const result = useQuery(() => {
          queryKey: ['todos'],
          queryFn: () => fetch('/todos'),
          initialData: initialTodos,
          staleTime: 1000,
        })
        
    
*   So what if your initialData isn't totally fresh? That leaves us with the last configuration that is actually the most accurate and uses an option called initialDataUpdatedAt. This option allows you to pass a numeric JS timestamp in milliseconds of when the initialData itself was last updated, e.g. what Date.now() provides. Take note that if you have a unix timestamp, you'll need to convert it to a JS timestamp by multiplying it by 1000.
    
        // Show initialTodos immediately, but won't refetch until another interaction event is encountered after 1000 ms
        const result = useQuery(() => {
          queryKey: ['todos'],
          queryFn: () => fetch('/todos'),
          initialData: initialTodos,
          staleTime: 60 * 1000, // 1 minute
          // This could be 10 seconds ago or 10 minutes ago
          initialDataUpdatedAt: initialTodosUpdatedTimestamp, // eg. 1608412420052
        })
        
    
        // Show initialTodos immediately, but won't refetch until another interaction event is encountered after 1000 ms
        const result = useQuery(() => {
          queryKey: ['todos'],
          queryFn: () => fetch('/todos'),
          initialData: initialTodos,
          staleTime: 60 * 1000, // 1 minute
          // This could be 10 seconds ago or 10 minutes ago
          initialDataUpdatedAt: initialTodosUpdatedTimestamp, // eg. 1608412420052
        })
        
    
    This option allows the staleTime to be used for its original purpose, determining how fresh the data needs to be, while also allowing the data to be refetched on mount if the initialData is older than the staleTime. In the example above, our data needs to be fresh within 1 minute, and we can hint to the query when the initialData was last updated so the query can decide for itself whether the data needs to be refetched again or not.
    
    > If you would rather treat your data as **prefetched data**, we recommend that you use the prefetchQuery or fetchQuery APIs to populate the cache beforehand, thus letting you configure your staleTime independently from your initialData
    

### [](#initial-data-function)[Initial Data Function](#initial-data-function)

If the process for accessing a query's initial data is intensive or just not something you want to perform on every render, you can pass a function as the initialData value. This function will be executed only once when the query is initialized, saving you precious memory and/or CPU:

    const result = useQuery(() => {
      queryKey: ['todos'],
      queryFn: () => fetch('/todos'),
      initialData: () => getExpensiveTodos(),
    })
    

    const result = useQuery(() => {
      queryKey: ['todos'],
      queryFn: () => fetch('/todos'),
      initialData: () => getExpensiveTodos(),
    })
    

### [](#initial-data-from-cache)[Initial Data from Cache](#initial-data-from-cache)

In some circumstances, you may be able to provide the initial data for a query from the cached result of another. A good example of this would be searching the cached data from a todos list query for an individual todo item, then using that as the initial data for your individual todo query:

    const result = useQuery(() => {
      queryKey: ['todo', todoId],
      queryFn: () => fetch('/todos'),
      initialData: () => {
        // Use a todo from the 'todos' query as the initial data for this todo query
        return queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId)
      },
    })
    

    const result = useQuery(() => {
      queryKey: ['todo', todoId],
      queryFn: () => fetch('/todos'),
      initialData: () => {
        // Use a todo from the 'todos' query as the initial data for this todo query
        return queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId)
      },
    })
    

### [](#initial-data-from-the-cache-with-initialdataupdatedat)[Initial Data from the cache with initialDataUpdatedAt](#initial-data-from-the-cache-with-initialdataupdatedat)

Getting initial data from the cache means the source query you're using to look up the initial data from is likely old. Instead of using an artificial staleTime to keep your query from refetching immediately, it's suggested that you pass the source query's dataUpdatedAt to initialDataUpdatedAt. This provides the query instance with all the information it needs to determine if and when the query needs to be refetched, regardless of initial data being provided.

    const result = useQuery(() => {
      queryKey: ['todos', todoId],
      queryFn: () => fetch(`/todos/${todoId}`),
      initialData: () =>
        queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId),
      initialDataUpdatedAt: () =>
        queryClient.getQueryState(['todos'])?.dataUpdatedAt,
    })
    

    const result = useQuery(() => {
      queryKey: ['todos', todoId],
      queryFn: () => fetch(`/todos/${todoId}`),
      initialData: () =>
        queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId),
      initialDataUpdatedAt: () =>
        queryClient.getQueryState(['todos'])?.dataUpdatedAt,
    })
    

### [](#conditional-initial-data-from-cache)[Conditional Initial Data from Cache](#conditional-initial-data-from-cache)

If the source query you're using to look up the initial data from is old, you may not want to use the cached data at all and just fetch from the server. To make this decision easier, you can use the queryClient.getQueryState method instead to get more information about the source query, including a state.dataUpdatedAt timestamp you can use to decide if the query is "fresh" enough for your needs:

    const result = useQuery(() => {
      queryKey: ['todo', todoId],
      queryFn: () => fetch(`/todos/${todoId}`),
      initialData: () => {
        // Get the query state
        const state = queryClient.getQueryState(['todos'])
    
        // If the query exists and has data that is no older than 10 seconds...
        if (state && Date.now() - state.dataUpdatedAt <= 10 * 1000) {
          // return the individual todo
          return state.data.find((d) => d.id === todoId)
        }
    
        // Otherwise, return undefined and let it fetch from a hard loading state!
      },
    })
    

    const result = useQuery(() => {
      queryKey: ['todo', todoId],
      queryFn: () => fetch(`/todos/${todoId}`),
      initialData: () => {
        // Get the query state
        const state = queryClient.getQueryState(['todos'])
    
        // If the query exists and has data that is no older than 10 seconds...
        if (state && Date.now() - state.dataUpdatedAt <= 10 * 1000) {
          // return the individual todo
          return state.data.find((d) => d.id === todoId)
        }
    
        // Otherwise, return undefined and let it fetch from a hard loading state!
      },
    })
    

[](#further-reading)[Further reading](#further-reading)
-------------------------------------------------------

For a comparison between Initial Data and Placeholder Data, see the [article by TkDodo](https://tkdodo.eu/blog/placeholder-and-initial-data-in-react-query).</content>
</page>

<page>
  <title>Placeholder Query Data | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/guides/placeholder-query-data</url>
  <content>[](#what-is-placeholder-data)[What is placeholder data?](#what-is-placeholder-data)
-----------------------------------------------------------------------------------

Placeholder data allows a query to behave as if it already has data, similar to the initialData option, but **the data is not persisted to the cache**. This comes in handy for situations where you have enough partial (or fake) data to render the query successfully while the actual data is fetched in the background.

> Example: An individual blog post query could pull "preview" data from a parent list of blog posts that only include title and a small snippet of the post body. You would not want to persist this partial data to the query result of the individual query, but it is useful for showing the content layout as quickly as possible while the actual query finishes to fetch the entire object.

There are a few ways to supply placeholder data for a query to the cache before you need it:

*   Declaratively:
    *   Provide placeholderData to a query to prepopulate its cache if empty
*   Imperatively:
    *   [Prefetch or fetch the data using queryClient and the placeholderData option](https://tanstack.com/query/latest/docs/framework/solid/guides/prefetching)

When we use placeholderData, our Query will not be in a pending state - it will start out as being in success state, because we have data to display - even if that data is just "placeholder" data. To distinguish it from "real" data, we will also have the isPlaceholderData flag set to true on the Query result.

[](#placeholder-data-as-a-value)[Placeholder Data as a Value](#placeholder-data-as-a-value)
-------------------------------------------------------------------------------------------

    function Todos() {
      const result = useQuery(() => {
        queryKey: ['todos'],
        queryFn: () => fetch('/todos'),
        placeholderData: placeholderTodos,
      })
    }
    

    function Todos() {
      const result = useQuery(() => {
        queryKey: ['todos'],
        queryFn: () => fetch('/todos'),
        placeholderData: placeholderTodos,
      })
    }
    

### [](#placeholder-data-memoization)[Placeholder Data Memoization](#placeholder-data-memoization)

If the process for accessing a query's placeholder data is intensive or just not something you want to perform on every render, you can memoize the value:

    function Todos() {
      const placeholderData = createMemo(() => generateFakeTodos(), [])
      const result = useQuery(() => {
        queryKey: ['todos'],
        queryFn: () => fetch('/todos'),
        placeholderData,
      })
    }
    

    function Todos() {
      const placeholderData = createMemo(() => generateFakeTodos(), [])
      const result = useQuery(() => {
        queryKey: ['todos'],
        queryFn: () => fetch('/todos'),
        placeholderData,
      })
    }
    

[](#placeholder-data-as-a-function)[Placeholder Data as a Function](#placeholder-data-as-a-function)
----------------------------------------------------------------------------------------------------

placeholderData can also be a function, where you can get access to the data and Query meta information of a "previous" successful Query. This is useful for situations where you want to use the data from one query as the placeholder data for another query. When the QueryKey changes, e.g. from \['todos', 1\] to \['todos', 2\], we can keep displaying "old" data instead of having to show a loading spinner while data is _transitioning_ from one Query to the next. For more information, see [Paginated Queries](https://tanstack.com/query/latest/docs/framework/solid/guides/paginated-queries).

    const result = useQuery(() => {
      queryKey: ['todos', id],
      queryFn: () => fetch(`/todos/${id}`),
      placeholderData: (previousData, previousQuery) => previousData,
    })
    

    const result = useQuery(() => {
      queryKey: ['todos', id],
      queryFn: () => fetch(`/todos/${id}`),
      placeholderData: (previousData, previousQuery) => previousData,
    })
    

### [](#placeholder-data-from-cache)[Placeholder Data from Cache](#placeholder-data-from-cache)

In some circumstances, you may be able to provide the placeholder data for a query from the cached result of another. A good example of this would be searching the cached data from a blog post list query for a preview version of the post, then using that as the placeholder data for your individual post query:

    function BlogPost({ blogPostId }) {
      const queryClient = useQueryClient()
      const result = useQuery(() => {
        queryKey: ['blogPost', blogPostId],
        queryFn: () => fetch(`/blogPosts/${blogPostId}`),
        placeholderData: () => {
          // Use the smaller/preview version of the blogPost from the 'blogPosts'
          // query as the placeholder data for this blogPost query
          return queryClient
            .getQueryData(['blogPosts'])
            ?.find((d) => d.id === blogPostId)
        },
      })
    }
    

    function BlogPost({ blogPostId }) {
      const queryClient = useQueryClient()
      const result = useQuery(() => {
        queryKey: ['blogPost', blogPostId],
        queryFn: () => fetch(`/blogPosts/${blogPostId}`),
        placeholderData: () => {
          // Use the smaller/preview version of the blogPost from the 'blogPosts'
          // query as the placeholder data for this blogPost query
          return queryClient
            .getQueryData(['blogPosts'])
            ?.find((d) => d.id === blogPostId)
        },
      })
    }
    

[](#further-reading)[Further reading](#further-reading)
-------------------------------------------------------

For a comparison between Placeholder Data and Initial Data, see the [article by TkDodo](https://tkdodo.eu/blog/placeholder-and-initial-data-in-react-query).</content>
</page>

<page>
  <title>Mutations | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/guides/mutations</url>
  <content>Unlike queries, mutations are typically used to create/update/delete data or perform server side-effects. For this purpose, TanStack Query exports a useMutation hook.

Here's an example of a mutation that adds a new todo to the server:

    function App() {
      const mutation = useMutation(() => {
        mutationFn: (newTodo) => {
          return axios.post('/todos', newTodo)
        },
      })
    
      return (
        <div>
          {mutation.isPending ? (
            'Adding todo...'
          ) : (
            <>
              {mutation.isError ? (
                <div>An error occurred: {mutation.error.message}</div>
              ) : null}
    
              {mutation.isSuccess ? <div>Todo added!</div> : null}
    
              <button
                onClick={() => {
                  mutation.mutate({ id: new Date(), title: 'Do Laundry' })
                }}
              >
                Create Todo
              </button>
            </>
          )}
        </div>
      )
    }
    

    function App() {
      const mutation = useMutation(() => {
        mutationFn: (newTodo) => {
          return axios.post('/todos', newTodo)
        },
      })
    
      return (
        <div>
          {mutation.isPending ? (
            'Adding todo...'
          ) : (
            <>
              {mutation.isError ? (
                <div>An error occurred: {mutation.error.message}</div>
              ) : null}
    
              {mutation.isSuccess ? <div>Todo added!</div> : null}
    
              <button
                onClick={() => {
                  mutation.mutate({ id: new Date(), title: 'Do Laundry' })
                }}
              >
                Create Todo
              </button>
            </>
          )}
        </div>
      )
    }
    

A mutation can only be in one of the following states at any given moment:

*   isIdle or status === 'idle' - The mutation is currently idle or in a fresh/reset state
*   isPending or status === 'pending' - The mutation is currently running
*   isError or status === 'error' - The mutation encountered an error
*   isSuccess or status === 'success' - The mutation was successful and mutation data is available

Beyond those primary states, more information is available depending on the state of the mutation:

*   error - If the mutation is in an error state, the error is available via the error property.
*   data - If the mutation is in a success state, the data is available via the data property.

In the example above, you also saw that you can pass variables to your mutations function by calling the mutate function with a **single variable or object**.

Even with just variables, mutations aren't all that special, but when used with the onSuccess option, the [Query Client's invalidateQueries method](https://tanstack.com/query/latest/docs/reference/QueryClient#queryclientinvalidatequeries) and the [Query Client's setQueryData method](https://tanstack.com/query/latest/docs/reference/QueryClient#queryclientsetquerydata), mutations become a very powerful tool.

> IMPORTANT: The mutate function is an asynchronous function, which means you cannot use it directly in an event callback in **Solid 16 and earlier**. If you need to access the event in onSubmit you need to wrap mutate in another function. This is due to [Solid event pooling](https://reactjs.org/docs/legacy-event-pooling.html).

    // This will not work in Solid 16 and earlier
    const CreateTodo = () => {
      const mutation = useMutation(() => {
        mutationFn: (event) => {
          event.preventDefault()
          return fetch('/api', new FormData(event.target))
        },
      })
    
      return <form onSubmit={mutation.mutate}>...</form>
    }
    
    // This will work
    const CreateTodo = () => {
      const mutation = useMutation(() => {
        mutationFn: (formData) => {
          return fetch('/api', formData)
        },
      })
      const onSubmit = (event) => {
        event.preventDefault()
        mutation.mutate(new FormData(event.target))
      }
    
      return <form onSubmit={onSubmit}>...</form>
    }
    

    // This will not work in Solid 16 and earlier
    const CreateTodo = () => {
      const mutation = useMutation(() => {
        mutationFn: (event) => {
          event.preventDefault()
          return fetch('/api', new FormData(event.target))
        },
      })
    
      return <form onSubmit={mutation.mutate}>...</form>
    }
    
    // This will work
    const CreateTodo = () => {
      const mutation = useMutation(() => {
        mutationFn: (formData) => {
          return fetch('/api', formData)
        },
      })
      const onSubmit = (event) => {
        event.preventDefault()
        mutation.mutate(new FormData(event.target))
      }
    
      return <form onSubmit={onSubmit}>...</form>
    }
    

[](#resetting-mutation-state)[Resetting Mutation State](#resetting-mutation-state)
----------------------------------------------------------------------------------

It's sometimes the case that you need to clear the error or data of a mutation request. To do this, you can use the reset function to handle this:

    const CreateTodo = () => {
      const [title, setTitle] = useState('')
      const mutation = useMutation(() => { mutationFn: createTodo })
    
      const onCreateTodo = (e) => {
        e.preventDefault()
        mutation.mutate({ title })
      }
    
      return (
        <form onSubmit={onCreateTodo}>
          {mutation.error && (
            <h5 onClick={() => mutation.reset()}>{mutation.error}</h5>
          )}
          <input
            type="text"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
          />
          <br />
          <button type="submit">Create Todo</button>
        </form>
      )
    }
    

    const CreateTodo = () => {
      const [title, setTitle] = useState('')
      const mutation = useMutation(() => { mutationFn: createTodo })
    
      const onCreateTodo = (e) => {
        e.preventDefault()
        mutation.mutate({ title })
      }
    
      return (
        <form onSubmit={onCreateTodo}>
          {mutation.error && (
            <h5 onClick={() => mutation.reset()}>{mutation.error}</h5>
          )}
          <input
            type="text"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
          />
          <br />
          <button type="submit">Create Todo</button>
        </form>
      )
    }
    

[](#mutation-side-effects)[Mutation Side Effects](#mutation-side-effects)
-------------------------------------------------------------------------

useMutation comes with some helper options that allow quick and easy side-effects at any stage during the mutation lifecycle. These come in handy for both [invalidating and refetching queries after mutations](https://tanstack.com/query/latest/docs/framework/solid/guides/invalidations-from-mutations) and even [optimistic updates](https://tanstack.com/query/latest/docs/framework/solid/guides/optimistic-updates)

    useMutation(() => {
      mutationFn: addTodo,
      onMutate: (variables, context) => {
        // A mutation is about to happen!
    
        // Optionally return a result containing data to use when for example rolling back
        return { id: 1 }
      },
      onError: (error, variables, onMutateResult, context) => {
        // An error happened!
        console.log(`rolling back optimistic update with id ${onMutateResult.id}`)
      },
      onSuccess: (data, variables, onMutateResult, context) => {
        // Boom baby!
      },
      onSettled: (data, error, variables, onMutateResult, context) => {
        // Error or success... doesn't matter!
      },
    })
    

    useMutation(() => {
      mutationFn: addTodo,
      onMutate: (variables, context) => {
        // A mutation is about to happen!
    
        // Optionally return a result containing data to use when for example rolling back
        return { id: 1 }
      },
      onError: (error, variables, onMutateResult, context) => {
        // An error happened!
        console.log(`rolling back optimistic update with id ${onMutateResult.id}`)
      },
      onSuccess: (data, variables, onMutateResult, context) => {
        // Boom baby!
      },
      onSettled: (data, error, variables, onMutateResult, context) => {
        // Error or success... doesn't matter!
      },
    })
    

When returning a promise in any of the callback functions it will first be awaited before the next callback is called:

    useMutation(() => {
      mutationFn: addTodo,
      onSuccess: async () => {
        console.log("I'm first!")
      },
      onSettled: async () => {
        console.log("I'm second!")
      },
    })
    

    useMutation(() => {
      mutationFn: addTodo,
      onSuccess: async () => {
        console.log("I'm first!")
      },
      onSettled: async () => {
        console.log("I'm second!")
      },
    })
    

You might find that you want to **trigger additional callbacks** beyond the ones defined on useMutation when calling mutate. This can be used to trigger component-specific side effects. To do that, you can provide any of the same callback options to the mutate function after your mutation variable. Supported options include: onSuccess, onError and onSettled. Please keep in mind that those additional callbacks won't run if your component unmounts _before_ the mutation finishes.

    useMutation(() => {
      mutationFn: addTodo,
      onSuccess: (data, variables, onMutateResult, context) => {
        // I will fire first
      },
      onError: (error, variables, onMutateResult, context) => {
        // I will fire first
      },
      onSettled: (data, error, variables, onMutateResult, context) => {
        // I will fire first
      },
    })
    
    mutate(todo, {
      onSuccess: (data, variables, onMutateResult, context) => {
        // I will fire second!
      },
      onError: (error, variables, onMutateResult, context) => {
        // I will fire second!
      },
      onSettled: (data, error, variables, onMutateResult, context) => {
        // I will fire second!
      },
    })
    

    useMutation(() => {
      mutationFn: addTodo,
      onSuccess: (data, variables, onMutateResult, context) => {
        // I will fire first
      },
      onError: (error, variables, onMutateResult, context) => {
        // I will fire first
      },
      onSettled: (data, error, variables, onMutateResult, context) => {
        // I will fire first
      },
    })
    
    mutate(todo, {
      onSuccess: (data, variables, onMutateResult, context) => {
        // I will fire second!
      },
      onError: (error, variables, onMutateResult, context) => {
        // I will fire second!
      },
      onSettled: (data, error, variables, onMutateResult, context) => {
        // I will fire second!
      },
    })
    

### [](#consecutive-mutations)[Consecutive mutations](#consecutive-mutations)

There is a slight difference in handling onSuccess, onError and onSettled callbacks when it comes to consecutive mutations. When passed to the mutate function, they will be fired up only _once_ and only if the component is still mounted. This is due to the fact that mutation observer is removed and resubscribed every time when the mutate function is called. On the contrary, useMutation handlers execute for each mutate call.

> Be aware that most likely, mutationFn passed to useMutation is asynchronous. In that case, the order in which mutations are fulfilled may differ from the order of mutate function calls.

    useMutation(() => {
      mutationFn: addTodo,
      onSuccess: (data, variables, onMutateResult, context) => {
        // Will be called 3 times
      },
    })
    
    const todos = ['Todo 1', 'Todo 2', 'Todo 3']
    todos.forEach((todo) => {
      mutate(todo, {
        onSuccess: (data, variables, onMutateResult, context) => {
          // Will execute only once, for the last mutation (Todo 3),
          // regardless which mutation resolves first
        },
      })
    })
    

    useMutation(() => {
      mutationFn: addTodo,
      onSuccess: (data, variables, onMutateResult, context) => {
        // Will be called 3 times
      },
    })
    
    const todos = ['Todo 1', 'Todo 2', 'Todo 3']
    todos.forEach((todo) => {
      mutate(todo, {
        onSuccess: (data, variables, onMutateResult, context) => {
          // Will execute only once, for the last mutation (Todo 3),
          // regardless which mutation resolves first
        },
      })
    })
    

[](#promises)[Promises](#promises)
----------------------------------

Use mutateAsync instead of mutate to get a promise which will resolve on success or throw on an error. This can for example be used to compose side effects.

    const mutation = useMutation(() => { mutationFn: addTodo })
    
    try {
      const todo = await mutation.mutateAsync(todo)
      console.log(todo)
    } catch (error) {
      console.error(error)
    } finally {
      console.log('done')
    }
    

    const mutation = useMutation(() => { mutationFn: addTodo })
    
    try {
      const todo = await mutation.mutateAsync(todo)
      console.log(todo)
    } catch (error) {
      console.error(error)
    } finally {
      console.log('done')
    }
    

[](#retry)[Retry](#retry)
-------------------------

By default, TanStack Query will not retry a mutation on error, but it is possible with the retry option:

    const mutation = useMutation(() => {
      mutationFn: addTodo,
      retry: 3,
    })
    

    const mutation = useMutation(() => {
      mutationFn: addTodo,
      retry: 3,
    })
    

If mutations fail because the device is offline, they will be retried in the same order when the device reconnects.

[](#persist-mutations)[Persist mutations](#persist-mutations)
-------------------------------------------------------------

Mutations can be persisted to storage if needed and resumed at a later point. This can be done with the hydration functions:

    const queryClient = new QueryClient()
    
    // Define the "addTodo" mutation
    queryClient.setMutationDefaults(['addTodo'], {
      mutationFn: addTodo,
      onMutate: async (variables, context) => {
        // Cancel current queries for the todos list
        await context.client.cancelQueries({ queryKey: ['todos'] })
    
        // Create optimistic todo
        const optimisticTodo = { id: uuid(), title: variables.title }
    
        // Add optimistic todo to todos list
        context.client.setQueryData(['todos'], (old) => [...old, optimisticTodo])
    
        // Return a result with the optimistic todo
        return { optimisticTodo }
      },
      onSuccess: (result, variables, onMutateResult, context) => {
        // Replace optimistic todo in the todos list with the result
        context.client.setQueryData(['todos'], (old) =>
          old.map((todo) =>
            todo.id === onMutateResult.optimisticTodo.id ? result : todo,
          ),
        )
      },
      onError: (error, variables, onMutateResult, context) => {
        // Remove optimistic todo from the todos list
        context.client.setQueryData(['todos'], (old) =>
          old.filter((todo) => todo.id !== onMutateResult.optimisticTodo.id),
        )
      },
      retry: 3,
    })
    
    // Start mutation in some component:
    const mutation = useMutation(() => { mutationKey: ['addTodo'] })
    mutation.mutate({ title: 'title' })
    
    // If the mutation has been paused because the device is for example offline,
    // Then the paused mutation can be dehydrated when the application quits:
    const state = dehydrate(queryClient)
    
    // The mutation can then be hydrated again when the application is started:
    hydrate(queryClient, state)
    
    // Resume the paused mutations:
    queryClient.resumePausedMutations()
    

    const queryClient = new QueryClient()
    
    // Define the "addTodo" mutation
    queryClient.setMutationDefaults(['addTodo'], {
      mutationFn: addTodo,
      onMutate: async (variables, context) => {
        // Cancel current queries for the todos list
        await context.client.cancelQueries({ queryKey: ['todos'] })
    
        // Create optimistic todo
        const optimisticTodo = { id: uuid(), title: variables.title }
    
        // Add optimistic todo to todos list
        context.client.setQueryData(['todos'], (old) => [...old, optimisticTodo])
    
        // Return a result with the optimistic todo
        return { optimisticTodo }
      },
      onSuccess: (result, variables, onMutateResult, context) => {
        // Replace optimistic todo in the todos list with the result
        context.client.setQueryData(['todos'], (old) =>
          old.map((todo) =>
            todo.id === onMutateResult.optimisticTodo.id ? result : todo,
          ),
        )
      },
      onError: (error, variables, onMutateResult, context) => {
        // Remove optimistic todo from the todos list
        context.client.setQueryData(['todos'], (old) =>
          old.filter((todo) => todo.id !== onMutateResult.optimisticTodo.id),
        )
      },
      retry: 3,
    })
    
    // Start mutation in some component:
    const mutation = useMutation(() => { mutationKey: ['addTodo'] })
    mutation.mutate({ title: 'title' })
    
    // If the mutation has been paused because the device is for example offline,
    // Then the paused mutation can be dehydrated when the application quits:
    const state = dehydrate(queryClient)
    
    // The mutation can then be hydrated again when the application is started:
    hydrate(queryClient, state)
    
    // Resume the paused mutations:
    queryClient.resumePausedMutations()
    

### [](#persisting-offline-mutations)[Persisting Offline mutations](#persisting-offline-mutations)

If you persist offline mutations with the [persistQueryClient plugin](https://tanstack.com/query/latest/docs/framework/solid/plugins/persistQueryClient), mutations cannot be resumed when the page is reloaded unless you provide a default mutation function.

This is a technical limitation. When persisting to an external storage, only the state of mutations is persisted, as functions cannot be serialized. After hydration, the component that triggers the mutation might not be mounted, so calling resumePausedMutations might yield an error: No mutationFn found.

    const persister = createSyncStoragePersister({
      storage: window.localStorage,
    })
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          gcTime: 1000 * 60 * 60 * 24, // 24 hours
        },
      },
    })
    
    // we need a default mutation function so that paused mutations can resume after a page reload
    queryClient.setMutationDefaults(['todos'], {
      mutationFn: ({ id, data }) => {
        return api.updateTodo(id, data)
      },
    })
    
    export default function App() {
      return (
        <PersistQueryClientProvider
          client={queryClient}
          persistOptions={{ persister }}
          onSuccess={() => {
            // resume mutations after initial restore from localStorage was successful
            queryClient.resumePausedMutations()
          }}
        >
          <RestOfTheApp />
        </PersistQueryClientProvider>
      )
    }
    

    const persister = createSyncStoragePersister({
      storage: window.localStorage,
    })
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          gcTime: 1000 * 60 * 60 * 24, // 24 hours
        },
      },
    })
    
    // we need a default mutation function so that paused mutations can resume after a page reload
    queryClient.setMutationDefaults(['todos'], {
      mutationFn: ({ id, data }) => {
        return api.updateTodo(id, data)
      },
    })
    
    export default function App() {
      return (
        <PersistQueryClientProvider
          client={queryClient}
          persistOptions={{ persister }}
          onSuccess={() => {
            // resume mutations after initial restore from localStorage was successful
            queryClient.resumePausedMutations()
          }}
        >
          <RestOfTheApp />
        </PersistQueryClientProvider>
      )
    }
    

We also have an extensive [offline example](https://tanstack.com/query/latest/docs/framework/solid/examples/offline) that covers both queries and mutations.

[](#mutation-scopes)[Mutation Scopes](#mutation-scopes)
-------------------------------------------------------

Per default, all mutations run in parallel - even if you invoke .mutate() of the same mutation multiple times. Mutations can be given a scope with an id to avoid that. All mutations with the same scope.id will run in serial, which means when they are triggered, they will start in isPaused: true state if there is already a mutation for that scope in progress. They will be put into a queue and will automatically resume once their time in the queue has come.

    const mutation = useMutation(() => {
      mutationFn: addTodo,
      scope: {
        id: 'todo',
      },
    })
    

    const mutation = useMutation(() => {
      mutationFn: addTodo,
      scope: {
        id: 'todo',
      },
    })
    

[](#further-reading)[Further reading](#further-reading)
-------------------------------------------------------

For more information about mutations, have a look at [TkDodo's article on Mastering Mutations in Solid Query](https://tkdodo.eu/blog/mastering-mutations-in-react-query).</content>
</page>

<page>
  <title>Query Invalidation | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/guides/query-invalidation</url>
  <content>Waiting for queries to become stale before they are fetched again doesn't always work, especially when you know for a fact that a query's data is out of date because of something the user has done. For that purpose, the QueryClient has an invalidateQueries method that lets you intelligently mark queries as stale and potentially refetch them too!

    // Invalidate every query in the cache
    queryClient.invalidateQueries()
    // Invalidate every query with a key that starts with `todos`
    queryClient.invalidateQueries({ queryKey: ['todos'] })
    

    // Invalidate every query in the cache
    queryClient.invalidateQueries()
    // Invalidate every query with a key that starts with `todos`
    queryClient.invalidateQueries({ queryKey: ['todos'] })
    

> Note: Where other libraries that use normalized caches would attempt to update local queries with the new data either imperatively or via schema inference, TanStack Query gives you the tools to avoid the manual labor that comes with maintaining normalized caches and instead prescribes **targeted invalidation, background-refetching and ultimately atomic updates**.

When a query is invalidated with invalidateQueries, two things happen:

*   It is marked as stale. This stale state overrides any staleTime configurations being used in useQuery or related hooks
*   If the query is currently being rendered via useQuery or related hooks, it will also be refetched in the background

[](#query-matching-with-invalidatequeries)[Query Matching with invalidateQueries](#query-matching-with-invalidatequeries)
-------------------------------------------------------------------------------------------------------------------------

When using APIs like invalidateQueries and removeQueries (and others that support partial query matching), you can match multiple queries by their prefix, or get really specific and match an exact query. For information on the types of filters you can use, please see [Query Filters](https://tanstack.com/query/latest/docs/framework/solid/guides/filters#query-filters).

In this example, we can use the todos prefix to invalidate any queries that start with todos in their query key:

    import { useQuery, useQueryClient } from '@tanstack/solid-query'
    
    // Get QueryClient from the context
    const queryClient = useQueryClient()
    
    queryClient.invalidateQueries({ queryKey: ['todos'] })
    
    // Both queries below will be invalidated
    const todoListQuery = useQuery(() => {
      queryKey: ['todos'],
      queryFn: fetchTodoList,
    })
    const todoListQuery = useQuery(() => {
      queryKey: ['todos', { page: 1 }],
      queryFn: fetchTodoList,
    })
    

    import { useQuery, useQueryClient } from '@tanstack/solid-query'
    
    // Get QueryClient from the context
    const queryClient = useQueryClient()
    
    queryClient.invalidateQueries({ queryKey: ['todos'] })
    
    // Both queries below will be invalidated
    const todoListQuery = useQuery(() => {
      queryKey: ['todos'],
      queryFn: fetchTodoList,
    })
    const todoListQuery = useQuery(() => {
      queryKey: ['todos', { page: 1 }],
      queryFn: fetchTodoList,
    })
    

You can even invalidate queries with specific variables by passing a more specific query key to the invalidateQueries method:

    queryClient.invalidateQueries({
      queryKey: ['todos', { type: 'done' }],
    })
    
    // The query below will be invalidated
    const todoListQuery = useQuery(() => {
      queryKey: ['todos', { type: 'done' }],
      queryFn: fetchTodoList,
    })
    
    // However, the following query below will NOT be invalidated
    const todoListQuery = useQuery(() => {
      queryKey: ['todos'],
      queryFn: fetchTodoList,
    })
    

    queryClient.invalidateQueries({
      queryKey: ['todos', { type: 'done' }],
    })
    
    // The query below will be invalidated
    const todoListQuery = useQuery(() => {
      queryKey: ['todos', { type: 'done' }],
      queryFn: fetchTodoList,
    })
    
    // However, the following query below will NOT be invalidated
    const todoListQuery = useQuery(() => {
      queryKey: ['todos'],
      queryFn: fetchTodoList,
    })
    

The invalidateQueries API is very flexible, so even if you want to **only** invalidate todos queries that don't have any more variables or subkeys, you can pass an exact: true option to the invalidateQueries method:

    queryClient.invalidateQueries({
      queryKey: ['todos'],
      exact: true,
    })
    
    // The query below will be invalidated
    const todoListQuery = useQuery(() => {
      queryKey: ['todos'],
      queryFn: fetchTodoList,
    })
    
    // However, the following query below will NOT be invalidated
    const todoListQuery = useQuery(() => {
      queryKey: ['todos', { type: 'done' }],
      queryFn: fetchTodoList,
    })
    

    queryClient.invalidateQueries({
      queryKey: ['todos'],
      exact: true,
    })
    
    // The query below will be invalidated
    const todoListQuery = useQuery(() => {
      queryKey: ['todos'],
      queryFn: fetchTodoList,
    })
    
    // However, the following query below will NOT be invalidated
    const todoListQuery = useQuery(() => {
      queryKey: ['todos', { type: 'done' }],
      queryFn: fetchTodoList,
    })
    

If you find yourself wanting **even more** granularity, you can pass a predicate function to the invalidateQueries method. This function will receive each Query instance from the query cache and allow you to return true or false for whether you want to invalidate that query:

    queryClient.invalidateQueries({
      predicate: (query) =>
        query.queryKey[0] === 'todos' && query.queryKey[1]?.version >= 10,
    })
    
    // The query below will be invalidated
    const todoListQuery = useQuery(() => {
      queryKey: ['todos', { version: 20 }],
      queryFn: fetchTodoList,
    })
    
    // The query below will be invalidated
    const todoListQuery = useQuery(() => {
      queryKey: ['todos', { version: 10 }],
      queryFn: fetchTodoList,
    })
    
    // However, the following query below will NOT be invalidated
    const todoListQuery = useQuery(() => {
      queryKey: ['todos', { version: 5 }],
      queryFn: fetchTodoList,
    })
    

    queryClient.invalidateQueries({
      predicate: (query) =>
        query.queryKey[0] === 'todos' && query.queryKey[1]?.version >= 10,
    })
    
    // The query below will be invalidated
    const todoListQuery = useQuery(() => {
      queryKey: ['todos', { version: 20 }],
      queryFn: fetchTodoList,
    })
    
    // The query below will be invalidated
    const todoListQuery = useQuery(() => {
      queryKey: ['todos', { version: 10 }],
      queryFn: fetchTodoList,
    })
    
    // However, the following query below will NOT be invalidated
    const todoListQuery = useQuery(() => {
      queryKey: ['todos', { version: 5 }],
      queryFn: fetchTodoList,
    })</content>
</page>

<page>
  <title>Invalidations from Mutations | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/guides/invalidations-from-mutations</url>
  <content>Invalidating queries is only half the battle. Knowing **when** to invalidate them is the other half. Usually when a mutation in your app succeeds, it's VERY likely that there are related queries in your application that need to be invalidated and possibly refetched to account for the new changes from your mutation.

For example, assume we have a mutation to post a new todo:

    const mutation = useMutation(() => { mutationFn: postTodo })
    

    const mutation = useMutation(() => { mutationFn: postTodo })
    

When a successful postTodo mutation happens, we likely want all todos queries to get invalidated and possibly refetched to show the new todo item. To do this, you can use useMutation's onSuccess options and the client's invalidateQueries function:

    import { useMutation, useQueryClient } from '@tanstack/solid-query'
    
    const queryClient = useQueryClient()
    
    // When this mutation succeeds, invalidate any queries with the `todos` or `reminders` query key
    const mutation = useMutation(() => {
      mutationFn: addTodo,
      onSuccess: async () => {
        // If you're invalidating a single query
        await queryClient.invalidateQueries({ queryKey: ['todos'] })
    
        // If you're invalidating multiple queries
        await Promise.all([
          queryClient.invalidateQueries({ queryKey: ['todos'] }),
          queryClient.invalidateQueries({ queryKey: ['reminders'] }),
        ])
      },
    })
    

    import { useMutation, useQueryClient } from '@tanstack/solid-query'
    
    const queryClient = useQueryClient()
    
    // When this mutation succeeds, invalidate any queries with the `todos` or `reminders` query key
    const mutation = useMutation(() => {
      mutationFn: addTodo,
      onSuccess: async () => {
        // If you're invalidating a single query
        await queryClient.invalidateQueries({ queryKey: ['todos'] })
    
        // If you're invalidating multiple queries
        await Promise.all([
          queryClient.invalidateQueries({ queryKey: ['todos'] }),
          queryClient.invalidateQueries({ queryKey: ['reminders'] }),
        ])
      },
    })
    

Returning a Promise on onSuccess makes sure the data is updated before the mutation is entirely complete (i.e., isPending is true until onSuccess is fulfilled)

You can wire up your invalidations to happen using any of the callbacks available in the [useMutation hook](https://tanstack.com/query/latest/docs/framework/solid/guides/mutations)

[](#further-reading)[Further reading](#further-reading)
-------------------------------------------------------

For a technique to automatically invalidate Queries after Mutations, have a look at [TkDodo's article on Automatic Query Invalidation after Mutations](https://tkdodo.eu/blog/automatic-query-invalidation-after-mutations).</content>
</page>

<page>
  <title>Angular TanStack Query Query Options From A Service Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/examples/query-options-from-a-service</url>
  <content>ts

    import { Component } from '@angular/core'
    import { RouterOutlet } from '@angular/router'
    
    @Component({
      selector: 'app-root',
      imports: [RouterOutlet],
      templateUrl: './app.component.html',
    })
    export class AppComponent {}
    

    import { Component } from '@angular/core'
    import { RouterOutlet } from '@angular/router'
    
    @Component({
      selector: 'app-root',
      imports: [RouterOutlet],
      templateUrl: './app.component.html',
    })
    export class AppComponent {}</content>
</page>

<page>
  <title>Angular TanStack Query Devtools Panel Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/examples/devtools-panel</url>
  <content>    import { ChangeDetectionStrategy, Component } from '@angular/core'
    import { RouterLink, RouterOutlet } from '@angular/router'
    
    @Component({
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: 'app-root',
      template: `
        <ul>
          <li>
            <a routerLink="basic">Basic devtools panel example</a>
          </li>
          <li>
            <a routerLink="lazy">Lazy load devtools panel example</a>
          </li>
        </ul>
    
        <router-outlet />
      `,
      imports: [RouterOutlet, RouterLink],
    })
    export class AppComponent {}
    

    import { ChangeDetectionStrategy, Component } from '@angular/core'
    import { RouterLink, RouterOutlet } from '@angular/router'
    
    @Component({
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: 'app-root',
      template: `
        <ul>
          <li>
            <a routerLink="basic">Basic devtools panel example</a>
          </li>
          <li>
            <a routerLink="lazy">Lazy load devtools panel example</a>
          </li>
        </ul>
    
        <router-outlet />
      `,
      imports: [RouterOutlet, RouterLink],
    })
    export class AppComponent {}</content>
</page>

<page>
  <title>Updates from Mutation Responses | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/guides/updates-from-mutation-responses</url>
  <content>When dealing with mutations that **update** objects on the server, it's common for the new object to be automatically returned in the response of the mutation. Instead of refetching any queries for that item and wasting a network call for data we already have, we can take advantage of the object returned by the mutation function and update the existing query with the new data immediately using the [Query Client's setQueryData](https://tanstack.com/query/latest/docs/reference/QueryClient#queryclientsetquerydata) method:

    const queryClient = useQueryClient()
    
    const mutation = useMutation(() => {
      mutationFn: editTodo,
      onSuccess: (data) => {
        queryClient.setQueryData(['todo', { id: 5 }], data)
      },
    })
    
    mutation.mutate({
      id: 5,
      name: 'Do the laundry',
    })
    
    // The query below will be updated with the response from the
    // successful mutation
    const { status, data, error } = useQuery(() => {
      queryKey: ['todo', { id: 5 }],
      queryFn: fetchTodoById,
    })
    

    const queryClient = useQueryClient()
    
    const mutation = useMutation(() => {
      mutationFn: editTodo,
      onSuccess: (data) => {
        queryClient.setQueryData(['todo', { id: 5 }], data)
      },
    })
    
    mutation.mutate({
      id: 5,
      name: 'Do the laundry',
    })
    
    // The query below will be updated with the response from the
    // successful mutation
    const { status, data, error } = useQuery(() => {
      queryKey: ['todo', { id: 5 }],
      queryFn: fetchTodoById,
    })
    

You might want to tie the onSuccess logic into a reusable mutation, for that you can create a custom hook like this:

    const useMutateTodo = () => {
      const queryClient = useQueryClient()
    
      return useMutation(() => {
        mutationFn: editTodo,
        // Notice the second argument is the variables object that the `mutate` function receives
        onSuccess: (data, variables) => {
          queryClient.setQueryData(['todo', { id: variables.id }], data)
        },
      })
    }
    

    const useMutateTodo = () => {
      const queryClient = useQueryClient()
    
      return useMutation(() => {
        mutationFn: editTodo,
        // Notice the second argument is the variables object that the `mutate` function receives
        onSuccess: (data, variables) => {
          queryClient.setQueryData(['todo', { id: variables.id }], data)
        },
      })
    }
    

[](#immutability)[Immutability](#immutability)
----------------------------------------------

Updates via setQueryData must be performed in an _immutable_ way. **DO NOT** attempt to write directly to the cache by mutating data (that you retrieved from the cache) in place. It might work at first but can lead to subtle bugs along the way.

    queryClient.setQueryData(['posts', { id }], (oldData) => {
      if (oldData) {
        // ‚ùå do not try this
        oldData.title = 'my new post title'
      }
      return oldData
    })
    
    queryClient.setQueryData(
      ['posts', { id }],
      // ‚úÖ this is the way
      (oldData) =>
        oldData
          ? {
              ...oldData,
              title: 'my new post title',
            }
          : oldData,
    )
    

    queryClient.setQueryData(['posts', { id }], (oldData) => {
      if (oldData) {
        // ‚ùå do not try this
        oldData.title = 'my new post title'
      }
      return oldData
    })
    
    queryClient.setQueryData(
      ['posts', { id }],
      // ‚úÖ this is the way
      (oldData) =>
        oldData
          ? {
              ...oldData,
              title: 'my new post title',
            }
          : oldData,
    )</content>
</page>

<page>
  <title>Optimistic Updates | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/guides/optimistic-updates</url>
  <content>Solid Query provides two ways to optimistically update your UI before a mutation has completed. You can either use the onMutate option to update your cache directly, or leverage the returned variables to update your UI from the useMutation result.

[](#via-the-ui)[Via the UI](#via-the-ui)
----------------------------------------

This is the simpler variant, as it doesn't interact with the cache directly.

    const addTodoMutation = useMutation(() => {
      mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
      // make sure to _return_ the Promise from the query invalidation
      // so that the mutation stays in `pending` state until the refetch is finished
      onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
    })
    
    const { isPending, submittedAt, variables, mutate, isError } = addTodoMutation
    

    const addTodoMutation = useMutation(() => {
      mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
      // make sure to _return_ the Promise from the query invalidation
      // so that the mutation stays in `pending` state until the refetch is finished
      onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
    })
    
    const { isPending, submittedAt, variables, mutate, isError } = addTodoMutation
    

you will then have access to addTodoMutation.variables, which contain the added todo. In your UI list, where the query is rendered, you can append another item to the list while the mutation isPending:

    <ul>
      {todoQuery.items.map((todo) => (
        <li key={todo.id}>{todo.text}</li>
      ))}
      {isPending && <li style={{ opacity: 0.5 }}>{variables}</li>}
    </ul>
    

    <ul>
      {todoQuery.items.map((todo) => (
        <li key={todo.id}>{todo.text}</li>
      ))}
      {isPending && <li style={{ opacity: 0.5 }}>{variables}</li>}
    </ul>
    

We're rendering a temporary item with a different opacity as long as the mutation is pending. Once it completes, the item will automatically no longer be rendered. Given that the refetch succeeded, we should see the item as a "normal item" in our list.

If the mutation errors, the item will also disappear. But we could continue to show it, if we want, by checking for the isError state of the mutation. variables are _not_ cleared when the mutation errors, so we can still access them, maybe even show a retry button:

    {
      isError && (
        <li style={{ color: 'red' }}>
          {variables}
          <button onClick={() => mutate(variables)}>Retry</button>
        </li>
      )
    }
    

    {
      isError && (
        <li style={{ color: 'red' }}>
          {variables}
          <button onClick={() => mutate(variables)}>Retry</button>
        </li>
      )
    }
    

### [](#if-the-mutation-and-the-query-dont-live-in-the-same-component)[If the mutation and the query don't live in the same component](#if-the-mutation-and-the-query-dont-live-in-the-same-component)

This approach works very well if the mutation and the query live in the same component. However, you also get access to all mutations in other components via the dedicated useMutationState hook. It is best combined with a mutationKey:

    // somewhere in your app
    const { mutate } = useMutation(() => {
      mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
      onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
      mutationKey: ['addTodo'],
    })
    
    // access variables somewhere else
    const variables = useMutationState<string>({
      filters: { mutationKey: ['addTodo'], status: 'pending' },
      select: (mutation) => mutation.state.variables,
    })
    

    // somewhere in your app
    const { mutate } = useMutation(() => {
      mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
      onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
      mutationKey: ['addTodo'],
    })
    
    // access variables somewhere else
    const variables = useMutationState<string>({
      filters: { mutationKey: ['addTodo'], status: 'pending' },
      select: (mutation) => mutation.state.variables,
    })
    

variables will be an Array, because there might be multiple mutations running at the same time. If we need a unique key for the items, we can also select mutation.state.submittedAt. This will even make displaying concurrent optimistic updates a breeze.

[](#via-the-cache)[Via the cache](#via-the-cache)
-------------------------------------------------

When you optimistically update your state before performing a mutation, there is a chance that the mutation will fail. In most of these failure cases, you can just trigger a refetch for your optimistic queries to revert them to their true server state. In some circumstances though, refetching may not work correctly and the mutation error could represent some type of server issue that won't make it possible to refetch. In this event, you can instead choose to roll back your update.

To do this, useMutation's onMutate handler option allows you to return a value that will later be passed to both onError and onSettled handlers as the last argument. In most cases, it is most useful to pass a rollback function.

### [](#updating-a-list-of-todos-when-adding-a-new-todo)[Updating a list of todos when adding a new todo](#updating-a-list-of-todos-when-adding-a-new-todo)

    const queryClient = useQueryClient()
    
    useMutation(() => {
      mutationFn: updateTodo,
      // When mutate is called:
      onMutate: async (newTodo, context) => {
        // Cancel any outgoing refetches
        // (so they don't overwrite our optimistic update)
        await context.client.cancelQueries({ queryKey: ['todos'] })
    
        // Snapshot the previous value
        const previousTodos = context.client.getQueryData(['todos'])
    
        // Optimistically update to the new value
        context.client.setQueryData(['todos'], (old) => [...old, newTodo])
    
        // Return a result with the snapshotted value
        return { previousTodos }
      },
      // If the mutation fails,
      // use the result returned from onMutate to roll back
      onError: (err, newTodo, onMutateResult, context) => {
        context.client.setQueryData(['todos'], onMutateResult.previousTodos)
      },
      // Always refetch after error or success:
      onSettled: (data, error, variables, onMutateResult, context) =>
        context.client.invalidateQueries({ queryKey: ['todos'] }),
    })
    

    const queryClient = useQueryClient()
    
    useMutation(() => {
      mutationFn: updateTodo,
      // When mutate is called:
      onMutate: async (newTodo, context) => {
        // Cancel any outgoing refetches
        // (so they don't overwrite our optimistic update)
        await context.client.cancelQueries({ queryKey: ['todos'] })
    
        // Snapshot the previous value
        const previousTodos = context.client.getQueryData(['todos'])
    
        // Optimistically update to the new value
        context.client.setQueryData(['todos'], (old) => [...old, newTodo])
    
        // Return a result with the snapshotted value
        return { previousTodos }
      },
      // If the mutation fails,
      // use the result returned from onMutate to roll back
      onError: (err, newTodo, onMutateResult, context) => {
        context.client.setQueryData(['todos'], onMutateResult.previousTodos)
      },
      // Always refetch after error or success:
      onSettled: (data, error, variables, onMutateResult, context) =>
        context.client.invalidateQueries({ queryKey: ['todos'] }),
    })
    

### [](#updating-a-single-todo)[Updating a single todo](#updating-a-single-todo)

    useMutation(() => {
      mutationFn: updateTodo,
      // When mutate is called:
      onMutate: async (newTodo, context) => {
        // Cancel any outgoing refetches
        // (so they don't overwrite our optimistic update)
        await context.client.cancelQueries({ queryKey: ['todos', newTodo.id] })
    
        // Snapshot the previous value
        const previousTodo = context.client.getQueryData(['todos', newTodo.id])
    
        // Optimistically update to the new value
        context.client.setQueryData(['todos', newTodo.id], newTodo)
    
        // Return a result with the previous and new todo
        return { previousTodo, newTodo }
      },
      // If the mutation fails, use the result we returned above
      onError: (err, newTodo, onMutateResult, context) => {
        context.client.setQueryData(
          ['todos', onMutateResult.newTodo.id],
          onMutateResult.previousTodo,
        )
      },
      // Always refetch after error or success:
      onSettled: (newTodo, error, variables, onMutateResult, context) =>
        context.client.invalidateQueries({ queryKey: ['todos', newTodo.id] }),
    })
    

    useMutation(() => {
      mutationFn: updateTodo,
      // When mutate is called:
      onMutate: async (newTodo, context) => {
        // Cancel any outgoing refetches
        // (so they don't overwrite our optimistic update)
        await context.client.cancelQueries({ queryKey: ['todos', newTodo.id] })
    
        // Snapshot the previous value
        const previousTodo = context.client.getQueryData(['todos', newTodo.id])
    
        // Optimistically update to the new value
        context.client.setQueryData(['todos', newTodo.id], newTodo)
    
        // Return a result with the previous and new todo
        return { previousTodo, newTodo }
      },
      // If the mutation fails, use the result we returned above
      onError: (err, newTodo, onMutateResult, context) => {
        context.client.setQueryData(
          ['todos', onMutateResult.newTodo.id],
          onMutateResult.previousTodo,
        )
      },
      // Always refetch after error or success:
      onSettled: (newTodo, error, variables, onMutateResult, context) =>
        context.client.invalidateQueries({ queryKey: ['todos', newTodo.id] }),
    })
    

You can also use the onSettled function in place of the separate onError and onSuccess handlers if you wish:

    useMutation(() => {
      mutationFn: updateTodo,
      // ...
      onSettled: async (newTodo, error, variables, onMutateResult, context) => {
        if (error) {
          // do something
        }
      },
    })
    

    useMutation(() => {
      mutationFn: updateTodo,
      // ...
      onSettled: async (newTodo, error, variables, onMutateResult, context) => {
        if (error) {
          // do something
        }
      },
    })
    

[](#when-to-use-what)[When to use what](#when-to-use-what)
----------------------------------------------------------

If you only have one place where the optimistic result should be shown, using variables and updating the UI directly is the approach that requires less code and is generally easier to reason about. For example, you don't need to handle rollbacks at all.

However, if you have multiple places on the screen that would require to know about the update, manipulating the cache directly will take care of this for you automatically.

[](#further-reading)[Further reading](#further-reading)
-------------------------------------------------------

Have a look at the guide by TkDodo on [Concurrent Optimistic Updates](https://tkdodo.eu/blog/concurrent-optimistic-updates-in-react-query).</content>
</page>

<page>
  <title>Scroll Restoration | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/guides/scroll-restoration</url>
  <content>Traditionally, when you navigate to a previously visited page on a web browser, you would find that the page would be scrolled to the exact position where you were before you navigated away from that page. This is called **scroll restoration** and has been in a bit of a regression since web applications have started moving towards client side data fetching. With TanStack Query however, that's no longer the case.

Out of the box, "scroll restoration" for all queries (including paginated and infinite queries) Just Works‚Ñ¢Ô∏è in TanStack Query. The reason for this is that query results are cached and able to be retrieved synchronously when a query is rendered. As long as your queries are being cached long enough (the default time is 5 minutes) and have not been garbage collected, scroll restoration will work out of the box all the time.</content>
</page>

<page>
  <title>Query Cancellation | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/guides/query-cancellation</url>
  <content>TanStack Query provides each query function with an [AbortSignal instance](https://developer.mozilla.org/docs/Web/API/AbortSignal). When a query becomes out-of-date or inactive, this signal will become aborted. This means that all queries are cancellable, and you can respond to the cancellation inside your query function if desired. The best part about this is that it allows you to continue to use normal async/await syntax while getting all the benefits of automatic cancellation.

The AbortController API is available in [most runtime environments](https://developer.mozilla.org/docs/Web/API/AbortController#browser_compatibility), but if your runtime environment does not support it, you will need to provide a polyfill. There are [several available](https://www.npmjs.com/search?q=abortcontroller%20polyfill).

[](#default-behavior)[Default behavior](#default-behavior)
----------------------------------------------------------

By default, queries that unmount or become unused before their promises are resolved are _not_ cancelled. This means that after the promise has resolved, the resulting data will be available in the cache. This is helpful if you've started receiving a query, but then unmount the component before it finishes. If you mount the component again and the query has not been garbage collected yet, data will be available.

However, if you consume the AbortSignal, the Promise will be cancelled (e.g. aborting the fetch) and therefore, also the Query must be cancelled. Cancelling the query will result in its state being _reverted_ to its previous state.

[](#using-fetch)[Using fetch](#using-fetch)
-------------------------------------------

    const query = useQuery(() => {
      queryKey: ['todos'],
      queryFn: async ({ signal }) => {
        const todosResponse = await fetch('/todos', {
          // Pass the signal to one fetch
          signal,
        })
        const todos = await todosResponse.json()
    
        const todoDetails = todos.map(async ({ details }) => {
          const response = await fetch(details, {
            // Or pass it to several
            signal,
          })
          return response.json()
        })
    
        return Promise.all(todoDetails)
      },
    })
    

    const query = useQuery(() => {
      queryKey: ['todos'],
      queryFn: async ({ signal }) => {
        const todosResponse = await fetch('/todos', {
          // Pass the signal to one fetch
          signal,
        })
        const todos = await todosResponse.json()
    
        const todoDetails = todos.map(async ({ details }) => {
          const response = await fetch(details, {
            // Or pass it to several
            signal,
          })
          return response.json()
        })
    
        return Promise.all(todoDetails)
      },
    })
    

[](#using-axios-v0220)[Using axios](#using-axios-v0220) [v0.22.0+](https://github.com/axios/axios/releases/tag/v0.22.0)
-----------------------------------------------------------------------------------------------------------------------

    import axios from 'axios'
    
    const query = useQuery(() => {
      queryKey: ['todos'],
      queryFn: ({ signal }) =>
        axios.get('/todos', {
          // Pass the signal to `axios`
          signal,
        }),
    })
    

    import axios from 'axios'
    
    const query = useQuery(() => {
      queryKey: ['todos'],
      queryFn: ({ signal }) =>
        axios.get('/todos', {
          // Pass the signal to `axios`
          signal,
        }),
    })
    

### [](#using-axios-with-version-lower-than-v0220)[Using axios with version lower than v0.22.0](#using-axios-with-version-lower-than-v0220)

    import axios from 'axios'
    
    const query = useQuery(() => {
      queryKey: ['todos'],
      queryFn: ({ signal }) => {
        // Create a new CancelToken source for this request
        const CancelToken = axios.CancelToken
        const source = CancelToken.source()
    
        const promise = axios.get('/todos', {
          // Pass the source token to your request
          cancelToken: source.token,
        })
    
        // Cancel the request if TanStack Query signals to abort
        signal?.addEventListener('abort', () => {
          source.cancel('Query was cancelled by TanStack Query')
        })
    
        return promise
      },
    })
    

    import axios from 'axios'
    
    const query = useQuery(() => {
      queryKey: ['todos'],
      queryFn: ({ signal }) => {
        // Create a new CancelToken source for this request
        const CancelToken = axios.CancelToken
        const source = CancelToken.source()
    
        const promise = axios.get('/todos', {
          // Pass the source token to your request
          cancelToken: source.token,
        })
    
        // Cancel the request if TanStack Query signals to abort
        signal?.addEventListener('abort', () => {
          source.cancel('Query was cancelled by TanStack Query')
        })
    
        return promise
      },
    })
    

[](#using-xmlhttprequest)[Using XMLHttpRequest](#using-xmlhttprequest)
----------------------------------------------------------------------

    const query = useQuery(() => {
      queryKey: ['todos'],
      queryFn: ({ signal }) => {
        return new Promise((resolve, reject) => {
          var oReq = new XMLHttpRequest()
          oReq.addEventListener('load', () => {
            resolve(JSON.parse(oReq.responseText))
          })
          signal?.addEventListener('abort', () => {
            oReq.abort()
            reject()
          })
          oReq.open('GET', '/todos')
          oReq.send()
        })
      },
    })
    

    const query = useQuery(() => {
      queryKey: ['todos'],
      queryFn: ({ signal }) => {
        return new Promise((resolve, reject) => {
          var oReq = new XMLHttpRequest()
          oReq.addEventListener('load', () => {
            resolve(JSON.parse(oReq.responseText))
          })
          signal?.addEventListener('abort', () => {
            oReq.abort()
            reject()
          })
          oReq.open('GET', '/todos')
          oReq.send()
        })
      },
    })
    

[](#using-graphql-request)[Using graphql-request](#using-graphql-request)
-------------------------------------------------------------------------

An AbortSignal can be set in the client request method.

    const client = new GraphQLClient(endpoint)
    
    const query = useQuery(() => {
      queryKey: ['todos'],
      queryFn: ({ signal }) => {
        client.request({ document: query, signal })
      },
    })
    

    const client = new GraphQLClient(endpoint)
    
    const query = useQuery(() => {
      queryKey: ['todos'],
      queryFn: ({ signal }) => {
        client.request({ document: query, signal })
      },
    })
    

[](#using-graphql-request-with-version-lower-than-v400)[Using graphql-request with version lower than v4.0.0](#using-graphql-request-with-version-lower-than-v400)
------------------------------------------------------------------------------------------------------------------------------------------------------------------

An AbortSignal can be set in the GraphQLClient constructor.

    const query = useQuery(() => {
      queryKey: ['todos'],
      queryFn: ({ signal }) => {
        const client = new GraphQLClient(endpoint, {
          signal,
        })
        return client.request(query, variables)
      },
    })
    

    const query = useQuery(() => {
      queryKey: ['todos'],
      queryFn: ({ signal }) => {
        const client = new GraphQLClient(endpoint, {
          signal,
        })
        return client.request(query, variables)
      },
    })
    

[](#manual-cancellation)[Manual Cancellation](#manual-cancellation)
-------------------------------------------------------------------

You might want to cancel a query manually. For example, if the request takes a long time to finish, you can allow the user to click a cancel button to stop the request. To do this, you just need to call queryClient.cancelQueries({ queryKey }), which will cancel the query and revert it back to its previous state. If you have consumed the signal passed to the query function, TanStack Query will additionally also cancel the Promise.

    const query = useQuery({
      queryKey: ['todos'],
      queryFn: async ({ signal }) => {
        const resp = await fetch('/todos', { signal })
        return resp.json()
      },
    })
    
    const queryClient = useQueryClient()
    
    function onButtonClick() {
      queryClient.cancelQueries({ queryKey: ['todos'] })
    }
    

    const query = useQuery({
      queryKey: ['todos'],
      queryFn: async ({ signal }) => {
        const resp = await fetch('/todos', { signal })
        return resp.json()
      },
    })
    
    const queryClient = useQueryClient()
    
    function onButtonClick() {
      queryClient.cancelQueries({ queryKey: ['todos'] })
    }
    

[](#cancel-options)[Cancel Options](#cancel-options)
----------------------------------------------------

Cancel options are used to control the behavior of query cancellation operations.

    // Cancel specific queries silently
    await queryClient.cancelQueries({ queryKey: ['posts'] }, { silent: true })
    

    // Cancel specific queries silently
    await queryClient.cancelQueries({ queryKey: ['posts'] }, { silent: true })
    

A cancel options object supports the following properties:

*   silent?: boolean
    *   When set to true, suppresses propagation of CancelledError to observers (e.g., onError callbacks) and related notifications, and returns the retry promise instead of rejecting.
    *   Defaults to false
*   revert?: boolean
    *   When set to true, restores the query‚Äôs state (data and status) from immediately before the in-flight fetch, sets fetchStatus back to idle, and only throws if there was no prior data.
    *   Defaults to true

[](#limitations)[Limitations](#limitations)
-------------------------------------------

Cancellation does not work when working with Suspense hooks: useSuspenseQuery, useSuspenseQueries and useSuspenseInfiniteQuery.</content>
</page>

<page>
  <title>Filters | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/guides/filters</url>
  <content>Some methods within TanStack Query accept a QueryFilters or MutationFilters object.

[](#query-filters)[Query Filters](#query-filters)
-------------------------------------------------

A query filter is an object with certain conditions to match a query with:

    // Cancel all queries
    await queryClient.cancelQueries()
    
    // Remove all inactive queries that begin with `posts` in the key
    queryClient.removeQueries({ queryKey: ['posts'], type: 'inactive' })
    
    // Refetch all active queries
    await queryClient.refetchQueries({ type: 'active' })
    
    // Refetch all active queries that begin with `posts` in the key
    await queryClient.refetchQueries({ queryKey: ['posts'], type: 'active' })
    

    // Cancel all queries
    await queryClient.cancelQueries()
    
    // Remove all inactive queries that begin with `posts` in the key
    queryClient.removeQueries({ queryKey: ['posts'], type: 'inactive' })
    
    // Refetch all active queries
    await queryClient.refetchQueries({ type: 'active' })
    
    // Refetch all active queries that begin with `posts` in the key
    await queryClient.refetchQueries({ queryKey: ['posts'], type: 'active' })
    

A query filter object supports the following properties:

*   queryKey?: QueryKey
    *   Set this property to define a query key to match on.
*   exact?: boolean
    *   If you don't want to search queries inclusively by query key, you can pass the exact: true option to return only the query with the exact query key you have passed.
*   type?: 'active' | 'inactive' | 'all'
    *   Defaults to all
    *   When set to active it will match active queries.
    *   When set to inactive it will match inactive queries.
*   stale?: boolean
    *   When set to true it will match stale queries.
    *   When set to false it will match fresh queries.
*   fetchStatus?: FetchStatus
    *   When set to fetching it will match queries that are currently fetching.
    *   When set to paused it will match queries that wanted to fetch, but have been paused.
    *   When set to idle it will match queries that are not fetching.
*   predicate?: (query: Query) => boolean
    *   This predicate function will be used as a final filter on all matching queries. If no other filters are specified, this function will be evaluated against every query in the cache.

[](#mutation-filters)[Mutation Filters](#mutation-filters)
----------------------------------------------------------

A mutation filter is an object with certain conditions to match a mutation with:

    // Get the number of all fetching mutations
    await queryClient.isMutating()
    
    // Filter mutations by mutationKey
    await queryClient.isMutating({ mutationKey: ['post'] })
    
    // Filter mutations using a predicate function
    await queryClient.isMutating({
      predicate: (mutation) => mutation.state.variables?.id === 1,
    })
    

    // Get the number of all fetching mutations
    await queryClient.isMutating()
    
    // Filter mutations by mutationKey
    await queryClient.isMutating({ mutationKey: ['post'] })
    
    // Filter mutations using a predicate function
    await queryClient.isMutating({
      predicate: (mutation) => mutation.state.variables?.id === 1,
    })
    

A mutation filter object supports the following properties:

*   mutationKey?: MutationKey
    *   Set this property to define a mutation key to match on.
*   exact?: boolean
    *   If you don't want to search mutations inclusively by mutation key, you can pass the exact: true option to return only the mutation with the exact mutation key you have passed.
*   status?: MutationStatus
    *   Allows for filtering mutations according to their status.
*   predicate?: (mutation: Mutation) => boolean
    *   This predicate function will be used as a final filter on all matching mutations. If no other filters are specified, this function will be evaluated against every mutation in the cache.

[](#utils)[Utils](#utils)
-------------------------

### [](#matchquery)[matchQuery](#matchquery)

    const isMatching = matchQuery(filters, query)
    

    const isMatching = matchQuery(filters, query)
    

Returns a boolean that indicates whether a query matches the provided set of query filters.

### [](#matchmutation)[matchMutation](#matchmutation)

    const isMatching = matchMutation(filters, mutation)
    

    const isMatching = matchMutation(filters, mutation)
    

Returns a boolean that indicates whether a mutation matches the provided set of mutation filters.</content>
</page>

<page>
  <title>Performance & Request Waterfalls | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/guides/request-waterfalls</url>
  <content>Application performance is a broad and complex area and while Solid Query can't make your APIs faster, there are still things to be mindful about in how you use Solid Query to ensure the best performance.

The biggest performance footgun when using Solid Query, or indeed any data fetching library that lets you fetch data inside of components, is request waterfalls. The rest of this page will explain what they are, how you can spot them and how you can restructure your application or APIs to avoid them.

The [Prefetching & Router Integration guide](https://tanstack.com/query/latest/docs/framework/solid/guides/prefetching) builds on this and teaches you how to prefetch data ahead of time when it's not possible or feasible to restructure your application or APIs.

The [Server Rendering & Hydration guide](https://tanstack.com/query/latest/docs/framework/solid/guides/ssr) teaches you how to prefetch data on the server and pass that data down to the client so you don't have to fetch it again.

The [Advanced Server Rendering guide](https://tanstack.com/query/latest/docs/framework/solid/guides/advanced-ssr) further teaches you how to apply these patterns to Server Components and Streaming Server Rendering.

[](#what-is-a-request-waterfall)[What is a Request Waterfall?](#what-is-a-request-waterfall)
--------------------------------------------------------------------------------------------

A request waterfall is what happens when a request for a resource (code, css, images, data) does not start until _after_ another request for a resource has finished.

Consider a web page. Before you can load things like the CSS, JS etc, the browser first needs to load the markup. This is a request waterfall.

    1. |-> Markup
    2.   |-> CSS
    2.   |-> JS
    2.   |-> Image
    

    1. |-> Markup
    2.   |-> CSS
    2.   |-> JS
    2.   |-> Image
    

If you fetch your CSS inside a JS file, you now have a double waterfall:

    1. |-> Markup
    2.   |-> JS
    3.     |-> CSS
    

    1. |-> Markup
    2.   |-> JS
    3.     |-> CSS
    

If that CSS uses a background image, it's a triple waterfall:

    1. |-> Markup
    2.   |-> JS
    3.     |-> CSS
    4.       |-> Image
    

    1. |-> Markup
    2.   |-> JS
    3.     |-> CSS
    4.       |-> Image
    

The best way to spot and analyze your request waterfalls is usually by opening your browsers devtools "Network" tab.

Each waterfall represents at least one roundtrip to the server, unless the resource is locally cached (in practice, some of these waterfalls might represent more than one roundtrip because the browser needs to establish a connection which requires some back and forth, but let's ignore that here). Because of this, the negative effects of request waterfalls are highly dependent on the users latency. Consider the example of the triple waterfall, which actually represents 4 server roundtrips. With 250ms latency, which is not uncommon on 3g networks or in bad network conditions, we end up with a total time of 4\*250=1000ms **only counting latency**. If we were able to flatten that to the first example with only 2 roundtrips, we get 500ms instead, possibly loading that background image in half the time!

[](#request-waterfalls--solid-query)[Request Waterfalls & Solid Query](#request-waterfalls--solid-query)
--------------------------------------------------------------------------------------------------------

Now let's consider Solid Query. We'll focus on the case without Server Rendering first. Before we can even start making a query, we need to load the JS, so before we can show that data on the screen, we have a double waterfall:

    1. |-> Markup
    2.   |-> JS
    3.     |-> Query
    

    1. |-> Markup
    2.   |-> JS
    3.     |-> Query
    

With this as a basis, let's look at a few different patterns that can lead to Request Waterfalls in Solid Query, and how to avoid them.

*   Single Component Waterfalls / Serial Queries
*   Nested Component Waterfalls
*   Code Splitting

### [](#single-component-waterfalls--serial-queries)[Single Component Waterfalls / Serial Queries](#single-component-waterfalls--serial-queries)

When a single component first fetches one query, and then another, that's a request waterfall. This can happen when the second query is a [Dependent Query](https://tanstack.com/query/latest/docs/framework/solid/guides/dependent-queries), that is, it depends on data from the first query when fetching:

    // Get the user
    const { data: user } = useQuery(() => {
      queryKey: ['user', email],
      queryFn: getUserByEmail,
    })
    
    const userId = user?.id
    
    // Then get the user's projects
    const {
      status,
      fetchStatus,
      data: projects,
    } = useQuery(() => {
      queryKey: ['projects', userId],
      queryFn: getProjectsByUser,
      // The query will not execute until the userId exists
      enabled: !!userId,
    })
    

    // Get the user
    const { data: user } = useQuery(() => {
      queryKey: ['user', email],
      queryFn: getUserByEmail,
    })
    
    const userId = user?.id
    
    // Then get the user's projects
    const {
      status,
      fetchStatus,
      data: projects,
    } = useQuery(() => {
      queryKey: ['projects', userId],
      queryFn: getProjectsByUser,
      // The query will not execute until the userId exists
      enabled: !!userId,
    })
    

While not always feasible, for optimal performance it's better to restructure your API so you can fetch both of these in a single query. In the example above, instead of first fetching getUserByEmail to be able to getProjectsByUser, introducing a new getProjectsByUserEmail query would flatten the waterfall.

> Another way to mitigate dependent queries without restructuring your API is to move the waterfall to the server where latency is lower. This is the idea behind Server Components which are covered in the [Advanced Server Rendering guide](https://tanstack.com/query/latest/docs/framework/solid/guides/advanced-ssr).

Another example of serial queries is when you use Solid Query with Suspense:

    function App () {
      // The following queries will execute in serial, causing separate roundtrips to the server:
      const usersQuery = useQuery({ queryKey: ['users'], queryFn: fetchUsers })
      const teamsQuery = useQuery({ queryKey: ['teams'], queryFn: fetchTeams })
      const projectsQuery = useQuery({ queryKey: ['projects'], queryFn: fetchProjects })
    
      // Note that since the queries above suspend rendering, no data
      // gets rendered until all of the queries finished
      ...
    }
    

    function App () {
      // The following queries will execute in serial, causing separate roundtrips to the server:
      const usersQuery = useQuery({ queryKey: ['users'], queryFn: fetchUsers })
      const teamsQuery = useQuery({ queryKey: ['teams'], queryFn: fetchTeams })
      const projectsQuery = useQuery({ queryKey: ['projects'], queryFn: fetchProjects })
    
      // Note that since the queries above suspend rendering, no data
      // gets rendered until all of the queries finished
      ...
    }
    

Note that with regular useQuery these would happen in parallel.

Luckily, this is easy to fix, by always using the hook useQueries when you have multiple suspenseful queries in a component.

    const [usersQuery, teamsQuery, projectsQuery] = useQueries({
      queries: [
        { queryKey: ['users'], queryFn: fetchUsers },
        { queryKey: ['teams'], queryFn: fetchTeams },
        { queryKey: ['projects'], queryFn: fetchProjects },
      ],
    })
    

    const [usersQuery, teamsQuery, projectsQuery] = useQueries({
      queries: [
        { queryKey: ['users'], queryFn: fetchUsers },
        { queryKey: ['teams'], queryFn: fetchTeams },
        { queryKey: ['projects'], queryFn: fetchProjects },
      ],
    })
    

### [](#nested-component-waterfalls)[Nested Component Waterfalls](#nested-component-waterfalls)

Nested Component Waterfalls is when both a parent and a child component contains queries, and the parent does not render the child until its query is done. This can happen both with useQuery and useQuery.

If the child renders conditionally based on the data in the parent, or if the child relies on some part of the result being passed down as a prop from the parent to make its query, we have a _dependent_ nested component waterfall.

Let's first look at an example where the child is **not** dependent on the parent.

    function Article({ id }) {
      const { data: articleData, isPending } = useQuery(() => {
        queryKey: ['article', id],
        queryFn: getArticleById,
      })
    
      if (isPending) {
        return 'Loading article...'
      }
    
      return (
        <>
          <ArticleHeader articleData={articleData} />
          <ArticleBody articleData={articleData} />
          <Comments id={id} />
        </>
      )
    
    }
    
    function Comments({ id }) {
      const { data, isPending } = useQuery(() => {
        queryKey: ['article-comments', id],
        queryFn: getArticleCommentsById,
      })
    
      ...
    }
    

    function Article({ id }) {
      const { data: articleData, isPending } = useQuery(() => {
        queryKey: ['article', id],
        queryFn: getArticleById,
      })
    
      if (isPending) {
        return 'Loading article...'
      }
    
      return (
        <>
          <ArticleHeader articleData={articleData} />
          <ArticleBody articleData={articleData} />
          <Comments id={id} />
        </>
      )
    
    }
    
    function Comments({ id }) {
      const { data, isPending } = useQuery(() => {
        queryKey: ['article-comments', id],
        queryFn: getArticleCommentsById,
      })
    
      ...
    }
    

Note that while <Comments> takes a prop id from the parent, that id is already available when the <Article> renders so there is no reason we could not fetch the comments at the same time as the article. In real world applications, the child might be nested far below the parent and these kinds of waterfalls are often trickier to spot and fix, but for our example, one way to flatten the waterfall would be to hoist the comments query to the parent instead:

    function Article({ id }) {
      const { data: articleData, isPending: articlePending } = useQuery(() => {
        queryKey: ['article', id],
        queryFn: getArticleById,
      })
    
      const { data: commentsData, isPending: commentsPending } = useQuery(() => {
        queryKey: ['article-comments', id],
        queryFn: getArticleCommentsById,
      })
    
      if (articlePending) {
        return 'Loading article...'
      }
    
      return (
        <>
          <ArticleHeader articleData={articleData} />
          <ArticleBody articleData={articleData} />
          {commentsPending ? (
            'Loading comments...'
          ) : (
            <Comments commentsData={commentsData} />
          )}
        </>
      )
    }
    

    function Article({ id }) {
      const { data: articleData, isPending: articlePending } = useQuery(() => {
        queryKey: ['article', id],
        queryFn: getArticleById,
      })
    
      const { data: commentsData, isPending: commentsPending } = useQuery(() => {
        queryKey: ['article-comments', id],
        queryFn: getArticleCommentsById,
      })
    
      if (articlePending) {
        return 'Loading article...'
      }
    
      return (
        <>
          <ArticleHeader articleData={articleData} />
          <ArticleBody articleData={articleData} />
          {commentsPending ? (
            'Loading comments...'
          ) : (
            <Comments commentsData={commentsData} />
          )}
        </>
      )
    }
    

The two queries will now fetch in parallel. Note that if you are using suspense, you'd want to combine these two queries into a single useQueries instead.

Another way to flatten this waterfall would be to prefetch the comments in the <Article> component, or prefetch both of these queries at the router level on page load or page navigation, read more about this in the [Prefetching & Router Integration guide](https://tanstack.com/query/latest/docs/framework/solid/guides/prefetching).

Next, let's look at a _Dependent Nested Component Waterfall_.

    function Feed() {
      const { data, isPending } = useQuery(() => {
        queryKey: ['feed'],
        queryFn: getFeed,
      })
    
      if (isPending) {
        return 'Loading feed...'
      }
    
      return (
        <>
          {data.map((feedItem) => {
            if (feedItem.type === 'GRAPH') {
              return <GraphFeedItem key={feedItem.id} feedItem={feedItem} />
            }
    
            return <StandardFeedItem key={feedItem.id} feedItem={feedItem} />
          })}
        </>
      )
    }
    
    function GraphFeedItem({ feedItem }) {
      const { data, isPending } = useQuery(() => {
        queryKey: ['graph', feedItem.id],
        queryFn: getGraphDataById,
      })
    
      ...
    }
    

    function Feed() {
      const { data, isPending } = useQuery(() => {
        queryKey: ['feed'],
        queryFn: getFeed,
      })
    
      if (isPending) {
        return 'Loading feed...'
      }
    
      return (
        <>
          {data.map((feedItem) => {
            if (feedItem.type === 'GRAPH') {
              return <GraphFeedItem key={feedItem.id} feedItem={feedItem} />
            }
    
            return <StandardFeedItem key={feedItem.id} feedItem={feedItem} />
          })}
        </>
      )
    }
    
    function GraphFeedItem({ feedItem }) {
      const { data, isPending } = useQuery(() => {
        queryKey: ['graph', feedItem.id],
        queryFn: getGraphDataById,
      })
    
      ...
    }
    

The second query getGraphDataById is dependent on its parent in two different ways. First of all, it doesn't ever happen unless the feedItem is a graph, and second, it needs an id from the parent.

    1. |> getFeed()
    2.   |> getGraphDataById()
    

    1. |> getFeed()
    2.   |> getGraphDataById()
    

In this example, we can't trivially flatten the waterfall by just hoisting the query to the parent, or even adding prefetching. Just like the dependent query example at the beginning of this guide, one option is to refactor our API to include the graph data in the getFeed query. Another more advanced solution is to leverage Server Components to move the waterfall to the server where latency is lower (read more about this in the [Advanced Server Rendering guide](https://tanstack.com/query/latest/docs/framework/solid/guides/advanced-ssr)) but note that this can be a very big architectural change.

You can have good performance even with a few query waterfalls here and there, just know they are a common performance concern and be mindful about them. An especially insidious version is when Code Splitting is involved, let's take a look at this next.

### [](#code-splitting)[Code Splitting](#code-splitting)

Splitting an applications JS-code into smaller chunks and only loading the necessary parts is usually a critical step in achieving good performance. It does have a downside however, in that it often introduces request waterfalls. When that code split code also has a query inside it, this problem is worsened further.

Consider this a slightly modified version of the Feed example.

    // This lazy loads the GraphFeedItem component, meaning
    // it wont start loading until something renders it
    const GraphFeedItem = Solid.lazy(() => import('./GraphFeedItem'))
    
    function Feed() {
      const { data, isPending } = useQuery(() => {
        queryKey: ['feed'],
        queryFn: getFeed,
      })
    
      if (isPending) {
        return 'Loading feed...'
      }
    
      return (
        <>
          {data.map((feedItem) => {
            if (feedItem.type === 'GRAPH') {
              return <GraphFeedItem key={feedItem.id} feedItem={feedItem} />
            }
    
            return <StandardFeedItem key={feedItem.id} feedItem={feedItem} />
          })}
        </>
      )
    }
    
    // GraphFeedItem.tsx
    function GraphFeedItem({ feedItem }) {
      const { data, isPending } = useQuery(() => {
        queryKey: ['graph', feedItem.id],
        queryFn: getGraphDataById,
      })
    
      ...
    }
    

    // This lazy loads the GraphFeedItem component, meaning
    // it wont start loading until something renders it
    const GraphFeedItem = Solid.lazy(() => import('./GraphFeedItem'))
    
    function Feed() {
      const { data, isPending } = useQuery(() => {
        queryKey: ['feed'],
        queryFn: getFeed,
      })
    
      if (isPending) {
        return 'Loading feed...'
      }
    
      return (
        <>
          {data.map((feedItem) => {
            if (feedItem.type === 'GRAPH') {
              return <GraphFeedItem key={feedItem.id} feedItem={feedItem} />
            }
    
            return <StandardFeedItem key={feedItem.id} feedItem={feedItem} />
          })}
        </>
      )
    }
    
    // GraphFeedItem.tsx
    function GraphFeedItem({ feedItem }) {
      const { data, isPending } = useQuery(() => {
        queryKey: ['graph', feedItem.id],
        queryFn: getGraphDataById,
      })
    
      ...
    }
    

This example has a double waterfall, looking like this:

    1. |> getFeed()
    2.   |> JS for <GraphFeedItem>
    3.     |> getGraphDataById()
    

    1. |> getFeed()
    2.   |> JS for <GraphFeedItem>
    3.     |> getGraphDataById()
    

But that's just looking at the code from the example, if we consider what the first page load of this page looks like, we actually have to complete 5 round trips to the server before we can render the graph!

    1. |> Markup
    2.   |> JS for <Feed>
    3.     |> getFeed()
    4.       |> JS for <GraphFeedItem>
    5.         |> getGraphDataById()
    

    1. |> Markup
    2.   |> JS for <Feed>
    3.     |> getFeed()
    4.       |> JS for <GraphFeedItem>
    5.         |> getGraphDataById()
    

Note that this looks a bit different when server rendering, we will explore that further in the [Server Rendering & Hydration guide](https://tanstack.com/query/latest/docs/framework/solid/guides/ssr). Also note that it's not uncommon for the route that contains <Feed> to also be code split, which could add yet another hop.

In the code split case, it might actually help to hoist the getGraphDataById query to the <Feed> component and make it conditional, or add a conditional prefetch. That query could then be fetched in parallel with the code, turning the example part into this:

    1. |> getFeed()
    2.   |> getGraphDataById()
    2.   |> JS for <GraphFeedItem>
    

    1. |> getFeed()
    2.   |> getGraphDataById()
    2.   |> JS for <GraphFeedItem>
    

This is very much a tradeoff however. You are now including the data fetching code for getGraphDataById in the same bundle as <Feed>, so evaluate what is best for your case. Read more about how to do this in the [Prefetching & Router Integration guide](https://tanstack.com/query/latest/docs/framework/solid/guides/prefetching).

> The tradeoff between:
> 
> *   Include all data fetching code in the main bundle, even if we seldom use it
> *   Put the data fetching code in the code split bundle, but with a request waterfall
> 
> is not great and has been one of the motivations for Server Components. With Server Components, it's possible to avoid both, read more about how this applies to Solid Query in the [Advanced Server Rendering guide](https://tanstack.com/query/latest/docs/framework/solid/guides/advanced-ssr).

[](#summary-and-takeaways)[Summary and takeaways](#summary-and-takeaways)
-------------------------------------------------------------------------

Request Waterfalls are a very common and complex performance concern with many tradeoffs. There are many ways to accidentally introduce them into your application:

*   Adding a query to a child, not realizing a parent already has a query
*   Adding a query to a parent, not realizing a child already has a query
*   Moving a component with descendants that has a query to a new parent with an ancestor that has a query
*   Etc..

Because of this accidental complexity, it pays off to be mindful of waterfalls and regularly examine your application looking for them (a good way is to examine the Network tab every now and then!). You don't necessarily have to flatten them all to have good performance, but keep an eye out for the high impact ones.

In the next guide, we'll look at more ways to flatten waterfalls, by leveraging [Prefetching & Router Integration](https://tanstack.com/query/latest/docs/framework/solid/guides/prefetching).</content>
</page>

<page>
  <title>Prefetching & Router Integration | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/guides/prefetching</url>
  <content>When you know or suspect that a certain piece of data will be needed, you can use prefetching to populate the cache with that data ahead of time, leading to a faster experience.

There are a few different prefetching patterns:

1.  In event handlers
2.  In components
3.  Via router integration
4.  During Server Rendering (another form of router integration)

In this guide, we'll take a look at the first three, while the fourth will be covered in depth in the [Server Rendering & Hydration guide](https://tanstack.com/query/latest/docs/framework/solid/guides/ssr) and the [Advanced Server Rendering guide](https://tanstack.com/query/latest/docs/framework/solid/guides/advanced-ssr).

One specific use of prefetching is to avoid Request Waterfalls, for an in-depth background and explanation of those, see the [Performance & Request Waterfalls guide](https://tanstack.com/query/latest/docs/framework/solid/guides/request-waterfalls).

[](#prefetchquery--prefetchinfinitequery)[prefetchQuery & prefetchInfiniteQuery](#prefetchquery--prefetchinfinitequery)
-----------------------------------------------------------------------------------------------------------------------

Before jumping into the different specific prefetch patterns, let's look at the prefetchQuery and prefetchInfiniteQuery functions. First a few basics:

*   Out of the box, these functions use the default staleTime configured for the queryClient to determine whether existing data in the cache is fresh or needs to be fetched again
*   You can also pass a specific staleTime like this: prefetchQuery({ queryKey: \['todos'\], queryFn: fn, staleTime: 5000 })
    *   This staleTime is only used for the prefetch, you still need to set it for any useQuery call as well
    *   If you want to ignore staleTime and instead always return data if it's available in the cache, you can use the ensureQueryData function.
    *   Tip: If you are prefetching on the server, set a default staleTime higher than 0 for that queryClient to avoid having to pass in a specific staleTime to each prefetch call
*   If no instances of useQuery appear for a prefetched query, it will be deleted and garbage collected after the time specified in gcTime
*   These functions returns Promise<void> and thus never return query data. If that's something you need, use fetchQuery/fetchInfiniteQuery instead.
*   The prefetch functions never throws errors because they usually try to fetch again in a useQuery which is a nice graceful fallback. If you need to catch errors, use fetchQuery/fetchInfiniteQuery instead.

This is how you use prefetchQuery:

    const prefetchTodos = async () => {
      // The results of this query will be cached like a normal query
      await queryClient.prefetchQuery({
        queryKey: ['todos'],
        queryFn: fetchTodos,
      })
    }
    

    const prefetchTodos = async () => {
      // The results of this query will be cached like a normal query
      await queryClient.prefetchQuery({
        queryKey: ['todos'],
        queryFn: fetchTodos,
      })
    }
    

Infinite Queries can be prefetched like regular Queries. Per default, only the first page of the Query will be prefetched and will be stored under the given QueryKey. If you want to prefetch more than one page, you can use the pages option, in which case you also have to provide a getNextPageParam function:

    const prefetchProjects = async () => {
      // The results of this query will be cached like a normal query
      await queryClient.prefetchInfiniteQuery({
        queryKey: ['projects'],
        queryFn: fetchProjects,
        initialPageParam: 0,
        getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
        pages: 3, // prefetch the first 3 pages
      })
    }
    

    const prefetchProjects = async () => {
      // The results of this query will be cached like a normal query
      await queryClient.prefetchInfiniteQuery({
        queryKey: ['projects'],
        queryFn: fetchProjects,
        initialPageParam: 0,
        getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
        pages: 3, // prefetch the first 3 pages
      })
    }
    

Next, let's look at how you can use these and other ways to prefetch in different situations.

[](#prefetch-in-event-handlers)[Prefetch in event handlers](#prefetch-in-event-handlers)
----------------------------------------------------------------------------------------

A straightforward form of prefetching is doing it when the user interacts with something. In this example we'll use queryClient.prefetchQuery to start a prefetch on onMouseEnter or onFocus.

    function ShowDetailsButton() {
      const queryClient = useQueryClient()
    
      const prefetch = () => {
        queryClient.prefetchQuery({
          queryKey: ['details'],
          queryFn: getDetailsData,
          // Prefetch only fires when data is older than the staleTime,
          // so in a case like this you definitely want to set one
          staleTime: 60000,
        })
      }
    
      return (
        <button onMouseEnter={prefetch} onFocus={prefetch} onClick={...}>
          Show Details
        </button>
      )
    }
    

    function ShowDetailsButton() {
      const queryClient = useQueryClient()
    
      const prefetch = () => {
        queryClient.prefetchQuery({
          queryKey: ['details'],
          queryFn: getDetailsData,
          // Prefetch only fires when data is older than the staleTime,
          // so in a case like this you definitely want to set one
          staleTime: 60000,
        })
      }
    
      return (
        <button onMouseEnter={prefetch} onFocus={prefetch} onClick={...}>
          Show Details
        </button>
      )
    }
    

[](#prefetch-in-components)[Prefetch in components](#prefetch-in-components)
----------------------------------------------------------------------------

Prefetching during the component lifecycle is useful when we know some child or descendant will need a particular piece of data, but we can't render that until some other query has finished loading. Let's borrow an example from the Request Waterfall guide to explain:

    function Article({ id }) {
      const { data: articleData, isPending } = useQuery(() => {
        queryKey: ['article', id],
        queryFn: getArticleById,
      })
    
      if (isPending) {
        return 'Loading article...'
      }
    
      return (
        <>
          <ArticleHeader articleData={articleData} />
          <ArticleBody articleData={articleData} />
          <Comments id={id} />
        </>
      )
    }
    
    function Comments({ id }) {
      const { data, isPending } = useQuery(() => {
        queryKey: ['article-comments', id],
        queryFn: getArticleCommentsById,
      })
    
      ...
    }
    

    function Article({ id }) {
      const { data: articleData, isPending } = useQuery(() => {
        queryKey: ['article', id],
        queryFn: getArticleById,
      })
    
      if (isPending) {
        return 'Loading article...'
      }
    
      return (
        <>
          <ArticleHeader articleData={articleData} />
          <ArticleBody articleData={articleData} />
          <Comments id={id} />
        </>
      )
    }
    
    function Comments({ id }) {
      const { data, isPending } = useQuery(() => {
        queryKey: ['article-comments', id],
        queryFn: getArticleCommentsById,
      })
    
      ...
    }
    

This results in a request waterfall looking like this:

    1. |> getArticleById()
    2.   |> getArticleCommentsById()
    

    1. |> getArticleById()
    2.   |> getArticleCommentsById()
    

As mentioned in that guide, one way to flatten this waterfall and improve performance is to hoist the getArticleCommentsById query to the parent and pass down the result as a prop, but what if this is not feasible or desirable, for example when the components are unrelated and have multiple levels between them?

In that case, we can instead prefetch the query in the parent. The simplest way to do this is to use a query but ignore the result:

    function Article({ id }) {
      const { data: articleData, isPending } = useQuery(() => {
        queryKey: ['article', id],
        queryFn: getArticleById,
      })
    
      // Prefetch
      useQuery(() => {
        queryKey: ['article-comments', id],
        queryFn: getArticleCommentsById,
        // Optional optimization to avoid rerenders when this query changes:
        notifyOnChangeProps: [],
      })
    
      if (isPending) {
        return 'Loading article...'
      }
    
      return (
        <>
          <ArticleHeader articleData={articleData} />
          <ArticleBody articleData={articleData} />
          <Comments id={id} />
        </>
      )
    }
    
    function Comments({ id }) {
      const { data, isPending } = useQuery(() => {
        queryKey: ['article-comments', id],
        queryFn: getArticleCommentsById,
      })
    
      ...
    }
    

    function Article({ id }) {
      const { data: articleData, isPending } = useQuery(() => {
        queryKey: ['article', id],
        queryFn: getArticleById,
      })
    
      // Prefetch
      useQuery(() => {
        queryKey: ['article-comments', id],
        queryFn: getArticleCommentsById,
        // Optional optimization to avoid rerenders when this query changes:
        notifyOnChangeProps: [],
      })
    
      if (isPending) {
        return 'Loading article...'
      }
    
      return (
        <>
          <ArticleHeader articleData={articleData} />
          <ArticleBody articleData={articleData} />
          <Comments id={id} />
        </>
      )
    }
    
    function Comments({ id }) {
      const { data, isPending } = useQuery(() => {
        queryKey: ['article-comments', id],
        queryFn: getArticleCommentsById,
      })
    
      ...
    }
    

This starts fetching 'article-comments' immediately and flattens the waterfall:

    1. |> getArticleById()
    1. |> getArticleCommentsById()
    

    1. |> getArticleById()
    1. |> getArticleCommentsById()
    

If you want to prefetch together with Suspense, you will have to do things a bit differently. You can't use useSuspenseQueries to prefetch, since the prefetch would block the component from rendering. You also can not use useQuery for the prefetch, because that wouldn't start the prefetch until after suspenseful query had resolved. For this scenario, you can use the [usePrefetchQuery](https://tanstack.com/query/latest/docs/framework/solid/reference/usePrefetchQuery) or the [usePrefetchInfiniteQuery](https://tanstack.com/query/latest/docs/framework/solid/reference/usePrefetchInfiniteQuery) hooks available in the library.

You can now use useSuspenseQuery in the component that actually needs the data. You _might_ want to wrap this later component in its own <Suspense> boundary so the "secondary" query we are prefetching does not block rendering of the "primary" data.

    function ArticleLayout({ id }) {
      usePrefetchQuery({
        queryKey: ['article-comments', id],
        queryFn: getArticleCommentsById,
      })
    
      return (
        <Suspense fallback="Loading article">
          <Article id={id} />
        </Suspense>
      )
    }
    
    function Article({ id }) {
      const { data: articleData, isPending } = useSuspenseQuery({
        queryKey: ['article', id],
        queryFn: getArticleById,
      })
    
      ...
    }
    

    function ArticleLayout({ id }) {
      usePrefetchQuery({
        queryKey: ['article-comments', id],
        queryFn: getArticleCommentsById,
      })
    
      return (
        <Suspense fallback="Loading article">
          <Article id={id} />
        </Suspense>
      )
    }
    
    function Article({ id }) {
      const { data: articleData, isPending } = useSuspenseQuery({
        queryKey: ['article', id],
        queryFn: getArticleById,
      })
    
      ...
    }
    

Another way is to prefetch inside of the query function. This makes sense if you know that every time an article is fetched it's very likely comments will also be needed. For this, we'll use queryClient.prefetchQuery:

    const queryClient = useQueryClient()
    const { data: articleData, isPending } = useQuery(() => {
      queryKey: ['article', id],
      queryFn: (...args) => {
        queryClient.prefetchQuery({
          queryKey: ['article-comments', id],
          queryFn: getArticleCommentsById,
        })
    
        return getArticleById(...args)
      },
    })
    

    const queryClient = useQueryClient()
    const { data: articleData, isPending } = useQuery(() => {
      queryKey: ['article', id],
      queryFn: (...args) => {
        queryClient.prefetchQuery({
          queryKey: ['article-comments', id],
          queryFn: getArticleCommentsById,
        })
    
        return getArticleById(...args)
      },
    })
    

Prefetching in an effect also works, but note that if you are using useSuspenseQuery in the same component, this effect wont run until _after_ the query finishes which might not be what you want.

    const queryClient = useQueryClient()
    
    useEffect(() => {
      queryClient.prefetchQuery({
        queryKey: ['article-comments', id],
        queryFn: getArticleCommentsById,
      })
    }, [queryClient, id])
    

    const queryClient = useQueryClient()
    
    useEffect(() => {
      queryClient.prefetchQuery({
        queryKey: ['article-comments', id],
        queryFn: getArticleCommentsById,
      })
    }, [queryClient, id])
    

To recap, if you want to prefetch a query during the component lifecycle, there are a few different ways to do it, pick the one that suits your situation best:

*   Prefetch before a suspense boundary using usePrefetchQuery or usePrefetchInfiniteQuery hooks
*   Use useQuery or useSuspenseQueries and ignore the result
*   Prefetch inside the query function
*   Prefetch in an effect

Let's look at a slightly more advanced case next.

### [](#dependent-queries--code-splitting)[Dependent Queries & Code Splitting](#dependent-queries--code-splitting)

Sometimes we want to prefetch conditionally, based on the result of another fetch. Consider this example borrowed from the [Performance & Request Waterfalls guide](https://tanstack.com/query/latest/docs/framework/solid/guides/request-waterfalls):

    // This lazy loads the GraphFeedItem component, meaning
    // it wont start loading until something renders it
    const GraphFeedItem = Solid.lazy(() => import('./GraphFeedItem'))
    
    function Feed() {
      const { data, isPending } = useQuery(() => {
        queryKey: ['feed'],
        queryFn: getFeed,
      })
    
      if (isPending) {
        return 'Loading feed...'
      }
    
      return (
        <>
          {data.map((feedItem) => {
            if (feedItem.type === 'GRAPH') {
              return <GraphFeedItem key={feedItem.id} feedItem={feedItem} />
            }
    
            return <StandardFeedItem key={feedItem.id} feedItem={feedItem} />
          })}
        </>
      )
    }
    
    // GraphFeedItem.tsx
    function GraphFeedItem({ feedItem }) {
      const { data, isPending } = useQuery(() => {
        queryKey: ['graph', feedItem.id],
        queryFn: getGraphDataById,
      })
    
      ...
    }
    

    // This lazy loads the GraphFeedItem component, meaning
    // it wont start loading until something renders it
    const GraphFeedItem = Solid.lazy(() => import('./GraphFeedItem'))
    
    function Feed() {
      const { data, isPending } = useQuery(() => {
        queryKey: ['feed'],
        queryFn: getFeed,
      })
    
      if (isPending) {
        return 'Loading feed...'
      }
    
      return (
        <>
          {data.map((feedItem) => {
            if (feedItem.type === 'GRAPH') {
              return <GraphFeedItem key={feedItem.id} feedItem={feedItem} />
            }
    
            return <StandardFeedItem key={feedItem.id} feedItem={feedItem} />
          })}
        </>
      )
    }
    
    // GraphFeedItem.tsx
    function GraphFeedItem({ feedItem }) {
      const { data, isPending } = useQuery(() => {
        queryKey: ['graph', feedItem.id],
        queryFn: getGraphDataById,
      })
    
      ...
    }
    

As noted over in that guide, this example leads to the following double request waterfall:

    1. |> getFeed()
    2.   |> JS for <GraphFeedItem>
    3.     |> getGraphDataById()
    

    1. |> getFeed()
    2.   |> JS for <GraphFeedItem>
    3.     |> getGraphDataById()
    

If we can not restructure our API so getFeed() also returns the getGraphDataById() data when necessary, there is no way to get rid of the getFeed->getGraphDataById waterfall, but by leveraging conditional prefetching, we can at least load the code and data in parallel. Just like described above, there are multiple ways to do this, but for this example, we'll do it in the query function:

    function Feed() {
      const queryClient = useQueryClient()
      const { data, isPending } = useQuery(() => {
        queryKey: ['feed'],
        queryFn: async (...args) => {
          const feed = await getFeed(...args)
    
          for (const feedItem of feed) {
            if (feedItem.type === 'GRAPH') {
              queryClient.prefetchQuery({
                queryKey: ['graph', feedItem.id],
                queryFn: getGraphDataById,
              })
            }
          }
    
          return feed
        }
      })
    
      ...
    }
    

    function Feed() {
      const queryClient = useQueryClient()
      const { data, isPending } = useQuery(() => {
        queryKey: ['feed'],
        queryFn: async (...args) => {
          const feed = await getFeed(...args)
    
          for (const feedItem of feed) {
            if (feedItem.type === 'GRAPH') {
              queryClient.prefetchQuery({
                queryKey: ['graph', feedItem.id],
                queryFn: getGraphDataById,
              })
            }
          }
    
          return feed
        }
      })
    
      ...
    }
    

This would load the code and data in parallel:

    1. |> getFeed()
    2.   |> JS for <GraphFeedItem>
    2.   |> getGraphDataById()
    

    1. |> getFeed()
    2.   |> JS for <GraphFeedItem>
    2.   |> getGraphDataById()
    

There is a tradeoff however, in that the code for getGraphDataById is now included in the parent bundle instead of in JS for <GraphFeedItem> so you'll need to determine what's the best performance tradeoff on a case by case basis. If GraphFeedItem are likely, it's probably worth to include the code in the parent. If they are exceedingly rare, it's probably not.

[](#router-integration)[Router Integration](#router-integration)
----------------------------------------------------------------

Because data fetching in the component tree itself can easily lead to request waterfalls and the different fixes for that can be cumbersome as they accumulate throughout the application, an attractive way to do prefetching is integrating it at the router level.

In this approach, you explicitly declare for each _route_ what data is going to be needed for that component tree, ahead of time. Because Server Rendering has traditionally needed all data to be loaded before rendering starts, this has been the dominating approach for SSR'd apps for a long time. This is still a common approach and you can read more about it in the [Server Rendering & Hydration guide](https://tanstack.com/query/latest/docs/framework/solid/guides/ssr).

For now, let's focus on the client side case and look at an example of how you can make this work with [Tanstack Router](https://tanstack.com/router). These examples leave out a lot of setup and boilerplate to stay concise, you can check out a [full React Query example](https://tanstack.com/router/.latest/docs/framework/solid/examples/basic-solid-query-file-based) over in the [Tanstack Router docs](https://tanstack.com/router/latest/docs).

When integrating at the router level, you can choose to either _block_ rendering of that route until all data is present, or you can start a prefetch but not await the result. That way, you can start rendering the route as soon as possible. You can also mix these two approaches and await some critical data, but start rendering before all the secondary data has finished loading. In this example, we'll configure an /article route to not render until the article data has finished loading, as well as start prefetching comments as soon as possible, but not block rendering the route if comments haven't finished loading yet.

    const queryClient = new QueryClient()
    const routerContext = new RouterContext()
    const rootRoute = routerContext.createRootRoute({
      component: () => { ... }
    })
    
    const articleRoute = new Route({
      getParentRoute: () => rootRoute,
      path: 'article',
      beforeLoad: () => {
        return {
          articleQueryOptions: { queryKey: ['article'], queryFn: fetchArticle },
          commentsQueryOptions: { queryKey: ['comments'], queryFn: fetchComments },
        }
      },
      loader: async ({
        context: { queryClient },
        routeContext: { articleQueryOptions, commentsQueryOptions },
      }) => {
        // Fetch comments asap, but don't block
        queryClient.prefetchQuery(commentsQueryOptions)
    
        // Don't render the route at all until article has been fetched
        await queryClient.prefetchQuery(articleQueryOptions)
      },
      component: ({ useRouteContext }) => {
        const { articleQueryOptions, commentsQueryOptions } = useRouteContext()
        const articleQuery = useQuery(() => articleQueryOptions)
        const commentsQuery = useQuery(() => commentsQueryOptions)
    
        return (
          ...
        )
      },
      errorComponent: () => 'Oh crap!',
    })
    

    const queryClient = new QueryClient()
    const routerContext = new RouterContext()
    const rootRoute = routerContext.createRootRoute({
      component: () => { ... }
    })
    
    const articleRoute = new Route({
      getParentRoute: () => rootRoute,
      path: 'article',
      beforeLoad: () => {
        return {
          articleQueryOptions: { queryKey: ['article'], queryFn: fetchArticle },
          commentsQueryOptions: { queryKey: ['comments'], queryFn: fetchComments },
        }
      },
      loader: async ({
        context: { queryClient },
        routeContext: { articleQueryOptions, commentsQueryOptions },
      }) => {
        // Fetch comments asap, but don't block
        queryClient.prefetchQuery(commentsQueryOptions)
    
        // Don't render the route at all until article has been fetched
        await queryClient.prefetchQuery(articleQueryOptions)
      },
      component: ({ useRouteContext }) => {
        const { articleQueryOptions, commentsQueryOptions } = useRouteContext()
        const articleQuery = useQuery(() => articleQueryOptions)
        const commentsQuery = useQuery(() => commentsQueryOptions)
    
        return (
          ...
        )
      },
      errorComponent: () => 'Oh crap!',
    })
    

Integration with other routers is also possible, see the [react-router](https://tanstack.com/query/latest/docs/framework/solid/examples/react-router) for another demonstration.

[](#manually-priming-a-query)[Manually Priming a Query](#manually-priming-a-query)
----------------------------------------------------------------------------------

If you already have the data for your query synchronously available, you don't need to prefetch it. You can just use the [Query Client's setQueryData method](https://tanstack.com/query/latest/docs/reference/QueryClient#queryclientsetquerydata) to directly add or update a query's cached result by key.

    queryClient.setQueryData(['todos'], todos)
    

    queryClient.setQueryData(['todos'], todos)
    

[](#further-reading)[Further reading](#further-reading)
-------------------------------------------------------

For a deep-dive on how to get data into your Query Cache before you fetch, see the [article Seeding the Query Cache by TkDodo](https://tkdodo.eu/blog/seeding-the-query-cache).

Integrating with Server Side routers and frameworks is very similar to what we just saw, with the addition that the data has to passed from the server to the client to be hydrated into the cache there. To learn how, continue on to the [Server Rendering & Hydration guide](https://tanstack.com/query/latest/docs/framework/solid/guides/ssr).</content>
</page>

<page>
  <title>SSR | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/guides/ssr</url>
  <content>Guides & Concepts

*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/important-defaults)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/queries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-keys)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-functions)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-options)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/network-mode)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/parallel-queries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/disabling-queries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-retries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/paginated-queries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/infinite-queries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/placeholder-query-data)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/mutations)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/invalidations-from-mutations)
*   [
    
    Updates from Mutation Responses
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/updates-from-mutation-responses)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/optimistic-updates)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-cancellation)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/scroll-restoration)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/filters)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/request-waterfalls)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/prefetching)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/ssr)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/advanced-ssr)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/caching)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/default-query-function)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/suspense)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/testing)
*   [
    
    Does this replace state managers?
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/does-this-replace-client-state)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Plugins

*   [
    
    broadcastQueryClient (Experimental)
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/plugins/broadcastQueryClient)
*   [
    
    createPersister (Experimental)
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/plugins/createPersister)

Guides & Concepts

*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/important-defaults)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/queries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-keys)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-functions)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-options)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/network-mode)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/parallel-queries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/disabling-queries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-retries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/paginated-queries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/infinite-queries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/placeholder-query-data)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/mutations)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/invalidations-from-mutations)
*   [
    
    Updates from Mutation Responses
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/updates-from-mutation-responses)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/optimistic-updates)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-cancellation)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/scroll-restoration)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/filters)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/request-waterfalls)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/prefetching)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/ssr)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/advanced-ssr)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/caching)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/default-query-function)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/suspense)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/testing)
*   [
    
    Does this replace state managers?
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/does-this-replace-client-state)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Plugins

*   [
    
    broadcastQueryClient (Experimental)
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/plugins/broadcastQueryClient)
*   [
    
    createPersister (Experimental)
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/plugins/createPersister)</content>
</page>

<page>
  <title>Advanced Server Rendering | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/guides/advanced-ssr</url>
  <content>Guides & Concepts

*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/important-defaults)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/queries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-keys)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-functions)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-options)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/network-mode)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/parallel-queries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/disabling-queries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-retries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/paginated-queries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/infinite-queries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/placeholder-query-data)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/mutations)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/invalidations-from-mutations)
*   [
    
    Updates from Mutation Responses
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/updates-from-mutation-responses)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/optimistic-updates)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-cancellation)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/scroll-restoration)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/filters)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/request-waterfalls)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/prefetching)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/ssr)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/advanced-ssr)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/caching)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/default-query-function)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/suspense)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/testing)
*   [
    
    Does this replace state managers?
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/does-this-replace-client-state)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Plugins

*   [
    
    broadcastQueryClient (Experimental)
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/plugins/broadcastQueryClient)
*   [
    
    createPersister (Experimental)
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/plugins/createPersister)

Guides & Concepts

*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/important-defaults)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/queries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-keys)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-functions)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-options)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/network-mode)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/parallel-queries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/disabling-queries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-retries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/paginated-queries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/infinite-queries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/placeholder-query-data)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/mutations)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/invalidations-from-mutations)
*   [
    
    Updates from Mutation Responses
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/updates-from-mutation-responses)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/optimistic-updates)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-cancellation)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/scroll-restoration)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/filters)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/request-waterfalls)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/prefetching)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/ssr)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/advanced-ssr)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/caching)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/default-query-function)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/suspense)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/testing)
*   [
    
    Does this replace state managers?
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/does-this-replace-client-state)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Plugins

*   [
    
    broadcastQueryClient (Experimental)
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/plugins/broadcastQueryClient)
*   [
    
    createPersister (Experimental)
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/plugins/createPersister)</content>
</page>

<page>
  <title>Caching Examples | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/guides/caching</url>
  <content>> Please thoroughly read the [Important Defaults](https://tanstack.com/query/latest/docs/framework/solid/guides/important-defaults) before reading this guide

[](#basic-example)[Basic Example](#basic-example)
-------------------------------------------------

This caching example illustrates the story and lifecycle of:

*   Query Instances with and without cache data
*   Background Refetching
*   Inactive Queries
*   Garbage Collection

Let's assume we are using the default gcTime of **5 minutes** and the default staleTime of 0.

*   A new instance of useQuery({ queryKey: \['todos'\], queryFn: fetchTodos }) mounts.
    *   Since no other queries have been made with the \['todos'\] query key, this query will show a hard loading state and make a network request to fetch the data.
    *   When the network request has completed, the returned data will be cached under the \['todos'\] key.
    *   The hook will mark the data as stale after the configured staleTime (defaults to 0, or immediately).
*   A second instance of useQuery({ queryKey: \['todos'\], queryFn: fetchTodos }) mounts elsewhere.
    *   Since the cache already has data for the \['todos'\] key from the first query, that data is immediately returned from the cache.
    *   The new instance triggers a new network request using its query function.
        *   Note that regardless of whether both fetchTodos query functions are identical or not, both queries' [status](https://tanstack.com/query/latest/docs/framework/solid/reference/useQuery) are updated (including isFetching, isPending, and other related values) because they have the same query key.
    *   When the request completes successfully, the cache's data under the \['todos'\] key is updated with the new data, and both instances are updated with the new data.
*   Both instances of the useQuery({ queryKey: \['todos'\], queryFn: fetchTodos }) query are unmounted and no longer in use.
    *   Since there are no more active instances of this query, a garbage collection timeout is set using gcTime to delete and garbage collect the query (defaults to **5 minutes**).
*   Before the cache timeout has completed, another instance of useQuery({ queryKey: \['todos'\], queryFn: fetchTodos }) mounts. The query immediately returns the available cached data while the fetchTodos function is being run in the background. When it completes successfully, it will populate the cache with fresh data.
*   The final instance of useQuery({ queryKey: \['todos'\], queryFn: fetchTodos }) unmounts.
*   No more instances of useQuery({ queryKey: \['todos'\], queryFn: fetchTodos }) appear within **5 minutes**.
    *   The cached data under the \['todos'\] key is deleted and garbage collected.</content>
</page>

<page>
  <title>Default Query Function | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/guides/default-query-function</url>
  <content>If you find yourself wishing for whatever reason that you could just share the same query function for your entire app and just use query keys to identify what it should fetch, you can do that by providing a **default query function** to TanStack Query:

    // Define a default query function that will receive the query key
    const defaultQueryFn = async ({ queryKey }) => {
      const { data } = await axios.get(
        `https://jsonplaceholder.typicode.com${queryKey[0]}`,
      )
      return data
    }
    
    // provide the default query function to your app with defaultOptions
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          queryFn: defaultQueryFn,
        },
      },
    })
    
    function App() {
      return (
        <QueryClientProvider client={queryClient}>
          <YourApp />
        </QueryClientProvider>
      )
    }
    
    // All you have to do now is pass a key!
    function Posts() {
      const { status, data, error, isFetching } = useQuery(() => { queryKey: ['/posts'] })
    
      // ...
    }
    
    // You can even leave out the queryFn and just go straight into options
    function Post({ postId }) {
      const { status, data, error, isFetching } = useQuery(() => {
        queryKey: [`/posts/${postId}`],
        enabled: !!postId,
      })
    
      // ...
    }
    

    // Define a default query function that will receive the query key
    const defaultQueryFn = async ({ queryKey }) => {
      const { data } = await axios.get(
        `https://jsonplaceholder.typicode.com${queryKey[0]}`,
      )
      return data
    }
    
    // provide the default query function to your app with defaultOptions
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          queryFn: defaultQueryFn,
        },
      },
    })
    
    function App() {
      return (
        <QueryClientProvider client={queryClient}>
          <YourApp />
        </QueryClientProvider>
      )
    }
    
    // All you have to do now is pass a key!
    function Posts() {
      const { status, data, error, isFetching } = useQuery(() => { queryKey: ['/posts'] })
    
      // ...
    }
    
    // You can even leave out the queryFn and just go straight into options
    function Post({ postId }) {
      const { status, data, error, isFetching } = useQuery(() => {
        queryKey: [`/posts/${postId}`],
        enabled: !!postId,
      })
    
      // ...
    }
    

If you ever want to override the default queryFn, you can just provide your own like you normally would.</content>
</page>

<page>
  <title>Testing | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/guides/testing</url>
  <content>Guides & Concepts

*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/important-defaults)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/queries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-keys)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-functions)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-options)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/network-mode)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/parallel-queries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/disabling-queries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-retries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/paginated-queries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/infinite-queries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/placeholder-query-data)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/mutations)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/invalidations-from-mutations)
*   [
    
    Updates from Mutation Responses
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/updates-from-mutation-responses)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/optimistic-updates)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-cancellation)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/scroll-restoration)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/filters)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/request-waterfalls)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/prefetching)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/ssr)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/advanced-ssr)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/caching)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/default-query-function)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/suspense)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/testing)
*   [
    
    Does this replace state managers?
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/does-this-replace-client-state)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Plugins

*   [
    
    broadcastQueryClient (Experimental)
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/plugins/broadcastQueryClient)
*   [
    
    createPersister (Experimental)
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/plugins/createPersister)

Guides & Concepts

*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/important-defaults)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/queries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-keys)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-functions)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-options)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/network-mode)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/parallel-queries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/disabling-queries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-retries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/paginated-queries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/infinite-queries)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/placeholder-query-data)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/mutations)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/invalidations-from-mutations)
*   [
    
    Updates from Mutation Responses
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/updates-from-mutation-responses)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/optimistic-updates)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/query-cancellation)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/scroll-restoration)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/filters)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/request-waterfalls)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/prefetching)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/ssr)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/advanced-ssr)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/caching)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/default-query-function)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/suspense)
*   [](https://tanstack.com/query/latest/docs/framework/solid/guides/testing)
*   [
    
    Does this replace state managers?
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/guides/does-this-replace-client-state)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Plugins

*   [
    
    broadcastQueryClient (Experimental)
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/plugins/broadcastQueryClient)
*   [
    
    createPersister (Experimental)
    
    solid
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/solid/plugins/createPersister)</content>
</page>

<page>
  <title>Suspense | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/guides/suspense</url>
  <content>Solid Query can also be used with Solid's [Suspense](https://docs.solidjs.com/reference/components/suspense) API's.

To do that you need to wrap your suspendable component with Suspense component provided by Solid

    import { Suspense } from 'solid-js'
    ;<Suspense fallback={<LoadingSpinner />}>
      <SuspendableComponent />
    </Suspense>
    

    import { Suspense } from 'solid-js'
    ;<Suspense fallback={<LoadingSpinner />}>
      <SuspendableComponent />
    </Suspense>
    

You can use async suspense function that is provided by solid-query.

    import { useQuery } from '@tanstack/solid-query'
    
    const todoFetcher = async () =>
      await fetch('https://jsonplaceholder.cypress.io/todos').then((response) =>
        response.json(),
      )
    
    function SuspendableComponent() {
      const query = useQuery(() => ({
        queryKey: ['todos'],
        queryFn: todoFetcher,
      }))
    
      // Accessing query.data directly inside a <Suspense> boundary
      // automatically triggers suspension until data is ready
      return <div>Data: {JSON.stringify(query.data)}</div>
    }
    

    import { useQuery } from '@tanstack/solid-query'
    
    const todoFetcher = async () =>
      await fetch('https://jsonplaceholder.cypress.io/todos').then((response) =>
        response.json(),
      )
    
    function SuspendableComponent() {
      const query = useQuery(() => ({
        queryKey: ['todos'],
        queryFn: todoFetcher,
      }))
    
      // Accessing query.data directly inside a <Suspense> boundary
      // automatically triggers suspension until data is ready
      return <div>Data: {JSON.stringify(query.data)}</div>
    }
    

[](#fetch-on-render-vs-render-as-you-fetch)[Fetch-on-render vs Render-as-you-fetch](#fetch-on-render-vs-render-as-you-fetch)
----------------------------------------------------------------------------------------------------------------------------

Out of the box, Solid Query in suspense mode works really well as a **Fetch-on-render** solution with no additional configuration. This means that when your components attempt to mount, they will trigger query fetching and suspend, but only once you have imported them and mounted them. If you want to take it to the next level and implement a **Render-as-you-fetch** model, we recommend implementing [Prefetching](https://tanstack.com/query/latest/docs/framework/solid/guides/prefetching) on routing callbacks and/or user interactions events to start loading queries before they are mounted and hopefully even before you start importing or mounting their parent components.</content>
</page>

<page>
  <title>Does TanStack Query replace Redux, MobX or other global state managers? | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/guides/does-this-replace-client-state</url>
  <content>Well, let's start with a few important items:

*   TanStack Query is a **server-state** library, responsible for managing asynchronous operations between your server and client
*   Redux, MobX, Zustand, etc. are **client-state** libraries that _can be used to store asynchronous data, albeit inefficiently when compared to a tool like TanStack Query_

With those points in mind, the short answer is that TanStack Query **replaces the boilerplate code and related wiring used to manage cache data in your client-state and replaces it with just a few lines of code.**

For a vast majority of applications, the truly **globally accessible client state** that is left over after migrating all of your async code to TanStack Query is usually very tiny.

> There are still some circumstances where an application might indeed have a massive amount of synchronous client-only state (like a visual designer or music production application), in which case, you will probably still want a client state manager. In this situation it's important to note that **TanStack Query is not a replacement for local/client state management**. However, you can use TanStack Query alongside most client state managers with zero issues.

[](#a-contrived-example)[A Contrived Example](#a-contrived-example)
-------------------------------------------------------------------

Here we have some "global" state being managed by a global state library:

    const globalState = {
      projects,
      teams,
      tasks,
      users,
      themeMode,
      sidebarStatus,
    }
    

    const globalState = {
      projects,
      teams,
      tasks,
      users,
      themeMode,
      sidebarStatus,
    }
    

Currently, the global state manager is caching 4 types of server-state: projects, teams, tasks, and users. If we were to move these server-state assets to TanStack Query, our remaining global state would look more like this:

    const globalState = {
      themeMode,
      sidebarStatus,
    }
    

    const globalState = {
      themeMode,
      sidebarStatus,
    }
    

This also means that with a few function calls to useQuery and useMutation, we also get to remove any boilerplate code that was used to manage our server state e.g.

*   Connectors
*   Action Creators
*   Middlewares
*   Reducers
*   Loading/Error/Result states
*   Contexts

With all of those things removed, you may ask yourself, **"Is it worth it to keep using our client state manager for this tiny global state?"**

**And that's up to you!**

But TanStack Query's role is clear. It removes asynchronous wiring and boilerplate from your application and replaces it with just a few lines of code.

What are you waiting for, give it a go already!</content>
</page>

<page>
  <title>useQuery | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/reference/useQuery</url>
  <content>    const {
      data,
      dataUpdatedAt,
      error,
      errorUpdatedAt,
      failureCount,
      failureReason,
      fetchStatus,
      isError,
      isFetched,
      isFetchedAfterMount,
      isFetching,
      isInitialLoading,
      isLoading,
      isLoadingError,
      isPaused,
      isPending,
      isPlaceholderData,
      isRefetchError,
      isRefetching,
      isStale,
      isSuccess,
      refetch,
      status,
    } = useQuery(
      () => ({
        queryKey,
        queryFn,
        enabled,
        select,
        placeholderData,
        deferStream,
        reconcile,
        gcTime,
        networkMode,
        initialData,
        initialDataUpdatedAt,
        meta,
        queryKeyHashFn,
        refetchInterval,
        refetchIntervalInBackground,
        refetchOnMount,
        refetchOnReconnect,
        refetchOnWindowFocus,
        retry,
        retryOnMount,
        retryDelay,
        staleTime,
        throwOnError,
      }),
      () => queryClient,
    )
    

    const {
      data,
      dataUpdatedAt,
      error,
      errorUpdatedAt,
      failureCount,
      failureReason,
      fetchStatus,
      isError,
      isFetched,
      isFetchedAfterMount,
      isFetching,
      isInitialLoading,
      isLoading,
      isLoadingError,
      isPaused,
      isPending,
      isPlaceholderData,
      isRefetchError,
      isRefetching,
      isStale,
      isSuccess,
      refetch,
      status,
    } = useQuery(
      () => ({
        queryKey,
        queryFn,
        enabled,
        select,
        placeholderData,
        deferStream,
        reconcile,
        gcTime,
        networkMode,
        initialData,
        initialDataUpdatedAt,
        meta,
        queryKeyHashFn,
        refetchInterval,
        refetchIntervalInBackground,
        refetchOnMount,
        refetchOnReconnect,
        refetchOnWindowFocus,
        retry,
        retryOnMount,
        retryDelay,
        staleTime,
        throwOnError,
      }),
      () => queryClient,
    )
    

[](#usage-example)[Usage example](#usage-example)
-------------------------------------------------

Here are some examples of how to use the useQuery primitive in Solid Query.

### [](#basic)[Basic](#basic)

The most basic usage of useQuery is to create a query that fetches data from an API.

    import { useQuery } from '@tanstack/solid-query'
    
    function App() {
      const todos = useQuery(() => ({
        queryKey: 'todos',
        queryFn: async () => {
          const response = await fetch('/api/todos')
          if (!response.ok) {
            throw new Error('Failed to fetch todos')
          }
          return response.json()
        },
      }))
    
      return (
        <div>
          <Show when={todos.isError}>
            <div>Error: {todos.error.message}</div>
          </Show>
          <Show when={todos.isLoading}>
            <div>Loading...</div>
          </Show>
          <Show when={todos.isSuccess}>
            <div>
              <div>Todos:</div>
              <ul>
                <For each={todos.data}>{(todo) => <li>{todo.title}</li>}</For>
              </ul>
            </div>
          </Show>
        </div>
      )
    }
    

    import { useQuery } from '@tanstack/solid-query'
    
    function App() {
      const todos = useQuery(() => ({
        queryKey: 'todos',
        queryFn: async () => {
          const response = await fetch('/api/todos')
          if (!response.ok) {
            throw new Error('Failed to fetch todos')
          }
          return response.json()
        },
      }))
    
      return (
        <div>
          <Show when={todos.isError}>
            <div>Error: {todos.error.message}</div>
          </Show>
          <Show when={todos.isLoading}>
            <div>Loading...</div>
          </Show>
          <Show when={todos.isSuccess}>
            <div>
              <div>Todos:</div>
              <ul>
                <For each={todos.data}>{(todo) => <li>{todo.title}</li>}</For>
              </ul>
            </div>
          </Show>
        </div>
      )
    }
    

### [](#reactive-options)[Reactive Options](#reactive-options)

The reason why useQuery accepts a function that returns an object is to allow for reactive options. This is useful when query options depend on other values/signals that might change over time. Solid Query can track the passed function in a reactive scope and re-run it whenever the dependencies change.

    import { useQuery } from '@tanstack/solid-query'
    
    function App() {
      const [filter, setFilter] = createSignal('all')
    
      const todos = useQuery(() => ({
        queryKey: ['todos', filter()],
        queryFn: async () => {
          const response = await fetch(`/api/todos?filter=${filter()}`)
          if (!response.ok) {
            throw new Error('Failed to fetch todos')
          }
          return response.json()
        },
      }))
    
      return (
        <div>
          <div>
            <button onClick={() => setFilter('all')}>All</button>
            <button onClick={() => setFilter('active')}>Active</button>
            <button onClick={() => setFilter('completed')}>Completed</button>
          </div>
          <Show when={todos.isError}>
            <div>Error: {todos.error.message}</div>
          </Show>
          <Show when={todos.isLoading}>
            <div>Loading...</div>
          </Show>
          <Show when={todos.isSuccess}>
            <div>
              <div>Todos:</div>
              <ul>
                <For each={todos.data}>{(todo) => <li>{todo.title}</li>}</For>
              </ul>
            </div>
          </Show>
        </div>
      )
    }
    

    import { useQuery } from '@tanstack/solid-query'
    
    function App() {
      const [filter, setFilter] = createSignal('all')
    
      const todos = useQuery(() => ({
        queryKey: ['todos', filter()],
        queryFn: async () => {
          const response = await fetch(`/api/todos?filter=${filter()}`)
          if (!response.ok) {
            throw new Error('Failed to fetch todos')
          }
          return response.json()
        },
      }))
    
      return (
        <div>
          <div>
            <button onClick={() => setFilter('all')}>All</button>
            <button onClick={() => setFilter('active')}>Active</button>
            <button onClick={() => setFilter('completed')}>Completed</button>
          </div>
          <Show when={todos.isError}>
            <div>Error: {todos.error.message}</div>
          </Show>
          <Show when={todos.isLoading}>
            <div>Loading...</div>
          </Show>
          <Show when={todos.isSuccess}>
            <div>
              <div>Todos:</div>
              <ul>
                <For each={todos.data}>{(todo) => <li>{todo.title}</li>}</For>
              </ul>
            </div>
          </Show>
        </div>
      )
    }
    

### [](#usage-with-suspense)[Usage with Suspense](#usage-with-suspense)

useQuery supports triggering SolidJS Suspense and ErrorBoundary components when the query is in a pending or error state. This allows you to easily handle loading and error states in your components.

    import { useQuery } from '@tanstack/solid-query'
    
    function App() {
      const todos = useQuery(() => ({
        queryKey: 'todos',
        queryFn: async () => {
          const response = await fetch('/api/todos')
          if (!response.ok) {
            throw new Error('Failed to fetch todos')
          }
          return response.json()
        },
        throwOnError: true,
      }))
    
      return (
        <ErrorBoundary fallback={<div>Error: {todos.error.message}</div>}>
          <Suspense fallback={<div>Loading...</div>}>
            <div>
              <div>Todos:</div>
              <ul>
                <For each={todos.data}>{(todo) => <li>{todo.title}</li>}</For>
              </ul>
            </div>
          </Suspense>
        </ErrorBoundary>
      )
    }
    

    import { useQuery } from '@tanstack/solid-query'
    
    function App() {
      const todos = useQuery(() => ({
        queryKey: 'todos',
        queryFn: async () => {
          const response = await fetch('/api/todos')
          if (!response.ok) {
            throw new Error('Failed to fetch todos')
          }
          return response.json()
        },
        throwOnError: true,
      }))
    
      return (
        <ErrorBoundary fallback={<div>Error: {todos.error.message}</div>}>
          <Suspense fallback={<div>Loading...</div>}>
            <div>
              <div>Todos:</div>
              <ul>
                <For each={todos.data}>{(todo) => <li>{todo.title}</li>}</For>
              </ul>
            </div>
          </Suspense>
        </ErrorBoundary>
      )
    }
    

[](#usequery-parameters)[useQuery Parameters](#usequery-parameters)
-------------------------------------------------------------------

*   [](#query-options---accessorqueryoptions)
    
    ### [](#query-options---accessorqueryoptions)[Query Options - Accessor<QueryOptions>](#query-options---accessorqueryoptions)
    
    *   [](#querykey-unknown)
        
        ##### [](#querykey-unknown)[queryKey: unknown\[\]](#querykey-unknown)
        
        *   **Required**
        *   The query key to use for this query.
        *   The query key will be hashed into a stable hash. See [Query Keys](https://tanstack.com/query/latest/docs/framework/solid/guides/query-keys) for more information.
        *   The query will automatically update when this key changes (as long as enabled is not set to false).
    *   [](#queryfn-context-queryfunctioncontext--promisetdata)
        
        ##### [](#queryfn-context-queryfunctioncontext--promisetdata)[queryFn: (context: QueryFunctionContext) => Promise<TData>](#queryfn-context-queryfunctioncontext--promisetdata)
        
        *   **Required, but only if no default query function has been defined** See [Default Query Function](https://tanstack.com/query/latest/docs/framework/solid/guides/default-query-function) for more information.
        *   The function that the query will use to request data.
        *   Receives a [QueryFunctionContext](https://tanstack.com/query/latest/docs/framework/solid/guides/query-functions#queryfunctioncontext)
        *   Must return a promise that will either resolve data or throw an error. The data cannot be undefined.
    *   [](#enabled-boolean)
        
        ##### [](#enabled-boolean)[enabled: boolean](#enabled-boolean)
        
        *   Set this to false to disable this query from automatically running.
        *   Can be used for [Dependent Queries](https://tanstack.com/query/latest/docs/framework/solid/guides/dependent-queries) for more information.
    *   [](#select-data-tdata--unknown)
        
        ##### [](#select-data-tdata--unknown)[select: (data: TData) => unknown](#select-data-tdata--unknown)
        
        *   Optional
        *   This option can be used to transform or select a part of the data returned by the query function. It affects the returned data value, but does not affect what gets stored in the query cache.
        *   The select function will only run if data changed, or if the reference to the select function itself changes. To optimize, wrap the function in useCallback.
    *   [](#placeholderdata-tdata--previousvalue-tdata--undefined-previousquery-query--undefined--tdata)
        
        ##### [](#placeholderdata-tdata--previousvalue-tdata--undefined-previousquery-query--undefined--tdata)[placeholderData: TData | (previousValue: TData | undefined; previousQuery: Query | undefined,) => TData](#placeholderdata-tdata--previousvalue-tdata--undefined-previousquery-query--undefined--tdata)
        
        *   Optional
        *   If set, this value will be used as the placeholder data for this particular query observer while the query is still in the pending state.
        *   placeholderData is **not persisted** to the cache
        *   If you provide a function for placeholderData, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.
    *   [](#deferstream-boolean)
        
        ##### [](#deferstream-boolean)[deferStream: boolean](#deferstream-boolean)
        
        *   Optional
        *   Defaults to false
        *   Only applicable while rendering queries on the server with streaming.
        *   Set deferStream to true to wait for the query to resolve on the server before flushing the stream.
        *   This can be useful to avoid sending a loading state to the client before the query has resolved.
    *   [](#reconcile-false--string--olddata-tdata--undefined-newdata-tdata--tdata)
        
        ##### [](#reconcile-false--string--olddata-tdata--undefined-newdata-tdata--tdata)[reconcile: false | string | ((oldData: TData | undefined, newData: TData) => TData)](#reconcile-false--string--olddata-tdata--undefined-newdata-tdata--tdata)
        
        *   Optional
        *   Defaults to false
        *   Set this to a string to enable reconciliation between query results based on the string key.
        *   Set this to a function which accepts the old and new data and returns resolved data of the same type to implement custom reconciliation logic.
    *   [](#gctime-number--infinity)
        
        ##### [](#gctime-number--infinity)[gcTime: number | Infinity](#gctime-number--infinity)
        
        *   Defaults to 5 \* 60 \* 1000 (5 minutes) or Infinity during SSR
        *   The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.
        *   Note: the maximum allowed time is about [24 days](https://developer.mozilla.org/en-US/docs/Web/API/setTimeout#maximum_delay_value), although it is possible to work around this limit using [timeoutManager.setTimeoutProvider](https://tanstack.com/query/latest/docs/reference/timeoutManager#timeoutmanagersettimeoutprovider).
        *   If set to Infinity, will disable garbage collection
    *   [](#networkmode-online--always--offlinefirst)
        
        ##### [](#networkmode-online--always--offlinefirst)[networkMode: 'online' | 'always' | 'offlineFirst'](#networkmode-online--always--offlinefirst)
        
        *   optional
        *   defaults to 'online'
        *   see [Network Mode](https://tanstack.com/query/latest/docs/framework/solid/guides/network-mode) for more information.
    *   [](#initialdata-tdata----tdata)
        
        ##### [](#initialdata-tdata----tdata)[initialData: TData | () => TData](#initialdata-tdata----tdata)
        
        *   Optional
        *   If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)
        *   If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the initialData
        *   Initial data is considered stale by default unless a staleTime has been set.
        *   initialData **is persisted** to the cache
    *   [](#initialdataupdatedat-number----number--undefined)
        
        ##### [](#initialdataupdatedat-number----number--undefined)[initialDataUpdatedAt: number | (() => number | undefined)](#initialdataupdatedat-number----number--undefined)
        
        *   Optional
        *   If set, this value will be used as the time (in milliseconds) of when the initialData itself was last updated.
    *   [](#meta-recordstring-unknown)
        
        ##### [](#meta-recordstring-unknown)[meta: Record<string, unknown>](#meta-recordstring-unknown)
        
        *   Optional
        *   If set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the query is available, and is also part of the QueryFunctionContext provided to the queryFn.
    *   [](#querykeyhashfn-querykey-querykey--string)
        
        ##### [](#querykeyhashfn-querykey-querykey--string)[queryKeyHashFn: (queryKey: QueryKey) => string](#querykeyhashfn-querykey-querykey--string)
        
        *   Optional
        *   If specified, this function is used to hash the queryKey to a string.
    *   [](#refetchinterval-number--false--query-query--number--false--undefined)
        
        ##### [](#refetchinterval-number--false--query-query--number--false--undefined)[refetchInterval: number | false | ((query: Query) => number | false | undefined)](#refetchinterval-number--false--query-query--number--false--undefined)
        
        *   Optional
        *   If set to a number, all queries will continuously refetch at this frequency in milliseconds
        *   If set to a function, the function will be executed with the query to compute a frequency
    *   [](#refetchintervalinbackground-boolean)
        
        ##### [](#refetchintervalinbackground-boolean)[refetchIntervalInBackground: boolean](#refetchintervalinbackground-boolean)
        
        *   Optional
        *   If set to true, queries that are set to continuously refetch with a refetchInterval will continue to refetch while their tab/window is in the background
    *   [](#refetchonmount-boolean--always--query-query--boolean--always)
        
        ##### [](#refetchonmount-boolean--always--query-query--boolean--always)[refetchOnMount: boolean | "always" | ((query: Query) => boolean | "always")](#refetchonmount-boolean--always--query-query--boolean--always)
        
        *   Optional
        *   Defaults to true
        *   If set to true, the query will refetch on mount if the data is stale.
        *   If set to false, the query will not refetch on mount.
        *   If set to "always", the query will always refetch on mount.
        *   If set to a function, the function will be executed with the query to compute the value
    *   [](#refetchonwindowfocus-boolean--always--query-query--boolean--always)
        
        ##### [](#refetchonwindowfocus-boolean--always--query-query--boolean--always)[refetchOnWindowFocus: boolean | "always" | ((query: Query) => boolean | "always")](#refetchonwindowfocus-boolean--always--query-query--boolean--always)
        
        *   Optional
        *   Defaults to true
        *   If set to true, the query will refetch on window focus if the data is stale.
        *   If set to false, the query will not refetch on window focus.
        *   If set to "always", the query will always refetch on window focus.
        *   If set to a function, the function will be executed with the query to compute the value
    *   [](#refetchonreconnect-boolean--always--query-query--boolean--always)
        
        ##### [](#refetchonreconnect-boolean--always--query-query--boolean--always)[refetchOnReconnect: boolean | "always" | ((query: Query) => boolean | "always")](#refetchonreconnect-boolean--always--query-query--boolean--always)
        
        *   Optional
        *   Defaults to true
        *   If set to true, the query will refetch on reconnect if the data is stale.
        *   If set to false, the query will not refetch on reconnect.
        *   If set to "always", the query will always refetch on reconnect.
        *   If set to a function, the function will be executed with the query to compute the value
    *   [](#retry-boolean--number--failurecount-number-error-terror--boolean)
        
        ##### [](#retry-boolean--number--failurecount-number-error-terror--boolean)[retry: boolean | number | (failureCount: number, error: TError) => boolean](#retry-boolean--number--failurecount-number-error-terror--boolean)
        
        *   If false, failed queries will not retry by default.
        *   If true, failed queries will retry infinitely.
        *   If set to a number, e.g. 3, failed queries will retry until the failed query count meets that number.
        *   defaults to 3 on the client and 0 on the server
    *   [](#retryonmount-boolean)
        
        ##### [](#retryonmount-boolean)[retryOnMount: boolean](#retryonmount-boolean)
        
        *   If set to false, the query will not be retried on mount if it contains an error. Defaults to true.
    *   [](#retrydelay-number--retryattempt-number-error-terror--number)
        
        ##### [](#retrydelay-number--retryattempt-number-error-terror--number)[retryDelay: number | (retryAttempt: number, error: TError) => number](#retrydelay-number--retryattempt-number-error-terror--number)
        
        *   This function receives a retryAttempt integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.
        *   A function like attempt => Math.min(attempt > 1 ? 2 \*\* attempt \* 1000 : 1000, 30 \* 1000) applies exponential backoff.
        *   A function like attempt => attempt \* 1000 applies linear backoff.
    *   [](#staletime-number--infinity)
        
        ##### [](#staletime-number--infinity)[staleTime: number | Infinity](#staletime-number--infinity)
        
        *   Optional
        *   Defaults to 0
        *   The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.
        *   If set to Infinity, the data will never be considered stale
    *   [](#throwonerror-undefined--boolean--error-terror-query-query--boolean)
        
        ##### [](#throwonerror-undefined--boolean--error-terror-query-query--boolean)[throwOnError: undefined | boolean | (error: TError, query: Query) => boolean](#throwonerror-undefined--boolean--error-terror-query-query--boolean)
        
        *   Set this to true if you want errors to be thrown in the render phase and propagate to the nearest error boundary
        *   Set this to false to disable suspense's default behavior of throwing errors to the error boundary.
        *   If set to a function, it will be passed the error and the query, and it should return a boolean indicating whether to show the error in an error boundary (true) or return the error as state (false)
*   [](#query-client---accessorqueryclient)
    
    ### [](#query-client---accessorqueryclient)[Query Client - Accessor<QueryClient>](#query-client---accessorqueryclient)
    
    *   Optional
    *   Use this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.

[](#usequery-return-value---storequeryresulttdata-terror)[useQuery Return Value - Store<QueryResult<TData, TError>>](#usequery-return-value---storequeryresulttdata-terror)
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

useQuery returns a SolidJS store with the following properties:

*   [](#status-querystatus)
    
    ##### [](#status-querystatus)[status: QueryStatus](#status-querystatus)
    
    *   Will be:
        *   pending if there's no cached data and no query attempt was finished yet.
        *   error if the query attempt resulted in an error. The corresponding error property has the error received from the attempted fetch
        *   success if the query has received a response with no errors and is ready to display its data. The corresponding data property on the query is the data received from the successful fetch or if the query's enabled property is set to false and has not been fetched yet data is the first initialData supplied to the query on initialization.
*   [](#ispending-boolean)
    
    ##### [](#ispending-boolean)[isPending: boolean](#ispending-boolean)
    
    *   A derived boolean from the status variable above, provided for convenience.
*   [](#issuccess-boolean)
    
    ##### [](#issuccess-boolean)[isSuccess: boolean](#issuccess-boolean)
    
    *   A derived boolean from the status variable above, provided for convenience.
*   [](#iserror-boolean)
    
    ##### [](#iserror-boolean)[isError: boolean](#iserror-boolean)
    
    *   A derived boolean from the status variable above, provided for convenience.
*   [](#isloadingerror-boolean)
    
    ##### [](#isloadingerror-boolean)[isLoadingError: boolean](#isloadingerror-boolean)
    
    *   Will be true if the query failed while fetching for the first time.
*   [](#isrefetcherror-boolean)
    
    ##### [](#isrefetcherror-boolean)[isRefetchError: boolean](#isrefetcherror-boolean)
    
    *   Will be true if the query failed while refetching.
*   [](#data-resourcetdata)
    
    ##### [](#data-resourcetdata)[data: Resource<TData>](#data-resourcetdata)
    
    *   Defaults to undefined.
    *   The last successfully resolved data for the query.
    *   **Important**: The data property is a SolidJS resource. This means that if the data is accessed underneath a <Suspense> component, it will trigger the Suspense boundary if the data is not available yet.
*   [](#dataupdatedat-number)
    
    ##### [](#dataupdatedat-number)[dataUpdatedAt: number](#dataupdatedat-number)
    
    *   The timestamp for when the query most recently returned the status as "success".
*   [](#error-null--terror)
    
    ##### [](#error-null--terror)[error: null | TError](#error-null--terror)
    
    *   Defaults to null
    *   The error object for the query, if an error was thrown.
*   [](#errorupdatedat-number)
    
    ##### [](#errorupdatedat-number)[errorUpdatedAt: number](#errorupdatedat-number)
    
    *   The timestamp for when the query most recently returned the status as "error".
*   [](#isstale-boolean)
    
    ##### [](#isstale-boolean)[isStale: boolean](#isstale-boolean)
    
    *   Will be true if the data in the cache is invalidated or if the data is older than the given staleTime.
*   [](#isplaceholderdata-boolean)
    
    ##### [](#isplaceholderdata-boolean)[isPlaceholderData: boolean](#isplaceholderdata-boolean)
    
    *   Will be true if the data shown is the placeholder data.
*   [](#isfetched-boolean)
    
    ##### [](#isfetched-boolean)[isFetched: boolean](#isfetched-boolean)
    
    *   Will be true if the query has been fetched.
*   [](#isfetchedaftermount-boolean)
    
    ##### [](#isfetchedaftermount-boolean)[isFetchedAfterMount: boolean](#isfetchedaftermount-boolean)
    
    *   Will be true if the query has been fetched after the component mounted.
    *   This property can be used to not show any previously cached data.
*   [](#fetchstatus-fetchstatus)
    
    ##### [](#fetchstatus-fetchstatus)[fetchStatus: FetchStatus](#fetchstatus-fetchstatus)
    
    *   fetching: Is true whenever the queryFn is executing, which includes initial pending as well as background refetches.
    *   paused: The query wanted to fetch, but has been paused.
    *   idle: The query is not fetching.
    *   see [Network Mode](https://tanstack.com/query/latest/docs/framework/solid/guides/network-mode) for more information.
*   [](#isfetching-boolean)
    
    ##### [](#isfetching-boolean)[isFetching: boolean](#isfetching-boolean)
    
    *   A derived boolean from the fetchStatus variable above, provided for convenience.
*   [](#ispaused-boolean)
    
    ##### [](#ispaused-boolean)[isPaused: boolean](#ispaused-boolean)
    
    *   A derived boolean from the fetchStatus variable above, provided for convenience.
*   [](#isrefetching-boolean)
    
    ##### [](#isrefetching-boolean)[isRefetching: boolean](#isrefetching-boolean)
    
    *   Is true whenever a background refetch is in-flight, which _does not_ include initial pending
    *   Is the same as isFetching && !isPending
*   [](#isloading-boolean)
    
    ##### [](#isloading-boolean)[isLoading: boolean](#isloading-boolean)
    
    *   Is true whenever the first fetch for a query is in-flight
    *   Is the same as isFetching && isPending
*   [](#isinitialloading-boolean)
    
    ##### [](#isinitialloading-boolean)[isInitialLoading: boolean](#isinitialloading-boolean)
    
    *   **deprecated**
    *   An alias for isLoading, will be removed in the next major version.
*   [](#failurecount-number)
    
    ##### [](#failurecount-number)[failureCount: number](#failurecount-number)
    
    *   The failure count for the query.
    *   Incremented every time the query fails.
    *   Reset to 0 when the query succeeds.
*   [](#failurereason-null--terror)
    
    ##### [](#failurereason-null--terror)[failureReason: null | TError](#failurereason-null--terror)
    
    *   The failure reason for the query retry.
    *   Reset to null when the query succeeds.
*   [](#errorupdatecount-number)
    
    ##### [](#errorupdatecount-number)[errorUpdateCount: number](#errorupdatecount-number)
    
    *   The sum of all errors.
*   [](#refetch-options--throwonerror-boolean-cancelrefetch-boolean---promiseusequeryresult)
    
    ##### [](#refetch-options--throwonerror-boolean-cancelrefetch-boolean---promiseusequeryresult)[refetch: (options: { throwOnError: boolean, cancelRefetch: boolean }) => Promise<UseQueryResult>](#refetch-options--throwonerror-boolean-cancelrefetch-boolean---promiseusequeryresult)
    
    *   A function to manually refetch the query.
    *   If the query errors, the error will only be logged. If you want an error to be thrown, pass the throwOnError: true option
    *   cancelRefetch?: boolean
        *   Defaults to true
            *   Per default, a currently running request will be cancelled before a new request is made
        *   When set to false, no refetch will be made if there is already a request running.</content>
</page>

<page>
  <title>useQueries | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/reference/useQueries</url>
  <content>The useQueries hook can be used to fetch a variable number of queries:

    const ids = [1, 2, 3]
    const results = useQueries(() => {
      queries: ids.map((id) => ({
        queryKey: ['post', id],
        queryFn: () => fetchPost(id),
        staleTime: Infinity,
      })),
    })
    

    const ids = [1, 2, 3]
    const results = useQueries(() => {
      queries: ids.map((id) => ({
        queryKey: ['post', id],
        queryFn: () => fetchPost(id),
        staleTime: Infinity,
      })),
    })
    

**Options**

The useQueries hook accepts an options object with a **queries** key whose value is an array with query option objects identical to the [useQuery hook](https://tanstack.com/query/latest/docs/framework/solid/reference/useQuery) (excluding the queryClient option - because the QueryClient can be passed in on the top level).

*   queryClient?: QueryClient
    *   Use this to provide a custom QueryClient. Otherwise, the one from the nearest context will be used.
*   combine?: (result: UseQueriesResults) => TCombinedResult
    *   Use this to combine the results of the queries into a single value.

> Having the same query key more than once in the array of query objects may cause some data to be shared between queries. To avoid this, consider de-duplicating the queries and map the results back to the desired structure.

**placeholderData**

The placeholderData option exists for useQueries as well, but it doesn't get information passed from previously rendered Queries like useQuery does, because the input to useQueries can be a different number of Queries on each render.

**Returns**

The useQueries hook returns an array with all the query results. The order returned is the same as the input order.

[](#combine)[Combine](#combine)
-------------------------------

If you want to combine data (or other Query information) from the results into a single value, you can use the combine option. The result will be structurally shared to be as referentially stable as possible.

    const ids = [1, 2, 3]
    const combinedQueries = useQueries(() => {
      queries: ids.map((id) => ({
        queryKey: ['post', id],
        queryFn: () => fetchPost(id),
      })),
      combine: (results) => {
        return {
          data: results.map((result) => result.data),
          pending: results.some((result) => result.isPending),
        }
      },
    })
    

    const ids = [1, 2, 3]
    const combinedQueries = useQueries(() => {
      queries: ids.map((id) => ({
        queryKey: ['post', id],
        queryFn: () => fetchPost(id),
      })),
      combine: (results) => {
        return {
          data: results.map((result) => result.data),
          pending: results.some((result) => result.isPending),
        }
      },
    })
    

In the above example, combinedQueries will be an object with a data and a pending property. Note that all other properties of the Query results will be lost.

### [](#memoization)[Memoization](#memoization)

The combine function will only re-run if:

*   the combine function itself changed referentially
*   any of the query results changed

This means that an inlined combine function, as shown above, will run on every render. To avoid this, you can wrap the combine function in useCallback, or extract it to a stable function reference if it doesn't have any dependencies.</content>
</page>

<page>
  <title>useInfiniteQuery | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/reference/useInfiniteQuery</url>
  <content>    const {
      fetchNextPage,
      fetchPreviousPage,
      hasNextPage,
      hasPreviousPage,
      isFetchingNextPage,
      isFetchingPreviousPage,
      promise,
      ...result
    } = useInfiniteQuery(() => {
      queryKey,
      queryFn: ({ pageParam }) => fetchPage(pageParam),
      initialPageParam: 1,
      ...options,
      getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) =>
        lastPage.nextCursor,
      getPreviousPageParam: (firstPage, allPages, firstPageParam, allPageParams) =>
        firstPage.prevCursor,
    })
    

    const {
      fetchNextPage,
      fetchPreviousPage,
      hasNextPage,
      hasPreviousPage,
      isFetchingNextPage,
      isFetchingPreviousPage,
      promise,
      ...result
    } = useInfiniteQuery(() => {
      queryKey,
      queryFn: ({ pageParam }) => fetchPage(pageParam),
      initialPageParam: 1,
      ...options,
      getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) =>
        lastPage.nextCursor,
      getPreviousPageParam: (firstPage, allPages, firstPageParam, allPageParams) =>
        firstPage.prevCursor,
    })
    

**Options**

The options for useInfiniteQuery are identical to the [useQuery hook](https://tanstack.com/query/latest/docs/framework/solid/reference/useQuery) with the addition of the following:

*   queryFn: (context: QueryFunctionContext) => Promise<TData>
    *   **Required, but only if no default query function has been defined** [defaultQueryFn](https://tanstack.com/query/latest/docs/framework/solid/guides/default-query-function)
    *   The function that the query will use to request data.
    *   Receives a [QueryFunctionContext](https://tanstack.com/query/latest/docs/framework/solid/guides/query-functions#queryfunctioncontext)
    *   Must return a promise that will either resolve data or throw an error.
*   initialPageParam: TPageParam
    *   **Required**
    *   The default page param to use when fetching the first page.
*   getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => TPageParam | undefined | null
    *   **Required**
    *   When new data is received for this query, this function receives both the last page of the infinite list of data and the full array of all pages, as well as pageParam information.
    *   It should return a **single variable** that will be passed as the last optional parameter to your query function.
    *   Return undefined or null to indicate there is no next page available.
*   getPreviousPageParam: (firstPage, allPages, firstPageParam, allPageParams) => TPageParam | undefined | null
    *   When new data is received for this query, this function receives both the first page of the infinite list of data and the full array of all pages, as well as pageParam information.
    *   It should return a **single variable** that will be passed as the last optional parameter to your query function.
    *   Return undefined or nullto indicate there is no previous page available.
*   maxPages: number | undefined
    *   The maximum number of pages to store in the infinite query data.
    *   When the maximum number of pages is reached, fetching a new page will result in the removal of either the first or last page from the pages array, depending on the specified direction.
    *   If undefined or equals 0, the number of pages is unlimited
    *   Default value is undefined
    *   getNextPageParam and getPreviousPageParam must be properly defined if maxPages value is greater than 0 to allow fetching a page in both directions when needed.

**Returns**

The returned properties for useInfiniteQuery are identical to the [useQuery hook](https://tanstack.com/query/latest/docs/framework/solid/reference/useQuery), with the addition of the following properties and a small difference in isRefetching and isRefetchError:

*   data.pages: TData\[\]
    *   Array containing all pages.
*   data.pageParams: unknown\[\]
    *   Array containing all page params.
*   isFetchingNextPage: boolean
    *   Will be true while fetching the next page with fetchNextPage.
*   isFetchingPreviousPage: boolean
    *   Will be true while fetching the previous page with fetchPreviousPage.
*   fetchNextPage: (options?: FetchNextPageOptions) => Promise<UseInfiniteQueryResult>
    *   This function allows you to fetch the next "page" of results.
    *   options.cancelRefetch: boolean if set to true, calling fetchNextPage repeatedly will invoke queryFn every time, whether the previous invocation has resolved or not. Also, the result from previous invocations will be ignored. If set to false, calling fetchNextPage repeatedly won't have any effect until the first invocation has resolved. Default is true.
*   fetchPreviousPage: (options?: FetchPreviousPageOptions) => Promise<UseInfiniteQueryResult>
    *   This function allows you to fetch the previous "page" of results.
    *   options.cancelRefetch: boolean same as for fetchNextPage.
*   hasNextPage: boolean
    *   Will be true if there is a next page to be fetched (known via the getNextPageParam option).
*   hasPreviousPage: boolean
    *   Will be true if there is a previous page to be fetched (known via the getPreviousPageParam option).
*   isFetchNextPageError: boolean
    *   Will be true if the query failed while fetching the next page.
*   isFetchPreviousPageError: boolean
    *   Will be true if the query failed while fetching the previous page.
*   isRefetching: boolean
    *   Will be true whenever a background refetch is in-flight, which _does not_ include initial pending or fetching of next or previous page
    *   Is the same as isFetching && !isPending && !isFetchingNextPage && !isFetchingPreviousPage
*   isRefetchError: boolean
    *   Will be true if the query failed while refetching a page.
*   promise: Promise<TData>
    *   A stable promise that resolves to the query result.
    *   This can be used with React.use() to fetch data
    *   Requires the experimental\_prefetchInRender feature flag to be enabled on the QueryClient.

Keep in mind that imperative fetch calls, such as fetchNextPage, may interfere with the default refetch behaviour, resulting in outdated data. Make sure to call these functions only in response to user actions, or add conditions like hasNextPage && !isFetching.</content>
</page>

<page>
  <title>useMutation | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/reference/useMutation</url>
  <content>    const {
      data,
      error,
      isError,
      isIdle,
      isPending,
      isPaused,
      isSuccess,
      failureCount,
      failureReason,
      mutate,
      mutateAsync,
      reset,
      status,
      submittedAt,
      variables,
    } = useMutation(() => 
      {
        mutationFn,
        gcTime,
        meta,
        mutationKey,
        networkMode,
        onError,
        onMutate,
        onSettled,
        onSuccess,
        retry,
        retryDelay,
        scope,
        throwOnError,
      },
      queryClient,
    )
    
    mutate(variables, {
      onError,
      onSettled,
      onSuccess,
    })
    

    const {
      data,
      error,
      isError,
      isIdle,
      isPending,
      isPaused,
      isSuccess,
      failureCount,
      failureReason,
      mutate,
      mutateAsync,
      reset,
      status,
      submittedAt,
      variables,
    } = useMutation(() => 
      {
        mutationFn,
        gcTime,
        meta,
        mutationKey,
        networkMode,
        onError,
        onMutate,
        onSettled,
        onSuccess,
        retry,
        retryDelay,
        scope,
        throwOnError,
      },
      queryClient,
    )
    
    mutate(variables, {
      onError,
      onSettled,
      onSuccess,
    })</content>
</page>

<page>
  <title>useIsFetching | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/reference/useIsFetching</url>
  <content>useIsFetching is an optional hook that returns the number of the queries that your application is loading or fetching in the background (useful for app-wide loading indicators).

    import { useIsFetching } from '@tanstack/solid-query'
    // How many queries are fetching?
    const isFetching = useIsFetching()
    // How many queries matching the posts prefix are fetching?
    const isFetchingPosts = useIsFetching({ queryKey: ['posts'] })
    

    import { useIsFetching } from '@tanstack/solid-query'
    // How many queries are fetching?
    const isFetching = useIsFetching()
    // How many queries matching the posts prefix are fetching?
    const isFetchingPosts = useIsFetching({ queryKey: ['posts'] })
    

**Options**

*   filters?: QueryFilters: [Query Filters](https://tanstack.com/query/latest/docs/framework/solid/guides/filters#query-filters)
*   queryClient?: QueryClient
    *   Use this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.

**Returns**

*   isFetching: number
    *   Will be the number of the queries that your application is currently loading or fetching in the background.</content>
</page>

<page>
  <title>useIsMutating | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/reference/useIsMutating</url>
  <content>useIsMutating is an optional hook that returns the number of mutations that your application is fetching (useful for app-wide loading indicators).

    import { useIsMutating } from '@tanstack/solid-query'
    // How many mutations are fetching?
    const isMutating = useIsMutating()
    // How many mutations matching the posts prefix are fetching?
    const isMutatingPosts = useIsMutating({ mutationKey: ['posts'] })
    

    import { useIsMutating } from '@tanstack/solid-query'
    // How many mutations are fetching?
    const isMutating = useIsMutating()
    // How many mutations matching the posts prefix are fetching?
    const isMutatingPosts = useIsMutating({ mutationKey: ['posts'] })
    

**Options**

*   filters?: MutationFilters: [Mutation Filters](https://tanstack.com/query/latest/docs/framework/solid/guides/filters#mutation-filters)
*   queryClient?: QueryClient
    *   Use this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.

**Returns**

*   isMutating: number
    *   Will be the number of the mutations that your application is currently fetching.</content>
</page>

<page>
  <title>useMutationState | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/reference/useMutationState</url>
  <content>useMutationState is a hook that gives you access to all mutations in the MutationCache. You can pass filters to it to narrow down your mutations, and select to transform the mutation state.

**Example 1: Get all variables of all running mutations**

    import { useMutationState } from '@tanstack/solid-query'
    
    const variables = useMutationState(() => {
      filters: { status: 'pending' },
      select: (mutation) => mutation.state.variables,
    })
    

    import { useMutationState } from '@tanstack/solid-query'
    
    const variables = useMutationState(() => {
      filters: { status: 'pending' },
      select: (mutation) => mutation.state.variables,
    })
    

**Example 2: Get all data for specific mutations via the mutationKey**

    import { useMutation, useMutationState } from '@tanstack/solid-query'
    
    const mutationKey = ['posts']
    
    // Some mutation that we want to get the state for
    const mutation = useMutation(() => {
      mutationKey,
      mutationFn: (newPost) => {
        return axios.post('/posts', newPost)
      },
    })
    
    const data = useMutationState(() => {
      // this mutation key needs to match the mutation key of the given mutation (see above)
      filters: { mutationKey },
      select: (mutation) => mutation.state.data,
    })
    

    import { useMutation, useMutationState } from '@tanstack/solid-query'
    
    const mutationKey = ['posts']
    
    // Some mutation that we want to get the state for
    const mutation = useMutation(() => {
      mutationKey,
      mutationFn: (newPost) => {
        return axios.post('/posts', newPost)
      },
    })
    
    const data = useMutationState(() => {
      // this mutation key needs to match the mutation key of the given mutation (see above)
      filters: { mutationKey },
      select: (mutation) => mutation.state.data,
    })
    

**Example 3: Access the latest mutation data via the mutationKey**. Each invocation of mutate adds a new entry to the mutation cache for gcTime milliseconds.

To access the latest invocation, you can check for the last item that useMutationState returns.

    import { useMutation, useMutationState } from '@tanstack/solid-query'
    
    const mutationKey = ['posts']
    
    // Some mutation that we want to get the state for
    const mutation = useMutation(() => {
      mutationKey,
      mutationFn: (newPost) => {
        return axios.post('/posts', newPost)
      },
    })
    
    const data = useMutationState(() => {
      // this mutation key needs to match the mutation key of the given mutation (see above)
      filters: { mutationKey },
      select: (mutation) => mutation.state.data,
    })
    
    // Latest mutation data
    const latest = data[data.length - 1]
    

    import { useMutation, useMutationState } from '@tanstack/solid-query'
    
    const mutationKey = ['posts']
    
    // Some mutation that we want to get the state for
    const mutation = useMutation(() => {
      mutationKey,
      mutationFn: (newPost) => {
        return axios.post('/posts', newPost)
      },
    })
    
    const data = useMutationState(() => {
      // this mutation key needs to match the mutation key of the given mutation (see above)
      filters: { mutationKey },
      select: (mutation) => mutation.state.data,
    })
    
    // Latest mutation data
    const latest = data[data.length - 1]
    

**Options**

*   options
    *   filters?: MutationFilters: [Mutation Filters](https://tanstack.com/query/latest/docs/framework/solid/guides/filters#mutation-filters)
    *   select?: (mutation: Mutation) => TResult
        *   Use this to transform the mutation state.
*   queryClient?: QueryClient
    *   Use this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.

**Returns**

*   Array<TResult>
    *   Will be an Array of whatever select returns for each matching mutation.</content>
</page>

<page>
  <title>queryOptions | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/reference/queryOptions</url>
  <content>    queryOptions({
      queryKey,
      ...options,
    })
    

    queryOptions({
      queryKey,
      ...options,
    })
    

**Options**

You can generally pass everything to queryOptions that you can also pass to [useQuery](https://tanstack.com/query/latest/docs/framework/solid/reference/useQuery). Some options will have no effect when then forwarded to a function like queryClient.prefetchQuery, but TypeScript will still be fine with those excess properties.

*   queryKey: QueryKey
    *   **Required**
    *   The query key to generate options for.
*   experimental\_prefetchInRender?: boolean
    *   Optional
    *   Defaults to false
    *   When set to true, queries will be prefetched during render, which can be useful for certain optimization scenarios
    *   Needs to be turned on for the experimental useQuery().promise functionality

[](#further-reading)[Further reading](#further-reading)
-------------------------------------------------------

To learn more about QueryOptions, have a look at [this article by TkDodo The Query Options API](https://tkdodo.eu/blog/the-query-options-api).</content>
</page>

<page>
  <title>infiniteQueryOptions | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/reference/infiniteQueryOptions</url>
  <content>tsx

    infiniteQueryOptions({
      queryKey,
      ...options,
    })
    

    infiniteQueryOptions({
      queryKey,
      ...options,
    })
    

**Options**

You can generally pass everything to infiniteQueryOptions that you can also pass to [useInfiniteQuery](https://tanstack.com/query/latest/docs/framework/solid/reference/useInfiniteQuery). Some options will have no effect when then forwarded to a function like queryClient.prefetchInfiniteQuery, but TypeScript will still be fine with those excess properties.

*   queryKey: QueryKey
    *   **Required**
    *   The query key to generate options for.

See [useInfiniteQuery](https://tanstack.com/query/latest/docs/framework/solid/reference/useInfiniteQuery) for more information.</content>
</page>

<page>
  <title>hydration | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/reference/hydration</url>
  <content>[](#dehydrate)[dehydrate](#dehydrate)
-------------------------------------

dehydrate creates a frozen representation of a cache that can later be hydrated with HydrationBoundary or hydrate. This is useful for passing prefetched queries from server to client or persisting queries to localStorage or other persistent locations. It only includes currently successful queries by default.

    import { dehydrate } from '@tanstack/solid-query'
    
    const dehydratedState = dehydrate(queryClient, {
      shouldDehydrateQuery,
      shouldDehydrateMutation,
    })
    

    import { dehydrate } from '@tanstack/solid-query'
    
    const dehydratedState = dehydrate(queryClient, {
      shouldDehydrateQuery,
      shouldDehydrateMutation,
    })
    

**Options**

*   client: QueryClient
    *   **Required**
    *   The queryClient that should be dehydrated
*   options: DehydrateOptions
    *   Optional
    *   shouldDehydrateMutation: (mutation: Mutation) => boolean
        *   Optional
        *   Whether to dehydrate mutations.
        *   The function is called for each mutation in the cache
            *   Return true to include this mutation in dehydration, or false otherwise
        *   Defaults to only including paused mutations
        *   If you would like to extend the function while retaining the default behavior, import and execute defaultShouldDehydrateMutation as part of the return statement
    *   shouldDehydrateQuery: (query: Query) => boolean
        *   Optional
        *   Whether to dehydrate queries.
        *   The function is called for each query in the cache
            *   Return true to include this query in dehydration, or false otherwise
        *   Defaults to only including successful queries
        *   If you would like to extend the function while retaining the default behavior, import and execute defaultShouldDehydrateQuery as part of the return statement
    *   serializeData?: (data: any) => any A function to transform (serialize) data during dehydration.
    *   shouldRedactErrors?: (error: unknown) => boolean
        *   Optional
        *   Whether to redact errors from the server during dehydration.
        *   The function is called for each error in the cache
            *   Return true to redact this error, or false otherwise
        *   Defaults to redacting all errors

**Returns**

*   dehydratedState: DehydratedState
    *   This includes everything that is needed to hydrate the queryClient at a later point
    *   You **should not** rely on the exact format of this response, it is not part of the public API and can change at any time
    *   This result is not in serialized form, you need to do that yourself if desired

### [](#limitations)[Limitations](#limitations)

Some storage systems (such as browser [Web Storage API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API)) require values to be JSON serializable. If you need to dehydrate values that are not automatically serializable to JSON (like Error or undefined), you have to serialize them for yourself. Since only successful queries are included per default, to also include Errors, you have to provide shouldDehydrateQuery, e.g.:

    // server
    const state = dehydrate(client, { shouldDehydrateQuery: () => true }) // to also include Errors
    const serializedState = mySerialize(state) // transform Error instances to objects
    
    // client
    const state = myDeserialize(serializedState) // transform objects back to Error instances
    hydrate(client, state)
    

    // server
    const state = dehydrate(client, { shouldDehydrateQuery: () => true }) // to also include Errors
    const serializedState = mySerialize(state) // transform Error instances to objects
    
    // client
    const state = myDeserialize(serializedState) // transform objects back to Error instances
    hydrate(client, state)
    

[](#hydrate)[hydrate](#hydrate)
-------------------------------

hydrate adds a previously dehydrated state into a cache.

    import { hydrate } from '@tanstack/solid-query'
    
    hydrate(queryClient, dehydratedState, options)
    

    import { hydrate } from '@tanstack/solid-query'
    
    hydrate(queryClient, dehydratedState, options)
    

**Options**

*   client: QueryClient
    *   **Required**
    *   The queryClient to hydrate the state into
*   dehydratedState: DehydratedState
    *   **Required**
    *   The state to hydrate into the client
*   options: HydrateOptions
    *   Optional
    *   defaultOptions: DefaultOptions
        *   Optional
        *   mutations: MutationOptions The default mutation options to use for the hydrated mutations.
        *   queries: QueryOptions The default query options to use for the hydrated queries.
        *   deserializeData?: (data: any) => any A function to transform (deserialize) data before it is put into the cache.
    *   queryClient?: QueryClient
        *   Use this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.

### [](#limitations-1)[Limitations](#limitations-1)

If the queries you're trying to hydrate already exist in the queryCache, hydrate will only overwrite them if the data is newer than the data present in the cache. Otherwise, it will **not** get applied.</content>
</page>

<page>
  <title>Solid TanStack Query Simple Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/examples/simple</url>
  <content>    /* @refresh reload */
    import {
      QueryClient,
      QueryClientProvider,
      useQuery,
    } from '@tanstack/solid-query'
    import { SolidQueryDevtools } from '@tanstack/solid-query-devtools'
    import { Match, Switch } from 'solid-js'
    import { render } from 'solid-js/web'
    
    const queryClient = new QueryClient()
    
    export default function App() {
      return (
        <QueryClientProvider client={queryClient}>
          <SolidQueryDevtools />
          <Example />
        </QueryClientProvider>
      )
    }
    
    function Example() {
      const state = useQuery(() => ({
        queryKey: ['repoData'],
        queryFn: async () => {
          const response = await fetch(
            'https://api.github.com/repos/TanStack/query',
          )
          return await response.json()
        },
      }))
    
      return (
        <Switch>
          <Match when={state.isPending}>Loading...</Match>
          <Match when={state.error}>
            {'An error has occurred: ' + (state.error as Error).message}
          </Match>
          <Match when={state.data !== undefined}>
            <div>
              <h1>{state.data.name}</h1>
              <p>{state.data.description}</p>
              <strong>üëÄ {state.data.subscribers_count}</strong>{' '}
              <strong>‚ú® {state.data.stargazers_count}</strong>{' '}
              <strong>üç¥ {state.data.forks_count}</strong>
              <div>{state.isFetching ? 'Updating...' : ''}</div>
            </div>
          </Match>
        </Switch>
      )
    }
    render(() => <App />, document.getElementById('root') as HTMLElement)
    

    /* @refresh reload */
    import {
      QueryClient,
      QueryClientProvider,
      useQuery,
    } from '@tanstack/solid-query'
    import { SolidQueryDevtools } from '@tanstack/solid-query-devtools'
    import { Match, Switch } from 'solid-js'
    import { render } from 'solid-js/web'
    
    const queryClient = new QueryClient()
    
    export default function App() {
      return (
        <QueryClientProvider client={queryClient}>
          <SolidQueryDevtools />
          <Example />
        </QueryClientProvider>
      )
    }
    
    function Example() {
      const state = useQuery(() => ({
        queryKey: ['repoData'],
        queryFn: async () => {
          const response = await fetch(
            'https://api.github.com/repos/TanStack/query',
          )
          return await response.json()
        },
      }))
    
      return (
        <Switch>
          <Match when={state.isPending}>Loading...</Match>
          <Match when={state.error}>
            {'An error has occurred: ' + (state.error as Error).message}
          </Match>
          <Match when={state.data !== undefined}>
            <div>
              <h1>{state.data.name}</h1>
              <p>{state.data.description}</p>
              <strong>üëÄ {state.data.subscribers_count}</strong>{' '}
              <strong>‚ú® {state.data.stargazers_count}</strong>{' '}
              <strong>üç¥ {state.data.forks_count}</strong>
              <div>{state.isFetching ? 'Updating...' : ''}</div>
            </div>
          </Match>
        </Switch>
      )
    }
    render(() => <App />, document.getElementById('root') as HTMLElement)</content>
</page>

<page>
  <title>Solid TanStack Query Default Query Function Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/examples/default-query-function</url>
  <content>    /* @refresh reload */
    import {
      QueryClient,
      QueryClientProvider,
      useQuery,
    } from '@tanstack/solid-query'
    import { SolidQueryDevtools } from '@tanstack/solid-query-devtools'
    import { For, Match, Show, Switch, createSignal } from 'solid-js'
    import { render } from 'solid-js/web'
    import type { Setter } from 'solid-js'
    import type { QueryFunction } from '@tanstack/solid-query'
    
    // Define a default query function that will receive the query key
    const defaultQueryFn: QueryFunction<unknown> = async ({ queryKey }) => {
      const response = await fetch(
        `https://jsonplaceholder.typicode.com${queryKey[0]}`,
        {
          method: 'GET',
        },
      )
      return response.json()
    }
    
    // provide the default query function to your app via the query client
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          queryFn: defaultQueryFn,
        },
      },
    })
    
    function App() {
      const [postId, setPostId] = createSignal(-1)
    
      return (
        <QueryClientProvider client={queryClient}>
          <SolidQueryDevtools />
          <p>
            As you visit the posts below, you will notice them in a loading state
            the first time you load them. However, after you return to this list and
            click on any posts you have already visited again, you will see them
            load instantly and background refresh right before your eyes!{' '}
            <strong>
              (You may need to throttle your network speed to simulate longer
              loading sequences)
            </strong>
          </p>
          <Show when={postId() > -1} fallback={<Posts setPostId={setPostId} />}>
            <Post postId={postId()} setPostId={setPostId} />
          </Show>
        </QueryClientProvider>
      )
    }
    
    function Posts(props: { setPostId: Setter<number> }) {
      // All you have to do now is pass a key!
      const state = useQuery<any[]>(() => ({ queryKey: ['/posts'] }))
    
      return (
        <div>
          <h1>Posts</h1>
          <div>
            <Switch>
              <Match when={state.status === 'pending'}>Loading...</Match>
              <Match when={state.status === 'error'}>
                <span>Error: {(state.error as Error).message}</span>
              </Match>
              <Match when={state.data !== undefined}>
                <>
                  <div>
                    <For each={state.data}>
                      {(post) => (
                        <p>
                          <a
                            onClick={() => props.setPostId(post.id)}
                            href="#"
                            style={
                              // We can use the queryCache here to show bold links for
                              // ones that are cached
                              queryClient.getQueryData(['post', post.id])
                                ? {
                                    'font-weight': 'bold',
                                    color: 'green',
                                  }
                                : {}
                            }
                          >
                            {post.title}
                          </a>
                        </p>
                      )}
                    </For>
                  </div>
                  <div>{state.isFetching ? 'Background Updating...' : ' '}</div>
                </>
              </Match>
            </Switch>
          </div>
        </div>
      )
    }
    
    function Post(props: { postId: number; setPostId: Setter<number> }) {
      // You can even leave out the queryFn and just go straight into options
      const state = useQuery<any>(() => ({
        queryKey: [`/posts/${props.postId}`],
        enabled: !!props.postId,
      }))
    
      return (
        <div>
          <div>
            <a onClick={() => props.setPostId(-1)} href="#">
              Back
            </a>
          </div>
          <Switch>
            <Match when={!props.postId || state.status === 'pending'}>
              Loading...
            </Match>
            <Match when={state.status === 'error'}>
              <span>Error: {(state.error as Error).message}</span>
            </Match>
            <Match when={state.data !== undefined}>
              <>
                <h1>{state.data.title}</h1>
                <div>
                  <p>{state.data.body}</p>
                </div>
                <div>{state.isFetching ? 'Background Updating...' : ' '}</div>
              </>
            </Match>
          </Switch>
        </div>
      )
    }
    
    render(() => <App />, document.getElementById('root') as HTMLElement)
    

    /* @refresh reload */
    import {
      QueryClient,
      QueryClientProvider,
      useQuery,
    } from '@tanstack/solid-query'
    import { SolidQueryDevtools } from '@tanstack/solid-query-devtools'
    import { For, Match, Show, Switch, createSignal } from 'solid-js'
    import { render } from 'solid-js/web'
    import type { Setter } from 'solid-js'
    import type { QueryFunction } from '@tanstack/solid-query'
    
    // Define a default query function that will receive the query key
    const defaultQueryFn: QueryFunction<unknown> = async ({ queryKey }) => {
      const response = await fetch(
        `https://jsonplaceholder.typicode.com${queryKey[0]}`,
        {
          method: 'GET',
        },
      )
      return response.json()
    }
    
    // provide the default query function to your app via the query client
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          queryFn: defaultQueryFn,
        },
      },
    })
    
    function App() {
      const [postId, setPostId] = createSignal(-1)
    
      return (
        <QueryClientProvider client={queryClient}>
          <SolidQueryDevtools />
          <p>
            As you visit the posts below, you will notice them in a loading state
            the first time you load them. However, after you return to this list and
            click on any posts you have already visited again, you will see them
            load instantly and background refresh right before your eyes!{' '}
            <strong>
              (You may need to throttle your network speed to simulate longer
              loading sequences)
            </strong>
          </p>
          <Show when={postId() > -1} fallback={<Posts setPostId={setPostId} />}>
            <Post postId={postId()} setPostId={setPostId} />
          </Show>
        </QueryClientProvider>
      )
    }
    
    function Posts(props: { setPostId: Setter<number> }) {
      // All you have to do now is pass a key!
      const state = useQuery<any[]>(() => ({ queryKey: ['/posts'] }))
    
      return (
        <div>
          <h1>Posts</h1>
          <div>
            <Switch>
              <Match when={state.status === 'pending'}>Loading...</Match>
              <Match when={state.status === 'error'}>
                <span>Error: {(state.error as Error).message}</span>
              </Match>
              <Match when={state.data !== undefined}>
                <>
                  <div>
                    <For each={state.data}>
                      {(post) => (
                        <p>
                          <a
                            onClick={() => props.setPostId(post.id)}
                            href="#"
                            style={
                              // We can use the queryCache here to show bold links for
                              // ones that are cached
                              queryClient.getQueryData(['post', post.id])
                                ? {
                                    'font-weight': 'bold',
                                    color: 'green',
                                  }
                                : {}
                            }
                          >
                            {post.title}
                          </a>
                        </p>
                      )}
                    </For>
                  </div>
                  <div>{state.isFetching ? 'Background Updating...' : ' '}</div>
                </>
              </Match>
            </Switch>
          </div>
        </div>
      )
    }
    
    function Post(props: { postId: number; setPostId: Setter<number> }) {
      // You can even leave out the queryFn and just go straight into options
      const state = useQuery<any>(() => ({
        queryKey: [`/posts/${props.postId}`],
        enabled: !!props.postId,
      }))
    
      return (
        <div>
          <div>
            <a onClick={() => props.setPostId(-1)} href="#">
              Back
            </a>
          </div>
          <Switch>
            <Match when={!props.postId || state.status === 'pending'}>
              Loading...
            </Match>
            <Match when={state.status === 'error'}>
              <span>Error: {(state.error as Error).message}</span>
            </Match>
            <Match when={state.data !== undefined}>
              <>
                <h1>{state.data.title}</h1>
                <div>
                  <p>{state.data.body}</p>
                </div>
                <div>{state.isFetching ? 'Background Updating...' : ' '}</div>
              </>
            </Match>
          </Switch>
        </div>
      )
    }
    
    render(() => <App />, document.getElementById('root') as HTMLElement)</content>
</page>

<page>
  <title>Solid TanStack Query Basic Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/examples/basic</url>
  <content>    /* @refresh reload */
    import {
      QueryClient,
      QueryClientProvider,
      useQuery,
    } from '@tanstack/solid-query'
    import { SolidQueryDevtools } from '@tanstack/solid-query-devtools'
    import { For, Match, Switch, createSignal } from 'solid-js'
    import { render } from 'solid-js/web'
    import type { Component, Setter } from 'solid-js'
    
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          gcTime: 1000 * 60 * 60 * 24, // 24 hours
        },
      },
    })
    
    type Post = {
      id: number
      title: string
      body: string
    }
    
    function createPosts() {
      return useQuery(() => ({
        queryKey: ['posts'],
        queryFn: async (): Promise<Array<Post>> => {
          const response = await fetch('https://jsonplaceholder.typicode.com/posts')
          return await response.json()
        },
      }))
    }
    
    function Posts(props: { setPostId: Setter<number> }) {
      const state = createPosts()
    
      return (
        <div>
          <h1>Posts</h1>
          <div>
            <Switch>
              <Match when={state.status === 'pending'}>Loading...</Match>
              <Match when={state.status === 'error'}>
                <span>Error: {(state.error as Error).message}</span>
              </Match>
              <Match when={state.data !== undefined}>
                <>
                  <div>
                    <For each={state.data}>
                      {(post) => (
                        <p>
                          <a
                            onClick={() => props.setPostId(post.id)}
                            href="#"
                            style={
                              // We can access the query data here to show bold links for
                              // ones that are cached
                              queryClient.getQueryData(['post', post.id])
                                ? {
                                    'font-weight': 'bold',
                                    color: 'green',
                                  }
                                : {}
                            }
                          >
                            {post.title}
                          </a>
                        </p>
                      )}
                    </For>
                  </div>
                  <div>{state.isFetching ? 'Background Updating...' : ' '}</div>
                </>
              </Match>
            </Switch>
          </div>
        </div>
      )
    }
    
    const getPostById = async (id: number): Promise<Post> => {
      const response = await fetch(
        `https://jsonplaceholder.typicode.com/posts/${id}`,
      )
      return await response.json()
    }
    
    function createPost(postId: number) {
      return useQuery(() => ({
        queryKey: ['post', postId],
        queryFn: () => getPostById(postId),
        enabled: !!postId,
      }))
    }
    
    function Post(props: { postId: number; setPostId: Setter<number> }) {
      const state = createPost(props.postId)
    
      return (
        <div>
          <div>
            <a onClick={() => props.setPostId(-1)} href="#">
              Back
            </a>
          </div>
          <Switch>
            <Match when={!props.postId || state.status === 'pending'}>
              Loading...
            </Match>
            <Match when={state.status === 'error'}>
              <span>Error: {(state.error as Error).message}</span>
            </Match>
            <Match when={state.data !== undefined}>
              <>
                <h1>{state.data?.title}</h1>
                <div>
                  <p>{state.data?.body}</p>
                </div>
                <div>{state.isFetching ? 'Background Updating...' : ' '}</div>
              </>
            </Match>
          </Switch>
        </div>
      )
    }
    
    const App: Component = () => {
      const [postId, setPostId] = createSignal(-1)
    
      return (
        <QueryClientProvider client={queryClient}>
          <SolidQueryDevtools />
          <p>
            As you visit the posts below, you will notice them in a loading state
            the first time you load them. However, after you return to this list and
            click on any posts you have already visited again, you will see them
            load instantly and background refresh right before your eyes!{' '}
            <strong>
              (You may need to throttle your network speed to simulate longer
              loading sequences)
            </strong>
          </p>
          {postId() > -1 ? (
            <Post postId={postId()} setPostId={setPostId} />
          ) : (
            <Posts setPostId={setPostId} />
          )}
        </QueryClientProvider>
      )
    }
    
    render(() => <App />, document.getElementById('root') as HTMLElement)
    

    /* @refresh reload */
    import {
      QueryClient,
      QueryClientProvider,
      useQuery,
    } from '@tanstack/solid-query'
    import { SolidQueryDevtools } from '@tanstack/solid-query-devtools'
    import { For, Match, Switch, createSignal } from 'solid-js'
    import { render } from 'solid-js/web'
    import type { Component, Setter } from 'solid-js'
    
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          gcTime: 1000 * 60 * 60 * 24, // 24 hours
        },
      },
    })
    
    type Post = {
      id: number
      title: string
      body: string
    }
    
    function createPosts() {
      return useQuery(() => ({
        queryKey: ['posts'],
        queryFn: async (): Promise<Array<Post>> => {
          const response = await fetch('https://jsonplaceholder.typicode.com/posts')
          return await response.json()
        },
      }))
    }
    
    function Posts(props: { setPostId: Setter<number> }) {
      const state = createPosts()
    
      return (
        <div>
          <h1>Posts</h1>
          <div>
            <Switch>
              <Match when={state.status === 'pending'}>Loading...</Match>
              <Match when={state.status === 'error'}>
                <span>Error: {(state.error as Error).message}</span>
              </Match>
              <Match when={state.data !== undefined}>
                <>
                  <div>
                    <For each={state.data}>
                      {(post) => (
                        <p>
                          <a
                            onClick={() => props.setPostId(post.id)}
                            href="#"
                            style={
                              // We can access the query data here to show bold links for
                              // ones that are cached
                              queryClient.getQueryData(['post', post.id])
                                ? {
                                    'font-weight': 'bold',
                                    color: 'green',
                                  }
                                : {}
                            }
                          >
                            {post.title}
                          </a>
                        </p>
                      )}
                    </For>
                  </div>
                  <div>{state.isFetching ? 'Background Updating...' : ' '}</div>
                </>
              </Match>
            </Switch>
          </div>
        </div>
      )
    }
    
    const getPostById = async (id: number): Promise<Post> => {
      const response = await fetch(
        `https://jsonplaceholder.typicode.com/posts/${id}`,
      )
      return await response.json()
    }
    
    function createPost(postId: number) {
      return useQuery(() => ({
        queryKey: ['post', postId],
        queryFn: () => getPostById(postId),
        enabled: !!postId,
      }))
    }
    
    function Post(props: { postId: number; setPostId: Setter<number> }) {
      const state = createPost(props.postId)
    
      return (
        <div>
          <div>
            <a onClick={() => props.setPostId(-1)} href="#">
              Back
            </a>
          </div>
          <Switch>
            <Match when={!props.postId || state.status === 'pending'}>
              Loading...
            </Match>
            <Match when={state.status === 'error'}>
              <span>Error: {(state.error as Error).message}</span>
            </Match>
            <Match when={state.data !== undefined}>
              <>
                <h1>{state.data?.title}</h1>
                <div>
                  <p>{state.data?.body}</p>
                </div>
                <div>{state.isFetching ? 'Background Updating...' : ' '}</div>
              </>
            </Match>
          </Switch>
        </div>
      )
    }
    
    const App: Component = () => {
      const [postId, setPostId] = createSignal(-1)
    
      return (
        <QueryClientProvider client={queryClient}>
          <SolidQueryDevtools />
          <p>
            As you visit the posts below, you will notice them in a loading state
            the first time you load them. However, after you return to this list and
            click on any posts you have already visited again, you will see them
            load instantly and background refresh right before your eyes!{' '}
            <strong>
              (You may need to throttle your network speed to simulate longer
              loading sequences)
            </strong>
          </p>
          {postId() > -1 ? (
            <Post postId={postId()} setPostId={setPostId} />
          ) : (
            <Posts setPostId={setPostId} />
          )}
        </QueryClientProvider>
      )
    }
    
    render(() => <App />, document.getElementById('root') as HTMLElement)</content>
</page>

<page>
  <title>Solid TanStack Query Solid Start Streaming Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/examples/solid-start-streaming</url>
  <content>    import { Title } from '@solidjs/meta'
    
    export default function Home() {
      return (
        <main>
          <Title>Solid Query v5</Title>
    
          <h1>Solid Query v5</h1>
    
          <p>
            This demo demonstrates how Solid Query can be used in SSR, with
            streaming support. Use the links in the top left to navigate between the
            various examples.
          </p>
        </main>
      )
    }
    

    import { Title } from '@solidjs/meta'
    
    export default function Home() {
      return (
        <main>
          <Title>Solid Query v5</Title>
    
          <h1>Solid Query v5</h1>
    
          <p>
            This demo demonstrates how Solid Query can be used in SSR, with
            streaming support. Use the links in the top left to navigate between the
            various examples.
          </p>
        </main>
      )
    }</content>
</page>

<page>
  <title>broadcastQueryClient (Experimental) | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/plugins/broadcastQueryClient</url>
  <content>> VERY IMPORTANT: This utility is currently in an experimental stage. This means that breaking changes will happen in minor AND patch releases. Use at your own risk. If you choose to rely on this in production in an experimental stage, please lock your version to a patch-level version to avoid unexpected breakages.

broadcastQueryClient is a utility for broadcasting and syncing the state of your queryClient between browser tabs/windows with the same origin.

[](#installation)[Installation](#installation)
----------------------------------------------

This utility comes as a separate package and is available under the '@tanstack/query-broadcast-client-experimental' import.

[](#usage)[Usage](#usage)
-------------------------

Import the broadcastQueryClient function, and pass it your QueryClient instance, and optionally, set a broadcastChannel.

    import { broadcastQueryClient } from '@tanstack/query-broadcast-client-experimental'
    
    const queryClient = new QueryClient()
    
    broadcastQueryClient({
      queryClient,
      broadcastChannel: 'my-app',
    })
    

    import { broadcastQueryClient } from '@tanstack/query-broadcast-client-experimental'
    
    const queryClient = new QueryClient()
    
    broadcastQueryClient({
      queryClient,
      broadcastChannel: 'my-app',
    })
    

[](#api)[API](#api)
-------------------

### [](#broadcastqueryclient)[broadcastQueryClient](#broadcastqueryclient)

Pass this function a QueryClient instance and optionally, a broadcastChannel.

    broadcastQueryClient({ queryClient, broadcastChannel })
    

    broadcastQueryClient({ queryClient, broadcastChannel })
    

### [](#options)[Options](#options)

An object of options:

    interface BroadcastQueryClientOptions {
      /** The QueryClient to sync */
      queryClient: QueryClient
      /** This is the unique channel name that will be used
       * to communicate between tabs and windows */
      broadcastChannel?: string
      /** Options for the BroadcastChannel API */
      options?: BroadcastChannelOptions
    }
    

    interface BroadcastQueryClientOptions {
      /** The QueryClient to sync */
      queryClient: QueryClient
      /** This is the unique channel name that will be used
       * to communicate between tabs and windows */
      broadcastChannel?: string
      /** Options for the BroadcastChannel API */
      options?: BroadcastChannelOptions
    }
    

The default options are:

    {
      broadcastChannel = 'tanstack-query',
    }
    

    {
      broadcastChannel = 'tanstack-query',
    }</content>
</page>

<page>
  <title>experimental_createQueryPersister | TanStack Query Solid Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/plugins/createPersister</url>
  <content>[](#installation)[Installation](#installation)
----------------------------------------------

This utility comes as a separate package and is available under the '@tanstack/query-persist-client-core' import.

    npm install @tanstack/query-persist-client-core
    

    npm install @tanstack/query-persist-client-core
    

or

    pnpm add @tanstack/query-persist-client-core
    

    pnpm add @tanstack/query-persist-client-core
    

or

    yarn add @tanstack/query-persist-client-core
    

    yarn add @tanstack/query-persist-client-core
    

or

    bun add @tanstack/query-persist-client-core
    

    bun add @tanstack/query-persist-client-core
    

> Note: This util is also included in the @tanstack/solid-query-persist-client package, so you do not need to install it separately if you are using that package.

[](#usage)[Usage](#usage)
-------------------------

*   Import the experimental\_createQueryPersister function
*   Create a new experimental\_createQueryPersister
    *   you can pass any storage to it that adheres to the AsyncStorage interface - the example below uses the async-storage from React Native.
*   Pass that persister as an option to your Query. This can be done either by passing it to the defaultOptions of the QueryClient or to any useQuery hook instance.
    *   If you pass this persister as defaultOptions, all queries will be persisted to the provided storage. You can additionally narrow this down by passing filters. In contrast to the persistClient plugin, this will not persist the whole query client as a single item, but each query separately. As a key, the query hash is used.
    *   If you provide this persister to a single useQuery hook, only this Query will be persisted.
*   Note: queryClient.setQueryData() operations are not persisted, this means that if you perform an optimistic update and refresh the page before the query has been invalidated, your changes to the query data will be lost. See [https://github.com/TanStack/query/issues/6310](https://github.com/TanStack/query/issues/6310)

This way, you do not need to store whole QueryClient, but choose what is worth to be persisted in your application. Each query is lazily restored (when the Query is first used) and persisted (after each run of the queryFn), so it does not need to be throttled. staleTime is also respected after restoring the Query, so if data is considered stale, it will be refetched immediately after restoring. If data is fresh, the queryFn will not run.

Garbage collecting a Query from memory **does not** affect the persisted data. That means Queries can be kept in memory for a shorter period of time to be more **memory efficient**. If they are used the next time, they will just be restored from the persistent storage again.

    import AsyncStorage from '@react-native-async-storage/async-storage'
    import { QueryClient } from '@tanstack/solid-query'
    import { experimental_createQueryPersister } from '@tanstack/query-persist-client-core'
    
    const persister = experimental_createQueryPersister({
      storage: AsyncStorage,
      maxAge: 1000 * 60 * 60 * 12, // 12 hours
    })
    
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          gcTime: 1000 * 30, // 30 seconds
          persister: persister.persisterFn,
        },
      },
    })
    

    import AsyncStorage from '@react-native-async-storage/async-storage'
    import { QueryClient } from '@tanstack/solid-query'
    import { experimental_createQueryPersister } from '@tanstack/query-persist-client-core'
    
    const persister = experimental_createQueryPersister({
      storage: AsyncStorage,
      maxAge: 1000 * 60 * 60 * 12, // 12 hours
    })
    
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          gcTime: 1000 * 30, // 30 seconds
          persister: persister.persisterFn,
        },
      },
    })
    

### [](#adapted-defaults)[Adapted defaults](#adapted-defaults)

The createPersister plugin technically wraps the queryFn, so it doesn't restore if the queryFn doesn't run. In that way, it acts as a caching layer between the Query and the network. Thus, the networkMode defaults to 'offlineFirst' when a persister is used, so that restoring from the persistent storage can also happen even if there is no network connection.

[](#additional-utilities)[Additional utilities](#additional-utilities)
----------------------------------------------------------------------

Invoking experimental\_createQueryPersister returns additional utilities in addition to persisterFn for easier implementation of userland functionalities.

### [](#persistquerybykeyquerykey-querykey-queryclient-queryclient-promisevoid)[persistQueryByKey(queryKey: QueryKey, queryClient: QueryClient): Promise<void>](#persistquerybykeyquerykey-querykey-queryclient-queryclient-promisevoid)

This function will persist Query to storage and key defined when creating persister.  
This utility might be used along setQueryData to persist optimistic update to storage without waiting for invalidation.

    const persister = experimental_createQueryPersister({
      storage: AsyncStorage,
      maxAge: 1000 * 60 * 60 * 12, // 12 hours
    })
    
    const queryClient = useQueryClient()
    
    useMutation({
      mutationFn: updateTodo,
      onMutate: async (newTodo) => {
        ...
        // Optimistically update to the new value
        queryClient.setQueryData(['todos'], (old) => [...old, newTodo])
        // And persist it to storage
        persister.persistQueryByKey(['todos'], queryClient)
        ...
      },
    })
    

    const persister = experimental_createQueryPersister({
      storage: AsyncStorage,
      maxAge: 1000 * 60 * 60 * 12, // 12 hours
    })
    
    const queryClient = useQueryClient()
    
    useMutation({
      mutationFn: updateTodo,
      onMutate: async (newTodo) => {
        ...
        // Optimistically update to the new value
        queryClient.setQueryData(['todos'], (old) => [...old, newTodo])
        // And persist it to storage
        persister.persistQueryByKey(['todos'], queryClient)
        ...
      },
    })
    

### [](#retrievequerytqueryhash-string-promiset--undefined)[retrieveQuery<T>(queryHash: string): Promise<T | undefined>](#retrievequerytqueryhash-string-promiset--undefined)

This function would attempt to retrieve persisted query by queryHash.  
If query is expired, busted or malformed it would be removed from the storage instead, and undefined would be returned.

### [](#persistergc-promisevoid)[persisterGc(): Promise<void>](#persistergc-promisevoid)

This function can be used to sporadically clean up stoage from expired, busted or malformed entries.

For this function to work, your storage must expose entries method that would return a key-value tuple array.  
For example Object.entries(localStorage) for localStorage or entries from idb-keyval.

### [](#restorequeriesqueryclient-queryclient-filters-promisevoid)[restoreQueries(queryClient: QueryClient, filters): Promise<void>](#restorequeriesqueryclient-queryclient-filters-promisevoid)

This function can be used to restore queries that are currently stored by persister.  
For example when your app is starting up in offline mode, or you want all or only specific data from previous session to be immediately available without intermediate loading state.

The filter object supports the following properties:

*   queryKey?: QueryKey
    *   Set this property to define a query key to match on.
*   exact?: boolean
    *   If you don't want to search queries inclusively by query key, you can pass the exact: true option to return only the query with the exact query key you have passed.

For this function to work, your storage must expose entries method that would return a key-value tuple array.  
For example Object.entries(localStorage) for localStorage or entries from idb-keyval.

[](#api)[API](#api)
-------------------

### [](#experimental_createquerypersister)[experimental\_createQueryPersister](#experimental_createquerypersister)

    experimental_createQueryPersister(options: StoragePersisterOptions)
    

    experimental_createQueryPersister(options: StoragePersisterOptions)
    

#### [](#options)[Options](#options)

    export interface StoragePersisterOptions {
      /** The storage client used for setting and retrieving items from cache.
       * For SSR pass in `undefined`.
       */
      storage: AsyncStorage | Storage | undefined | null
      /**
       * How to serialize the data to storage.
       * @default `JSON.stringify`
       */
      serialize?: (persistedQuery: PersistedQuery) => string
      /**
       * How to deserialize the data from storage.
       * @default `JSON.parse`
       */
      deserialize?: (cachedString: string) => PersistedQuery
      /**
       * A unique string that can be used to forcefully invalidate existing caches,
       * if they do not share the same buster string
       */
      buster?: string
      /**
       * The max-allowed age of the cache in milliseconds.
       * If a persisted cache is found that is older than this
       * time, it will be discarded
       * @default 24 hours
       */
      maxAge?: number
      /**
       * Prefix to be used for storage key.
       * Storage key is a combination of prefix and query hash in a form of `prefix-queryHash`.
       */
      prefix?: string
      /**
       * If set to `true`, the query will refetch on successful query restoration if the data is stale.
       * If set to `false`, the query will not refetch on successful query restoration.
       * If set to `'always'`, the query will always refetch on successful query restoration.
       * Defaults to `true`.
       */
      refetchOnRestore?: boolean | 'always'
      /**
       * Filters to narrow down which Queries should be persisted.
       */
      filters?: QueryFilters
    }
    
    interface AsyncStorage<TStorageValue = string> {
      getItem: (key: string) => MaybePromise<TStorageValue | undefined | null>
      setItem: (key: string, value: TStorageValue) => MaybePromise<unknown>
      removeItem: (key: string) => MaybePromise<void>
      entries?: () => MaybePromise<Array<[key: string, value: TStorageValue]>>
    }
    

    export interface StoragePersisterOptions {
      /** The storage client used for setting and retrieving items from cache.
       * For SSR pass in `undefined`.
       */
      storage: AsyncStorage | Storage | undefined | null
      /**
       * How to serialize the data to storage.
       * @default `JSON.stringify`
       */
      serialize?: (persistedQuery: PersistedQuery) => string
      /**
       * How to deserialize the data from storage.
       * @default `JSON.parse`
       */
      deserialize?: (cachedString: string) => PersistedQuery
      /**
       * A unique string that can be used to forcefully invalidate existing caches,
       * if they do not share the same buster string
       */
      buster?: string
      /**
       * The max-allowed age of the cache in milliseconds.
       * If a persisted cache is found that is older than this
       * time, it will be discarded
       * @default 24 hours
       */
      maxAge?: number
      /**
       * Prefix to be used for storage key.
       * Storage key is a combination of prefix and query hash in a form of `prefix-queryHash`.
       */
      prefix?: string
      /**
       * If set to `true`, the query will refetch on successful query restoration if the data is stale.
       * If set to `false`, the query will not refetch on successful query restoration.
       * If set to `'always'`, the query will always refetch on successful query restoration.
       * Defaults to `true`.
       */
      refetchOnRestore?: boolean | 'always'
      /**
       * Filters to narrow down which Queries should be persisted.
       */
      filters?: QueryFilters
    }
    
    interface AsyncStorage<TStorageValue = string> {
      getItem: (key: string) => MaybePromise<TStorageValue | undefined | null>
      setItem: (key: string, value: TStorageValue) => MaybePromise<unknown>
      removeItem: (key: string) => MaybePromise<void>
      entries?: () => MaybePromise<Array<[key: string, value: TStorageValue]>>
    }
    

The default options are:

    {
      prefix = 'tanstack-query',
      maxAge = 1000 * 60 * 60 * 24,
      serialize = JSON.stringify,
      deserialize = JSON.parse,
      refetchOnRestore = true,
    }
    

    {
      prefix = 'tanstack-query',
      maxAge = 1000 * 60 * 60 * 24,
      serialize = JSON.stringify,
      deserialize = JSON.parse,
      refetchOnRestore = true,
    }</content>
</page>

<page>
  <title>Accessor | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/Accessor</url>
  <content>API Reference

*   [](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [](https://tanstack.com/query/latest/docs/framework/svelte/reference/index)
*   [
    
    Functions / createQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQuery)
*   [
    
    Functions / createQueries
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQueries)
*   [
    
    Functions / createInfiniteQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createInfiniteQuery)
*   [
    
    Functions / createMutation
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createMutation)
*   [
    
    Functions / useIsFetching
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsFetching)
*   [
    
    Functions / useIsMutating
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsMutating)
*   [
    
    Functions / useMutationState
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useMutationState)
*   [
    
    Functions / queryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/queryOptions)
*   [
    
    Functions / infiniteQueryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/infiniteQueryOptions)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

API Reference

*   [](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [](https://tanstack.com/query/latest/docs/framework/svelte/reference/index)
*   [
    
    Functions / createQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQuery)
*   [
    
    Functions / createQueries
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQueries)
*   [
    
    Functions / createInfiniteQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createInfiniteQuery)
*   [
    
    Functions / createMutation
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createMutation)
*   [
    
    Functions / useIsFetching
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsFetching)
*   [
    
    Functions / useIsMutating
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsMutating)
*   [
    
    Functions / useMutationState
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useMutationState)
*   [
    
    Functions / queryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/queryOptions)
*   [
    
    Functions / infiniteQueryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/infiniteQueryOptions)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)</content>
</page>

<page>
  <title>Solid TanStack Query Basic Graphql Request Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/examples/basic-graphql-request</url>
  <content>    /* @refresh reload */
    import {
      QueryClient,
      QueryClientProvider,
      useQuery,
    } from '@tanstack/solid-query'
    import { SolidQueryDevtools } from '@tanstack/solid-query-devtools'
    import { For, Match, Switch, createSignal } from 'solid-js'
    import { render } from 'solid-js/web'
    import { gql, request } from 'graphql-request'
    import type { Accessor, Setter } from 'solid-js'
    
    const endpoint = 'https://graphqlzero.almansi.me/api'
    
    const queryClient = new QueryClient()
    
    type Post = {
      id: number
      title: string
      body: string
    }
    
    function App() {
      const [postId, setPostId] = createSignal(-1)
    
      return (
        <QueryClientProvider client={queryClient}>
          <SolidQueryDevtools />
          <p>
            As you visit the posts below, you will notice them in a loading state
            the first time you load them. However, after you return to this list and
            click on any posts you have already visited again, you will see them
            load instantly and background refresh right before your eyes!{' '}
            <strong>
              (You may need to throttle your network speed to simulate longer
              loading sequences)
            </strong>
          </p>
          {postId() > -1 ? (
            <Post postId={postId()} setPostId={setPostId} />
          ) : (
            <Posts setPostId={setPostId} />
          )}
        </QueryClientProvider>
      )
    }
    
    function createPosts() {
      return useQuery(() => ({
        queryKey: ['posts'],
        queryFn: async () => {
          const {
            posts: { data },
          } = await request<{ posts: { data: Array<Post> } }>(
            endpoint,
            gql`
              query {
                posts {
                  data {
                    id
                    title
                  }
                }
              }
            `,
          )
          return data
        },
      }))
    }
    
    function Posts(props: { setPostId: Setter<number> }) {
      const state = createPosts()
    
      return (
        <div>
          <h1>Posts</h1>
          <div>
            <Switch>
              <Match when={state.status === 'pending'}>Loading...</Match>
              <Match when={state.status === 'error'}>
                <span>Error: {(state.error as Error).message}</span>
              </Match>
              <Match when={state.data !== undefined}>
                <>
                  <div>
                    <For each={state.data}>
                      {(post: any) => (
                        <p>
                          <a
                            onClick={() => props.setPostId(post.id)}
                            href="#"
                            style={
                              // We can find the existing query data here to show bold links for
                              // ones that are cached
                              queryClient.getQueryData(['post', post.id])
                                ? {
                                    'font-weight': 'bold',
                                    color: 'green',
                                  }
                                : {}
                            }
                          >
                            {post.title}
                          </a>
                        </p>
                      )}
                    </For>
                  </div>
                  <div>{state.isFetching ? 'Background Updating...' : ' '}</div>
                </>
              </Match>
            </Switch>
          </div>
        </div>
      )
    }
    
    function createPost(postId: Accessor<number>) {
      return useQuery(() => ({
        queryKey: ['post', postId()],
        queryFn: async () => {
          const { post } = await request<{ post: Post }>(
            endpoint,
            gql`
            query {
              post(id: ${postId()}) {
                id
                title
                body
              }
            }
            `,
          )
    
          return post
        },
        enabled: !!postId(),
      }))
    }
    
    function Post(props: { postId: number; setPostId: Setter<number> }) {
      const state = createPost(() => props.postId)
    
      return (
        <div>
          <div>
            <a onClick={() => props.setPostId(-1)} href="#">
              Back
            </a>
          </div>
          <Switch>
            <Match when={!props.postId || state.status === 'pending'}>
              Loading...
            </Match>
            <Match when={state.status === 'error'}>
              <span>Error: {(state.error as Error).message}</span>
            </Match>
            <Match when={state.data !== undefined}>
              <>
                <h1>{state.data?.title}</h1>
                <div>
                  <p>{state.data?.body}</p>
                </div>
                <div>{state.isFetching ? 'Background Updating...' : ' '}</div>
              </>
            </Match>
          </Switch>
        </div>
      )
    }
    
    render(() => <App />, document.getElementById('root') as HTMLElement)
    

    /* @refresh reload */
    import {
      QueryClient,
      QueryClientProvider,
      useQuery,
    } from '@tanstack/solid-query'
    import { SolidQueryDevtools } from '@tanstack/solid-query-devtools'
    import { For, Match, Switch, createSignal } from 'solid-js'
    import { render } from 'solid-js/web'
    import { gql, request } from 'graphql-request'
    import type { Accessor, Setter } from 'solid-js'
    
    const endpoint = 'https://graphqlzero.almansi.me/api'
    
    const queryClient = new QueryClient()
    
    type Post = {
      id: number
      title: string
      body: string
    }
    
    function App() {
      const [postId, setPostId] = createSignal(-1)
    
      return (
        <QueryClientProvider client={queryClient}>
          <SolidQueryDevtools />
          <p>
            As you visit the posts below, you will notice them in a loading state
            the first time you load them. However, after you return to this list and
            click on any posts you have already visited again, you will see them
            load instantly and background refresh right before your eyes!{' '}
            <strong>
              (You may need to throttle your network speed to simulate longer
              loading sequences)
            </strong>
          </p>
          {postId() > -1 ? (
            <Post postId={postId()} setPostId={setPostId} />
          ) : (
            <Posts setPostId={setPostId} />
          )}
        </QueryClientProvider>
      )
    }
    
    function createPosts() {
      return useQuery(() => ({
        queryKey: ['posts'],
        queryFn: async () => {
          const {
            posts: { data },
          } = await request<{ posts: { data: Array<Post> } }>(
            endpoint,
            gql`
              query {
                posts {
                  data {
                    id
                    title
                  }
                }
              }
            `,
          )
          return data
        },
      }))
    }
    
    function Posts(props: { setPostId: Setter<number> }) {
      const state = createPosts()
    
      return (
        <div>
          <h1>Posts</h1>
          <div>
            <Switch>
              <Match when={state.status === 'pending'}>Loading...</Match>
              <Match when={state.status === 'error'}>
                <span>Error: {(state.error as Error).message}</span>
              </Match>
              <Match when={state.data !== undefined}>
                <>
                  <div>
                    <For each={state.data}>
                      {(post: any) => (
                        <p>
                          <a
                            onClick={() => props.setPostId(post.id)}
                            href="#"
                            style={
                              // We can find the existing query data here to show bold links for
                              // ones that are cached
                              queryClient.getQueryData(['post', post.id])
                                ? {
                                    'font-weight': 'bold',
                                    color: 'green',
                                  }
                                : {}
                            }
                          >
                            {post.title}
                          </a>
                        </p>
                      )}
                    </For>
                  </div>
                  <div>{state.isFetching ? 'Background Updating...' : ' '}</div>
                </>
              </Match>
            </Switch>
          </div>
        </div>
      )
    }
    
    function createPost(postId: Accessor<number>) {
      return useQuery(() => ({
        queryKey: ['post', postId()],
        queryFn: async () => {
          const { post } = await request<{ post: Post }>(
            endpoint,
            gql`
            query {
              post(id: ${postId()}) {
                id
                title
                body
              }
            }
            `,
          )
    
          return post
        },
        enabled: !!postId(),
      }))
    }
    
    function Post(props: { postId: number; setPostId: Setter<number> }) {
      const state = createPost(() => props.postId)
    
      return (
        <div>
          <div>
            <a onClick={() => props.setPostId(-1)} href="#">
              Back
            </a>
          </div>
          <Switch>
            <Match when={!props.postId || state.status === 'pending'}>
              Loading...
            </Match>
            <Match when={state.status === 'error'}>
              <span>Error: {(state.error as Error).message}</span>
            </Match>
            <Match when={state.data !== undefined}>
              <>
                <h1>{state.data?.title}</h1>
                <div>
                  <p>{state.data?.body}</p>
                </div>
                <div>{state.isFetching ? 'Background Updating...' : ' '}</div>
              </>
            </Match>
          </Switch>
        </div>
      )
    }
    
    render(() => <App />, document.getElementById('root') as HTMLElement)</content>
</page>

<page>
  <title>CreateBaseMutationResult | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/CreateBaseMutationResult</url>
  <content>[](#type-alias-createbasemutationresulttdata-terror-tvariables-tonmutateresult)[Type Alias: CreateBaseMutationResult<TData, TError, TVariables, TOnMutateResult>](#type-alias-createbasemutationresulttdata-terror-tvariables-tonmutateresult)
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    type CreateBaseMutationResult<TData, TError, TVariables, TOnMutateResult> = Override<MutationObserverResult<TData, TError, TVariables, TOnMutateResult>, {
      mutate: CreateMutateFunction<TData, TError, TVariables, TOnMutateResult>;
    }> & object;
    

    type CreateBaseMutationResult<TData, TError, TVariables, TOnMutateResult> = Override<MutationObserverResult<TData, TError, TVariables, TOnMutateResult>, {
      mutate: CreateMutateFunction<TData, TError, TVariables, TOnMutateResult>;
    }> & object;
    

Defined in: [packages/svelte-query/src/types.ts:114](https://github.com/TanStack/query/blob/main/packages/svelte-query/src/types.ts#L114)

[](#type-declaration)[Type Declaration](#type-declaration)
----------------------------------------------------------

### [](#mutateasync)[mutateAsync](#mutateasync)

    mutateAsync: CreateMutateAsyncFunction<TData, TError, TVariables, TOnMutateResult>;
    

    mutateAsync: CreateMutateAsyncFunction<TData, TError, TVariables, TOnMutateResult>;
    

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tdata)[TData](#tdata)

TData = unknown

### [](#terror)[TError](#terror)

TError = DefaultError

### [](#tvariables)[TVariables](#tvariables)

TVariables = unknown

### [](#tonmutateresult)[TOnMutateResult](#tonmutateresult)

TOnMutateResult = unknown</content>
</page>

<page>
  <title>CreateBaseQueryOptions | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/CreateBaseQueryOptions</url>
  <content>[](#type-alias-createbasequeryoptionstqueryfndata-terror-tdata-tquerydata-tquerykey)[Type Alias: CreateBaseQueryOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>](#type-alias-createbasequeryoptionstqueryfndata-terror-tdata-tquerydata-tquerykey)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    type CreateBaseQueryOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey> = QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>;
    

    type CreateBaseQueryOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey> = QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>;
    

Defined in: [packages/svelte-query/src/types.ts:24](https://github.com/TanStack/query/blob/main/packages/svelte-query/src/types.ts#L24)

Options for createBaseQuery

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tqueryfndata)[TQueryFnData](#tqueryfndata)

TQueryFnData = unknown

### [](#terror)[TError](#terror)

TError = DefaultError

### [](#tdata)[TData](#tdata)

TData = TQueryFnData

### [](#tquerydata)[TQueryData](#tquerydata)

TQueryData = TQueryFnData

### [](#tquerykey)[TQueryKey](#tquerykey)

TQueryKey _extends_ QueryKey = QueryKey</content>
</page>

<page>
  <title>Solid TanStack Query Astro Example | TanStack Query Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/solid/examples/astro</url>
  <content>    import { createSignal } from 'solid-js'
    
    export const getSearchParams = (init: string) => {
      const [search, setSearch] = createSignal(init)
      if (typeof window !== 'undefined') {
        window.addEventListener('popstate', () => {
          const location = window.location
          const params = new URLSearchParams(location.search)
          setSearch(params.get('id') || '')
        })
      }
      return search
    }
    
    export const properCase = (str: string) =>
      str.charAt(0).toUpperCase() + str.slice(1)
    

    import { createSignal } from 'solid-js'
    
    export const getSearchParams = (init: string) => {
      const [search, setSearch] = createSignal(init)
      if (typeof window !== 'undefined') {
        window.addEventListener('popstate', () => {
          const location = window.location
          const params = new URLSearchParams(location.search)
          setSearch(params.get('id') || '')
        })
      }
      return search
    }
    
    export const properCase = (str: string) =>
      str.charAt(0).toUpperCase() + str.slice(1)</content>
</page>

<page>
  <title>CreateBaseQueryResult | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/CreateBaseQueryResult</url>
  <content>ts

    type CreateBaseQueryResult<TData, TError> = QueryObserverResult<TData, TError>;
    

    type CreateBaseQueryResult<TData, TError> = QueryObserverResult<TData, TError>;</content>
</page>

<page>
  <title>CreateInfiniteQueryOptions | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/CreateInfiniteQueryOptions</url>
  <content>[](#type-alias-createinfinitequeryoptionstqueryfndata-terror-tdata-tquerykey-tpageparam)[Type Alias: CreateInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>](#type-alias-createinfinitequeryoptionstqueryfndata-terror-tdata-tquerykey-tpageparam)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    type CreateInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam> = InfiniteQueryObserverOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>;
    

    type CreateInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam> = InfiniteQueryObserverOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>;
    

Defined in: [packages/svelte-query/src/types.ts:53](https://github.com/TanStack/query/blob/main/packages/svelte-query/src/types.ts#L53)

Options for createInfiniteQuery

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tqueryfndata)[TQueryFnData](#tqueryfndata)

TQueryFnData = unknown

### [](#terror)[TError](#terror)

TError = DefaultError

### [](#tdata)[TData](#tdata)

TData = TQueryFnData

### [](#tquerykey)[TQueryKey](#tquerykey)

TQueryKey _extends_ QueryKey = QueryKey

### [](#tpageparam)[TPageParam](#tpageparam)

TPageParam = unknown</content>
</page>

<page>
  <title>CreateInfiniteQueryResult | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/CreateInfiniteQueryResult</url>
  <content>[](#type-alias-createinfinitequeryresulttdata-terror)[Type Alias: CreateInfiniteQueryResult<TData, TError>](#type-alias-createinfinitequeryresulttdata-terror)
--------------------------------------------------------------------------------------------------------------------------------------------------------------

    type CreateInfiniteQueryResult<TData, TError> = InfiniteQueryObserverResult<TData, TError>;
    

    type CreateInfiniteQueryResult<TData, TError> = InfiniteQueryObserverResult<TData, TError>;
    

Defined in: [packages/svelte-query/src/types.ts:68](https://github.com/TanStack/query/blob/main/packages/svelte-query/src/types.ts#L68)

Result from createInfiniteQuery

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tdata)[TData](#tdata)

TData = unknown

### [](#terror)[TError](#terror)

TError = DefaultError</content>
</page>

<page>
  <title>CreateMutateAsyncFunction | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/CreateMutateAsyncFunction</url>
  <content>[](#type-alias-createmutateasyncfunctiontdata-terror-tvariables-tonmutateresult)[Type Alias: CreateMutateAsyncFunction<TData, TError, TVariables, TOnMutateResult>](#type-alias-createmutateasyncfunctiontdata-terror-tvariables-tonmutateresult)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    type CreateMutateAsyncFunction<TData, TError, TVariables, TOnMutateResult> = MutateFunction<TData, TError, TVariables, TOnMutateResult>;
    

    type CreateMutateAsyncFunction<TData, TError, TVariables, TOnMutateResult> = MutateFunction<TData, TError, TVariables, TOnMutateResult>;
    

Defined in: [packages/svelte-query/src/types.ts:107](https://github.com/TanStack/query/blob/main/packages/svelte-query/src/types.ts#L107)

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tdata)[TData](#tdata)

TData = unknown

### [](#terror)[TError](#terror)

TError = DefaultError

### [](#tvariables)[TVariables](#tvariables)

TVariables = void

### [](#tonmutateresult)[TOnMutateResult](#tonmutateresult)

TOnMutateResult = unknown</content>
</page>

<page>
  <title>CreateMutateFunction | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/CreateMutateFunction</url>
  <content>[](#type-alias-createmutatefunctiontdata-terror-tvariables-tonmutateresult)[Type Alias: CreateMutateFunction()<TData, TError, TVariables, TOnMutateResult>](#type-alias-createmutatefunctiontdata-terror-tvariables-tonmutateresult)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    type CreateMutateFunction<TData, TError, TVariables, TOnMutateResult> = (...args) => void;
    

    type CreateMutateFunction<TData, TError, TVariables, TOnMutateResult> = (...args) => void;
    

Defined in: [packages/svelte-query/src/types.ts:96](https://github.com/TanStack/query/blob/main/packages/svelte-query/src/types.ts#L96)

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tdata)[TData](#tdata)

TData = unknown

### [](#terror)[TError](#terror)

TError = DefaultError

### [](#tvariables)[TVariables](#tvariables)

TVariables = void

### [](#tonmutateresult)[TOnMutateResult](#tonmutateresult)

TOnMutateResult = unknown

[](#parameters)[Parameters](#parameters)
----------------------------------------

### [](#args)[args](#args)

...Parameters<MutateFunction<TData, TError, TVariables, TOnMutateResult\>>

[](#returns)[Returns](#returns)
-------------------------------

void</content>
</page>

<page>
  <title>CreateMutationResult | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/CreateMutationResult</url>
  <content>[](#type-alias-createmutationresulttdata-terror-tvariables-tonmutateresult)[Type Alias: CreateMutationResult<TData, TError, TVariables, TOnMutateResult>](#type-alias-createmutationresulttdata-terror-tvariables-tonmutateresult)
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    type CreateMutationResult<TData, TError, TVariables, TOnMutateResult> = CreateBaseMutationResult<TData, TError, TVariables, TOnMutateResult>;
    

    type CreateMutationResult<TData, TError, TVariables, TOnMutateResult> = CreateBaseMutationResult<TData, TError, TVariables, TOnMutateResult>;
    

Defined in: [packages/svelte-query/src/types.ts:132](https://github.com/TanStack/query/blob/main/packages/svelte-query/src/types.ts#L132)

Result from createMutation

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tdata)[TData](#tdata)

TData = unknown

### [](#terror)[TError](#terror)

TError = DefaultError

### [](#tvariables)[TVariables](#tvariables)

TVariables = unknown

### [](#tonmutateresult)[TOnMutateResult](#tonmutateresult)

TOnMutateResult = unknown</content>
</page>

<page>
  <title>CreateMutationOptions | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/CreateMutationOptions</url>
  <content>[](#type-alias-createmutationoptionstdata-terror-tvariables-tonmutateresult)[Type Alias: CreateMutationOptions<TData, TError, TVariables, TOnMutateResult>](#type-alias-createmutationoptionstdata-terror-tvariables-tonmutateresult)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    type CreateMutationOptions<TData, TError, TVariables, TOnMutateResult> = OmitKeyof<MutationObserverOptions<TData, TError, TVariables, TOnMutateResult>, "_defaulted">;
    

    type CreateMutationOptions<TData, TError, TVariables, TOnMutateResult> = OmitKeyof<MutationObserverOptions<TData, TError, TVariables, TOnMutateResult>, "_defaulted">;
    

Defined in: [packages/svelte-query/src/types.ts:86](https://github.com/TanStack/query/blob/main/packages/svelte-query/src/types.ts#L86)

Options for createMutation

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tdata)[TData](#tdata)

TData = unknown

### [](#terror)[TError](#terror)

TError = DefaultError

### [](#tvariables)[TVariables](#tvariables)

TVariables = void

### [](#tonmutateresult)[TOnMutateResult](#tonmutateresult)

TOnMutateResult = unknown</content>
</page>

<page>
  <title>CreateQueryOptions | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/CreateQueryOptions</url>
  <content>[](#type-alias-createqueryoptionstqueryfndata-terror-tdata-tquerykey)[Type Alias: CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey>](#type-alias-createqueryoptionstqueryfndata-terror-tdata-tquerykey)
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    type CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey> = CreateBaseQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey>;
    

    type CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey> = CreateBaseQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey>;
    

Defined in: [packages/svelte-query/src/types.ts:39](https://github.com/TanStack/query/blob/main/packages/svelte-query/src/types.ts#L39)

Options for createQuery

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tqueryfndata)[TQueryFnData](#tqueryfndata)

TQueryFnData = unknown

### [](#terror)[TError](#terror)

TError = DefaultError

### [](#tdata)[TData](#tdata)

TData = TQueryFnData

### [](#tquerykey)[TQueryKey](#tquerykey)

TQueryKey _extends_ QueryKey = QueryKey</content>
</page>

<page>
  <title>DefinedCreateBaseQueryResult | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/DefinedCreateBaseQueryResult</url>
  <content>[](#type-alias-definedcreatebasequeryresulttdata-terror)[Type Alias: DefinedCreateBaseQueryResult<TData, TError>](#type-alias-definedcreatebasequeryresulttdata-terror)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

    type DefinedCreateBaseQueryResult<TData, TError> = DefinedQueryObserverResult<TData, TError>;
    

    type DefinedCreateBaseQueryResult<TData, TError> = DefinedQueryObserverResult<TData, TError>;
    

Defined in: [packages/svelte-query/src/types.ts:74](https://github.com/TanStack/query/blob/main/packages/svelte-query/src/types.ts#L74)

Options for createBaseQuery with initialData

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tdata)[TData](#tdata)

TData = unknown

### [](#terror)[TError](#terror)

TError = DefaultError</content>
</page>

<page>
  <title>CreateQueryResult | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/CreateQueryResult</url>
  <content>ts

    type CreateQueryResult<TData, TError> = CreateBaseQueryResult<TData, TError>;
    

    type CreateQueryResult<TData, TError> = CreateBaseQueryResult<TData, TError>;</content>
</page>

<page>
  <title>DefinedInitialDataOptions | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/DefinedInitialDataOptions</url>
  <content>[](#type-alias-definedinitialdataoptionstqueryfndata-terror-tdata-tquerykey)[Type Alias: DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>](#type-alias-definedinitialdataoptionstqueryfndata-terror-tdata-tquerykey)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    type DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> = CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey> & object;
    

    type DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> = CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey> & object;
    

Defined in: [packages/svelte-query/src/queryOptions.ts:19](https://github.com/TanStack/query/blob/main/packages/svelte-query/src/queryOptions.ts#L19)

[](#type-declaration)[Type Declaration](#type-declaration)
----------------------------------------------------------

### [](#initialdata)[initialData](#initialdata)

    initialData: 
      | NonUndefinedGuard<TQueryFnData>
    | () => NonUndefinedGuard<TQueryFnData>;
    

    initialData: 
      | NonUndefinedGuard<TQueryFnData>
    | () => NonUndefinedGuard<TQueryFnData>;
    

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tqueryfndata)[TQueryFnData](#tqueryfndata)

TQueryFnData = unknown

### [](#terror)[TError](#terror)

TError = DefaultError

### [](#tdata)[TData](#tdata)

TData = TQueryFnData

### [](#tquerykey)[TQueryKey](#tquerykey)

TQueryKey _extends_ QueryKey = QueryKey</content>
</page>

<page>
  <title>DefinedCreateQueryResult | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/DefinedCreateQueryResult</url>
  <content>[](#type-alias-definedcreatequeryresulttdata-terror)[Type Alias: DefinedCreateQueryResult<TData, TError>](#type-alias-definedcreatequeryresulttdata-terror)
-----------------------------------------------------------------------------------------------------------------------------------------------------------

    type DefinedCreateQueryResult<TData, TError> = DefinedCreateBaseQueryResult<TData, TError>;
    

    type DefinedCreateQueryResult<TData, TError> = DefinedCreateBaseQueryResult<TData, TError>;
    

Defined in: [packages/svelte-query/src/types.ts:80](https://github.com/TanStack/query/blob/main/packages/svelte-query/src/types.ts#L80)

Options for createQuery with initialData

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tdata)[TData](#tdata)

TData = unknown

### [](#terror)[TError](#terror)

TError = DefaultError</content>
</page>

<page>
  <title>HydrationBoundary | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/HydrationBoundary</url>
  <content>Documentation

Framework

Version

Menu

*   [
    
    Home
    
    
    
    ](https://tanstack.com/query/latest)
*   [
    
    Frameworks
    
    
    
    ](https://tanstack.com/query/latest/docs/framework)
*   [
    
    Contributors
    
    
    
    ](https://tanstack.com/query/latest/docs/contributors)
*   [
    
    Community Resources
    
    
    
    ](https://tanstack.com/query/latest/docs/community-resources)
*   [
    
    GitHub
    
    
    
    ](https://github.com/tanstack/query)
*   [
    
    Discord
    
    
    
    ](https://tlinz.com/discord)

Getting Started

*   [
    
    Overview
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/overview)
*   [
    
    Installation
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/installation)
*   [
    
    Devtools
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/devtools)
*   [
    
    SSR & SvelteKit
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/ssr)
*   [
    
    Migrate from v5 to v6
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/migrate-from-v5-to-v6)

API Reference

*   [
    
    QueryClient
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [
    
    QueryCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [
    
    MutationCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [
    
    QueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [
    
    QueriesObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [
    
    streamedQuery
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [
    
    focusManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [
    
    onlineManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [
    
    notifyManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [
    
    timeoutManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [
    
    Svelte Reference
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/index)
*   [
    
    Functions / createQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQuery)
*   [
    
    Functions / createQueries
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQueries)
*   [
    
    Functions / createInfiniteQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createInfiniteQuery)
*   [
    
    Functions / createMutation
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createMutation)
*   [
    
    Functions / useIsFetching
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsFetching)
*   [
    
    Functions / useIsMutating
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsMutating)
*   [
    
    Functions / useMutationState
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useMutationState)
*   [
    
    Functions / queryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/queryOptions)
*   [
    
    Functions / infiniteQueryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/infiniteQueryOptions)

ESLint

*   [
    
    ESLint Plugin Query
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [
    
    Exhaustive Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [
    
    Stable Query Client
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [
    
    No Unstable Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Examples

*   [
    
    Simple
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/simple)
*   [
    
    Basic
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/basic)
*   [
    
    Auto Refetching / Polling / Realtime
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/auto-refetching)
*   [
    
    SSR
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/ssr)
*   [
    
    Optimistic Updates
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/optimistic-updates)
*   [
    
    Playground
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/playground)
*   [
    
    Star Wars
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/star-wars)
*   [
    
    Infinite Queries
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/load-more-infinite-scroll)

Framework

Version

Menu

*   [
    
    Home
    
    
    
    ](https://tanstack.com/query/latest)
*   [
    
    Frameworks
    
    
    
    ](https://tanstack.com/query/latest/docs/framework)
*   [
    
    Contributors
    
    
    
    ](https://tanstack.com/query/latest/docs/contributors)
*   [
    
    Community Resources
    
    
    
    ](https://tanstack.com/query/latest/docs/community-resources)
*   [
    
    GitHub
    
    
    
    ](https://github.com/tanstack/query)
*   [
    
    Discord
    
    
    
    ](https://tlinz.com/discord)

Getting Started

*   [
    
    Overview
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/overview)
*   [
    
    Installation
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/installation)
*   [
    
    Devtools
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/devtools)
*   [
    
    SSR & SvelteKit
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/ssr)
*   [
    
    Migrate from v5 to v6
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/migrate-from-v5-to-v6)

API Reference

*   [
    
    QueryClient
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [
    
    QueryCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [
    
    MutationCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [
    
    QueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [
    
    QueriesObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [
    
    streamedQuery
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [
    
    focusManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [
    
    onlineManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [
    
    notifyManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [
    
    timeoutManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [
    
    Svelte Reference
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/index)
*   [
    
    Functions / createQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQuery)
*   [
    
    Functions / createQueries
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQueries)
*   [
    
    Functions / createInfiniteQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createInfiniteQuery)
*   [
    
    Functions / createMutation
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createMutation)
*   [
    
    Functions / useIsFetching
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsFetching)
*   [
    
    Functions / useIsMutating
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsMutating)
*   [
    
    Functions / useMutationState
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useMutationState)
*   [
    
    Functions / queryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/queryOptions)
*   [
    
    Functions / infiniteQueryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/infiniteQueryOptions)

ESLint

*   [
    
    ESLint Plugin Query
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [
    
    Exhaustive Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [
    
    Stable Query Client
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [
    
    No Unstable Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Examples

*   [
    
    Simple
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/simple)
*   [
    
    Basic
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/basic)
*   [
    
    Auto Refetching / Polling / Realtime
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/auto-refetching)
*   [
    
    SSR
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/ssr)
*   [
    
    Optimistic Updates
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/optimistic-updates)
*   [
    
    Playground
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/playground)
*   [
    
    Star Wars
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/star-wars)
*   [
    
    Infinite Queries
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/load-more-infinite-scroll)

[Learn about TanStack Ads](https://tanstack.com/ads)[Hide Ads](https://tanstack.com/ads#hide-ads)

[](#type-alias-hydrationboundary)[Type Alias: HydrationBoundary](#type-alias-hydrationboundary)
-----------------------------------------------------------------------------------------------

ts

    type HydrationBoundary = SvelteComponent;
    

    type HydrationBoundary = SvelteComponent;
    

Defined in: node\_modules/.pnpm/svelte@5.39.3/node\_modules/svelte/types/index.d.ts:3092

[Edit on GitHub](https://github.com/tanstack/query/edit/main/docs/framework/svelte/reference/type-aliases/HydrationBoundary.md)

[Learn about TanStack Ads](https://tanstack.com/ads)[Hide Ads](https://tanstack.com/ads#hide-ads)

[

Home



](https://tanstack.com/query/latest)

[Partners](https://tanstack.com/partners)[Become a Partner](https://docs.google.com/document/d/1Hg2MzY2TU6U3hFEZ3MLe2oEOM3JS4-eByti3kdJU3I8)

[](https://coderabbit.link/tanstack?utm_source=tanstack&via=tanstack)[](https://www.cloudflare.com/?utm_source=tanstack)[](https://ag-grid.com/react-data-grid/?utm_source=reacttable&utm_campaign=githubreacttable)[](https://netlify.com/?utm_source=tanstack)[](https://neon.tech/?utm_source=tanstack)[](https://workos.com/?utm_source=tanstack)[](https://go.clerk.com/wOwHtuJ)[](https://convex.dev/?utm_source=tanstack)[](https://electric-sql.com/)[](https://sentry.io/?utm_source=tanstack)[](https://www.prisma.io/?utm_source=tanstack&via=tanstack)[](https://strapi.link/tanstack-start)[](https://www.unkey.com/?utm_source=tanstack)

[Learn about TanStack Ads](https://tanstack.com/ads)[Hide Ads](https://tanstack.com/ads#hide-ads)

[

###### Want to Skip the Docs?

Query.gg - The Official React Query Course

Black Friday Sale
-----------------

Get 50% off through December 6th

01

days

:

22

hours

:

50

minutes









](https://query.gg/?s=tanstack)</content>
</page>

<page>
  <title>MutationStateOptions | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/MutationStateOptions</url>
  <content>[](#type-alias-mutationstateoptionstresult)[Type Alias: MutationStateOptions<TResult>](#type-alias-mutationstateoptionstresult)
-------------------------------------------------------------------------------------------------------------------------------

    type MutationStateOptions<TResult> = object;
    

    type MutationStateOptions<TResult> = object;
    

Defined in: [packages/svelte-query/src/types.ts:140](https://github.com/TanStack/query/blob/main/packages/svelte-query/src/types.ts#L140)

Options for useMutationState

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tresult)[TResult](#tresult)

TResult = MutationState

[](#properties)[Properties](#properties)
----------------------------------------

### [](#filters)[filters?](#filters)

    optional filters: MutationFilters;
    

    optional filters: MutationFilters;
    

Defined in: [packages/svelte-query/src/types.ts:141](https://github.com/TanStack/query/blob/main/packages/svelte-query/src/types.ts#L141)

* * *

### [](#select)[select()?](#select)

    optional select: (mutation) => TResult;
    

    optional select: (mutation) => TResult;
    

Defined in: [packages/svelte-query/src/types.ts:142](https://github.com/TanStack/query/blob/main/packages/svelte-query/src/types.ts#L142)

#### [](#parameters)[Parameters](#parameters)

##### [](#mutation)[mutation](#mutation)

Mutation<unknown, DefaultError, unknown, unknown\>

#### [](#returns)[Returns](#returns)

TResult</content>
</page>

<page>
  <title>QueriesOptions | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/QueriesOptions</url>
  <content>[](#type-alias-queriesoptionst-tresults-tdepth)[Type Alias: QueriesOptions<T, TResults, TDepth>](#type-alias-queriesoptionst-tresults-tdepth)
---------------------------------------------------------------------------------------------------------------------------------------------

    type QueriesOptions<T, TResults, TDepth> = TDepth["length"] extends MAXIMUM_DEPTH ? CreateQueryOptionsForCreateQueries[] : T extends [] ? [] : T extends [infer Head] ? [...TResults, GetCreateQueryOptionsForCreateQueries<Head>] : T extends [infer Head, ...(infer Tails)] ? QueriesOptions<[...Tails], [...TResults, GetCreateQueryOptionsForCreateQueries<Head>], [...TDepth, 1]> : ReadonlyArray<unknown> extends T ? T : T extends CreateQueryOptionsForCreateQueries<infer TQueryFnData, infer TError, infer TData, infer TQueryKey>[] ? CreateQueryOptionsForCreateQueries<TQueryFnData, TError, TData, TQueryKey>[] : CreateQueryOptionsForCreateQueries[];
    

    type QueriesOptions<T, TResults, TDepth> = TDepth["length"] extends MAXIMUM_DEPTH ? CreateQueryOptionsForCreateQueries[] : T extends [] ? [] : T extends [infer Head] ? [...TResults, GetCreateQueryOptionsForCreateQueries<Head>] : T extends [infer Head, ...(infer Tails)] ? QueriesOptions<[...Tails], [...TResults, GetCreateQueryOptionsForCreateQueries<Head>], [...TDepth, 1]> : ReadonlyArray<unknown> extends T ? T : T extends CreateQueryOptionsForCreateQueries<infer TQueryFnData, infer TError, infer TData, infer TQueryKey>[] ? CreateQueryOptionsForCreateQueries<TQueryFnData, TError, TData, TQueryKey>[] : CreateQueryOptionsForCreateQueries[];
    

Defined in: [packages/svelte-query/src/createQueries.svelte.ts:129](https://github.com/TanStack/query/blob/main/packages/svelte-query/src/createQueries.svelte.ts#L129)

QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#t)[T](#t)

T _extends_ any\[\]

### [](#tresults)[TResults](#tresults)

TResults _extends_ any\[\] = \[\]

### [](#tdepth)[TDepth](#tdepth)

TDepth _extends_ ReadonlyArray<number\> = \[\]</content>
</page>

<page>
  <title>QueriesResults | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/QueriesResults</url>
  <content>[](#type-alias-queriesresultst-tresults-tdepth)[Type Alias: QueriesResults<T, TResults, TDepth>](#type-alias-queriesresultst-tresults-tdepth)
---------------------------------------------------------------------------------------------------------------------------------------------

    type QueriesResults<T, TResults, TDepth> = TDepth["length"] extends MAXIMUM_DEPTH ? CreateQueryResult[] : T extends [] ? [] : T extends [infer Head] ? [...TResults, GetCreateQueryResult<Head>] : T extends [infer Head, ...(infer Tails)] ? QueriesResults<[...Tails], [...TResults, GetCreateQueryResult<Head>], [...TDepth, 1]> : { [K in keyof T]: GetCreateQueryResult<T[K]> };
    

    type QueriesResults<T, TResults, TDepth> = TDepth["length"] extends MAXIMUM_DEPTH ? CreateQueryResult[] : T extends [] ? [] : T extends [infer Head] ? [...TResults, GetCreateQueryResult<Head>] : T extends [infer Head, ...(infer Tails)] ? QueriesResults<[...Tails], [...TResults, GetCreateQueryResult<Head>], [...TDepth, 1]> : { [K in keyof T]: GetCreateQueryResult<T[K]> };
    

Defined in: [packages/svelte-query/src/createQueries.svelte.ts:171](https://github.com/TanStack/query/blob/main/packages/svelte-query/src/createQueries.svelte.ts#L171)

QueriesResults reducer recursively maps type param to results

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#t)[T](#t)

T _extends_ any\[\]

### [](#tresults)[TResults](#tresults)

TResults _extends_ any\[\] = \[\]

### [](#tdepth)[TDepth](#tdepth)

TDepth _extends_ ReadonlyArray<number\> = \[\]</content>
</page>

<page>
  <title>QueryClientProviderProps | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/QueryClientProviderProps</url>
  <content>API Reference

*   [](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [](https://tanstack.com/query/latest/docs/framework/svelte/reference/index)
*   [
    
    Functions / createQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQuery)
*   [
    
    Functions / createQueries
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQueries)
*   [
    
    Functions / createInfiniteQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createInfiniteQuery)
*   [
    
    Functions / createMutation
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createMutation)
*   [
    
    Functions / useIsFetching
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsFetching)
*   [
    
    Functions / useIsMutating
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsMutating)
*   [
    
    Functions / useMutationState
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useMutationState)
*   [
    
    Functions / queryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/queryOptions)
*   [
    
    Functions / infiniteQueryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/infiniteQueryOptions)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

API Reference

*   [](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [](https://tanstack.com/query/latest/docs/framework/svelte/reference/index)
*   [
    
    Functions / createQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQuery)
*   [
    
    Functions / createQueries
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQueries)
*   [
    
    Functions / createInfiniteQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createInfiniteQuery)
*   [
    
    Functions / createMutation
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createMutation)
*   [
    
    Functions / useIsFetching
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsFetching)
*   [
    
    Functions / useIsMutating
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsMutating)
*   [
    
    Functions / useMutationState
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useMutationState)
*   [
    
    Functions / queryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/queryOptions)
*   [
    
    Functions / infiniteQueryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/infiniteQueryOptions)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)</content>
</page>

<page>
  <title>UndefinedInitialDataOptions | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/type-aliases/UndefinedInitialDataOptions</url>
  <content>[](#type-alias-undefinedinitialdataoptionstqueryfndata-terror-tdata-tquerykey)[Type Alias: UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>](#type-alias-undefinedinitialdataoptionstqueryfndata-terror-tdata-tquerykey)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    type UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> = CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey> & object;
    

    type UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> = CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey> & object;
    

Defined in: [packages/svelte-query/src/queryOptions.ts:10](https://github.com/TanStack/query/blob/main/packages/svelte-query/src/queryOptions.ts#L10)

[](#type-declaration)[Type Declaration](#type-declaration)
----------------------------------------------------------

### [](#initialdata)[initialData?](#initialdata)

    optional initialData: InitialDataFunction<NonUndefinedGuard<TQueryFnData>>;
    

    optional initialData: InitialDataFunction<NonUndefinedGuard<TQueryFnData>>;
    

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tqueryfndata)[TQueryFnData](#tqueryfndata)

TQueryFnData = unknown

### [](#terror)[TError](#terror)

TError = DefaultError

### [](#tdata)[TData](#tdata)

TData = TQueryFnData

### [](#tquerykey)[TQueryKey](#tquerykey)

TQueryKey _extends_ QueryKey = QueryKey</content>
</page>

<page>
  <title>HydrationBoundary | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/variables/HydrationBoundary</url>
  <content>Documentation

Framework

Version

Menu

*   [
    
    Home
    
    
    
    ](https://tanstack.com/query/latest)
*   [
    
    Frameworks
    
    
    
    ](https://tanstack.com/query/latest/docs/framework)
*   [
    
    Contributors
    
    
    
    ](https://tanstack.com/query/latest/docs/contributors)
*   [
    
    Community Resources
    
    
    
    ](https://tanstack.com/query/latest/docs/community-resources)
*   [
    
    GitHub
    
    
    
    ](https://github.com/tanstack/query)
*   [
    
    Discord
    
    
    
    ](https://tlinz.com/discord)

Getting Started

*   [
    
    Overview
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/overview)
*   [
    
    Installation
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/installation)
*   [
    
    Devtools
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/devtools)
*   [
    
    SSR & SvelteKit
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/ssr)
*   [
    
    Migrate from v5 to v6
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/migrate-from-v5-to-v6)

API Reference

*   [
    
    QueryClient
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [
    
    QueryCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [
    
    MutationCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [
    
    QueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [
    
    QueriesObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [
    
    streamedQuery
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [
    
    focusManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [
    
    onlineManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [
    
    notifyManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [
    
    timeoutManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [
    
    Svelte Reference
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/index)
*   [
    
    Functions / createQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQuery)
*   [
    
    Functions / createQueries
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQueries)
*   [
    
    Functions / createInfiniteQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createInfiniteQuery)
*   [
    
    Functions / createMutation
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createMutation)
*   [
    
    Functions / useIsFetching
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsFetching)
*   [
    
    Functions / useIsMutating
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsMutating)
*   [
    
    Functions / useMutationState
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useMutationState)
*   [
    
    Functions / queryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/queryOptions)
*   [
    
    Functions / infiniteQueryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/infiniteQueryOptions)

ESLint

*   [
    
    ESLint Plugin Query
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [
    
    Exhaustive Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [
    
    Stable Query Client
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [
    
    No Unstable Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Examples

*   [
    
    Simple
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/simple)
*   [
    
    Basic
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/basic)
*   [
    
    Auto Refetching / Polling / Realtime
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/auto-refetching)
*   [
    
    SSR
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/ssr)
*   [
    
    Optimistic Updates
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/optimistic-updates)
*   [
    
    Playground
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/playground)
*   [
    
    Star Wars
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/star-wars)
*   [
    
    Infinite Queries
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/load-more-infinite-scroll)

Framework

Version

Menu

*   [
    
    Home
    
    
    
    ](https://tanstack.com/query/latest)
*   [
    
    Frameworks
    
    
    
    ](https://tanstack.com/query/latest/docs/framework)
*   [
    
    Contributors
    
    
    
    ](https://tanstack.com/query/latest/docs/contributors)
*   [
    
    Community Resources
    
    
    
    ](https://tanstack.com/query/latest/docs/community-resources)
*   [
    
    GitHub
    
    
    
    ](https://github.com/tanstack/query)
*   [
    
    Discord
    
    
    
    ](https://tlinz.com/discord)

Getting Started

*   [
    
    Overview
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/overview)
*   [
    
    Installation
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/installation)
*   [
    
    Devtools
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/devtools)
*   [
    
    SSR & SvelteKit
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/ssr)
*   [
    
    Migrate from v5 to v6
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/migrate-from-v5-to-v6)

API Reference

*   [
    
    QueryClient
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [
    
    QueryCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [
    
    MutationCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [
    
    QueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [
    
    QueriesObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [
    
    streamedQuery
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [
    
    focusManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [
    
    onlineManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [
    
    notifyManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [
    
    timeoutManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [
    
    Svelte Reference
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/index)
*   [
    
    Functions / createQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQuery)
*   [
    
    Functions / createQueries
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQueries)
*   [
    
    Functions / createInfiniteQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createInfiniteQuery)
*   [
    
    Functions / createMutation
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createMutation)
*   [
    
    Functions / useIsFetching
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsFetching)
*   [
    
    Functions / useIsMutating
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsMutating)
*   [
    
    Functions / useMutationState
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useMutationState)
*   [
    
    Functions / queryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/queryOptions)
*   [
    
    Functions / infiniteQueryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/infiniteQueryOptions)

ESLint

*   [
    
    ESLint Plugin Query
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [
    
    Exhaustive Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [
    
    Stable Query Client
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [
    
    No Unstable Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Examples

*   [
    
    Simple
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/simple)
*   [
    
    Basic
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/basic)
*   [
    
    Auto Refetching / Polling / Realtime
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/auto-refetching)
*   [
    
    SSR
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/ssr)
*   [
    
    Optimistic Updates
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/optimistic-updates)
*   [
    
    Playground
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/playground)
*   [
    
    Star Wars
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/star-wars)
*   [
    
    Infinite Queries
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/examples/load-more-infinite-scroll)

[Learn about TanStack Ads](https://tanstack.com/ads)[Hide Ads](https://tanstack.com/ads#hide-ads)

[](#variable-hydrationboundary)[Variable: HydrationBoundary](#variable-hydrationboundary)
-----------------------------------------------------------------------------------------

ts

    const HydrationBoundary: LegacyComponentType;
    

    const HydrationBoundary: LegacyComponentType;
    

Defined in: node\_modules/.pnpm/svelte@5.39.3/node\_modules/svelte/types/index.d.ts:3092

[Edit on GitHub](https://github.com/tanstack/query/edit/main/docs/framework/svelte/reference/variables/HydrationBoundary.md)

[Learn about TanStack Ads](https://tanstack.com/ads)[Hide Ads](https://tanstack.com/ads#hide-ads)

[

Home



](https://tanstack.com/query/latest)

[Partners](https://tanstack.com/partners)[Become a Partner](https://docs.google.com/document/d/1Hg2MzY2TU6U3hFEZ3MLe2oEOM3JS4-eByti3kdJU3I8)

[](https://coderabbit.link/tanstack?utm_source=tanstack&via=tanstack)[](https://www.cloudflare.com/?utm_source=tanstack)[](https://ag-grid.com/react-data-grid/?utm_source=reacttable&utm_campaign=githubreacttable)[](https://netlify.com/?utm_source=tanstack)[](https://neon.tech/?utm_source=tanstack)[](https://workos.com/?utm_source=tanstack)[](https://go.clerk.com/wOwHtuJ)[](https://convex.dev/?utm_source=tanstack)[](https://electric-sql.com/)[](https://sentry.io/?utm_source=tanstack)[](https://www.prisma.io/?utm_source=tanstack&via=tanstack)[](https://strapi.link/tanstack-start)[](https://www.unkey.com/?utm_source=tanstack)

[Learn about TanStack Ads](https://tanstack.com/ads)[Hide Ads](https://tanstack.com/ads#hide-ads)

[

###### Want to Skip the Docs?

Query.gg - The Official React Query Course

Black Friday Sale
-----------------

Get 50% off through December 6th

01

days

:

22

hours

:

50

minutes









](https://query.gg/?s=tanstack)</content>
</page>

<page>
  <title>getIsRestoringContext | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/getIsRestoringContext</url>
  <content>API Reference

*   [](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [](https://tanstack.com/query/latest/docs/framework/svelte/reference/index)
*   [
    
    Functions / createQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQuery)
*   [
    
    Functions / createQueries
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQueries)
*   [
    
    Functions / createInfiniteQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createInfiniteQuery)
*   [
    
    Functions / createMutation
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createMutation)
*   [
    
    Functions / useIsFetching
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsFetching)
*   [
    
    Functions / useIsMutating
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsMutating)
*   [
    
    Functions / useMutationState
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useMutationState)
*   [
    
    Functions / queryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/queryOptions)
*   [
    
    Functions / infiniteQueryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/infiniteQueryOptions)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

API Reference

*   [](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [](https://tanstack.com/query/latest/docs/framework/svelte/reference/index)
*   [
    
    Functions / createQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQuery)
*   [
    
    Functions / createQueries
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQueries)
*   [
    
    Functions / createInfiniteQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createInfiniteQuery)
*   [
    
    Functions / createMutation
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createMutation)
*   [
    
    Functions / useIsFetching
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsFetching)
*   [
    
    Functions / useIsMutating
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsMutating)
*   [
    
    Functions / useMutationState
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useMutationState)
*   [
    
    Functions / queryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/queryOptions)
*   [
    
    Functions / infiniteQueryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/infiniteQueryOptions)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)</content>
</page>

<page>
  <title>getQueryClientContext | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/getQueryClientContext</url>
  <content>API Reference

*   [](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [](https://tanstack.com/query/latest/docs/framework/svelte/reference/index)
*   [
    
    Functions / createQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQuery)
*   [
    
    Functions / createQueries
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQueries)
*   [
    
    Functions / createInfiniteQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createInfiniteQuery)
*   [
    
    Functions / createMutation
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createMutation)
*   [
    
    Functions / useIsFetching
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsFetching)
*   [
    
    Functions / useIsMutating
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsMutating)
*   [
    
    Functions / useMutationState
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useMutationState)
*   [
    
    Functions / queryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/queryOptions)
*   [
    
    Functions / infiniteQueryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/infiniteQueryOptions)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

API Reference

*   [](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [](https://tanstack.com/query/latest/docs/framework/svelte/reference/index)
*   [
    
    Functions / createQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQuery)
*   [
    
    Functions / createQueries
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQueries)
*   [
    
    Functions / createInfiniteQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createInfiniteQuery)
*   [
    
    Functions / createMutation
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createMutation)
*   [
    
    Functions / useIsFetching
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsFetching)
*   [
    
    Functions / useIsMutating
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsMutating)
*   [
    
    Functions / useMutationState
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useMutationState)
*   [
    
    Functions / queryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/queryOptions)
*   [
    
    Functions / infiniteQueryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/infiniteQueryOptions)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)</content>
</page>

<page>
  <title>setIsRestoringContext | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/setIsRestoringContext</url>
  <content>API Reference

*   [](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [](https://tanstack.com/query/latest/docs/framework/svelte/reference/index)
*   [
    
    Functions / createQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQuery)
*   [
    
    Functions / createQueries
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQueries)
*   [
    
    Functions / createInfiniteQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createInfiniteQuery)
*   [
    
    Functions / createMutation
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createMutation)
*   [
    
    Functions / useIsFetching
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsFetching)
*   [
    
    Functions / useIsMutating
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsMutating)
*   [
    
    Functions / useMutationState
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useMutationState)
*   [
    
    Functions / queryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/queryOptions)
*   [
    
    Functions / infiniteQueryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/infiniteQueryOptions)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

API Reference

*   [](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [](https://tanstack.com/query/latest/docs/framework/svelte/reference/index)
*   [
    
    Functions / createQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQuery)
*   [
    
    Functions / createQueries
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQueries)
*   [
    
    Functions / createInfiniteQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createInfiniteQuery)
*   [
    
    Functions / createMutation
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createMutation)
*   [
    
    Functions / useIsFetching
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsFetching)
*   [
    
    Functions / useIsMutating
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsMutating)
*   [
    
    Functions / useMutationState
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useMutationState)
*   [
    
    Functions / queryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/queryOptions)
*   [
    
    Functions / infiniteQueryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/infiniteQueryOptions)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)</content>
</page>

<page>
  <title>setQueryClientContext | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/setQueryClientContext</url>
  <content>API Reference

*   [](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [](https://tanstack.com/query/latest/docs/framework/svelte/reference/index)
*   [
    
    Functions / createQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQuery)
*   [
    
    Functions / createQueries
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQueries)
*   [
    
    Functions / createInfiniteQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createInfiniteQuery)
*   [
    
    Functions / createMutation
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createMutation)
*   [
    
    Functions / useIsFetching
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsFetching)
*   [
    
    Functions / useIsMutating
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsMutating)
*   [
    
    Functions / useMutationState
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useMutationState)
*   [
    
    Functions / queryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/queryOptions)
*   [
    
    Functions / infiniteQueryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/infiniteQueryOptions)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

API Reference

*   [](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [](https://tanstack.com/query/latest/docs/framework/svelte/reference/index)
*   [
    
    Functions / createQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQuery)
*   [
    
    Functions / createQueries
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQueries)
*   [
    
    Functions / createInfiniteQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createInfiniteQuery)
*   [
    
    Functions / createMutation
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createMutation)
*   [
    
    Functions / useIsFetching
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsFetching)
*   [
    
    Functions / useIsMutating
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsMutating)
*   [
    
    Functions / useMutationState
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useMutationState)
*   [
    
    Functions / queryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/queryOptions)
*   [
    
    Functions / infiniteQueryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/infiniteQueryOptions)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)</content>
</page>

<page>
  <title>useIsRestoring | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsRestoring</url>
  <content>API Reference

*   [](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [](https://tanstack.com/query/latest/docs/framework/svelte/reference/index)
*   [
    
    Functions / createQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQuery)
*   [
    
    Functions / createQueries
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQueries)
*   [
    
    Functions / createInfiniteQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createInfiniteQuery)
*   [
    
    Functions / createMutation
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createMutation)
*   [
    
    Functions / useIsFetching
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsFetching)
*   [
    
    Functions / useIsMutating
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsMutating)
*   [
    
    Functions / useMutationState
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useMutationState)
*   [
    
    Functions / queryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/queryOptions)
*   [
    
    Functions / infiniteQueryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/infiniteQueryOptions)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

API Reference

*   [](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [](https://tanstack.com/query/latest/docs/framework/svelte/reference/index)
*   [
    
    Functions / createQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQuery)
*   [
    
    Functions / createQueries
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQueries)
*   [
    
    Functions / createInfiniteQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createInfiniteQuery)
*   [
    
    Functions / createMutation
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createMutation)
*   [
    
    Functions / useIsFetching
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsFetching)
*   [
    
    Functions / useIsMutating
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsMutating)
*   [
    
    Functions / useMutationState
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useMutationState)
*   [
    
    Functions / queryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/queryOptions)
*   [
    
    Functions / infiniteQueryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/infiniteQueryOptions)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)</content>
</page>

<page>
  <title>useQueryClient | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useQueryClient</url>
  <content>API Reference

*   [](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [](https://tanstack.com/query/latest/docs/framework/svelte/reference/index)
*   [
    
    Functions / createQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQuery)
*   [
    
    Functions / createQueries
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQueries)
*   [
    
    Functions / createInfiniteQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createInfiniteQuery)
*   [
    
    Functions / createMutation
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createMutation)
*   [
    
    Functions / useIsFetching
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsFetching)
*   [
    
    Functions / useIsMutating
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsMutating)
*   [
    
    Functions / useMutationState
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useMutationState)
*   [
    
    Functions / queryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/queryOptions)
*   [
    
    Functions / infiniteQueryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/infiniteQueryOptions)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

API Reference

*   [](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [](https://tanstack.com/query/latest/docs/framework/svelte/reference/index)
*   [
    
    Functions / createQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQuery)
*   [
    
    Functions / createQueries
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createQueries)
*   [
    
    Functions / createInfiniteQuery
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createInfiniteQuery)
*   [
    
    Functions / createMutation
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/createMutation)
*   [
    
    Functions / useIsFetching
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsFetching)
*   [
    
    Functions / useIsMutating
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useIsMutating)
*   [
    
    Functions / useMutationState
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useMutationState)
*   [
    
    Functions / queryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/queryOptions)
*   [
    
    Functions / infiniteQueryOptions
    
    svelte
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/infiniteQueryOptions)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)</content>
</page>

<page>
  <title>useHydrate | TanStack Query Svelte Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/svelte/reference/functions/useHydrate</url>
  <content>ts

    function useHydrate(
       state?, 
       options?, 
       queryClient?): void;
    

    function useHydrate(
       state?, 
       options?, 
       queryClient?): void;</content>
</page>

<page>
  <title>BaseMutationNarrowing | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/BaseMutationNarrowing</url>
  <content>[](#interface-basemutationnarrowingtdata-terror-tvariables-tonmutateresult)[Interface: BaseMutationNarrowing<TData, TError, TVariables, TOnMutateResult>](#interface-basemutationnarrowingtdata-terror-tvariables-tonmutateresult)
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Defined in: [types.ts:190](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/types.ts#L190)

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tdata)[TData](#tdata)

TData = unknown

### [](#terror)[TError](#terror)

TError = DefaultError

### [](#tvariables)[TVariables](#tvariables)

TVariables = unknown

### [](#tonmutateresult)[TOnMutateResult](#tonmutateresult)

TOnMutateResult = unknown

[](#properties)[Properties](#properties)
----------------------------------------

### [](#iserror)[isError](#iserror)

    isError: SignalFunction<(this) => this is CreateMutationResult<TData, TError, TVariables, TOnMutateResult, Override<MutationObserverErrorResult<TData, TError, TVariables, TOnMutateResult>, { mutate: CreateMutateFunction<TData, TError, TVariables, TOnMutateResult> }> & { mutateAsync: CreateMutateAsyncFunction<TData, TError, TVariables, TOnMutateResult> }>>;
    

    isError: SignalFunction<(this) => this is CreateMutationResult<TData, TError, TVariables, TOnMutateResult, Override<MutationObserverErrorResult<TData, TError, TVariables, TOnMutateResult>, { mutate: CreateMutateFunction<TData, TError, TVariables, TOnMutateResult> }> & { mutateAsync: CreateMutateAsyncFunction<TData, TError, TVariables, TOnMutateResult> }>>;
    

Defined in: [types.ts:213](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/types.ts#L213)

* * *

### [](#isidle)[isIdle](#isidle)

    isIdle: SignalFunction<(this) => this is CreateMutationResult<TData, TError, TVariables, TOnMutateResult, Override<MutationObserverIdleResult<TData, TError, TVariables, TOnMutateResult>, { mutate: CreateMutateFunction<TData, TError, TVariables, TOnMutateResult> }> & { mutateAsync: CreateMutateAsyncFunction<TData, TError, TVariables, TOnMutateResult> }>>;
    

    isIdle: SignalFunction<(this) => this is CreateMutationResult<TData, TError, TVariables, TOnMutateResult, Override<MutationObserverIdleResult<TData, TError, TVariables, TOnMutateResult>, { mutate: CreateMutateFunction<TData, TError, TVariables, TOnMutateResult> }> & { mutateAsync: CreateMutateAsyncFunction<TData, TError, TVariables, TOnMutateResult> }>>;
    

Defined in: [types.ts:247](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/types.ts#L247)

* * *

### [](#ispending)[isPending](#ispending)

    isPending: SignalFunction<(this) => this is CreateMutationResult<TData, TError, TVariables, TOnMutateResult, Override<MutationObserverLoadingResult<TData, TError, TVariables, TOnMutateResult>, { mutate: CreateMutateFunction<TData, TError, TVariables, TOnMutateResult> }> & { mutateAsync: CreateMutateAsyncFunction<TData, TError, TVariables, TOnMutateResult> }>>;
    

    isPending: SignalFunction<(this) => this is CreateMutationResult<TData, TError, TVariables, TOnMutateResult, Override<MutationObserverLoadingResult<TData, TError, TVariables, TOnMutateResult>, { mutate: CreateMutateFunction<TData, TError, TVariables, TOnMutateResult> }> & { mutateAsync: CreateMutateAsyncFunction<TData, TError, TVariables, TOnMutateResult> }>>;
    

Defined in: [types.ts:230](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/types.ts#L230)

* * *

### [](#issuccess)[isSuccess](#issuccess)

    isSuccess: SignalFunction<(this) => this is CreateMutationResult<TData, TError, TVariables, TOnMutateResult, Override<MutationObserverSuccessResult<TData, TError, TVariables, TOnMutateResult>, { mutate: CreateMutateFunction<TData, TError, TVariables, TOnMutateResult> }> & { mutateAsync: CreateMutateAsyncFunction<TData, TError, TVariables, TOnMutateResult> }>>;
    

    isSuccess: SignalFunction<(this) => this is CreateMutationResult<TData, TError, TVariables, TOnMutateResult, Override<MutationObserverSuccessResult<TData, TError, TVariables, TOnMutateResult>, { mutate: CreateMutateFunction<TData, TError, TVariables, TOnMutateResult> }> & { mutateAsync: CreateMutateAsyncFunction<TData, TError, TVariables, TOnMutateResult> }>>;
    

Defined in: [types.ts:196](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/types.ts#L196)</content>
</page>

<page>
  <title>BaseQueryNarrowing | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/BaseQueryNarrowing</url>
  <content>[](#interface-basequerynarrowingtdata-terror)[Interface: BaseQueryNarrowing<TData, TError>](#interface-basequerynarrowingtdata-terror)
--------------------------------------------------------------------------------------------------------------------------------------

Defined in: [types.ts:57](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/types.ts#L57)

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tdata)[TData](#tdata)

TData = unknown

### [](#terror)[TError](#terror)

TError = DefaultError

[](#properties)[Properties](#properties)
----------------------------------------

### [](#iserror)[isError()](#iserror)

    isError: (this) => this is CreateBaseQueryResult<TData, TError, CreateStatusBasedQueryResult<"error", TData, TError>>;
    

    isError: (this) => this is CreateBaseQueryResult<TData, TError, CreateStatusBasedQueryResult<"error", TData, TError>>;
    

Defined in: [types.ts:65](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/types.ts#L65)

#### [](#parameters)[Parameters](#parameters)

##### [](#this)[this](#this)

[CreateBaseQueryResult](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/CreateBaseQueryResult)<TData, TError\>

#### [](#returns)[Returns](#returns)

this is CreateBaseQueryResult<TData, TError, CreateStatusBasedQueryResult<"error", TData, TError>>

* * *

### [](#ispending)[isPending()](#ispending)

    isPending: (this) => this is CreateBaseQueryResult<TData, TError, CreateStatusBasedQueryResult<"pending", TData, TError>>;
    

    isPending: (this) => this is CreateBaseQueryResult<TData, TError, CreateStatusBasedQueryResult<"pending", TData, TError>>;
    

Defined in: [types.ts:72](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/types.ts#L72)

#### [](#parameters-1)[Parameters](#parameters-1)

##### [](#this-1)[this](#this-1)

[CreateBaseQueryResult](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/CreateBaseQueryResult)<TData, TError\>

#### [](#returns-1)[Returns](#returns-1)

this is CreateBaseQueryResult<TData, TError, CreateStatusBasedQueryResult<"pending", TData, TError>>

* * *

### [](#issuccess)[isSuccess()](#issuccess)

    isSuccess: (this) => this is CreateBaseQueryResult<TData, TError, CreateStatusBasedQueryResult<"success", TData, TError>>;
    

    isSuccess: (this) => this is CreateBaseQueryResult<TData, TError, CreateStatusBasedQueryResult<"success", TData, TError>>;
    

Defined in: [types.ts:58](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/types.ts#L58)

#### [](#parameters-2)[Parameters](#parameters-2)

##### [](#this-2)[this](#this-2)

[CreateBaseQueryResult](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/CreateBaseQueryResult)<TData, TError\>

#### [](#returns-2)[Returns](#returns-2)

this is CreateBaseQueryResult<TData, TError, CreateStatusBasedQueryResult<"success", TData, TError>></content>
</page>

<page>
  <title>CreateInfiniteQueryOptions | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/CreateInfiniteQueryOptions</url>
  <content>Documentation

Framework

Version

Menu

*   [
    
    Home
    
    
    
    ](https://tanstack.com/query/latest)
*   [
    
    Frameworks
    
    
    
    ](https://tanstack.com/query/latest/docs/framework)
*   [
    
    Contributors
    
    
    
    ](https://tanstack.com/query/latest/docs/contributors)
*   [
    
    Community Resources
    
    
    
    ](https://tanstack.com/query/latest/docs/community-resources)
*   [
    
    GitHub
    
    
    
    ](https://github.com/tanstack/query)
*   [
    
    Discord
    
    
    
    ](https://tlinz.com/discord)

Getting Started

*   [
    
    Overview
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/overview)
*   [
    
    Installation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/installation)
*   [
    
    Quick Start
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/quick-start)
*   [
    
    Angular HttpClient and other data fetching clients
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/angular-httpclient-and-other-data-fetching-clients)
*   [
    
    Devtools
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/devtools)
*   [
    
    TypeScript
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/typescript)
*   [
    
    Zoneless
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/zoneless)

Guides & Concepts

*   [
    
    Important Defaults
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/important-defaults)
*   [
    
    Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/queries)
*   [
    
    Query Keys
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-keys)
*   [
    
    Query Functions
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-functions)
*   [
    
    Query Options
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-options)
*   [
    
    Network Mode
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/network-mode)
*   [
    
    Parallel Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/parallel-queries)
*   [
    
    Dependent Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/disabling-queries)
*   [
    
    Query Retries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-retries)
*   [
    
    Paginated Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/paginated-queries)
*   [
    
    Infinite Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/infinite-queries)
*   [
    
    Initial Query Data
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/placeholder-query-data)
*   [
    
    Mutations
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/mutations)
*   [
    
    Mutation Options
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/mutation-options)
*   [
    
    Query Invalidation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/invalidations-from-mutations)
*   [
    
    Optimistic Updates
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/optimistic-updates)
*   [
    
    Query Cancellation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-cancellation)
*   [
    
    Scroll Restoration
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/scroll-restoration)
*   [
    
    Filters
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/filters)
*   [
    
    Caching
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/caching)
*   [
    
    Default Query Fn
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/default-query-function)
*   [
    
    Testing
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/testing)
*   [
    
    Does this replace state managers?
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/does-this-replace-client-state)

API Reference

*   [
    
    QueryClient
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [
    
    QueryCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [
    
    MutationCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [
    
    QueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [
    
    QueriesObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [
    
    streamedQuery
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [
    
    focusManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [
    
    onlineManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [
    
    notifyManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [
    
    timeoutManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [
    
    Angular Reference
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/reference/index)
*   [
    
    Functions / injectQuery
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectQuery)
*   [
    
    Functions / injectMutation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectMutation)

ESLint

*   [
    
    ESLint Plugin Query
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [
    
    Exhaustive Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [
    
    Stable Query Client
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [
    
    No Unstable Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Examples

*   [
    
    Simple
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/simple)
*   [
    
    Basic
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/basic)
*   [
    
    Auto Refetching / Polling / Realtime
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/auto-refetching)
*   [
    
    Optimistic Updates
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/optimistic-updates)
*   [
    
    Pagination
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/pagination)
*   [
    
    Infinite query with maxPages
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/infinite-query-with-max-pages)
*   [
    
    Angular Router
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/router)
*   [
    
    RxJS autocomplete
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/rxjs)
*   [
    
    Query options from a service
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/query-options-from-a-service)
*   [
    
    Devtools embedded panel
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/devtools-panel)

Framework

Version

Menu

*   [
    
    Home
    
    
    
    ](https://tanstack.com/query/latest)
*   [
    
    Frameworks
    
    
    
    ](https://tanstack.com/query/latest/docs/framework)
*   [
    
    Contributors
    
    
    
    ](https://tanstack.com/query/latest/docs/contributors)
*   [
    
    Community Resources
    
    
    
    ](https://tanstack.com/query/latest/docs/community-resources)
*   [
    
    GitHub
    
    
    
    ](https://github.com/tanstack/query)
*   [
    
    Discord
    
    
    
    ](https://tlinz.com/discord)

Getting Started

*   [
    
    Overview
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/overview)
*   [
    
    Installation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/installation)
*   [
    
    Quick Start
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/quick-start)
*   [
    
    Angular HttpClient and other data fetching clients
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/angular-httpclient-and-other-data-fetching-clients)
*   [
    
    Devtools
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/devtools)
*   [
    
    TypeScript
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/typescript)
*   [
    
    Zoneless
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/zoneless)

Guides & Concepts

*   [
    
    Important Defaults
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/important-defaults)
*   [
    
    Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/queries)
*   [
    
    Query Keys
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-keys)
*   [
    
    Query Functions
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-functions)
*   [
    
    Query Options
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-options)
*   [
    
    Network Mode
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/network-mode)
*   [
    
    Parallel Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/parallel-queries)
*   [
    
    Dependent Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/disabling-queries)
*   [
    
    Query Retries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-retries)
*   [
    
    Paginated Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/paginated-queries)
*   [
    
    Infinite Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/infinite-queries)
*   [
    
    Initial Query Data
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/placeholder-query-data)
*   [
    
    Mutations
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/mutations)
*   [
    
    Mutation Options
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/mutation-options)
*   [
    
    Query Invalidation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/invalidations-from-mutations)
*   [
    
    Optimistic Updates
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/optimistic-updates)
*   [
    
    Query Cancellation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-cancellation)
*   [
    
    Scroll Restoration
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/scroll-restoration)
*   [
    
    Filters
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/filters)
*   [
    
    Caching
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/caching)
*   [
    
    Default Query Fn
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/default-query-function)
*   [
    
    Testing
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/testing)
*   [
    
    Does this replace state managers?
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/does-this-replace-client-state)

API Reference

*   [
    
    QueryClient
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [
    
    QueryCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [
    
    MutationCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [
    
    QueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [
    
    QueriesObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [
    
    streamedQuery
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [
    
    focusManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [
    
    onlineManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [
    
    notifyManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [
    
    timeoutManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [
    
    Angular Reference
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/reference/index)
*   [
    
    Functions / injectQuery
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectQuery)
*   [
    
    Functions / injectMutation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectMutation)

ESLint

*   [
    
    ESLint Plugin Query
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [
    
    Exhaustive Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [
    
    Stable Query Client
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [
    
    No Unstable Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Examples

*   [
    
    Simple
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/simple)
*   [
    
    Basic
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/basic)
*   [
    
    Auto Refetching / Polling / Realtime
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/auto-refetching)
*   [
    
    Optimistic Updates
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/optimistic-updates)
*   [
    
    Pagination
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/pagination)
*   [
    
    Infinite query with maxPages
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/infinite-query-with-max-pages)
*   [
    
    Angular Router
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/router)
*   [
    
    RxJS autocomplete
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/rxjs)
*   [
    
    Query options from a service
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/query-options-from-a-service)
*   [
    
    Devtools embedded panel
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/devtools-panel)

[Learn about TanStack Ads](https://tanstack.com/ads)[Hide Ads](https://tanstack.com/ads#hide-ads)

[](#interface-createinfinitequeryoptionstqueryfndata-terror-tdata-tquerykey-tpageparam)[Interface: CreateInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>](#interface-createinfinitequeryoptionstqueryfndata-terror-tdata-tquerykey-tpageparam)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Defined in: [types.ts:81](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/types.ts#L81)

[](#extends)[Extends](#extends)
-------------------------------

*   OmitKeyof<InfiniteQueryObserverOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam\>, "suspense"\>

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tqueryfndata)[TQueryFnData](#tqueryfndata)

TQueryFnData = unknown

### [](#terror)[TError](#terror)

TError = DefaultError

### [](#tdata)[TData](#tdata)

TData = TQueryFnData

### [](#tquerykey)[TQueryKey](#tquerykey)

TQueryKey _extends_ QueryKey = QueryKey

### [](#tpageparam)[TPageParam](#tpageparam)

TPageParam = unknown

[Edit on GitHub](https://github.com/tanstack/query/edit/main/docs/framework/angular/reference/interfaces/CreateInfiniteQueryOptions.md)

[Learn about TanStack Ads](https://tanstack.com/ads)[Hide Ads](https://tanstack.com/ads#hide-ads)

[

Home



](https://tanstack.com/query/latest)

[Partners](https://tanstack.com/partners)[Become a Partner](https://docs.google.com/document/d/1Hg2MzY2TU6U3hFEZ3MLe2oEOM3JS4-eByti3kdJU3I8)

[](https://coderabbit.link/tanstack?utm_source=tanstack&via=tanstack)[](https://www.cloudflare.com/?utm_source=tanstack)[](https://ag-grid.com/react-data-grid/?utm_source=reacttable&utm_campaign=githubreacttable)[](https://netlify.com/?utm_source=tanstack)[](https://neon.tech/?utm_source=tanstack)[](https://workos.com/?utm_source=tanstack)[](https://go.clerk.com/wOwHtuJ)[](https://convex.dev/?utm_source=tanstack)[](https://electric-sql.com/)[](https://sentry.io/?utm_source=tanstack)[](https://www.prisma.io/?utm_source=tanstack&via=tanstack)[](https://strapi.link/tanstack-start)[](https://www.unkey.com/?utm_source=tanstack)

[Learn about TanStack Ads](https://tanstack.com/ads)[Hide Ads](https://tanstack.com/ads#hide-ads)

[

###### Want to Skip the Docs?

Query.gg - The Official React Query Course

Black Friday Sale
-----------------

Get 50% off through December 6th

01

days

:

22

hours

:

50

minutes









](https://query.gg/?s=tanstack)</content>
</page>

<page>
  <title>CreateBaseQueryOptions | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/CreateBaseQueryOptions</url>
  <content>Documentation

Framework

Version

Menu

*   [
    
    Home
    
    
    
    ](https://tanstack.com/query/latest)
*   [
    
    Frameworks
    
    
    
    ](https://tanstack.com/query/latest/docs/framework)
*   [
    
    Contributors
    
    
    
    ](https://tanstack.com/query/latest/docs/contributors)
*   [
    
    Community Resources
    
    
    
    ](https://tanstack.com/query/latest/docs/community-resources)
*   [
    
    GitHub
    
    
    
    ](https://github.com/tanstack/query)
*   [
    
    Discord
    
    
    
    ](https://tlinz.com/discord)

Getting Started

*   [
    
    Overview
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/overview)
*   [
    
    Installation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/installation)
*   [
    
    Quick Start
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/quick-start)
*   [
    
    Angular HttpClient and other data fetching clients
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/angular-httpclient-and-other-data-fetching-clients)
*   [
    
    Devtools
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/devtools)
*   [
    
    TypeScript
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/typescript)
*   [
    
    Zoneless
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/zoneless)

Guides & Concepts

*   [
    
    Important Defaults
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/important-defaults)
*   [
    
    Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/queries)
*   [
    
    Query Keys
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-keys)
*   [
    
    Query Functions
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-functions)
*   [
    
    Query Options
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-options)
*   [
    
    Network Mode
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/network-mode)
*   [
    
    Parallel Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/parallel-queries)
*   [
    
    Dependent Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/disabling-queries)
*   [
    
    Query Retries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-retries)
*   [
    
    Paginated Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/paginated-queries)
*   [
    
    Infinite Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/infinite-queries)
*   [
    
    Initial Query Data
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/placeholder-query-data)
*   [
    
    Mutations
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/mutations)
*   [
    
    Mutation Options
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/mutation-options)
*   [
    
    Query Invalidation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/invalidations-from-mutations)
*   [
    
    Optimistic Updates
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/optimistic-updates)
*   [
    
    Query Cancellation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-cancellation)
*   [
    
    Scroll Restoration
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/scroll-restoration)
*   [
    
    Filters
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/filters)
*   [
    
    Caching
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/caching)
*   [
    
    Default Query Fn
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/default-query-function)
*   [
    
    Testing
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/testing)
*   [
    
    Does this replace state managers?
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/does-this-replace-client-state)

API Reference

*   [
    
    QueryClient
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [
    
    QueryCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [
    
    MutationCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [
    
    QueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [
    
    QueriesObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [
    
    streamedQuery
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [
    
    focusManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [
    
    onlineManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [
    
    notifyManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [
    
    timeoutManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [
    
    Angular Reference
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/reference/index)
*   [
    
    Functions / injectQuery
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectQuery)
*   [
    
    Functions / injectMutation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectMutation)

ESLint

*   [
    
    ESLint Plugin Query
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [
    
    Exhaustive Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [
    
    Stable Query Client
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [
    
    No Unstable Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Examples

*   [
    
    Simple
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/simple)
*   [
    
    Basic
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/basic)
*   [
    
    Auto Refetching / Polling / Realtime
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/auto-refetching)
*   [
    
    Optimistic Updates
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/optimistic-updates)
*   [
    
    Pagination
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/pagination)
*   [
    
    Infinite query with maxPages
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/infinite-query-with-max-pages)
*   [
    
    Angular Router
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/router)
*   [
    
    RxJS autocomplete
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/rxjs)
*   [
    
    Query options from a service
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/query-options-from-a-service)
*   [
    
    Devtools embedded panel
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/devtools-panel)

Framework

Version

Menu

*   [
    
    Home
    
    
    
    ](https://tanstack.com/query/latest)
*   [
    
    Frameworks
    
    
    
    ](https://tanstack.com/query/latest/docs/framework)
*   [
    
    Contributors
    
    
    
    ](https://tanstack.com/query/latest/docs/contributors)
*   [
    
    Community Resources
    
    
    
    ](https://tanstack.com/query/latest/docs/community-resources)
*   [
    
    GitHub
    
    
    
    ](https://github.com/tanstack/query)
*   [
    
    Discord
    
    
    
    ](https://tlinz.com/discord)

Getting Started

*   [
    
    Overview
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/overview)
*   [
    
    Installation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/installation)
*   [
    
    Quick Start
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/quick-start)
*   [
    
    Angular HttpClient and other data fetching clients
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/angular-httpclient-and-other-data-fetching-clients)
*   [
    
    Devtools
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/devtools)
*   [
    
    TypeScript
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/typescript)
*   [
    
    Zoneless
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/zoneless)

Guides & Concepts

*   [
    
    Important Defaults
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/important-defaults)
*   [
    
    Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/queries)
*   [
    
    Query Keys
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-keys)
*   [
    
    Query Functions
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-functions)
*   [
    
    Query Options
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-options)
*   [
    
    Network Mode
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/network-mode)
*   [
    
    Parallel Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/parallel-queries)
*   [
    
    Dependent Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/disabling-queries)
*   [
    
    Query Retries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-retries)
*   [
    
    Paginated Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/paginated-queries)
*   [
    
    Infinite Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/infinite-queries)
*   [
    
    Initial Query Data
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/placeholder-query-data)
*   [
    
    Mutations
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/mutations)
*   [
    
    Mutation Options
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/mutation-options)
*   [
    
    Query Invalidation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/invalidations-from-mutations)
*   [
    
    Optimistic Updates
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/optimistic-updates)
*   [
    
    Query Cancellation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-cancellation)
*   [
    
    Scroll Restoration
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/scroll-restoration)
*   [
    
    Filters
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/filters)
*   [
    
    Caching
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/caching)
*   [
    
    Default Query Fn
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/default-query-function)
*   [
    
    Testing
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/testing)
*   [
    
    Does this replace state managers?
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/does-this-replace-client-state)

API Reference

*   [
    
    QueryClient
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [
    
    QueryCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [
    
    MutationCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [
    
    QueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [
    
    QueriesObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [
    
    streamedQuery
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [
    
    focusManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [
    
    onlineManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [
    
    notifyManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [
    
    timeoutManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [
    
    Angular Reference
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/reference/index)
*   [
    
    Functions / injectQuery
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectQuery)
*   [
    
    Functions / injectMutation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectMutation)

ESLint

*   [
    
    ESLint Plugin Query
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [
    
    Exhaustive Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [
    
    Stable Query Client
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [
    
    No Unstable Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Examples

*   [
    
    Simple
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/simple)
*   [
    
    Basic
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/basic)
*   [
    
    Auto Refetching / Polling / Realtime
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/auto-refetching)
*   [
    
    Optimistic Updates
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/optimistic-updates)
*   [
    
    Pagination
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/pagination)
*   [
    
    Infinite query with maxPages
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/infinite-query-with-max-pages)
*   [
    
    Angular Router
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/router)
*   [
    
    RxJS autocomplete
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/rxjs)
*   [
    
    Query options from a service
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/query-options-from-a-service)
*   [
    
    Devtools embedded panel
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/devtools-panel)

[Learn about TanStack Ads](https://tanstack.com/ads)[Hide Ads](https://tanstack.com/ads#hide-ads)

[](#interface-createbasequeryoptionstqueryfndata-terror-tdata-tquerydata-tquerykey)[Interface: CreateBaseQueryOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>](#interface-createbasequeryoptionstqueryfndata-terror-tdata-tquerydata-tquerykey)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Defined in: [types.ts:21](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/types.ts#L21)

[](#extends)[Extends](#extends)
-------------------------------

*   QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey\>

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tqueryfndata)[TQueryFnData](#tqueryfndata)

TQueryFnData = unknown

### [](#terror)[TError](#terror)

TError = DefaultError

### [](#tdata)[TData](#tdata)

TData = TQueryFnData

### [](#tquerydata)[TQueryData](#tquerydata)

TQueryData = TQueryFnData

### [](#tquerykey)[TQueryKey](#tquerykey)

TQueryKey _extends_ QueryKey = QueryKey

[Edit on GitHub](https://github.com/tanstack/query/edit/main/docs/framework/angular/reference/interfaces/CreateBaseQueryOptions.md)

[Learn about TanStack Ads](https://tanstack.com/ads)[Hide Ads](https://tanstack.com/ads#hide-ads)

[

Home



](https://tanstack.com/query/latest)

[Partners](https://tanstack.com/partners)[Become a Partner](https://docs.google.com/document/d/1Hg2MzY2TU6U3hFEZ3MLe2oEOM3JS4-eByti3kdJU3I8)

[](https://coderabbit.link/tanstack?utm_source=tanstack&via=tanstack)[](https://www.cloudflare.com/?utm_source=tanstack)[](https://ag-grid.com/react-data-grid/?utm_source=reacttable&utm_campaign=githubreacttable)[](https://netlify.com/?utm_source=tanstack)[](https://neon.tech/?utm_source=tanstack)[](https://workos.com/?utm_source=tanstack)[](https://go.clerk.com/wOwHtuJ)[](https://convex.dev/?utm_source=tanstack)[](https://electric-sql.com/)[](https://sentry.io/?utm_source=tanstack)[](https://www.prisma.io/?utm_source=tanstack&via=tanstack)[](https://strapi.link/tanstack-start)[](https://www.unkey.com/?utm_source=tanstack)

[Learn about TanStack Ads](https://tanstack.com/ads)[Hide Ads](https://tanstack.com/ads#hide-ads)

[

###### Want to Skip the Docs?

Query.gg - The Official React Query Course

Black Friday Sale
-----------------

Get 50% off through December 6th

01

days

:

22

hours

:

50

minutes









](https://query.gg/?s=tanstack)</content>
</page>

<page>
  <title>CreateQueryOptions | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/CreateQueryOptions</url>
  <content>Guides & Concepts

*   [
    
    Important Defaults
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/important-defaults)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/queries)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/query-keys)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/query-functions)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/query-options)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/network-mode)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/parallel-queries)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/disabling-queries)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/query-retries)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/paginated-queries)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/infinite-queries)
*   [
    
    Initial Query Data
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/placeholder-query-data)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/mutations)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/mutation-options)
*   [
    
    Query Invalidation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/invalidations-from-mutations)
*   [
    
    Optimistic Updates
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/optimistic-updates)
*   [
    
    Query Cancellation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-cancellation)
*   [
    
    Scroll Restoration
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/scroll-restoration)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/filters)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/caching)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/default-query-function)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/testing)
*   [
    
    Does this replace state managers?
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/does-this-replace-client-state)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Examples

*   [](https://tanstack.com/query/latest/docs/framework/angular/examples/simple)
*   [](https://tanstack.com/query/latest/docs/framework/angular/examples/basic)
*   [
    
    Auto Refetching / Polling / Realtime
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/auto-refetching)
*   [
    
    Optimistic Updates
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/optimistic-updates)
*   [](https://tanstack.com/query/latest/docs/framework/angular/examples/pagination)
*   [
    
    Infinite query with maxPages
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/infinite-query-with-max-pages)
*   [](https://tanstack.com/query/latest/docs/framework/angular/examples/router)
*   [](https://tanstack.com/query/latest/docs/framework/angular/examples/rxjs)
*   [
    
    Query options from a service
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/query-options-from-a-service)
*   [
    
    Devtools embedded panel
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/devtools-panel)

Guides & Concepts

*   [
    
    Important Defaults
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/important-defaults)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/queries)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/query-keys)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/query-functions)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/query-options)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/network-mode)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/parallel-queries)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/disabling-queries)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/query-retries)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/paginated-queries)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/infinite-queries)
*   [
    
    Initial Query Data
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/placeholder-query-data)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/mutations)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/mutation-options)
*   [
    
    Query Invalidation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/invalidations-from-mutations)
*   [
    
    Optimistic Updates
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/optimistic-updates)
*   [
    
    Query Cancellation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-cancellation)
*   [
    
    Scroll Restoration
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/scroll-restoration)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/filters)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/caching)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/default-query-function)
*   [](https://tanstack.com/query/latest/docs/framework/angular/guides/testing)
*   [
    
    Does this replace state managers?
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/does-this-replace-client-state)

ESLint

*   [](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Examples

*   [](https://tanstack.com/query/latest/docs/framework/angular/examples/simple)
*   [](https://tanstack.com/query/latest/docs/framework/angular/examples/basic)
*   [
    
    Auto Refetching / Polling / Realtime
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/auto-refetching)
*   [
    
    Optimistic Updates
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/optimistic-updates)
*   [](https://tanstack.com/query/latest/docs/framework/angular/examples/pagination)
*   [
    
    Infinite query with maxPages
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/infinite-query-with-max-pages)
*   [](https://tanstack.com/query/latest/docs/framework/angular/examples/router)
*   [](https://tanstack.com/query/latest/docs/framework/angular/examples/rxjs)
*   [
    
    Query options from a service
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/query-options-from-a-service)
*   [
    
    Devtools embedded panel
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/devtools-panel)</content>
</page>

<page>
  <title>CreateMutationOptions | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/CreateMutationOptions</url>
  <content>Documentation

Framework

Version

Menu

*   [
    
    Home
    
    
    
    ](https://tanstack.com/query/latest)
*   [
    
    Frameworks
    
    
    
    ](https://tanstack.com/query/latest/docs/framework)
*   [
    
    Contributors
    
    
    
    ](https://tanstack.com/query/latest/docs/contributors)
*   [
    
    Community Resources
    
    
    
    ](https://tanstack.com/query/latest/docs/community-resources)
*   [
    
    GitHub
    
    
    
    ](https://github.com/tanstack/query)
*   [
    
    Discord
    
    
    
    ](https://tlinz.com/discord)

Getting Started

*   [
    
    Overview
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/overview)
*   [
    
    Installation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/installation)
*   [
    
    Quick Start
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/quick-start)
*   [
    
    Angular HttpClient and other data fetching clients
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/angular-httpclient-and-other-data-fetching-clients)
*   [
    
    Devtools
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/devtools)
*   [
    
    TypeScript
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/typescript)
*   [
    
    Zoneless
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/zoneless)

Guides & Concepts

*   [
    
    Important Defaults
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/important-defaults)
*   [
    
    Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/queries)
*   [
    
    Query Keys
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-keys)
*   [
    
    Query Functions
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-functions)
*   [
    
    Query Options
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-options)
*   [
    
    Network Mode
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/network-mode)
*   [
    
    Parallel Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/parallel-queries)
*   [
    
    Dependent Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/disabling-queries)
*   [
    
    Query Retries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-retries)
*   [
    
    Paginated Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/paginated-queries)
*   [
    
    Infinite Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/infinite-queries)
*   [
    
    Initial Query Data
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/placeholder-query-data)
*   [
    
    Mutations
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/mutations)
*   [
    
    Mutation Options
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/mutation-options)
*   [
    
    Query Invalidation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/invalidations-from-mutations)
*   [
    
    Optimistic Updates
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/optimistic-updates)
*   [
    
    Query Cancellation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-cancellation)
*   [
    
    Scroll Restoration
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/scroll-restoration)
*   [
    
    Filters
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/filters)
*   [
    
    Caching
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/caching)
*   [
    
    Default Query Fn
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/default-query-function)
*   [
    
    Testing
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/testing)
*   [
    
    Does this replace state managers?
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/does-this-replace-client-state)

API Reference

*   [
    
    QueryClient
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [
    
    QueryCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [
    
    MutationCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [
    
    QueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [
    
    QueriesObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [
    
    streamedQuery
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [
    
    focusManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [
    
    onlineManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [
    
    notifyManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [
    
    timeoutManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [
    
    Angular Reference
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/reference/index)
*   [
    
    Functions / injectQuery
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectQuery)
*   [
    
    Functions / injectMutation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectMutation)

ESLint

*   [
    
    ESLint Plugin Query
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [
    
    Exhaustive Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [
    
    Stable Query Client
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [
    
    No Unstable Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Examples

*   [
    
    Simple
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/simple)
*   [
    
    Basic
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/basic)
*   [
    
    Auto Refetching / Polling / Realtime
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/auto-refetching)
*   [
    
    Optimistic Updates
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/optimistic-updates)
*   [
    
    Pagination
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/pagination)
*   [
    
    Infinite query with maxPages
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/infinite-query-with-max-pages)
*   [
    
    Angular Router
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/router)
*   [
    
    RxJS autocomplete
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/rxjs)
*   [
    
    Query options from a service
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/query-options-from-a-service)
*   [
    
    Devtools embedded panel
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/devtools-panel)

Framework

Version

Menu

*   [
    
    Home
    
    
    
    ](https://tanstack.com/query/latest)
*   [
    
    Frameworks
    
    
    
    ](https://tanstack.com/query/latest/docs/framework)
*   [
    
    Contributors
    
    
    
    ](https://tanstack.com/query/latest/docs/contributors)
*   [
    
    Community Resources
    
    
    
    ](https://tanstack.com/query/latest/docs/community-resources)
*   [
    
    GitHub
    
    
    
    ](https://github.com/tanstack/query)
*   [
    
    Discord
    
    
    
    ](https://tlinz.com/discord)

Getting Started

*   [
    
    Overview
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/overview)
*   [
    
    Installation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/installation)
*   [
    
    Quick Start
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/quick-start)
*   [
    
    Angular HttpClient and other data fetching clients
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/angular-httpclient-and-other-data-fetching-clients)
*   [
    
    Devtools
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/devtools)
*   [
    
    TypeScript
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/typescript)
*   [
    
    Zoneless
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/zoneless)

Guides & Concepts

*   [
    
    Important Defaults
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/important-defaults)
*   [
    
    Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/queries)
*   [
    
    Query Keys
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-keys)
*   [
    
    Query Functions
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-functions)
*   [
    
    Query Options
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-options)
*   [
    
    Network Mode
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/network-mode)
*   [
    
    Parallel Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/parallel-queries)
*   [
    
    Dependent Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/dependent-queries)
*   [
    
    Background Fetching Indicators
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/background-fetching-indicators)
*   [
    
    Window Focus Refetching
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/window-focus-refetching)
*   [
    
    Disabling/Pausing Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/disabling-queries)
*   [
    
    Query Retries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-retries)
*   [
    
    Paginated Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/paginated-queries)
*   [
    
    Infinite Queries
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/infinite-queries)
*   [
    
    Initial Query Data
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/initial-query-data)
*   [
    
    Placeholder Query Data
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/placeholder-query-data)
*   [
    
    Mutations
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/mutations)
*   [
    
    Mutation Options
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/mutation-options)
*   [
    
    Query Invalidation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-invalidation)
*   [
    
    Invalidation from Mutations
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/invalidations-from-mutations)
*   [
    
    Optimistic Updates
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/optimistic-updates)
*   [
    
    Query Cancellation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/query-cancellation)
*   [
    
    Scroll Restoration
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/scroll-restoration)
*   [
    
    Filters
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/filters)
*   [
    
    Caching
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/caching)
*   [
    
    Default Query Fn
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/default-query-function)
*   [
    
    Testing
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/testing)
*   [
    
    Does this replace state managers?
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/guides/does-this-replace-client-state)

API Reference

*   [
    
    QueryClient
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryClient)
*   [
    
    QueryCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryCache)
*   [
    
    MutationCache
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/MutationCache)
*   [
    
    QueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueryObserver)
*   [
    
    InfiniteQueryObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/InfiniteQueryObserver)
*   [
    
    QueriesObserver
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/QueriesObserver)
*   [
    
    streamedQuery
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/streamedQuery)
*   [
    
    focusManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/focusManager)
*   [
    
    onlineManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/onlineManager)
*   [
    
    notifyManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/notifyManager)
*   [
    
    timeoutManager
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/reference/timeoutManager)
*   [
    
    Angular Reference
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/reference/index)
*   [
    
    Functions / injectQuery
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectQuery)
*   [
    
    Functions / injectMutation
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectMutation)

ESLint

*   [
    
    ESLint Plugin Query
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/eslint-plugin-query)
*   [
    
    Exhaustive Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/exhaustive-deps)
*   [
    
    Stable Query Client
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/stable-query-client)
*   [
    
    No Rest Destructuring
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-rest-destructuring)
*   [
    
    No Unstable Deps
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/no-unstable-deps)
*   [
    
    Infinite Query Property Order
    
    core
    
    
    
    ](https://tanstack.com/query/latest/docs/eslint/infinite-query-property-order)

Examples

*   [
    
    Simple
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/simple)
*   [
    
    Basic
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/basic)
*   [
    
    Auto Refetching / Polling / Realtime
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/auto-refetching)
*   [
    
    Optimistic Updates
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/optimistic-updates)
*   [
    
    Pagination
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/pagination)
*   [
    
    Infinite query with maxPages
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/infinite-query-with-max-pages)
*   [
    
    Angular Router
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/router)
*   [
    
    RxJS autocomplete
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/rxjs)
*   [
    
    Query options from a service
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/query-options-from-a-service)
*   [
    
    Devtools embedded panel
    
    angular
    
    
    
    ](https://tanstack.com/query/latest/docs/framework/angular/examples/devtools-panel)

[Learn about TanStack Ads](https://tanstack.com/ads)[Hide Ads](https://tanstack.com/ads#hide-ads)

[](#interface-createmutationoptionstdata-terror-tvariables-tonmutateresult)[Interface: CreateMutationOptions<TData, TError, TVariables, TOnMutateResult>](#interface-createmutationoptionstdata-terror-tvariables-tonmutateresult)
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Defined in: [types.ts:132](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/types.ts#L132)

[](#extends)[Extends](#extends)
-------------------------------

*   OmitKeyof<MutationObserverOptions<TData, TError, TVariables, TOnMutateResult\>, "\_defaulted"\>

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tdata)[TData](#tdata)

TData = unknown

### [](#terror)[TError](#terror)

TError = DefaultError

### [](#tvariables)[TVariables](#tvariables)

TVariables = void

### [](#tonmutateresult)[TOnMutateResult](#tonmutateresult)

TOnMutateResult = unknown

[Edit on GitHub](https://github.com/tanstack/query/edit/main/docs/framework/angular/reference/interfaces/CreateMutationOptions.md)

[Learn about TanStack Ads](https://tanstack.com/ads)[Hide Ads](https://tanstack.com/ads#hide-ads)

[

Home



](https://tanstack.com/query/latest)

[Partners](https://tanstack.com/partners)[Become a Partner](https://docs.google.com/document/d/1Hg2MzY2TU6U3hFEZ3MLe2oEOM3JS4-eByti3kdJU3I8)

[](https://coderabbit.link/tanstack?utm_source=tanstack&via=tanstack)[](https://www.cloudflare.com/?utm_source=tanstack)[](https://ag-grid.com/react-data-grid/?utm_source=reacttable&utm_campaign=githubreacttable)[](https://netlify.com/?utm_source=tanstack)[](https://neon.tech/?utm_source=tanstack)[](https://workos.com/?utm_source=tanstack)[](https://go.clerk.com/wOwHtuJ)[](https://convex.dev/?utm_source=tanstack)[](https://electric-sql.com/)[](https://sentry.io/?utm_source=tanstack)[](https://www.prisma.io/?utm_source=tanstack&via=tanstack)[](https://strapi.link/tanstack-start)[](https://www.unkey.com/?utm_source=tanstack)

[Learn about TanStack Ads](https://tanstack.com/ads)[Hide Ads](https://tanstack.com/ads#hide-ads)

[

###### Want to Skip the Docs?

Query.gg - The Official React Query Course

Black Friday Sale
-----------------

Get 50% off through December 6th

01

days

:

22

hours

:

50

minutes









](https://query.gg/?s=tanstack)</content>
</page>

<page>
  <title>InjectIsFetchingOptions | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/InjectIsFetchingOptions</url>
  <content>[](#interface-injectisfetchingoptions)[Interface: InjectIsFetchingOptions](#interface-injectisfetchingoptions)
--------------------------------------------------------------------------------------------------------------

Defined in: [inject-is-fetching.ts:13](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/inject-is-fetching.ts#L13)

[](#properties)[Properties](#properties)
----------------------------------------

### [](#injector)[injector?](#injector)

ts

    optional injector: Injector;
    

    optional injector: Injector;
    

Defined in: [inject-is-fetching.ts:19](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/inject-is-fetching.ts#L19)

The Injector in which to create the isFetching signal.

If this is not provided, the current injection context will be used instead (via inject).</content>
</page>

<page>
  <title>InjectInfiniteQueryOptions | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/InjectInfiniteQueryOptions</url>
  <content>[](#interface-injectinfinitequeryoptions)[Interface: InjectInfiniteQueryOptions](#interface-injectinfinitequeryoptions)
-----------------------------------------------------------------------------------------------------------------------

Defined in: [inject-infinite-query.ts:25](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/inject-infinite-query.ts#L25)

[](#properties)[Properties](#properties)
----------------------------------------

### [](#injector)[injector?](#injector)

ts

    optional injector: Injector;
    

    optional injector: Injector;
    

Defined in: [inject-infinite-query.ts:31](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/inject-infinite-query.ts#L31)

The Injector in which to create the infinite query.

If this is not provided, the current injection context will be used instead (via inject).</content>
</page>

<page>
  <title>InjectIsMutatingOptions | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/InjectIsMutatingOptions</url>
  <content>[](#interface-injectismutatingoptions)[Interface: InjectIsMutatingOptions](#interface-injectismutatingoptions)
--------------------------------------------------------------------------------------------------------------

Defined in: [inject-is-mutating.ts:13](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/inject-is-mutating.ts#L13)

[](#properties)[Properties](#properties)
----------------------------------------

### [](#injector)[injector?](#injector)

ts

    optional injector: Injector;
    

    optional injector: Injector;
    

Defined in: [inject-is-mutating.ts:19](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/inject-is-mutating.ts#L19)

The Injector in which to create the isMutating signal.

If this is not provided, the current injection context will be used instead (via inject).</content>
</page>

<page>
  <title>InjectMutationOptions | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/InjectMutationOptions</url>
  <content>[](#interface-injectmutationoptions)[Interface: InjectMutationOptions](#interface-injectmutationoptions)
--------------------------------------------------------------------------------------------------------

Defined in: [inject-mutation.ts:28](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/inject-mutation.ts#L28)

[](#properties)[Properties](#properties)
----------------------------------------

### [](#injector)[injector?](#injector)

ts

    optional injector: Injector;
    

    optional injector: Injector;
    

Defined in: [inject-mutation.ts:34](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/inject-mutation.ts#L34)

The Injector in which to create the mutation.

If this is not provided, the current injection context will be used instead (via inject).</content>
</page>

<page>
  <title>InjectMutationStateOptions | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/InjectMutationStateOptions</url>
  <content>[](#interface-injectmutationstateoptions)[Interface: InjectMutationStateOptions](#interface-injectmutationstateoptions)
-----------------------------------------------------------------------------------------------------------------------

Defined in: [inject-mutation-state.ts:45](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/inject-mutation-state.ts#L45)

[](#properties)[Properties](#properties)
----------------------------------------

### [](#injector)[injector?](#injector)

ts

    optional injector: Injector;
    

    optional injector: Injector;
    

Defined in: [inject-mutation-state.ts:51](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/inject-mutation-state.ts#L51)

The Injector in which to create the mutation state signal.

If this is not provided, the current injection context will be used instead (via inject).</content>
</page>

<page>
  <title>InjectQueryOptions | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/InjectQueryOptions</url>
  <content>[](#interface-injectqueryoptions)[Interface: InjectQueryOptions](#interface-injectqueryoptions)
-----------------------------------------------------------------------------------------------

Defined in: [inject-query.ts:20](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/inject-query.ts#L20)

[](#properties)[Properties](#properties)
----------------------------------------

### [](#injector)[injector?](#injector)

ts

    optional injector: Injector;
    

    optional injector: Injector;
    

Defined in: [inject-query.ts:26](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/inject-query.ts#L26)

The Injector in which to create the query.

If this is not provided, the current injection context will be used instead (via inject).</content>
</page>

<page>
  <title>QueryFeature | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/QueryFeature</url>
  <content>[](#interface-queryfeaturetfeaturekind)[Interface: QueryFeature<TFeatureKind>](#interface-queryfeaturetfeaturekind)
-------------------------------------------------------------------------------------------------------------------

Defined in: [providers.ts:135](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/providers.ts#L135)

Helper type to represent a Query feature.

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tfeaturekind)[TFeatureKind](#tfeaturekind)

TFeatureKind _extends_ QueryFeatureKind

[](#properties)[Properties](#properties)
----------------------------------------

### [](#…µkind)[…µkind](#…µkind)

ts

    …µkind: TFeatureKind;
    

    …µkind: TFeatureKind;
    

Defined in: [providers.ts:136](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/providers.ts#L136)

* * *

### [](#…µproviders)[…µproviders](#…µproviders)

ts

    …µproviders: Provider[];
    

    …µproviders: Provider[];
    

Defined in: [providers.ts:137](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/providers.ts#L137)</content>
</page>

<page>
  <title>CreateBaseQueryResult | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/CreateBaseQueryResult</url>
  <content>[](#type-alias-createbasequeryresulttdata-terror-tstate)[Type Alias: CreateBaseQueryResult<TData, TError, TState>](#type-alias-createbasequeryresulttdata-terror-tstate)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    type CreateBaseQueryResult<TData, TError, TState> = BaseQueryNarrowing<TData, TError> & MapToSignals<OmitKeyof<TState, keyof BaseQueryNarrowing, "safely">>;
    

    type CreateBaseQueryResult<TData, TError, TState> = BaseQueryNarrowing<TData, TError> & MapToSignals<OmitKeyof<TState, keyof BaseQueryNarrowing, "safely">>;
    

Defined in: [types.ts:98](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/types.ts#L98)

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tdata)[TData](#tdata)

TData = unknown

### [](#terror)[TError](#terror)

TError = DefaultError

### [](#tstate)[TState](#tstate)

TState = QueryObserverResult<TData, TError\></content>
</page>

<page>
  <title>CreateBaseMutationResult | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/CreateBaseMutationResult</url>
  <content>[](#type-alias-createbasemutationresulttdata-terror-tvariables-tonmutateresult)[Type Alias: CreateBaseMutationResult<TData, TError, TVariables, TOnMutateResult>](#type-alias-createbasemutationresulttdata-terror-tvariables-tonmutateresult)
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    type CreateBaseMutationResult<TData, TError, TVariables, TOnMutateResult> = Override<MutationObserverResult<TData, TError, TVariables, TOnMutateResult>, {
      mutate: CreateMutateFunction<TData, TError, TVariables, TOnMutateResult>;
    }> & object;
    

    type CreateBaseMutationResult<TData, TError, TVariables, TOnMutateResult> = Override<MutationObserverResult<TData, TError, TVariables, TOnMutateResult>, {
      mutate: CreateMutateFunction<TData, TError, TVariables, TOnMutateResult>;
    }> & object;
    

Defined in: [types.ts:160](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/types.ts#L160)

[](#type-declaration)[Type Declaration](#type-declaration)
----------------------------------------------------------

### [](#mutateasync)[mutateAsync](#mutateasync)

    mutateAsync: CreateMutateAsyncFunction<TData, TError, TVariables, TOnMutateResult>;
    

    mutateAsync: CreateMutateAsyncFunction<TData, TError, TVariables, TOnMutateResult>;
    

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tdata)[TData](#tdata)

TData = unknown

### [](#terror)[TError](#terror)

TError = DefaultError

### [](#tvariables)[TVariables](#tvariables)

TVariables = unknown

### [](#tonmutateresult)[TOnMutateResult](#tonmutateresult)

TOnMutateResult = unknown</content>
</page>

<page>
  <title>CreateInfiniteQueryResult | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/CreateInfiniteQueryResult</url>
  <content>[](#type-alias-createinfinitequeryresulttdata-terror)[Type Alias: CreateInfiniteQueryResult<TData, TError>](#type-alias-createinfinitequeryresulttdata-terror)
--------------------------------------------------------------------------------------------------------------------------------------------------------------

    type CreateInfiniteQueryResult<TData, TError> = BaseQueryNarrowing<TData, TError> & MapToSignals<InfiniteQueryObserverResult<TData, TError>>;
    

    type CreateInfiniteQueryResult<TData, TError> = BaseQueryNarrowing<TData, TError> & MapToSignals<InfiniteQueryObserverResult<TData, TError>>;
    

Defined in: [types.ts:117](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/types.ts#L117)

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tdata)[TData](#tdata)

TData = unknown

### [](#terror)[TError](#terror)

TError = DefaultError</content>
</page>

<page>
  <title>CreateMutateAsyncFunction | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/CreateMutateAsyncFunction</url>
  <content>[](#type-alias-createmutateasyncfunctiontdata-terror-tvariables-tonmutateresult)[Type Alias: CreateMutateAsyncFunction<TData, TError, TVariables, TOnMutateResult>](#type-alias-createmutateasyncfunctiontdata-terror-tvariables-tonmutateresult)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    type CreateMutateAsyncFunction<TData, TError, TVariables, TOnMutateResult> = MutateFunction<TData, TError, TVariables, TOnMutateResult>;
    

    type CreateMutateAsyncFunction<TData, TError, TVariables, TOnMutateResult> = MutateFunction<TData, TError, TVariables, TOnMutateResult>;
    

Defined in: [types.ts:153](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/types.ts#L153)

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tdata)[TData](#tdata)

TData = unknown

### [](#terror)[TError](#terror)

TError = DefaultError

### [](#tvariables)[TVariables](#tvariables)

TVariables = void

### [](#tonmutateresult)[TOnMutateResult](#tonmutateresult)

TOnMutateResult = unknown</content>
</page>

<page>
  <title>CreateMutateFunction | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/CreateMutateFunction</url>
  <content>[](#type-alias-createmutatefunctiontdata-terror-tvariables-tonmutateresult)[Type Alias: CreateMutateFunction()<TData, TError, TVariables, TOnMutateResult>](#type-alias-createmutatefunctiontdata-terror-tvariables-tonmutateresult)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    type CreateMutateFunction<TData, TError, TVariables, TOnMutateResult> = (...args) => void;
    

    type CreateMutateFunction<TData, TError, TVariables, TOnMutateResult> = (...args) => void;
    

Defined in: [types.ts:142](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/types.ts#L142)

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tdata)[TData](#tdata)

TData = unknown

### [](#terror)[TError](#terror)

TError = DefaultError

### [](#tvariables)[TVariables](#tvariables)

TVariables = void

### [](#tonmutateresult)[TOnMutateResult](#tonmutateresult)

TOnMutateResult = unknown

[](#parameters)[Parameters](#parameters)
----------------------------------------

### [](#args)[args](#args)

...Parameters<MutateFunction<TData, TError, TVariables, TOnMutateResult\>>

[](#returns)[Returns](#returns)
-------------------------------

void</content>
</page>

<page>
  <title>CreateMutationResult | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/CreateMutationResult</url>
  <content>[](#type-alias-createmutationresulttdata-terror-tvariables-tonmutateresult-tstate)[Type Alias: CreateMutationResult<TData, TError, TVariables, TOnMutateResult, TState>](#type-alias-createmutationresulttdata-terror-tvariables-tonmutateresult-tstate)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    type CreateMutationResult<TData, TError, TVariables, TOnMutateResult, TState> = BaseMutationNarrowing<TData, TError, TVariables, TOnMutateResult> & MapToSignals<OmitKeyof<TState, keyof BaseMutationNarrowing, "safely">>;
    

    type CreateMutationResult<TData, TError, TVariables, TOnMutateResult, TState> = BaseMutationNarrowing<TData, TError, TVariables, TOnMutateResult> & MapToSignals<OmitKeyof<TState, keyof BaseMutationNarrowing, "safely">>;
    

Defined in: [types.ts:266](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/types.ts#L266)

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tdata)[TData](#tdata)

TData = unknown

### [](#terror)[TError](#terror)

TError = DefaultError

### [](#tvariables)[TVariables](#tvariables)

TVariables = unknown

### [](#tonmutateresult)[TOnMutateResult](#tonmutateresult)

TOnMutateResult = unknown

### [](#tstate)[TState](#tstate)

TState = CreateStatusBasedMutationResult<[CreateBaseMutationResult](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/CreateBaseMutationResult)\["status"\], TData, TError, TVariables, TOnMutateResult\></content>
</page>

<page>
  <title>CreateQueryResult | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/CreateQueryResult</url>
  <content>ts

    type CreateQueryResult<TData, TError> = CreateBaseQueryResult<TData, TError>;
    

    type CreateQueryResult<TData, TError> = CreateBaseQueryResult<TData, TError>;</content>
</page>

<page>
  <title>DefinedCreateInfiniteQueryResult | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/DefinedCreateInfiniteQueryResult</url>
  <content>[](#type-alias-definedcreateinfinitequeryresulttdata-terror-tdefinedinfinitequeryobserver)[Type Alias: DefinedCreateInfiniteQueryResult<TData, TError, TDefinedInfiniteQueryObserver>](#type-alias-definedcreateinfinitequeryresulttdata-terror-tdefinedinfinitequeryobserver)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    type DefinedCreateInfiniteQueryResult<TData, TError, TDefinedInfiniteQueryObserver> = MapToSignals<TDefinedInfiniteQueryObserver>;
    

    type DefinedCreateInfiniteQueryResult<TData, TError, TDefinedInfiniteQueryObserver> = MapToSignals<TDefinedInfiniteQueryObserver>;
    

Defined in: [types.ts:123](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/types.ts#L123)

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tdata)[TData](#tdata)

TData = unknown

### [](#terror)[TError](#terror)

TError = DefaultError

### [](#tdefinedinfinitequeryobserver)[TDefinedInfiniteQueryObserver](#tdefinedinfinitequeryobserver)

TDefinedInfiniteQueryObserver = DefinedInfiniteQueryObserverResult<TData, TError\></content>
</page>

<page>
  <title>DefinedCreateQueryResult | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/DefinedCreateQueryResult</url>
  <content>[](#type-alias-definedcreatequeryresulttdata-terror-tstate)[Type Alias: DefinedCreateQueryResult<TData, TError, TState>](#type-alias-definedcreatequeryresulttdata-terror-tstate)
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    type DefinedCreateQueryResult<TData, TError, TState> = BaseQueryNarrowing<TData, TError> & MapToSignals<OmitKeyof<TState, keyof BaseQueryNarrowing, "safely">>;
    

    type DefinedCreateQueryResult<TData, TError, TState> = BaseQueryNarrowing<TData, TError> & MapToSignals<OmitKeyof<TState, keyof BaseQueryNarrowing, "safely">>;
    

Defined in: [types.ts:110](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/types.ts#L110)

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tdata)[TData](#tdata)

TData = unknown

### [](#terror)[TError](#terror)

TError = DefaultError

### [](#tstate)[TState](#tstate)

TState = DefinedQueryObserverResult<TData, TError\></content>
</page>

<page>
  <title>DefinedInitialDataInfiniteOptions | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/DefinedInitialDataInfiniteOptions</url>
  <content>[](#type-alias-definedinitialdatainfiniteoptionstqueryfndata-terror-tdata-tquerykey-tpageparam)[Type Alias: DefinedInitialDataInfiniteOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>](#type-alias-definedinitialdatainfiniteoptionstqueryfndata-terror-tdata-tquerykey-tpageparam)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    type DefinedInitialDataInfiniteOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam> = CreateInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam> & object;
    

    type DefinedInitialDataInfiniteOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam> = CreateInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam> & object;
    

Defined in: [infinite-query-options.ts:62](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/infinite-query-options.ts#L62)

[](#type-declaration)[Type Declaration](#type-declaration)
----------------------------------------------------------

### [](#initialdata)[initialData](#initialdata)

    initialData: 
      | NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>>
      | () => NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>>
      | undefined;
    

    initialData: 
      | NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>>
      | () => NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>>
      | undefined;
    

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tqueryfndata)[TQueryFnData](#tqueryfndata)

TQueryFnData

### [](#terror)[TError](#terror)

TError = DefaultError

### [](#tdata)[TData](#tdata)

TData = InfiniteData<TQueryFnData\>

### [](#tquerykey)[TQueryKey](#tquerykey)

TQueryKey _extends_ QueryKey = QueryKey

### [](#tpageparam)[TPageParam](#tpageparam)

TPageParam = unknown</content>
</page>

<page>
  <title>DefinedInitialDataOptions | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/DefinedInitialDataOptions</url>
  <content>[](#type-alias-definedinitialdataoptionstqueryfndata-terror-tdata-tquerykey)[Type Alias: DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>](#type-alias-definedinitialdataoptionstqueryfndata-terror-tdata-tquerykey)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    type DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> = Omit<CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey>, "queryFn"> & object;
    

    type DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> = Omit<CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey>, "queryFn"> & object;
    

Defined in: [query-options.ts:40](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/query-options.ts#L40)

[](#type-declaration)[Type Declaration](#type-declaration)
----------------------------------------------------------

### [](#initialdata)[initialData](#initialdata)

    initialData: 
      | NonUndefinedGuard<TQueryFnData>
    | () => NonUndefinedGuard<TQueryFnData>;
    

    initialData: 
      | NonUndefinedGuard<TQueryFnData>
    | () => NonUndefinedGuard<TQueryFnData>;
    

### [](#queryfn)[queryFn?](#queryfn)

    optional queryFn: QueryFunction<TQueryFnData, TQueryKey>;
    

    optional queryFn: QueryFunction<TQueryFnData, TQueryKey>;
    

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tqueryfndata)[TQueryFnData](#tqueryfndata)

TQueryFnData = unknown

### [](#terror)[TError](#terror)

TError = DefaultError

### [](#tdata)[TData](#tdata)

TData = TQueryFnData

### [](#tquerykey)[TQueryKey](#tquerykey)

TQueryKey _extends_ QueryKey = QueryKey</content>
</page>

<page>
  <title>DevtoolsFeature | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/DevtoolsFeature</url>
  <content>[](#type-alias-devtoolsfeature)[Type Alias: DevtoolsFeature](#type-alias-devtoolsfeature)
-----------------------------------------------------------------------------------------

ts

    type DevtoolsFeature = QueryFeature<"Devtools">;
    

    type DevtoolsFeature = QueryFeature<"Devtools">;
    

Defined in: [providers.ts:158](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/providers.ts#L158)

A type alias that represents a feature which enables developer tools. The type is used to describe the return value of the withDevtools function.

[](#see)[See](#see)
-------------------

withDevtools</content>
</page>

<page>
  <title>PersistQueryClientFeature | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/PersistQueryClientFeature</url>
  <content>[](#type-alias-persistqueryclientfeature)[Type Alias: PersistQueryClientFeature](#type-alias-persistqueryclientfeature)
-----------------------------------------------------------------------------------------------------------------------

ts

    type PersistQueryClientFeature = QueryFeature<"PersistQueryClient">;
    

    type PersistQueryClientFeature = QueryFeature<"PersistQueryClient">;
    

Defined in: [providers.ts:164](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/providers.ts#L164)

A type alias that represents a feature which enables persistence. The type is used to describe the return value of the withPersistQueryClient function.</content>
</page>

<page>
  <title>QueriesOptions | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/QueriesOptions</url>
  <content>[](#type-alias-queriesoptionst-tresults-tdepth)[Type Alias: QueriesOptions<T, TResults, TDepth>](#type-alias-queriesoptionst-tresults-tdepth)
---------------------------------------------------------------------------------------------------------------------------------------------

    type QueriesOptions<T, TResults, TDepth> = TDepth["length"] extends MAXIMUM_DEPTH ? QueryObserverOptionsForCreateQueries[] : T extends [] ? [] : T extends [infer Head] ? [...TResults, GetCreateQueryOptionsForCreateQueries<Head>] : T extends [infer Head, ...(infer Tails)] ? QueriesOptions<[...Tails], [...TResults, GetCreateQueryOptionsForCreateQueries<Head>], [...TDepth, 1]> : ReadonlyArray<unknown> extends T ? T : T extends QueryObserverOptionsForCreateQueries<infer TQueryFnData, infer TError, infer TData, infer TQueryKey>[] ? QueryObserverOptionsForCreateQueries<TQueryFnData, TError, TData, TQueryKey>[] : QueryObserverOptionsForCreateQueries[];
    

    type QueriesOptions<T, TResults, TDepth> = TDepth["length"] extends MAXIMUM_DEPTH ? QueryObserverOptionsForCreateQueries[] : T extends [] ? [] : T extends [infer Head] ? [...TResults, GetCreateQueryOptionsForCreateQueries<Head>] : T extends [infer Head, ...(infer Tails)] ? QueriesOptions<[...Tails], [...TResults, GetCreateQueryOptionsForCreateQueries<Head>], [...TDepth, 1]> : ReadonlyArray<unknown> extends T ? T : T extends QueryObserverOptionsForCreateQueries<infer TQueryFnData, infer TError, infer TData, infer TQueryKey>[] ? QueryObserverOptionsForCreateQueries<TQueryFnData, TError, TData, TQueryKey>[] : QueryObserverOptionsForCreateQueries[];
    

Defined in: [inject-queries.ts:144](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/inject-queries.ts#L144)

QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#t)[T](#t)

T _extends_ any\[\]

### [](#tresults)[TResults](#tresults)

TResults _extends_ any\[\] = \[\]

### [](#tdepth)[TDepth](#tdepth)

TDepth _extends_ ReadonlyArray<number\> = \[\]</content>
</page>

<page>
  <title>QueryFeatures | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/QueryFeatures</url>
  <content>[](#type-alias-queryfeatures)[Type Alias: QueryFeatures](#type-alias-queryfeatures)
-----------------------------------------------------------------------------------

    type QueryFeatures = 
      | DevtoolsFeature
      | PersistQueryClientFeature;
    

    type QueryFeatures = 
      | DevtoolsFeature
      | PersistQueryClientFeature;
    

Defined in: [providers.ts:173](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/providers.ts#L173)

A type alias that represents all Query features available for use with provideTanStackQuery. Features can be enabled by adding special functions to the provideTanStackQuery call. See documentation for each symbol to find corresponding function name. See also provideTanStackQuery documentation on how to use those functions.

[](#see)[See](#see)
-------------------

[provideTanStackQuery](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/provideTanStackQuery)</content>
</page>

<page>
  <title>QueriesResults | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/QueriesResults</url>
  <content>[](#type-alias-queriesresultst-tresults-tdepth)[Type Alias: QueriesResults<T, TResults, TDepth>](#type-alias-queriesresultst-tresults-tdepth)
---------------------------------------------------------------------------------------------------------------------------------------------

    type QueriesResults<T, TResults, TDepth> = TDepth["length"] extends MAXIMUM_DEPTH ? CreateQueryResult[] : T extends [] ? [] : T extends [infer Head] ? [...TResults, GetCreateQueryResult<Head>] : T extends [infer Head, ...(infer Tails)] ? QueriesResults<[...Tails], [...TResults, GetCreateQueryResult<Head>], [...TDepth, 1]> : { [K in keyof T]: GetCreateQueryResult<T[K]> };
    

    type QueriesResults<T, TResults, TDepth> = TDepth["length"] extends MAXIMUM_DEPTH ? CreateQueryResult[] : T extends [] ? [] : T extends [infer Head] ? [...TResults, GetCreateQueryResult<Head>] : T extends [infer Head, ...(infer Tails)] ? QueriesResults<[...Tails], [...TResults, GetCreateQueryResult<Head>], [...TDepth, 1]> : { [K in keyof T]: GetCreateQueryResult<T[K]> };
    

Defined in: [inject-queries.ts:186](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/inject-queries.ts#L186)

QueriesResults reducer recursively maps type param to results

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#t)[T](#t)

T _extends_ any\[\]

### [](#tresults)[TResults](#tresults)

TResults _extends_ any\[\] = \[\]

### [](#tdepth)[TDepth](#tdepth)

TDepth _extends_ ReadonlyArray<number\> = \[\]</content>
</page>

<page>
  <title>UndefinedInitialDataInfiniteOptions | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/UndefinedInitialDataInfiniteOptions</url>
  <content>[](#type-alias-undefinedinitialdatainfiniteoptionstqueryfndata-terror-tdata-tquerykey-tpageparam)[Type Alias: UndefinedInitialDataInfiniteOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>](#type-alias-undefinedinitialdatainfiniteoptionstqueryfndata-terror-tdata-tquerykey-tpageparam)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    type UndefinedInitialDataInfiniteOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam> = CreateInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam> & object;
    

    type UndefinedInitialDataInfiniteOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam> = CreateInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam> & object;
    

Defined in: [infinite-query-options.ts:13](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/infinite-query-options.ts#L13)

[](#type-declaration)[Type Declaration](#type-declaration)
----------------------------------------------------------

### [](#initialdata)[initialData?](#initialdata)

    optional initialData: 
      | NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>>
    | InitialDataFunction<NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>>>;
    

    optional initialData: 
      | NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>>
    | InitialDataFunction<NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>>>;
    

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tqueryfndata)[TQueryFnData](#tqueryfndata)

TQueryFnData

### [](#terror)[TError](#terror)

TError = DefaultError

### [](#tdata)[TData](#tdata)

TData = InfiniteData<TQueryFnData\>

### [](#tquerykey)[TQueryKey](#tquerykey)

TQueryKey _extends_ QueryKey = QueryKey

### [](#tpageparam)[TPageParam](#tpageparam)

TPageParam = unknown</content>
</page>

<page>
  <title>UndefinedInitialDataOptions | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/UndefinedInitialDataOptions</url>
  <content>[](#type-alias-undefinedinitialdataoptionstqueryfndata-terror-tdata-tquerykey)[Type Alias: UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>](#type-alias-undefinedinitialdataoptionstqueryfndata-terror-tdata-tquerykey)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    type UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> = CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey> & object;
    

    type UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> = CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey> & object;
    

Defined in: [query-options.ts:13](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/query-options.ts#L13)

[](#type-declaration)[Type Declaration](#type-declaration)
----------------------------------------------------------

### [](#initialdata)[initialData?](#initialdata)

    optional initialData: 
      | InitialDataFunction<NonUndefinedGuard<TQueryFnData>>
    | NonUndefinedGuard<TQueryFnData>;
    

    optional initialData: 
      | InitialDataFunction<NonUndefinedGuard<TQueryFnData>>
    | NonUndefinedGuard<TQueryFnData>;
    

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tqueryfndata)[TQueryFnData](#tqueryfndata)

TQueryFnData = unknown

### [](#terror)[TError](#terror)

TError = DefaultError

### [](#tdata)[TData](#tdata)

TData = TQueryFnData

### [](#tquerykey)[TQueryKey](#tquerykey)

TQueryKey _extends_ QueryKey = QueryKey</content>
</page>

<page>
  <title>UnusedSkipTokenInfiniteOptions | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/UnusedSkipTokenInfiniteOptions</url>
  <content>[](#type-alias-unusedskiptokeninfiniteoptionstqueryfndata-terror-tdata-tquerykey-tpageparam)[Type Alias: UnusedSkipTokenInfiniteOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>](#type-alias-unusedskiptokeninfiniteoptionstqueryfndata-terror-tdata-tquerykey-tpageparam)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    type UnusedSkipTokenInfiniteOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam> = OmitKeyof<CreateInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>, "queryFn"> & object;
    

    type UnusedSkipTokenInfiniteOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam> = OmitKeyof<CreateInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>, "queryFn"> & object;
    

Defined in: [infinite-query-options.ts:34](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/infinite-query-options.ts#L34)

[](#type-declaration)[Type Declaration](#type-declaration)
----------------------------------------------------------

### [](#queryfn)[queryFn?](#queryfn)

    optional queryFn: Exclude<CreateInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>["queryFn"], SkipToken | undefined>;
    

    optional queryFn: Exclude<CreateInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>["queryFn"], SkipToken | undefined>;
    

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tqueryfndata)[TQueryFnData](#tqueryfndata)

TQueryFnData

### [](#terror)[TError](#terror)

TError = DefaultError

### [](#tdata)[TData](#tdata)

TData = InfiniteData<TQueryFnData\>

### [](#tquerykey)[TQueryKey](#tquerykey)

TQueryKey _extends_ QueryKey = QueryKey

### [](#tpageparam)[TPageParam](#tpageparam)

TPageParam = unknown</content>
</page>

<page>
  <title>UnusedSkipTokenOptions | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/UnusedSkipTokenOptions</url>
  <content>[](#type-alias-unusedskiptokenoptionstqueryfndata-terror-tdata-tquerykey)[Type Alias: UnusedSkipTokenOptions<TQueryFnData, TError, TData, TQueryKey>](#type-alias-unusedskiptokenoptionstqueryfndata-terror-tdata-tquerykey)
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    type UnusedSkipTokenOptions<TQueryFnData, TError, TData, TQueryKey> = OmitKeyof<CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey>, "queryFn"> & object;
    

    type UnusedSkipTokenOptions<TQueryFnData, TError, TData, TQueryKey> = OmitKeyof<CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey>, "queryFn"> & object;
    

Defined in: [query-options.ts:25](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/query-options.ts#L25)

[](#type-declaration)[Type Declaration](#type-declaration)
----------------------------------------------------------

### [](#queryfn)[queryFn?](#queryfn)

    optional queryFn: Exclude<CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey>["queryFn"], SkipToken | undefined>;
    

    optional queryFn: Exclude<CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey>["queryFn"], SkipToken | undefined>;
    

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tqueryfndata)[TQueryFnData](#tqueryfndata)

TQueryFnData = unknown

### [](#terror)[TError](#terror)

TError = DefaultError

### [](#tdata)[TData](#tdata)

TData = TQueryFnData

### [](#tquerykey)[TQueryKey](#tquerykey)

TQueryKey _extends_ QueryKey = QueryKey</content>
</page>

<page>
  <title>infiniteQueryOptions | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/functions/infiniteQueryOptions</url>
  <content>[](#function-infinitequeryoptions)[Function: infiniteQueryOptions()](#function-infinitequeryoptions)
----------------------------------------------------------------------------------------------------

Allows to share and re-use infinite query options in a type-safe way.

The queryKey will be tagged with the type from queryFn.

[](#param)[Param](#param)
-------------------------

The infinite query options to tag with the type from queryFn.

[](#call-signature)[Call Signature](#call-signature)
----------------------------------------------------

    function infiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>(options): CreateInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam> & object & object;
    

    function infiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>(options): CreateInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam> & object & object;
    

Defined in: [infinite-query-options.ts:88](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/infinite-query-options.ts#L88)

Allows to share and re-use infinite query options in a type-safe way.

The queryKey will be tagged with the type from queryFn.

### [](#type-parameters)[Type Parameters](#type-parameters)

#### [](#tqueryfndata)[TQueryFnData](#tqueryfndata)

TQueryFnData

#### [](#terror)[TError](#terror)

TError = Error

#### [](#tdata)[TData](#tdata)

TData = InfiniteData<TQueryFnData, unknown\>

#### [](#tquerykey)[TQueryKey](#tquerykey)

TQueryKey _extends_ readonly unknown\[\] = readonly unknown\[\]

#### [](#tpageparam)[TPageParam](#tpageparam)

TPageParam = unknown

### [](#parameters)[Parameters](#parameters)

#### [](#options)[options](#options)

[DefinedInitialDataInfiniteOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/DefinedInitialDataInfiniteOptions)<TQueryFnData, TError, TData, TQueryKey, TPageParam\>

The infinite query options to tag with the type from queryFn.

### [](#returns)[Returns](#returns)

[CreateInfiniteQueryOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/CreateInfiniteQueryOptions)<TQueryFnData, TError, TData, TQueryKey, TPageParam\> & object & object

The tagged infinite query options.

[](#call-signature-1)[Call Signature](#call-signature-1)
--------------------------------------------------------

    function infiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>(options): OmitKeyof<CreateInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>, "queryFn"> & object & object;
    

    function infiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>(options): OmitKeyof<CreateInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>, "queryFn"> & object & object;
    

Defined in: [infinite-query-options.ts:119](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/infinite-query-options.ts#L119)

Allows to share and re-use infinite query options in a type-safe way.

The queryKey will be tagged with the type from queryFn.

### [](#type-parameters-1)[Type Parameters](#type-parameters-1)

#### [](#tqueryfndata-1)[TQueryFnData](#tqueryfndata-1)

TQueryFnData

#### [](#terror-1)[TError](#terror-1)

TError = Error

#### [](#tdata-1)[TData](#tdata-1)

TData = InfiniteData<TQueryFnData, unknown\>

#### [](#tquerykey-1)[TQueryKey](#tquerykey-1)

TQueryKey _extends_ readonly unknown\[\] = readonly unknown\[\]

#### [](#tpageparam-1)[TPageParam](#tpageparam-1)

TPageParam = unknown

### [](#parameters-1)[Parameters](#parameters-1)

#### [](#options-1)[options](#options-1)

[UnusedSkipTokenInfiniteOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/UnusedSkipTokenInfiniteOptions)<TQueryFnData, TError, TData, TQueryKey, TPageParam\>

The infinite query options to tag with the type from queryFn.

### [](#returns-1)[Returns](#returns-1)

OmitKeyof<[CreateInfiniteQueryOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/CreateInfiniteQueryOptions)<TQueryFnData, TError, TData, TQueryKey, TPageParam\>, "queryFn"\> & object & object

The tagged infinite query options.

[](#call-signature-2)[Call Signature](#call-signature-2)
--------------------------------------------------------

    function infiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>(options): CreateInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam> & object & object;
    

    function infiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>(options): CreateInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam> & object & object;
    

Defined in: [infinite-query-options.ts:150](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/infinite-query-options.ts#L150)

Allows to share and re-use infinite query options in a type-safe way.

The queryKey will be tagged with the type from queryFn.

### [](#type-parameters-2)[Type Parameters](#type-parameters-2)

#### [](#tqueryfndata-2)[TQueryFnData](#tqueryfndata-2)

TQueryFnData

#### [](#terror-2)[TError](#terror-2)

TError = Error

#### [](#tdata-2)[TData](#tdata-2)

TData = InfiniteData<TQueryFnData, unknown\>

#### [](#tquerykey-2)[TQueryKey](#tquerykey-2)

TQueryKey _extends_ readonly unknown\[\] = readonly unknown\[\]

#### [](#tpageparam-2)[TPageParam](#tpageparam-2)

TPageParam = unknown

### [](#parameters-2)[Parameters](#parameters-2)

#### [](#options-2)[options](#options-2)

[UndefinedInitialDataInfiniteOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/UndefinedInitialDataInfiniteOptions)<TQueryFnData, TError, TData, TQueryKey, TPageParam\>

The infinite query options to tag with the type from queryFn.

### [](#returns-2)[Returns](#returns-2)

[CreateInfiniteQueryOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/CreateInfiniteQueryOptions)<TQueryFnData, TError, TData, TQueryKey, TPageParam\> & object & object

The tagged infinite query options.</content>
</page>

<page>
  <title>injectInfiniteQuery | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectInfiniteQuery</url>
  <content>[](#function-injectinfinitequery)[Function: injectInfiniteQuery()](#function-injectinfinitequery)
-------------------------------------------------------------------------------------------------

Injects an infinite query: a declarative dependency on an asynchronous source of data that is tied to a unique key. Infinite queries can additively "load more" data onto an existing set of data or "infinite scroll"

[](#param)[Param](#param)
-------------------------

A function that returns infinite query options.

[](#param-1)[Param](#param-1)
-----------------------------

Additional configuration.

[](#call-signature)[Call Signature](#call-signature)
----------------------------------------------------

    function injectInfiniteQuery<TQueryFnData, TError, TData, TQueryKey, TPageParam>(injectInfiniteQueryFn, options?): DefinedCreateInfiniteQueryResult<TData, TError>;
    

    function injectInfiniteQuery<TQueryFnData, TError, TData, TQueryKey, TPageParam>(injectInfiniteQueryFn, options?): DefinedCreateInfiniteQueryResult<TData, TError>;
    

Defined in: [inject-infinite-query.ts:41](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/inject-infinite-query.ts#L41)

Injects an infinite query: a declarative dependency on an asynchronous source of data that is tied to a unique key. Infinite queries can additively "load more" data onto an existing set of data or "infinite scroll"

### [](#type-parameters)[Type Parameters](#type-parameters)

#### [](#tqueryfndata)[TQueryFnData](#tqueryfndata)

TQueryFnData

#### [](#terror)[TError](#terror)

TError = Error

#### [](#tdata)[TData](#tdata)

TData = InfiniteData<TQueryFnData, unknown\>

#### [](#tquerykey)[TQueryKey](#tquerykey)

TQueryKey _extends_ readonly unknown\[\] = readonly unknown\[\]

#### [](#tpageparam)[TPageParam](#tpageparam)

TPageParam = unknown

### [](#parameters)[Parameters](#parameters)

#### [](#injectinfinitequeryfn)[injectInfiniteQueryFn](#injectinfinitequeryfn)

() => [DefinedInitialDataInfiniteOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/DefinedInitialDataInfiniteOptions)<TQueryFnData, TError, TData, TQueryKey, TPageParam\>

A function that returns infinite query options.

#### [](#options)[options?](#options)

[InjectInfiniteQueryOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/InjectInfiniteQueryOptions)

Additional configuration.

### [](#returns)[Returns](#returns)

[DefinedCreateInfiniteQueryResult](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/DefinedCreateInfiniteQueryResult)<TData, TError\>

The infinite query result.

[](#call-signature-1)[Call Signature](#call-signature-1)
--------------------------------------------------------

    function injectInfiniteQuery<TQueryFnData, TError, TData, TQueryKey, TPageParam>(injectInfiniteQueryFn, options?): CreateInfiniteQueryResult<TData, TError>;
    

    function injectInfiniteQuery<TQueryFnData, TError, TData, TQueryKey, TPageParam>(injectInfiniteQueryFn, options?): CreateInfiniteQueryResult<TData, TError>;
    

Defined in: [inject-infinite-query.ts:65](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/inject-infinite-query.ts#L65)

Injects an infinite query: a declarative dependency on an asynchronous source of data that is tied to a unique key. Infinite queries can additively "load more" data onto an existing set of data or "infinite scroll"

### [](#type-parameters-1)[Type Parameters](#type-parameters-1)

#### [](#tqueryfndata-1)[TQueryFnData](#tqueryfndata-1)

TQueryFnData

#### [](#terror-1)[TError](#terror-1)

TError = Error

#### [](#tdata-1)[TData](#tdata-1)

TData = InfiniteData<TQueryFnData, unknown\>

#### [](#tquerykey-1)[TQueryKey](#tquerykey-1)

TQueryKey _extends_ readonly unknown\[\] = readonly unknown\[\]

#### [](#tpageparam-1)[TPageParam](#tpageparam-1)

TPageParam = unknown

### [](#parameters-1)[Parameters](#parameters-1)

#### [](#injectinfinitequeryfn-1)[injectInfiniteQueryFn](#injectinfinitequeryfn-1)

() => [UndefinedInitialDataInfiniteOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/UndefinedInitialDataInfiniteOptions)<TQueryFnData, TError, TData, TQueryKey, TPageParam\>

A function that returns infinite query options.

#### [](#options-1)[options?](#options-1)

[InjectInfiniteQueryOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/InjectInfiniteQueryOptions)

Additional configuration.

### [](#returns-1)[Returns](#returns-1)

[CreateInfiniteQueryResult](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/CreateInfiniteQueryResult)<TData, TError\>

The infinite query result.

[](#call-signature-2)[Call Signature](#call-signature-2)
--------------------------------------------------------

    function injectInfiniteQuery<TQueryFnData, TError, TData, TQueryKey, TPageParam>(injectInfiniteQueryFn, options?): CreateInfiniteQueryResult<TData, TError>;
    

    function injectInfiniteQuery<TQueryFnData, TError, TData, TQueryKey, TPageParam>(injectInfiniteQueryFn, options?): CreateInfiniteQueryResult<TData, TError>;
    

Defined in: [inject-infinite-query.ts:89](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/inject-infinite-query.ts#L89)

Injects an infinite query: a declarative dependency on an asynchronous source of data that is tied to a unique key. Infinite queries can additively "load more" data onto an existing set of data or "infinite scroll"

### [](#type-parameters-2)[Type Parameters](#type-parameters-2)

#### [](#tqueryfndata-2)[TQueryFnData](#tqueryfndata-2)

TQueryFnData

#### [](#terror-2)[TError](#terror-2)

TError = Error

#### [](#tdata-2)[TData](#tdata-2)

TData = InfiniteData<TQueryFnData, unknown\>

#### [](#tquerykey-2)[TQueryKey](#tquerykey-2)

TQueryKey _extends_ readonly unknown\[\] = readonly unknown\[\]

#### [](#tpageparam-2)[TPageParam](#tpageparam-2)

TPageParam = unknown

### [](#parameters-2)[Parameters](#parameters-2)

#### [](#injectinfinitequeryfn-2)[injectInfiniteQueryFn](#injectinfinitequeryfn-2)

() => [CreateInfiniteQueryOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/CreateInfiniteQueryOptions)<TQueryFnData, TError, TData, TQueryKey, TPageParam\>

A function that returns infinite query options.

#### [](#options-2)[options?](#options-2)

[InjectInfiniteQueryOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/InjectInfiniteQueryOptions)

Additional configuration.

### [](#returns-2)[Returns](#returns-2)

[CreateInfiniteQueryResult](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/CreateInfiniteQueryResult)<TData, TError\>

The infinite query result.</content>
</page>

<page>
  <title>injectIsFetching | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectIsFetching</url>
  <content>[](#function-injectisfetching)[Function: injectIsFetching()](#function-injectisfetching)
----------------------------------------------------------------------------------------

    function injectIsFetching(filters?, options?): Signal<number>;
    

    function injectIsFetching(filters?, options?): Signal<number>;
    

Defined in: [inject-is-fetching.ts:31](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/inject-is-fetching.ts#L31)

Injects a signal that tracks the number of queries that your application is loading or fetching in the background.

Can be used for app-wide loading indicators

[](#parameters)[Parameters](#parameters)
----------------------------------------

### [](#filters)[filters?](#filters)

QueryFilters<readonly unknown\[\]>

The filters to apply to the query.

### [](#options)[options?](#options)

[InjectIsFetchingOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/InjectIsFetchingOptions)

Additional configuration

[](#returns)[Returns](#returns)
-------------------------------

Signal<number\>

signal with number of loading or fetching queries.</content>
</page>

<page>
  <title>injectIsMutating | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectIsMutating</url>
  <content>[](#function-injectismutating)[Function: injectIsMutating()](#function-injectismutating)
----------------------------------------------------------------------------------------

    function injectIsMutating(filters?, options?): Signal<number>;
    

    function injectIsMutating(filters?, options?): Signal<number>;
    

Defined in: [inject-is-mutating.ts:30](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/inject-is-mutating.ts#L30)

Injects a signal that tracks the number of mutations that your application is fetching.

Can be used for app-wide loading indicators

[](#parameters)[Parameters](#parameters)
----------------------------------------

### [](#filters)[filters?](#filters)

MutationFilters<unknown, Error, unknown, unknown\>

The filters to apply to the query.

### [](#options)[options?](#options)

[InjectIsMutatingOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/InjectIsMutatingOptions)

Additional configuration

[](#returns)[Returns](#returns)
-------------------------------

Signal<number\>

A read-only signal with the number of fetching mutations.</content>
</page>

<page>
  <title>injectIsRestoring | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectIsRestoring</url>
  <content>[](#function-injectisrestoring)[Function: injectIsRestoring()](#function-injectisrestoring)
-------------------------------------------------------------------------------------------

    function injectIsRestoring(options?): Signal<boolean>;
    

    function injectIsRestoring(options?): Signal<boolean>;
    

Defined in: [inject-is-restoring.ts:32](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/inject-is-restoring.ts#L32)

Injects a signal that tracks whether a restore is currently in progress. [injectQuery](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectQuery) and friends also check this internally to avoid race conditions between the restore and initializing queries.

[](#parameters)[Parameters](#parameters)
----------------------------------------

### [](#options)[options?](#options)

InjectIsRestoringOptions

Options for injectIsRestoring.

[](#returns)[Returns](#returns)
-------------------------------

Signal<boolean\>

readonly signal with boolean that indicates whether a restore is in progress.</content>
</page>

<page>
  <title>injectMutationState | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectMutationState</url>
  <content>[](#function-injectmutationstate)[Function: injectMutationState()](#function-injectmutationstate)
-------------------------------------------------------------------------------------------------

    function injectMutationState<TResult>(injectMutationStateFn, options?): Signal<TResult[]>;
    

    function injectMutationState<TResult>(injectMutationStateFn, options?): Signal<TResult[]>;
    

Defined in: [inject-mutation-state.ts:60](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/inject-mutation-state.ts#L60)

Injects a signal that tracks the state of all mutations.

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tresult)[TResult](#tresult)

TResult = MutationState<unknown, Error, unknown, unknown\>

[](#parameters)[Parameters](#parameters)
----------------------------------------

### [](#injectmutationstatefn)[injectMutationStateFn](#injectmutationstatefn)

() => MutationStateOptions<TResult\>

A function that returns mutation state options.

### [](#options)[options?](#options)

[InjectMutationStateOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/InjectMutationStateOptions)

The Angular injector to use.

[](#returns)[Returns](#returns)
-------------------------------

Signal<TResult\[\]>

The signal that tracks the state of all mutations.</content>
</page>

<page>
  <title>injectQueryClient | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/functions/injectQueryClient</url>
  <content>[](#function-injectqueryclient)[~Function: injectQueryClient()~](#function-injectqueryclient)
---------------------------------------------------------------------------------------------

    function injectQueryClient(injectOptions): QueryClient;
    

    function injectQueryClient(injectOptions): QueryClient;
    

Defined in: [inject-query-client.ts:18](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/inject-query-client.ts#L18)

Injects a QueryClient instance and allows passing a custom injector.

[](#parameters)[Parameters](#parameters)
----------------------------------------

### [](#injectoptions)[injectOptions](#injectoptions)

InjectOptions & object = {}

Type of the options argument to inject and optionally a custom injector.

[](#returns)[Returns](#returns)
-------------------------------

QueryClient

The QueryClient instance.

[](#deprecated)[Deprecated](#deprecated)
----------------------------------------

Use inject(QueryClient) instead. If you need to get a QueryClient from a custom injector, use injector.get(QueryClient).

**Example**

    const queryClient = injectQueryClient();
    

    const queryClient = injectQueryClient();</content>
</page>

<page>
  <title>mutationOptions | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/functions/mutationOptions</url>
  <content>[](#function-mutationoptions)[Function: mutationOptions()](#function-mutationoptions)
-------------------------------------------------------------------------------------

Allows to share and re-use mutation options in a type-safe way.

**Example**

    export class QueriesService {
      private http = inject(HttpClient)
      private queryClient = inject(QueryClient)
    
      updatePost(id: number) {
        return mutationOptions({
          mutationFn: (post: Post) => Promise.resolve(post),
          mutationKey: ["updatePost", id],
          onSuccess: (newPost) => {
            //           ^? newPost: Post
            this.queryClient.setQueryData(["posts", id], newPost)
          },
        });
      }
    }
    
    class ComponentOrService {
      queries = inject(QueriesService)
      id = signal(0)
      mutation = injectMutation(() => this.queries.updatePost(this.id()))
    
      save() {
        this.mutation.mutate({ title: 'New Title' })
      }
    }
    

    export class QueriesService {
      private http = inject(HttpClient)
      private queryClient = inject(QueryClient)
    
      updatePost(id: number) {
        return mutationOptions({
          mutationFn: (post: Post) => Promise.resolve(post),
          mutationKey: ["updatePost", id],
          onSuccess: (newPost) => {
            //           ^? newPost: Post
            this.queryClient.setQueryData(["posts", id], newPost)
          },
        });
      }
    }
    
    class ComponentOrService {
      queries = inject(QueriesService)
      id = signal(0)
      mutation = injectMutation(() => this.queries.updatePost(this.id()))
    
      save() {
        this.mutation.mutate({ title: 'New Title' })
      }
    }
    

[](#param)[Param](#param)
-------------------------

The mutation options.

[](#call-signature)[Call Signature](#call-signature)
----------------------------------------------------

    function mutationOptions<TData, TError, TVariables, TOnMutateResult>(options): WithRequired<CreateMutationOptions<TData, TError, TVariables, TOnMutateResult>, "mutationKey">;
    

    function mutationOptions<TData, TError, TVariables, TOnMutateResult>(options): WithRequired<CreateMutationOptions<TData, TError, TVariables, TOnMutateResult>, "mutationKey">;
    

Defined in: [mutation-options.ts:39](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/mutation-options.ts#L39)

Allows to share and re-use mutation options in a type-safe way.

**Example**

    export class QueriesService {
      private http = inject(HttpClient)
      private queryClient = inject(QueryClient)
    
      updatePost(id: number) {
        return mutationOptions({
          mutationFn: (post: Post) => Promise.resolve(post),
          mutationKey: ["updatePost", id],
          onSuccess: (newPost) => {
            //           ^? newPost: Post
            this.queryClient.setQueryData(["posts", id], newPost)
          },
        });
      }
    }
    
    class ComponentOrService {
      queries = inject(QueriesService)
      id = signal(0)
      mutation = injectMutation(() => this.queries.updatePost(this.id()))
    
      save() {
        this.mutation.mutate({ title: 'New Title' })
      }
    }
    

    export class QueriesService {
      private http = inject(HttpClient)
      private queryClient = inject(QueryClient)
    
      updatePost(id: number) {
        return mutationOptions({
          mutationFn: (post: Post) => Promise.resolve(post),
          mutationKey: ["updatePost", id],
          onSuccess: (newPost) => {
            //           ^? newPost: Post
            this.queryClient.setQueryData(["posts", id], newPost)
          },
        });
      }
    }
    
    class ComponentOrService {
      queries = inject(QueriesService)
      id = signal(0)
      mutation = injectMutation(() => this.queries.updatePost(this.id()))
    
      save() {
        this.mutation.mutate({ title: 'New Title' })
      }
    }
    

### [](#type-parameters)[Type Parameters](#type-parameters)

#### [](#tdata)[TData](#tdata)

TData = unknown

#### [](#terror)[TError](#terror)

TError = Error

#### [](#tvariables)[TVariables](#tvariables)

TVariables = void

#### [](#tonmutateresult)[TOnMutateResult](#tonmutateresult)

TOnMutateResult = unknown

### [](#parameters)[Parameters](#parameters)

#### [](#options)[options](#options)

WithRequired<[CreateMutationOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/CreateMutationOptions)<TData, TError, TVariables, TOnMutateResult\>, "mutationKey"\>

The mutation options.

### [](#returns)[Returns](#returns)

WithRequired<[CreateMutationOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/CreateMutationOptions)<TData, TError, TVariables, TOnMutateResult\>, "mutationKey"\>

Mutation options.

[](#call-signature-1)[Call Signature](#call-signature-1)
--------------------------------------------------------

    function mutationOptions<TData, TError, TVariables, TOnMutateResult>(options): Omit<CreateMutationOptions<TData, TError, TVariables, TOnMutateResult>, "mutationKey">;
    

    function mutationOptions<TData, TError, TVariables, TOnMutateResult>(options): Omit<CreateMutationOptions<TData, TError, TVariables, TOnMutateResult>, "mutationKey">;
    

Defined in: [mutation-options.ts:53](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/mutation-options.ts#L53)

Allows to share and re-use mutation options in a type-safe way.

**Example**

    export class QueriesService {
      private http = inject(HttpClient)
      private queryClient = inject(QueryClient)
    
      updatePost(id: number) {
        return mutationOptions({
          mutationFn: (post: Post) => Promise.resolve(post),
          mutationKey: ["updatePost", id],
          onSuccess: (newPost) => {
            //           ^? newPost: Post
            this.queryClient.setQueryData(["posts", id], newPost)
          },
        });
      }
    }
    
    class ComponentOrService {
      queries = inject(QueriesService)
      id = signal(0)
      mutation = injectMutation(() => this.queries.updatePost(this.id()))
    
      save() {
        this.mutation.mutate({ title: 'New Title' })
      }
    }
    

    export class QueriesService {
      private http = inject(HttpClient)
      private queryClient = inject(QueryClient)
    
      updatePost(id: number) {
        return mutationOptions({
          mutationFn: (post: Post) => Promise.resolve(post),
          mutationKey: ["updatePost", id],
          onSuccess: (newPost) => {
            //           ^? newPost: Post
            this.queryClient.setQueryData(["posts", id], newPost)
          },
        });
      }
    }
    
    class ComponentOrService {
      queries = inject(QueriesService)
      id = signal(0)
      mutation = injectMutation(() => this.queries.updatePost(this.id()))
    
      save() {
        this.mutation.mutate({ title: 'New Title' })
      }
    }
    

### [](#type-parameters-1)[Type Parameters](#type-parameters-1)

#### [](#tdata-1)[TData](#tdata-1)

TData = unknown

#### [](#terror-1)[TError](#terror-1)

TError = Error

#### [](#tvariables-1)[TVariables](#tvariables-1)

TVariables = void

#### [](#tonmutateresult-1)[TOnMutateResult](#tonmutateresult-1)

TOnMutateResult = unknown

### [](#parameters-1)[Parameters](#parameters-1)

#### [](#options-1)[options](#options-1)

Omit<[CreateMutationOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/CreateMutationOptions)<TData, TError, TVariables, TOnMutateResult\>, "mutationKey"\>

The mutation options.

### [](#returns-1)[Returns](#returns-1)

Omit<[CreateMutationOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/CreateMutationOptions)<TData, TError, TVariables, TOnMutateResult\>, "mutationKey"\>

Mutation options.</content>
</page>

<page>
  <title>provideAngularQuery | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/functions/provideAngularQuery</url>
  <content>[](#function-provideangularquery)[~Function: provideAngularQuery()~](#function-provideangularquery)
---------------------------------------------------------------------------------------------------

    function provideAngularQuery(queryClient): Provider[];
    

    function provideAngularQuery(queryClient): Provider[];
    

Defined in: [providers.ts:124](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/providers.ts#L124)

Sets up providers necessary to enable TanStack Query functionality for Angular applications.

Allows to configure a QueryClient.

[](#parameters)[Parameters](#parameters)
----------------------------------------

### [](#queryclient)[queryClient](#queryclient)

QueryClient

A QueryClient instance.

[](#returns)[Returns](#returns)
-------------------------------

Provider\[\]

A set of providers to set up TanStack Query.

[](#see)[See](#see)
-------------------

[https://tanstack.com/query/v5/docs/framework/angular/quick-start](https://tanstack.com/query/v5/docs/framework/angular/quick-start)

[](#deprecated)[Deprecated](#deprecated)
----------------------------------------

Use provideTanStackQuery instead.</content>
</page>

<page>
  <title>provideIsRestoring | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/functions/provideIsRestoring</url>
  <content>[](#function-provideisrestoring)[Function: provideIsRestoring()](#function-provideisrestoring)
----------------------------------------------------------------------------------------------

ts

    function provideIsRestoring(isRestoring): Provider;
    

    function provideIsRestoring(isRestoring): Provider;
    

Defined in: [inject-is-restoring.ts:43](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/inject-is-restoring.ts#L43)

Used by TanStack Query Angular persist client plugin to provide the signal that tracks the restore state

[](#parameters)[Parameters](#parameters)
----------------------------------------

### [](#isrestoring)[isRestoring](#isrestoring)

Signal<boolean\>

a readonly signal that returns a boolean

[](#returns)[Returns](#returns)
-------------------------------

Provider

Provider for the isRestoring signal</content>
</page>

<page>
  <title>provideQueryClient | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/functions/provideQueryClient</url>
  <content>[](#function-providequeryclient)[Function: provideQueryClient()](#function-providequeryclient)
----------------------------------------------------------------------------------------------

    function provideQueryClient(queryClient): Provider;
    

    function provideQueryClient(queryClient): Provider;
    

Defined in: [providers.ts:14](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/providers.ts#L14)

Usually [provideTanStackQuery](https://tanstack.com/query/latest/docs/framework/angular/reference/functions/provideTanStackQuery) is used once to set up TanStack Query and the [https://tanstack.com/query/latest/docs/reference/QueryClient|QueryClient](https://tanstack.com/query/latest/docs/reference/QueryClient%7CQueryClient) for the entire application. Internally it calls provideQueryClient. You can use provideQueryClient to provide a different QueryClient instance for a part of the application or for unit testing purposes.

[](#parameters)[Parameters](#parameters)
----------------------------------------

### [](#queryclient)[queryClient](#queryclient)

A QueryClient instance, or an InjectionToken which provides a QueryClient.

QueryClient | InjectionToken<QueryClient\>

[](#returns)[Returns](#returns)
-------------------------------

Provider

a provider object that can be used to provide the QueryClient instance.</content>
</page>

<page>
  <title>provideTanStackQuery | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/functions/provideTanStackQuery</url>
  <content>[](#function-providetanstackquery)[Function: provideTanStackQuery()](#function-providetanstackquery)
----------------------------------------------------------------------------------------------------

    function provideTanStackQuery(queryClient, ...features): Provider[];
    

    function provideTanStackQuery(queryClient, ...features): Provider[];
    

Defined in: [providers.ts:105](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/providers.ts#L105)

Sets up providers necessary to enable TanStack Query functionality for Angular applications.

Allows to configure a QueryClient and optional features such as developer tools.

**Example - standalone**

    import {
      provideTanStackQuery,
      QueryClient,
    } from '@tanstack/angular-query-experimental'
    
    bootstrapApplication(AppComponent, {
      providers: [provideTanStackQuery(new QueryClient())],
    })
    

    import {
      provideTanStackQuery,
      QueryClient,
    } from '@tanstack/angular-query-experimental'
    
    bootstrapApplication(AppComponent, {
      providers: [provideTanStackQuery(new QueryClient())],
    })
    

**Example - NgModule-based**

    import {
      provideTanStackQuery,
      QueryClient,
    } from '@tanstack/angular-query-experimental'
    
    @NgModule({
      declarations: [AppComponent],
      imports: [BrowserModule],
      providers: [provideTanStackQuery(new QueryClient())],
      bootstrap: [AppComponent],
    })
    export class AppModule {}
    

    import {
      provideTanStackQuery,
      QueryClient,
    } from '@tanstack/angular-query-experimental'
    
    @NgModule({
      declarations: [AppComponent],
      imports: [BrowserModule],
      providers: [provideTanStackQuery(new QueryClient())],
      bootstrap: [AppComponent],
    })
    export class AppModule {}
    

You can also enable optional developer tools by adding withDevtools. By default the tools will then be loaded when your app is in development mode.

    import {
      provideTanStackQuery,
      withDevtools
      QueryClient,
    } from '@tanstack/angular-query-experimental'
    
    bootstrapApplication(AppComponent,
      {
        providers: [
          provideTanStackQuery(new QueryClient(), withDevtools())
        ]
      }
    )
    

    import {
      provideTanStackQuery,
      withDevtools
      QueryClient,
    } from '@tanstack/angular-query-experimental'
    
    bootstrapApplication(AppComponent,
      {
        providers: [
          provideTanStackQuery(new QueryClient(), withDevtools())
        ]
      }
    )
    

**Example: using an InjectionToken**

    export const MY_QUERY_CLIENT = new InjectionToken('', {
      factory: () => new QueryClient(),
    })
    
    // In a lazy loaded route or lazy loaded component's providers array:
    providers: [provideTanStackQuery(MY_QUERY_CLIENT)]
    

    export const MY_QUERY_CLIENT = new InjectionToken('', {
      factory: () => new QueryClient(),
    })
    
    // In a lazy loaded route or lazy loaded component's providers array:
    providers: [provideTanStackQuery(MY_QUERY_CLIENT)]
    

Using an InjectionToken for the QueryClient is an advanced optimization which allows TanStack Query to be absent from the main application bundle. This can be beneficial if you want to include TanStack Query on lazy loaded routes only while still sharing a QueryClient.

Note that this is a small optimization and for most applications it's preferable to provide the QueryClient in the main application config.

[](#parameters)[Parameters](#parameters)
----------------------------------------

### [](#queryclient)[queryClient](#queryclient)

A QueryClient instance, or an InjectionToken which provides a QueryClient.

QueryClient | InjectionToken<QueryClient\>

### [](#features)[features](#features)

...[QueryFeatures](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/QueryFeatures)\[\]

Optional features to configure additional Query functionality.

[](#returns)[Returns](#returns)
-------------------------------

Provider\[\]

A set of providers to set up TanStack Query.

[](#see)[See](#see)
-------------------

*   [https://tanstack.com/query/v5/docs/framework/angular/quick-start](https://tanstack.com/query/v5/docs/framework/angular/quick-start)
*   withDevtools</content>
</page>

<page>
  <title>queryFeature | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/functions/queryFeature</url>
  <content>[](#function-queryfeature)[Function: queryFeature()](#function-queryfeature)
----------------------------------------------------------------------------

ts

    function queryFeature<TFeatureKind>(kind, providers): QueryFeature<TFeatureKind>;
    

    function queryFeature<TFeatureKind>(kind, providers): QueryFeature<TFeatureKind>;
    

Defined in: [providers.ts:146](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/providers.ts#L146)

Helper function to create an object that represents a Query feature.

[](#type-parameters)[Type Parameters](#type-parameters)
-------------------------------------------------------

### [](#tfeaturekind)[TFeatureKind](#tfeaturekind)

TFeatureKind _extends_ "Devtools" | "PersistQueryClient"

[](#parameters)[Parameters](#parameters)
----------------------------------------

### [](#kind)[kind](#kind)

TFeatureKind

### [](#providers)[providers](#providers)

Provider\[\]

[](#returns)[Returns](#returns)
-------------------------------

[QueryFeature](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/QueryFeature)<TFeatureKind\>

A Query feature.</content>
</page>

<page>
  <title>queryOptions | TanStack Query Angular Docs</title>
  <url>https://tanstack.com/query/latest/docs/framework/angular/reference/functions/queryOptions</url>
  <content>[](#function-queryoptions)[Function: queryOptions()](#function-queryoptions)
----------------------------------------------------------------------------

Allows to share and re-use query options in a type-safe way.

The queryKey will be tagged with the type from queryFn.

**Example**

     const { queryKey } = queryOptions({
        queryKey: ['key'],
        queryFn: () => Promise.resolve(5),
        //  ^?  Promise<number>
      })
    
      const queryClient = new QueryClient()
      const data = queryClient.getQueryData(queryKey)
      //    ^?  number | undefined
    

     const { queryKey } = queryOptions({
        queryKey: ['key'],
        queryFn: () => Promise.resolve(5),
        //  ^?  Promise<number>
      })
    
      const queryClient = new QueryClient()
      const data = queryClient.getQueryData(queryKey)
      //    ^?  number | undefined
    

[](#param)[Param](#param)
-------------------------

The query options to tag with the type from queryFn.

[](#call-signature)[Call Signature](#call-signature)
----------------------------------------------------

    function queryOptions<TQueryFnData, TError, TData, TQueryKey>(options): Omit<CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey>, "queryFn"> & object & object;
    

    function queryOptions<TQueryFnData, TError, TData, TQueryKey>(options): Omit<CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey>, "queryFn"> & object & object;
    

Defined in: [query-options.ts:76](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/query-options.ts#L76)

Allows to share and re-use query options in a type-safe way.

The queryKey will be tagged with the type from queryFn.

**Example**

     const { queryKey } = queryOptions({
        queryKey: ['key'],
        queryFn: () => Promise.resolve(5),
        //  ^?  Promise<number>
      })
    
      const queryClient = new QueryClient()
      const data = queryClient.getQueryData(queryKey)
      //    ^?  number | undefined
    

     const { queryKey } = queryOptions({
        queryKey: ['key'],
        queryFn: () => Promise.resolve(5),
        //  ^?  Promise<number>
      })
    
      const queryClient = new QueryClient()
      const data = queryClient.getQueryData(queryKey)
      //    ^?  number | undefined
    

### [](#type-parameters)[Type Parameters](#type-parameters)

#### [](#tqueryfndata)[TQueryFnData](#tqueryfndata)

TQueryFnData = unknown

#### [](#terror)[TError](#terror)

TError = Error

#### [](#tdata)[TData](#tdata)

TData = TQueryFnData

#### [](#tquerykey)[TQueryKey](#tquerykey)

TQueryKey _extends_ readonly unknown\[\] = readonly unknown\[\]

### [](#parameters)[Parameters](#parameters)

#### [](#options)[options](#options)

[DefinedInitialDataOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/DefinedInitialDataOptions)<TQueryFnData, TError, TData, TQueryKey\>

The query options to tag with the type from queryFn.

### [](#returns)[Returns](#returns)

Omit<[CreateQueryOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/CreateQueryOptions)<TQueryFnData, TError, TData, TQueryKey\>, "queryFn"\> & object & object

The tagged query options.

[](#call-signature-1)[Call Signature](#call-signature-1)
--------------------------------------------------------

    function queryOptions<TQueryFnData, TError, TData, TQueryKey>(options): OmitKeyof<CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey>, "queryFn"> & object & object;
    

    function queryOptions<TQueryFnData, TError, TData, TQueryKey>(options): OmitKeyof<CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey>, "queryFn"> & object & object;
    

Defined in: [query-options.ts:108](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/query-options.ts#L108)

Allows to share and re-use query options in a type-safe way.

The queryKey will be tagged with the type from queryFn.

**Example**

     const { queryKey } = queryOptions({
        queryKey: ['key'],
        queryFn: () => Promise.resolve(5),
        //  ^?  Promise<number>
      })
    
      const queryClient = new QueryClient()
      const data = queryClient.getQueryData(queryKey)
      //    ^?  number | undefined
    

     const { queryKey } = queryOptions({
        queryKey: ['key'],
        queryFn: () => Promise.resolve(5),
        //  ^?  Promise<number>
      })
    
      const queryClient = new QueryClient()
      const data = queryClient.getQueryData(queryKey)
      //    ^?  number | undefined
    

### [](#type-parameters-1)[Type Parameters](#type-parameters-1)

#### [](#tqueryfndata-1)[TQueryFnData](#tqueryfndata-1)

TQueryFnData = unknown

#### [](#terror-1)[TError](#terror-1)

TError = Error

#### [](#tdata-1)[TData](#tdata-1)

TData = TQueryFnData

#### [](#tquerykey-1)[TQueryKey](#tquerykey-1)

TQueryKey _extends_ readonly unknown\[\] = readonly unknown\[\]

### [](#parameters-1)[Parameters](#parameters-1)

#### [](#options-1)[options](#options-1)

[UnusedSkipTokenOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/UnusedSkipTokenOptions)<TQueryFnData, TError, TData, TQueryKey\>

The query options to tag with the type from queryFn.

### [](#returns-1)[Returns](#returns-1)

OmitKeyof<[CreateQueryOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/CreateQueryOptions)<TQueryFnData, TError, TData, TQueryKey\>, "queryFn"\> & object & object

The tagged query options.

[](#call-signature-2)[Call Signature](#call-signature-2)
--------------------------------------------------------

    function queryOptions<TQueryFnData, TError, TData, TQueryKey>(options): CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey> & object & object;
    

    function queryOptions<TQueryFnData, TError, TData, TQueryKey>(options): CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey> & object & object;
    

Defined in: [query-options.ts:140](https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/src/query-options.ts#L140)

Allows to share and re-use query options in a type-safe way.

The queryKey will be tagged with the type from queryFn.

**Example**

     const { queryKey } = queryOptions({
        queryKey: ['key'],
        queryFn: () => Promise.resolve(5),
        //  ^?  Promise<number>
      })
    
      const queryClient = new QueryClient()
      const data = queryClient.getQueryData(queryKey)
      //    ^?  number | undefined
    

     const { queryKey } = queryOptions({
        queryKey: ['key'],
        queryFn: () => Promise.resolve(5),
        //  ^?  Promise<number>
      })
    
      const queryClient = new QueryClient()
      const data = queryClient.getQueryData(queryKey)
      //    ^?  number | undefined
    

### [](#type-parameters-2)[Type Parameters](#type-parameters-2)

#### [](#tqueryfndata-2)[TQueryFnData](#tqueryfndata-2)

TQueryFnData = unknown

#### [](#terror-2)[TError](#terror-2)

TError = Error

#### [](#tdata-2)[TData](#tdata-2)

TData = TQueryFnData

#### [](#tquerykey-2)[TQueryKey](#tquerykey-2)

TQueryKey _extends_ readonly unknown\[\] = readonly unknown\[\]

### [](#parameters-2)[Parameters](#parameters-2)

#### [](#options-2)[options](#options-2)

[UndefinedInitialDataOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/type-aliases/UndefinedInitialDataOptions)<TQueryFnData, TError, TData, TQueryKey\>

The query options to tag with the type from queryFn.

### [](#returns-2)[Returns](#returns-2)

[CreateQueryOptions](https://tanstack.com/query/latest/docs/framework/angular/reference/interfaces/CreateQueryOptions)<TQueryFnData, TError, TData, TQueryKey\> & object & object

The tagged query options.</content>
</page>
